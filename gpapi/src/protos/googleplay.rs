// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `googleplay.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AckNotificationResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckNotificationResponse {
    fn default() -> &'a AckNotificationResponse {
        <AckNotificationResponse as ::protobuf::Message>::default_instance()
    }
}

impl AckNotificationResponse {
    pub fn new() -> AckNotificationResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AckNotificationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationResponse {
        AckNotificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AckNotificationResponse>(
                "AckNotificationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationResponse {
        static instance: ::protobuf::rt::LazyV2<AckNotificationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AckNotificationResponse::new)
    }
}

impl ::protobuf::Clear for AckNotificationResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppDeliveryData {
    // message fields
    pub downloadSize: ::std::option::Option<i64>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub additionalFile: ::protobuf::RepeatedField<AppFileMetadata>,
    pub downloadAuthCookie: ::protobuf::RepeatedField<HttpCookie>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub refundTimeout: ::std::option::Option<i64>,
    pub serverInitiated: ::std::option::Option<bool>,
    pub postInstallRefundWindowMillis: ::std::option::Option<i64>,
    pub immediateStartNeeded: ::std::option::Option<bool>,
    pub patchData: ::protobuf::SingularPtrField<AndroidAppPatchData>,
    pub encryptionParams: ::protobuf::SingularPtrField<EncryptionParams>,
    pub gzippedDownloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub gzippedDownloadSize: ::std::option::Option<i64>,
    pub splitDeliveryData: ::protobuf::RepeatedField<SplitDeliveryData>,
    pub installLocation: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppDeliveryData {
    fn default() -> &'a AndroidAppDeliveryData {
        <AndroidAppDeliveryData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppDeliveryData {
    pub fn new() -> AndroidAppDeliveryData {
        ::std::default::Default::default()
    }

    // optional int64 downloadSize = 1;


    pub fn get_downloadSize(&self) -> i64 {
        self.downloadSize.unwrap_or(0)
    }

    // optional string signature = 2;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .AppFileMetadata additionalFile = 4;


    pub fn get_additionalFile(&self) -> &[AppFileMetadata] {
        &self.additionalFile
    }

    // repeated .HttpCookie downloadAuthCookie = 5;


    pub fn get_downloadAuthCookie(&self) -> &[HttpCookie] {
        &self.downloadAuthCookie
    }

    // optional bool forwardLocked = 6;


    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional int64 refundTimeout = 7;


    pub fn get_refundTimeout(&self) -> i64 {
        self.refundTimeout.unwrap_or(0)
    }

    // optional bool serverInitiated = 8;


    pub fn get_serverInitiated(&self) -> bool {
        self.serverInitiated.unwrap_or(false)
    }

    // optional int64 postInstallRefundWindowMillis = 9;


    pub fn get_postInstallRefundWindowMillis(&self) -> i64 {
        self.postInstallRefundWindowMillis.unwrap_or(0)
    }

    // optional bool immediateStartNeeded = 10;


    pub fn get_immediateStartNeeded(&self) -> bool {
        self.immediateStartNeeded.unwrap_or(false)
    }

    // optional .AndroidAppPatchData patchData = 11;


    pub fn get_patchData(&self) -> &AndroidAppPatchData {
        self.patchData.as_ref().unwrap_or_else(|| <AndroidAppPatchData as ::protobuf::Message>::default_instance())
    }

    // optional .EncryptionParams encryptionParams = 12;


    pub fn get_encryptionParams(&self) -> &EncryptionParams {
        self.encryptionParams.as_ref().unwrap_or_else(|| <EncryptionParams as ::protobuf::Message>::default_instance())
    }

    // optional string gzippedDownloadUrl = 13;


    pub fn get_gzippedDownloadUrl(&self) -> &str {
        match self.gzippedDownloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 gzippedDownloadSize = 14;


    pub fn get_gzippedDownloadSize(&self) -> i64 {
        self.gzippedDownloadSize.unwrap_or(0)
    }

    // repeated .SplitDeliveryData splitDeliveryData = 15;


    pub fn get_splitDeliveryData(&self) -> &[SplitDeliveryData] {
        &self.splitDeliveryData
    }

    // optional int32 installLocation = 16;


    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidAppDeliveryData {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downloadAuthCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patchData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryptionParams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.splitDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additionalFile)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.downloadAuthCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeout = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serverInitiated = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postInstallRefundWindowMillis = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.immediateStartNeeded = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patchData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptionParams)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gzippedDownloadUrl)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gzippedDownloadSize = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.splitDeliveryData)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.downloadSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.downloadAuthCookie {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.forwardLocked {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeout {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverInitiated {
            my_size += 2;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.immediateStartNeeded {
            my_size += 2;
        }
        if let Some(ref v) = self.patchData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryptionParams.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gzippedDownloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.gzippedDownloadSize {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.splitDeliveryData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.downloadSize {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.additionalFile {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.downloadAuthCookie {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.forwardLocked {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.refundTimeout {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.serverInitiated {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.immediateStartNeeded {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.patchData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryptionParams.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gzippedDownloadUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.gzippedDownloadSize {
            os.write_int64(14, v)?;
        }
        for v in &self.splitDeliveryData {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.installLocation {
            os.write_int32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppDeliveryData {
        AndroidAppDeliveryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloadSize",
                |m: &AndroidAppDeliveryData| { &m.downloadSize },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &AndroidAppDeliveryData| { &m.signature },
                |m: &mut AndroidAppDeliveryData| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AndroidAppDeliveryData| { &m.downloadUrl },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppFileMetadata>>(
                "additionalFile",
                |m: &AndroidAppDeliveryData| { &m.additionalFile },
                |m: &mut AndroidAppDeliveryData| { &mut m.additionalFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HttpCookie>>(
                "downloadAuthCookie",
                |m: &AndroidAppDeliveryData| { &m.downloadAuthCookie },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadAuthCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forwardLocked",
                |m: &AndroidAppDeliveryData| { &m.forwardLocked },
                |m: &mut AndroidAppDeliveryData| { &mut m.forwardLocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeout",
                |m: &AndroidAppDeliveryData| { &m.refundTimeout },
                |m: &mut AndroidAppDeliveryData| { &mut m.refundTimeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "serverInitiated",
                |m: &AndroidAppDeliveryData| { &m.serverInitiated },
                |m: &mut AndroidAppDeliveryData| { &mut m.serverInitiated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postInstallRefundWindowMillis",
                |m: &AndroidAppDeliveryData| { &m.postInstallRefundWindowMillis },
                |m: &mut AndroidAppDeliveryData| { &mut m.postInstallRefundWindowMillis },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "immediateStartNeeded",
                |m: &AndroidAppDeliveryData| { &m.immediateStartNeeded },
                |m: &mut AndroidAppDeliveryData| { &mut m.immediateStartNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppPatchData>>(
                "patchData",
                |m: &AndroidAppDeliveryData| { &m.patchData },
                |m: &mut AndroidAppDeliveryData| { &mut m.patchData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionParams>>(
                "encryptionParams",
                |m: &AndroidAppDeliveryData| { &m.encryptionParams },
                |m: &mut AndroidAppDeliveryData| { &mut m.encryptionParams },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gzippedDownloadUrl",
                |m: &AndroidAppDeliveryData| { &m.gzippedDownloadUrl },
                |m: &mut AndroidAppDeliveryData| { &mut m.gzippedDownloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gzippedDownloadSize",
                |m: &AndroidAppDeliveryData| { &m.gzippedDownloadSize },
                |m: &mut AndroidAppDeliveryData| { &mut m.gzippedDownloadSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SplitDeliveryData>>(
                "splitDeliveryData",
                |m: &AndroidAppDeliveryData| { &m.splitDeliveryData },
                |m: &mut AndroidAppDeliveryData| { &mut m.splitDeliveryData },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "installLocation",
                |m: &AndroidAppDeliveryData| { &m.installLocation },
                |m: &mut AndroidAppDeliveryData| { &mut m.installLocation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppDeliveryData>(
                "AndroidAppDeliveryData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppDeliveryData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppDeliveryData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppDeliveryData::new)
    }
}

impl ::protobuf::Clear for AndroidAppDeliveryData {
    fn clear(&mut self) {
        self.downloadSize = ::std::option::Option::None;
        self.signature.clear();
        self.downloadUrl.clear();
        self.additionalFile.clear();
        self.downloadAuthCookie.clear();
        self.forwardLocked = ::std::option::Option::None;
        self.refundTimeout = ::std::option::Option::None;
        self.serverInitiated = ::std::option::Option::None;
        self.postInstallRefundWindowMillis = ::std::option::Option::None;
        self.immediateStartNeeded = ::std::option::Option::None;
        self.patchData.clear();
        self.encryptionParams.clear();
        self.gzippedDownloadUrl.clear();
        self.gzippedDownloadSize = ::std::option::Option::None;
        self.splitDeliveryData.clear();
        self.installLocation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppDeliveryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppDeliveryData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SplitDeliveryData {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub downloadSize: ::std::option::Option<i64>,
    pub gzippedDownloadSize: ::std::option::Option<i64>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub gzippedDownloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub patchData: ::protobuf::SingularPtrField<AndroidAppPatchData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SplitDeliveryData {
    fn default() -> &'a SplitDeliveryData {
        <SplitDeliveryData as ::protobuf::Message>::default_instance()
    }
}

impl SplitDeliveryData {
    pub fn new() -> SplitDeliveryData {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 downloadSize = 2;


    pub fn get_downloadSize(&self) -> i64 {
        self.downloadSize.unwrap_or(0)
    }

    // optional int64 gzippedDownloadSize = 3;


    pub fn get_gzippedDownloadSize(&self) -> i64 {
        self.gzippedDownloadSize.unwrap_or(0)
    }

    // optional string signature = 4;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 5;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gzippedDownloadUrl = 6;


    pub fn get_gzippedDownloadUrl(&self) -> &str {
        match self.gzippedDownloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AndroidAppPatchData patchData = 7;


    pub fn get_patchData(&self) -> &AndroidAppPatchData {
        self.patchData.as_ref().unwrap_or_else(|| <AndroidAppPatchData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SplitDeliveryData {
    fn is_initialized(&self) -> bool {
        for v in &self.patchData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gzippedDownloadSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gzippedDownloadUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patchData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.downloadSize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gzippedDownloadSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.gzippedDownloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.patchData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.downloadSize {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.gzippedDownloadSize {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.gzippedDownloadUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.patchData.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitDeliveryData {
        SplitDeliveryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SplitDeliveryData| { &m.id },
                |m: &mut SplitDeliveryData| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloadSize",
                |m: &SplitDeliveryData| { &m.downloadSize },
                |m: &mut SplitDeliveryData| { &mut m.downloadSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gzippedDownloadSize",
                |m: &SplitDeliveryData| { &m.gzippedDownloadSize },
                |m: &mut SplitDeliveryData| { &mut m.gzippedDownloadSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &SplitDeliveryData| { &m.signature },
                |m: &mut SplitDeliveryData| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &SplitDeliveryData| { &m.downloadUrl },
                |m: &mut SplitDeliveryData| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gzippedDownloadUrl",
                |m: &SplitDeliveryData| { &m.gzippedDownloadUrl },
                |m: &mut SplitDeliveryData| { &mut m.gzippedDownloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppPatchData>>(
                "patchData",
                |m: &SplitDeliveryData| { &m.patchData },
                |m: &mut SplitDeliveryData| { &mut m.patchData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SplitDeliveryData>(
                "SplitDeliveryData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SplitDeliveryData {
        static instance: ::protobuf::rt::LazyV2<SplitDeliveryData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SplitDeliveryData::new)
    }
}

impl ::protobuf::Clear for SplitDeliveryData {
    fn clear(&mut self) {
        self.id.clear();
        self.downloadSize = ::std::option::Option::None;
        self.gzippedDownloadSize = ::std::option::Option::None;
        self.signature.clear();
        self.downloadUrl.clear();
        self.gzippedDownloadUrl.clear();
        self.patchData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SplitDeliveryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitDeliveryData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppPatchData {
    // message fields
    pub baseVersionCode: ::std::option::Option<i32>,
    pub baseSignature: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub patchFormat: ::std::option::Option<i32>,
    pub maxPatchSize: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppPatchData {
    fn default() -> &'a AndroidAppPatchData {
        <AndroidAppPatchData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppPatchData {
    pub fn new() -> AndroidAppPatchData {
        ::std::default::Default::default()
    }

    // optional int32 baseVersionCode = 1;


    pub fn get_baseVersionCode(&self) -> i32 {
        self.baseVersionCode.unwrap_or(0)
    }

    // optional string baseSignature = 2;


    pub fn get_baseSignature(&self) -> &str {
        match self.baseSignature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 patchFormat = 4;


    pub fn get_patchFormat(&self) -> i32 {
        self.patchFormat.unwrap_or(0)
    }

    // optional int64 maxPatchSize = 5;


    pub fn get_maxPatchSize(&self) -> i64 {
        self.maxPatchSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidAppPatchData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baseVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseSignature)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.patchFormat = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxPatchSize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.baseSignature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.patchFormat {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxPatchSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.baseSignature.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.patchFormat {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maxPatchSize {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppPatchData {
        AndroidAppPatchData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "baseVersionCode",
                |m: &AndroidAppPatchData| { &m.baseVersionCode },
                |m: &mut AndroidAppPatchData| { &mut m.baseVersionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baseSignature",
                |m: &AndroidAppPatchData| { &m.baseSignature },
                |m: &mut AndroidAppPatchData| { &mut m.baseSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AndroidAppPatchData| { &m.downloadUrl },
                |m: &mut AndroidAppPatchData| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "patchFormat",
                |m: &AndroidAppPatchData| { &m.patchFormat },
                |m: &mut AndroidAppPatchData| { &mut m.patchFormat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxPatchSize",
                |m: &AndroidAppPatchData| { &m.maxPatchSize },
                |m: &mut AndroidAppPatchData| { &mut m.maxPatchSize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppPatchData>(
                "AndroidAppPatchData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppPatchData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppPatchData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppPatchData::new)
    }
}

impl ::protobuf::Clear for AndroidAppPatchData {
    fn clear(&mut self) {
        self.baseVersionCode = ::std::option::Option::None;
        self.baseSignature.clear();
        self.downloadUrl.clear();
        self.patchFormat = ::std::option::Option::None;
        self.maxPatchSize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppPatchData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppPatchData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppFileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppFileMetadata {
    fn default() -> &'a AppFileMetadata {
        <AppFileMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AppFileMetadata {
    pub fn new() -> AppFileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;


    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string downloadUrl = 4;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppFileMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppFileMetadata {
        AppFileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fileType",
                |m: &AppFileMetadata| { &m.fileType },
                |m: &mut AppFileMetadata| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AppFileMetadata| { &m.versionCode },
                |m: &mut AppFileMetadata| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &AppFileMetadata| { &m.size },
                |m: &mut AppFileMetadata| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AppFileMetadata| { &m.downloadUrl },
                |m: &mut AppFileMetadata| { &mut m.downloadUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppFileMetadata>(
                "AppFileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppFileMetadata {
        static instance: ::protobuf::rt::LazyV2<AppFileMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppFileMetadata::new)
    }
}

impl ::protobuf::Clear for AppFileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.downloadUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppFileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppFileMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EncryptionParams {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub encryptionKey: ::protobuf::SingularField<::std::string::String>,
    pub hmacKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionParams {
    fn default() -> &'a EncryptionParams {
        <EncryptionParams as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionParams {
    pub fn new() -> EncryptionParams {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional string encryptionKey = 2;


    pub fn get_encryptionKey(&self) -> &str {
        match self.encryptionKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hmacKey = 3;


    pub fn get_hmacKey(&self) -> &str {
        match self.hmacKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EncryptionParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptionKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hmacKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.hmacKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.hmacKey.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionParams {
        EncryptionParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &EncryptionParams| { &m.version },
                |m: &mut EncryptionParams| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryptionKey",
                |m: &EncryptionParams| { &m.encryptionKey },
                |m: &mut EncryptionParams| { &mut m.encryptionKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hmacKey",
                |m: &EncryptionParams| { &m.hmacKey },
                |m: &mut EncryptionParams| { &mut m.hmacKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptionParams>(
                "EncryptionParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionParams {
        static instance: ::protobuf::rt::LazyV2<EncryptionParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionParams::new)
    }
}

impl ::protobuf::Clear for EncryptionParams {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.encryptionKey.clear();
        self.hmacKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HttpCookie {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpCookie {
    fn default() -> &'a HttpCookie {
        <HttpCookie as ::protobuf::Message>::default_instance()
    }
}

impl HttpCookie {
    pub fn new() -> HttpCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for HttpCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpCookie {
        HttpCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HttpCookie| { &m.name },
                |m: &mut HttpCookie| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HttpCookie| { &m.value },
                |m: &mut HttpCookie| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpCookie>(
                "HttpCookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpCookie {
        static instance: ::protobuf::rt::LazyV2<HttpCookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpCookie::new)
    }
}

impl ::protobuf::Clear for HttpCookie {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Address {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub addressLine1: ::protobuf::SingularField<::std::string::String>,
    pub addressLine2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub postalCountry: ::protobuf::SingularField<::std::string::String>,
    pub dependentLocality: ::protobuf::SingularField<::std::string::String>,
    pub sortingCode: ::protobuf::SingularField<::std::string::String>,
    pub languageCode: ::protobuf::SingularField<::std::string::String>,
    pub phoneNumber: ::protobuf::SingularField<::std::string::String>,
    pub deprecatedIsReduced: ::std::option::Option<bool>,
    pub firstName: ::protobuf::SingularField<::std::string::String>,
    pub lastName: ::protobuf::SingularField<::std::string::String>,
    pub email: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addressLine1 = 2;


    pub fn get_addressLine1(&self) -> &str {
        match self.addressLine1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addressLine2 = 3;


    pub fn get_addressLine2(&self) -> &str {
        match self.addressLine2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city = 4;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state = 5;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCode = 6;


    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCountry = 7;


    pub fn get_postalCountry(&self) -> &str {
        match self.postalCountry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dependentLocality = 8;


    pub fn get_dependentLocality(&self) -> &str {
        match self.dependentLocality.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sortingCode = 9;


    pub fn get_sortingCode(&self) -> &str {
        match self.sortingCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string languageCode = 10;


    pub fn get_languageCode(&self) -> &str {
        match self.languageCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string phoneNumber = 11;


    pub fn get_phoneNumber(&self) -> &str {
        match self.phoneNumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool deprecatedIsReduced = 12;


    pub fn get_deprecatedIsReduced(&self) -> bool {
        self.deprecatedIsReduced.unwrap_or(false)
    }

    // optional string firstName = 13;


    pub fn get_firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastName = 14;


    pub fn get_lastName(&self) -> &str {
        match self.lastName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string email = 15;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCountry)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dependentLocality)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sortingCode)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.languageCode)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phoneNumber)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deprecatedIsReduced = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.addressLine1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.addressLine2.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.postalCountry.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.dependentLocality.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.sortingCode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.languageCode.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.phoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.deprecatedIsReduced {
            my_size += 2;
        }
        if let Some(ref v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.lastName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.addressLine1.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.addressLine2.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.postalCountry.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.dependentLocality.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.sortingCode.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.languageCode.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.phoneNumber.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.deprecatedIsReduced {
            os.write_bool(12, v)?;
        }
        if let Some(ref v) = self.firstName.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.lastName.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Address| { &m.name },
                |m: &mut Address| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressLine1",
                |m: &Address| { &m.addressLine1 },
                |m: &mut Address| { &mut m.addressLine1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressLine2",
                |m: &Address| { &m.addressLine2 },
                |m: &mut Address| { &mut m.addressLine2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &Address| { &m.city },
                |m: &mut Address| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &Address| { &m.state },
                |m: &mut Address| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCode",
                |m: &Address| { &m.postalCode },
                |m: &mut Address| { &mut m.postalCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCountry",
                |m: &Address| { &m.postalCountry },
                |m: &mut Address| { &mut m.postalCountry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dependentLocality",
                |m: &Address| { &m.dependentLocality },
                |m: &mut Address| { &mut m.dependentLocality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortingCode",
                |m: &Address| { &m.sortingCode },
                |m: &mut Address| { &mut m.sortingCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languageCode",
                |m: &Address| { &m.languageCode },
                |m: &mut Address| { &mut m.languageCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phoneNumber",
                |m: &Address| { &m.phoneNumber },
                |m: &mut Address| { &mut m.phoneNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deprecatedIsReduced",
                |m: &Address| { &m.deprecatedIsReduced },
                |m: &mut Address| { &mut m.deprecatedIsReduced },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &Address| { &m.firstName },
                |m: &mut Address| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &Address| { &m.lastName },
                |m: &mut Address| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &Address| { &m.email },
                |m: &mut Address| { &mut m.email },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::LazyV2<Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.name.clear();
        self.addressLine1.clear();
        self.addressLine2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.postalCountry.clear();
        self.dependentLocality.clear();
        self.sortingCode.clear();
        self.languageCode.clear();
        self.phoneNumber.clear();
        self.deprecatedIsReduced = ::std::option::Option::None;
        self.firstName.clear();
        self.lastName.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookAuthor {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub deprecatedQuery: ::protobuf::SingularField<::std::string::String>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookAuthor {
    fn default() -> &'a BookAuthor {
        <BookAuthor as ::protobuf::Message>::default_instance()
    }
}

impl BookAuthor {
    pub fn new() -> BookAuthor {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deprecatedQuery = 2;


    pub fn get_deprecatedQuery(&self) -> &str {
        match self.deprecatedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Docid docid = 3;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BookAuthor {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedQuery)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.deprecatedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.deprecatedQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookAuthor {
        BookAuthor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BookAuthor| { &m.name },
                |m: &mut BookAuthor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deprecatedQuery",
                |m: &BookAuthor| { &m.deprecatedQuery },
                |m: &mut BookAuthor| { &mut m.deprecatedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &BookAuthor| { &m.docid },
                |m: &mut BookAuthor| { &mut m.docid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookAuthor>(
                "BookAuthor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookAuthor {
        static instance: ::protobuf::rt::LazyV2<BookAuthor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookAuthor::new)
    }
}

impl ::protobuf::Clear for BookAuthor {
    fn clear(&mut self) {
        self.name.clear();
        self.deprecatedQuery.clear();
        self.docid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookAuthor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookAuthor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookDetails {
    // message fields
    pub subject: ::protobuf::RepeatedField<BookSubject>,
    pub publisher: ::protobuf::SingularField<::std::string::String>,
    pub publicationDate: ::protobuf::SingularField<::std::string::String>,
    pub isbn: ::protobuf::SingularField<::std::string::String>,
    pub numberOfPages: ::std::option::Option<i32>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub author: ::protobuf::RepeatedField<BookAuthor>,
    pub readerUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadEpubUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadPdfUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsEpubTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsPdfTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub epubAvailable: ::std::option::Option<bool>,
    pub pdfAvailable: ::std::option::Option<bool>,
    pub aboutTheAuthor: ::protobuf::SingularField<::std::string::String>,
    // identifier: <group>
    pub fixedLayoutContent: ::std::option::Option<bool>,
    pub audioVideoContent: ::std::option::Option<bool>,
    pub isAgencyBook: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookDetails {
    fn default() -> &'a BookDetails {
        <BookDetails as ::protobuf::Message>::default_instance()
    }
}

impl BookDetails {
    pub fn new() -> BookDetails {
        ::std::default::Default::default()
    }

    // repeated .BookSubject subject = 3;


    pub fn get_subject(&self) -> &[BookSubject] {
        &self.subject
    }

    // optional string publisher = 4;


    pub fn get_publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string publicationDate = 5;


    pub fn get_publicationDate(&self) -> &str {
        match self.publicationDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string isbn = 6;


    pub fn get_isbn(&self) -> &str {
        match self.isbn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 numberOfPages = 7;


    pub fn get_numberOfPages(&self) -> i32 {
        self.numberOfPages.unwrap_or(0)
    }

    // optional string subtitle = 8;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .BookAuthor author = 9;


    pub fn get_author(&self) -> &[BookAuthor] {
        &self.author
    }

    // optional string readerUrl = 10;


    pub fn get_readerUrl(&self) -> &str {
        match self.readerUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadEpubUrl = 11;


    pub fn get_downloadEpubUrl(&self) -> &str {
        match self.downloadEpubUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadPdfUrl = 12;


    pub fn get_downloadPdfUrl(&self) -> &str {
        match self.downloadPdfUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string acsEpubTokenUrl = 13;


    pub fn get_acsEpubTokenUrl(&self) -> &str {
        match self.acsEpubTokenUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string acsPdfTokenUrl = 14;


    pub fn get_acsPdfTokenUrl(&self) -> &str {
        match self.acsPdfTokenUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool epubAvailable = 15;


    pub fn get_epubAvailable(&self) -> bool {
        self.epubAvailable.unwrap_or(false)
    }

    // optional bool pdfAvailable = 16;


    pub fn get_pdfAvailable(&self) -> bool {
        self.pdfAvailable.unwrap_or(false)
    }

    // optional string aboutTheAuthor = 17;


    pub fn get_aboutTheAuthor(&self) -> &str {
        match self.aboutTheAuthor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool fixedLayoutContent = 21;


    pub fn get_fixedLayoutContent(&self) -> bool {
        self.fixedLayoutContent.unwrap_or(false)
    }

    // optional bool audioVideoContent = 22;


    pub fn get_audioVideoContent(&self) -> bool {
        self.audioVideoContent.unwrap_or(false)
    }

    // optional bool isAgencyBook = 23;


    pub fn get_isAgencyBook(&self) -> bool {
        self.isAgencyBook.unwrap_or(false)
    }
}

impl ::protobuf::Message for BookDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.subject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publisher)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publicationDate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.isbn)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numberOfPages = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.author)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.readerUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadEpubUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadPdfUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsEpubTokenUrl)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsPdfTokenUrl)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.epubAvailable = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pdfAvailable = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.aboutTheAuthor)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fixedLayoutContent = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.audioVideoContent = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isAgencyBook = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subject {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.publicationDate.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.isbn.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.numberOfPages {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.author {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.readerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.downloadEpubUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.downloadPdfUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.acsEpubTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.acsPdfTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.epubAvailable {
            my_size += 2;
        }
        if let Some(v) = self.pdfAvailable {
            my_size += 3;
        }
        if let Some(ref v) = self.aboutTheAuthor.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.fixedLayoutContent {
            my_size += 3;
        }
        if let Some(v) = self.audioVideoContent {
            my_size += 3;
        }
        if let Some(v) = self.isAgencyBook {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subject {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.publisher.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.publicationDate.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.isbn.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.numberOfPages {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.author {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.readerUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.downloadEpubUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.downloadPdfUrl.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.acsEpubTokenUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.acsPdfTokenUrl.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.epubAvailable {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.pdfAvailable {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.aboutTheAuthor.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.fixedLayoutContent {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.audioVideoContent {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.isAgencyBook {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails {
        BookDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookSubject>>(
                "subject",
                |m: &BookDetails| { &m.subject },
                |m: &mut BookDetails| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "publisher",
                |m: &BookDetails| { &m.publisher },
                |m: &mut BookDetails| { &mut m.publisher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "publicationDate",
                |m: &BookDetails| { &m.publicationDate },
                |m: &mut BookDetails| { &mut m.publicationDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "isbn",
                |m: &BookDetails| { &m.isbn },
                |m: &mut BookDetails| { &mut m.isbn },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numberOfPages",
                |m: &BookDetails| { &m.numberOfPages },
                |m: &mut BookDetails| { &mut m.numberOfPages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &BookDetails| { &m.subtitle },
                |m: &mut BookDetails| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookAuthor>>(
                "author",
                |m: &BookDetails| { &m.author },
                |m: &mut BookDetails| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "readerUrl",
                |m: &BookDetails| { &m.readerUrl },
                |m: &mut BookDetails| { &mut m.readerUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadEpubUrl",
                |m: &BookDetails| { &m.downloadEpubUrl },
                |m: &mut BookDetails| { &mut m.downloadEpubUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadPdfUrl",
                |m: &BookDetails| { &m.downloadPdfUrl },
                |m: &mut BookDetails| { &mut m.downloadPdfUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acsEpubTokenUrl",
                |m: &BookDetails| { &m.acsEpubTokenUrl },
                |m: &mut BookDetails| { &mut m.acsEpubTokenUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acsPdfTokenUrl",
                |m: &BookDetails| { &m.acsPdfTokenUrl },
                |m: &mut BookDetails| { &mut m.acsPdfTokenUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "epubAvailable",
                |m: &BookDetails| { &m.epubAvailable },
                |m: &mut BookDetails| { &mut m.epubAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pdfAvailable",
                |m: &BookDetails| { &m.pdfAvailable },
                |m: &mut BookDetails| { &mut m.pdfAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "aboutTheAuthor",
                |m: &BookDetails| { &m.aboutTheAuthor },
                |m: &mut BookDetails| { &mut m.aboutTheAuthor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fixedLayoutContent",
                |m: &BookDetails| { &m.fixedLayoutContent },
                |m: &mut BookDetails| { &mut m.fixedLayoutContent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "audioVideoContent",
                |m: &BookDetails| { &m.audioVideoContent },
                |m: &mut BookDetails| { &mut m.audioVideoContent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isAgencyBook",
                |m: &BookDetails| { &m.isAgencyBook },
                |m: &mut BookDetails| { &mut m.isAgencyBook },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookDetails>(
                "BookDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails {
        static instance: ::protobuf::rt::LazyV2<BookDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookDetails::new)
    }
}

impl ::protobuf::Clear for BookDetails {
    fn clear(&mut self) {
        self.subject.clear();
        self.publisher.clear();
        self.publicationDate.clear();
        self.isbn.clear();
        self.numberOfPages = ::std::option::Option::None;
        self.subtitle.clear();
        self.author.clear();
        self.readerUrl.clear();
        self.downloadEpubUrl.clear();
        self.downloadPdfUrl.clear();
        self.acsEpubTokenUrl.clear();
        self.acsPdfTokenUrl.clear();
        self.epubAvailable = ::std::option::Option::None;
        self.pdfAvailable = ::std::option::Option::None;
        self.aboutTheAuthor.clear();
        self.fixedLayoutContent = ::std::option::Option::None;
        self.audioVideoContent = ::std::option::Option::None;
        self.isAgencyBook = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookDetails_Identifier {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookDetails_Identifier {
    fn default() -> &'a BookDetails_Identifier {
        <BookDetails_Identifier as ::protobuf::Message>::default_instance()
    }
}

impl BookDetails_Identifier {
    pub fn new() -> BookDetails_Identifier {
        ::std::default::Default::default()
    }

    // optional int32 type = 19;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string identifier = 20;


    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookDetails_Identifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(19, v)?;
        }
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_string(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails_Identifier {
        BookDetails_Identifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BookDetails_Identifier| { &m.field_type },
                |m: &mut BookDetails_Identifier| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &BookDetails_Identifier| { &m.identifier },
                |m: &mut BookDetails_Identifier| { &mut m.identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookDetails_Identifier>(
                "BookDetails.Identifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails_Identifier {
        static instance: ::protobuf::rt::LazyV2<BookDetails_Identifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookDetails_Identifier::new)
    }
}

impl ::protobuf::Clear for BookDetails_Identifier {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails_Identifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails_Identifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookSubject {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub subjectId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookSubject {
    fn default() -> &'a BookSubject {
        <BookSubject as ::protobuf::Message>::default_instance()
    }
}

impl BookSubject {
    pub fn new() -> BookSubject {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string query = 2;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subjectId = 3;


    pub fn get_subjectId(&self) -> &str {
        match self.subjectId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookSubject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subjectId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.subjectId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.subjectId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookSubject {
        BookSubject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BookSubject| { &m.name },
                |m: &mut BookSubject| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &BookSubject| { &m.query },
                |m: &mut BookSubject| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subjectId",
                |m: &BookSubject| { &m.subjectId },
                |m: &mut BookSubject| { &mut m.subjectId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookSubject>(
                "BookSubject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookSubject {
        static instance: ::protobuf::rt::LazyV2<BookSubject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookSubject::new)
    }
}

impl ::protobuf::Clear for BookSubject {
    fn clear(&mut self) {
        self.name.clear();
        self.query.clear();
        self.subjectId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookSubject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BrowseLink {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub dataUrl: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BrowseLink {
    fn default() -> &'a BrowseLink {
        <BrowseLink as ::protobuf::Message>::default_instance()
    }
}

impl BrowseLink {
    pub fn new() -> BrowseLink {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dataUrl = 3;


    pub fn get_dataUrl(&self) -> &str {
        match self.dataUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 4;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for BrowseLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dataUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dataUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dataUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseLink {
        BrowseLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BrowseLink| { &m.name },
                |m: &mut BrowseLink| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataUrl",
                |m: &BrowseLink| { &m.dataUrl },
                |m: &mut BrowseLink| { &mut m.dataUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &BrowseLink| { &m.serverLogsCookie },
                |m: &mut BrowseLink| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BrowseLink>(
                "BrowseLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseLink {
        static instance: ::protobuf::rt::LazyV2<BrowseLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BrowseLink::new)
    }
}

impl ::protobuf::Clear for BrowseLink {
    fn clear(&mut self) {
        self.name.clear();
        self.dataUrl.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BrowseResponse {
    // message fields
    pub contentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub promoUrl: ::protobuf::SingularField<::std::string::String>,
    pub category: ::protobuf::RepeatedField<BrowseLink>,
    pub breadcrumb: ::protobuf::RepeatedField<BrowseLink>,
    pub quickLink: ::protobuf::RepeatedField<QuickLink>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BrowseResponse {
    fn default() -> &'a BrowseResponse {
        <BrowseResponse as ::protobuf::Message>::default_instance()
    }
}

impl BrowseResponse {
    pub fn new() -> BrowseResponse {
        ::std::default::Default::default()
    }

    // optional string contentsUrl = 1;


    pub fn get_contentsUrl(&self) -> &str {
        match self.contentsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string promoUrl = 2;


    pub fn get_promoUrl(&self) -> &str {
        match self.promoUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .BrowseLink category = 3;


    pub fn get_category(&self) -> &[BrowseLink] {
        &self.category
    }

    // repeated .BrowseLink breadcrumb = 4;


    pub fn get_breadcrumb(&self) -> &[BrowseLink] {
        &self.breadcrumb
    }

    // repeated .QuickLink quickLink = 5;


    pub fn get_quickLink(&self) -> &[QuickLink] {
        &self.quickLink
    }

    // optional bytes serverLogsCookie = 6;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for BrowseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.category {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.breadcrumb {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quickLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promoUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.category)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.breadcrumb)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quickLink)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.promoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.category {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.breadcrumb {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.quickLink {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.promoUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.category {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.breadcrumb {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.quickLink {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseResponse {
        BrowseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentsUrl",
                |m: &BrowseResponse| { &m.contentsUrl },
                |m: &mut BrowseResponse| { &mut m.contentsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promoUrl",
                |m: &BrowseResponse| { &m.promoUrl },
                |m: &mut BrowseResponse| { &mut m.promoUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "category",
                |m: &BrowseResponse| { &m.category },
                |m: &mut BrowseResponse| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "breadcrumb",
                |m: &BrowseResponse| { &m.breadcrumb },
                |m: &mut BrowseResponse| { &mut m.breadcrumb },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuickLink>>(
                "quickLink",
                |m: &BrowseResponse| { &m.quickLink },
                |m: &mut BrowseResponse| { &mut m.quickLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &BrowseResponse| { &m.serverLogsCookie },
                |m: &mut BrowseResponse| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BrowseResponse>(
                "BrowseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseResponse {
        static instance: ::protobuf::rt::LazyV2<BrowseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BrowseResponse::new)
    }
}

impl ::protobuf::Clear for BrowseResponse {
    fn clear(&mut self) {
        self.contentsUrl.clear();
        self.promoUrl.clear();
        self.category.clear();
        self.breadcrumb.clear();
        self.quickLink.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuickLink {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub link: ::protobuf::SingularPtrField<ResolvedLink>,
    pub displayRequired: ::std::option::Option<bool>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub backendId: ::std::option::Option<i32>,
    pub prismStyle: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuickLink {
    fn default() -> &'a QuickLink {
        <QuickLink as ::protobuf::Message>::default_instance()
    }
}

impl QuickLink {
    pub fn new() -> QuickLink {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 2;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional .ResolvedLink link = 3;


    pub fn get_link(&self) -> &ResolvedLink {
        self.link.as_ref().unwrap_or_else(|| <ResolvedLink as ::protobuf::Message>::default_instance())
    }

    // optional bool displayRequired = 4;


    pub fn get_displayRequired(&self) -> bool {
        self.displayRequired.unwrap_or(false)
    }

    // optional bytes serverLogsCookie = 5;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 backendId = 6;


    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional bool prismStyle = 7;


    pub fn get_prismStyle(&self) -> bool {
        self.prismStyle.unwrap_or(false)
    }
}

impl ::protobuf::Message for QuickLink {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.displayRequired = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prismStyle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.displayRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prismStyle {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.displayRequired {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.prismStyle {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuickLink {
        QuickLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QuickLink| { &m.name },
                |m: &mut QuickLink| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &QuickLink| { &m.image },
                |m: &mut QuickLink| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>>(
                "link",
                |m: &QuickLink| { &m.link },
                |m: &mut QuickLink| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "displayRequired",
                |m: &QuickLink| { &m.displayRequired },
                |m: &mut QuickLink| { &mut m.displayRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &QuickLink| { &m.serverLogsCookie },
                |m: &mut QuickLink| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backendId",
                |m: &QuickLink| { &m.backendId },
                |m: &mut QuickLink| { &mut m.backendId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prismStyle",
                |m: &QuickLink| { &m.prismStyle },
                |m: &mut QuickLink| { &mut m.prismStyle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuickLink>(
                "QuickLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuickLink {
        static instance: ::protobuf::rt::LazyV2<QuickLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuickLink::new)
    }
}

impl ::protobuf::Clear for QuickLink {
    fn clear(&mut self) {
        self.name.clear();
        self.image.clear();
        self.link.clear();
        self.displayRequired = ::std::option::Option::None;
        self.serverLogsCookie.clear();
        self.backendId = ::std::option::Option::None;
        self.prismStyle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuickLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuickLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuyResponse {
    // message fields
    pub purchaseResponse: ::protobuf::SingularPtrField<PurchaseNotificationResponse>,
    // checkoutinfo: <group>
    pub continueViaUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseStatusUrl: ::protobuf::SingularField<::std::string::String>,
    pub checkoutServiceId: ::protobuf::SingularField<::std::string::String>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub baseCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosCheckboxHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub permissionError: ::std::option::Option<i32>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub purchaseCookie: ::protobuf::SingularField<::std::string::String>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub addInstrumentPromptHtml: ::protobuf::SingularField<::std::string::String>,
    pub confirmButtonText: ::protobuf::SingularField<::std::string::String>,
    pub permissionErrorTitleText: ::protobuf::SingularField<::std::string::String>,
    pub permissionErrorMessageText: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub encodedDeliveryToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyResponse {
    fn default() -> &'a BuyResponse {
        <BuyResponse as ::protobuf::Message>::default_instance()
    }
}

impl BuyResponse {
    pub fn new() -> BuyResponse {
        ::std::default::Default::default()
    }

    // optional .PurchaseNotificationResponse purchaseResponse = 1;


    pub fn get_purchaseResponse(&self) -> &PurchaseNotificationResponse {
        self.purchaseResponse.as_ref().unwrap_or_else(|| <PurchaseNotificationResponse as ::protobuf::Message>::default_instance())
    }

    // optional string continueViaUrl = 8;


    pub fn get_continueViaUrl(&self) -> &str {
        match self.continueViaUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseStatusUrl = 9;


    pub fn get_purchaseStatusUrl(&self) -> &str {
        match self.purchaseStatusUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string checkoutServiceId = 12;


    pub fn get_checkoutServiceId(&self) -> &str {
        match self.checkoutServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool checkoutTokenRequired = 13;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }

    // optional string baseCheckoutUrl = 14;


    pub fn get_baseCheckoutUrl(&self) -> &str {
        match self.baseCheckoutUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string tosCheckboxHtml = 37;


    pub fn get_tosCheckboxHtml(&self) -> &[::std::string::String] {
        &self.tosCheckboxHtml
    }

    // optional int32 permissionError = 38;


    pub fn get_permissionError(&self) -> i32 {
        self.permissionError.unwrap_or(0)
    }

    // optional .PurchaseStatusResponse purchaseStatusResponse = 39;


    pub fn get_purchaseStatusResponse(&self) -> &PurchaseStatusResponse {
        self.purchaseStatusResponse.as_ref().unwrap_or_else(|| <PurchaseStatusResponse as ::protobuf::Message>::default_instance())
    }

    // optional string purchaseCookie = 46;


    pub fn get_purchaseCookie(&self) -> &str {
        match self.purchaseCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Challenge challenge = 49;


    pub fn get_challenge(&self) -> &Challenge {
        self.challenge.as_ref().unwrap_or_else(|| <Challenge as ::protobuf::Message>::default_instance())
    }

    // optional string addInstrumentPromptHtml = 50;


    pub fn get_addInstrumentPromptHtml(&self) -> &str {
        match self.addInstrumentPromptHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string confirmButtonText = 51;


    pub fn get_confirmButtonText(&self) -> &str {
        match self.confirmButtonText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string permissionErrorTitleText = 52;


    pub fn get_permissionErrorTitleText(&self) -> &str {
        match self.permissionErrorTitleText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string permissionErrorMessageText = 53;


    pub fn get_permissionErrorMessageText(&self) -> &str {
        match self.permissionErrorMessageText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 54;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string encodedDeliveryToken = 55;


    pub fn get_encodedDeliveryToken(&self) -> &str {
        match self.encodedDeliveryToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BuyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.continueViaUrl)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseStatusUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutServiceId)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseCheckoutUrl)?;
                },
                37 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tosCheckboxHtml)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permissionError = ::std::option::Option::Some(tmp);
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseCookie)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentPromptHtml)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.confirmButtonText)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permissionErrorTitleText)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permissionErrorMessageText)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encodedDeliveryToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.purchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.continueViaUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.purchaseStatusUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.checkoutServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.baseCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.tosCheckboxHtml {
            my_size += ::protobuf::rt::string_size(37, &value);
        };
        if let Some(v) = self.permissionError {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(ref v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addInstrumentPromptHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(50, &v);
        }
        if let Some(ref v) = self.confirmButtonText.as_ref() {
            my_size += ::protobuf::rt::string_size(51, &v);
        }
        if let Some(ref v) = self.permissionErrorTitleText.as_ref() {
            my_size += ::protobuf::rt::string_size(52, &v);
        }
        if let Some(ref v) = self.permissionErrorMessageText.as_ref() {
            my_size += ::protobuf::rt::string_size(53, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(54, &v);
        }
        if let Some(ref v) = self.encodedDeliveryToken.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.purchaseResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.continueViaUrl.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.purchaseStatusUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.checkoutServiceId.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.baseCheckoutUrl.as_ref() {
            os.write_string(14, &v)?;
        }
        for v in &self.tosCheckboxHtml {
            os.write_string(37, &v)?;
        };
        if let Some(v) = self.permissionError {
            os.write_int32(38, v)?;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseCookie.as_ref() {
            os.write_string(46, &v)?;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addInstrumentPromptHtml.as_ref() {
            os.write_string(50, &v)?;
        }
        if let Some(ref v) = self.confirmButtonText.as_ref() {
            os.write_string(51, &v)?;
        }
        if let Some(ref v) = self.permissionErrorTitleText.as_ref() {
            os.write_string(52, &v)?;
        }
        if let Some(ref v) = self.permissionErrorMessageText.as_ref() {
            os.write_string(53, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(54, &v)?;
        }
        if let Some(ref v) = self.encodedDeliveryToken.as_ref() {
            os.write_string(55, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse {
        BuyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseNotificationResponse>>(
                "purchaseResponse",
                |m: &BuyResponse| { &m.purchaseResponse },
                |m: &mut BuyResponse| { &mut m.purchaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "continueViaUrl",
                |m: &BuyResponse| { &m.continueViaUrl },
                |m: &mut BuyResponse| { &mut m.continueViaUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseStatusUrl",
                |m: &BuyResponse| { &m.purchaseStatusUrl },
                |m: &mut BuyResponse| { &mut m.purchaseStatusUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutServiceId",
                |m: &BuyResponse| { &m.checkoutServiceId },
                |m: &mut BuyResponse| { &mut m.checkoutServiceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &BuyResponse| { &m.checkoutTokenRequired },
                |m: &mut BuyResponse| { &mut m.checkoutTokenRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baseCheckoutUrl",
                |m: &BuyResponse| { &m.baseCheckoutUrl },
                |m: &mut BuyResponse| { &mut m.baseCheckoutUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosCheckboxHtml",
                |m: &BuyResponse| { &m.tosCheckboxHtml },
                |m: &mut BuyResponse| { &mut m.tosCheckboxHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permissionError",
                |m: &BuyResponse| { &m.permissionError },
                |m: &mut BuyResponse| { &mut m.permissionError },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>>(
                "purchaseStatusResponse",
                |m: &BuyResponse| { &m.purchaseStatusResponse },
                |m: &mut BuyResponse| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseCookie",
                |m: &BuyResponse| { &m.purchaseCookie },
                |m: &mut BuyResponse| { &mut m.purchaseCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>>(
                "challenge",
                |m: &BuyResponse| { &m.challenge },
                |m: &mut BuyResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addInstrumentPromptHtml",
                |m: &BuyResponse| { &m.addInstrumentPromptHtml },
                |m: &mut BuyResponse| { &mut m.addInstrumentPromptHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "confirmButtonText",
                |m: &BuyResponse| { &m.confirmButtonText },
                |m: &mut BuyResponse| { &mut m.confirmButtonText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissionErrorTitleText",
                |m: &BuyResponse| { &m.permissionErrorTitleText },
                |m: &mut BuyResponse| { &mut m.permissionErrorTitleText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permissionErrorMessageText",
                |m: &BuyResponse| { &m.permissionErrorMessageText },
                |m: &mut BuyResponse| { &mut m.permissionErrorMessageText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &BuyResponse| { &m.serverLogsCookie },
                |m: &mut BuyResponse| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encodedDeliveryToken",
                |m: &BuyResponse| { &m.encodedDeliveryToken },
                |m: &mut BuyResponse| { &mut m.encodedDeliveryToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyResponse>(
                "BuyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse {
        static instance: ::protobuf::rt::LazyV2<BuyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyResponse::new)
    }
}

impl ::protobuf::Clear for BuyResponse {
    fn clear(&mut self) {
        self.purchaseResponse.clear();
        self.continueViaUrl.clear();
        self.purchaseStatusUrl.clear();
        self.checkoutServiceId.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.baseCheckoutUrl.clear();
        self.tosCheckboxHtml.clear();
        self.permissionError = ::std::option::Option::None;
        self.purchaseStatusResponse.clear();
        self.purchaseCookie.clear();
        self.challenge.clear();
        self.addInstrumentPromptHtml.clear();
        self.confirmButtonText.clear();
        self.permissionErrorTitleText.clear();
        self.permissionErrorMessageText.clear();
        self.serverLogsCookie.clear();
        self.encodedDeliveryToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuyResponse_CheckoutInfo {
    // message fields
    pub item: ::protobuf::SingularPtrField<LineItem>,
    pub subItem: ::protobuf::RepeatedField<LineItem>,
    // checkoutoption: <group>
    pub deprecatedCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub addInstrumentUrl: ::protobuf::SingularField<::std::string::String>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrumentFamily: ::std::vec::Vec<i32>,
    pub footnoteHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrument: ::protobuf::RepeatedField<Instrument>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyResponse_CheckoutInfo {
    fn default() -> &'a BuyResponse_CheckoutInfo {
        <BuyResponse_CheckoutInfo as ::protobuf::Message>::default_instance()
    }
}

impl BuyResponse_CheckoutInfo {
    pub fn new() -> BuyResponse_CheckoutInfo {
        ::std::default::Default::default()
    }

    // optional .LineItem item = 3;


    pub fn get_item(&self) -> &LineItem {
        self.item.as_ref().unwrap_or_else(|| <LineItem as ::protobuf::Message>::default_instance())
    }

    // repeated .LineItem subItem = 4;


    pub fn get_subItem(&self) -> &[LineItem] {
        &self.subItem
    }

    // optional string deprecatedCheckoutUrl = 10;


    pub fn get_deprecatedCheckoutUrl(&self) -> &str {
        match self.deprecatedCheckoutUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addInstrumentUrl = 11;


    pub fn get_addInstrumentUrl(&self) -> &str {
        match self.addInstrumentUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string footerHtml = 20;


    pub fn get_footerHtml(&self) -> &[::std::string::String] {
        &self.footerHtml
    }

    // repeated int32 eligibleInstrumentFamily = 31;


    pub fn get_eligibleInstrumentFamily(&self) -> &[i32] {
        &self.eligibleInstrumentFamily
    }

    // repeated string footnoteHtml = 36;


    pub fn get_footnoteHtml(&self) -> &[::std::string::String] {
        &self.footnoteHtml
    }

    // repeated .Instrument eligibleInstrument = 44;


    pub fn get_eligibleInstrument(&self) -> &[Instrument] {
        &self.eligibleInstrument
    }
}

impl ::protobuf::Message for BuyResponse_CheckoutInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subItem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eligibleInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subItem)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedCheckoutUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.eligibleInstrumentFamily)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footnoteHtml)?;
                },
                44 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.eligibleInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subItem {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.deprecatedCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.addInstrumentUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.eligibleInstrumentFamily {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.footnoteHtml {
            my_size += ::protobuf::rt::string_size(36, &value);
        };
        for value in &self.eligibleInstrument {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subItem {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.deprecatedCheckoutUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.addInstrumentUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.footerHtml {
            os.write_string(20, &v)?;
        };
        for v in &self.eligibleInstrumentFamily {
            os.write_int32(31, *v)?;
        };
        for v in &self.footnoteHtml {
            os.write_string(36, &v)?;
        };
        for v in &self.eligibleInstrument {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse_CheckoutInfo {
        BuyResponse_CheckoutInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "item",
                |m: &BuyResponse_CheckoutInfo| { &m.item },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "subItem",
                |m: &BuyResponse_CheckoutInfo| { &m.subItem },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.subItem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deprecatedCheckoutUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.deprecatedCheckoutUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.deprecatedCheckoutUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addInstrumentUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.addInstrumentUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.addInstrumentUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footerHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eligibleInstrumentFamily",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrumentFamily },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footnoteHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footnoteHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footnoteHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "eligibleInstrument",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrument },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyResponse_CheckoutInfo>(
                "BuyResponse.CheckoutInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse_CheckoutInfo {
        static instance: ::protobuf::rt::LazyV2<BuyResponse_CheckoutInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyResponse_CheckoutInfo::new)
    }
}

impl ::protobuf::Clear for BuyResponse_CheckoutInfo {
    fn clear(&mut self) {
        self.item.clear();
        self.subItem.clear();
        self.deprecatedCheckoutUrl.clear();
        self.addInstrumentUrl.clear();
        self.footerHtml.clear();
        self.eligibleInstrumentFamily.clear();
        self.footnoteHtml.clear();
        self.eligibleInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse_CheckoutInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse_CheckoutInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LineItem {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::SingularPtrField<Offer>,
    pub amount: ::protobuf::SingularPtrField<Money>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LineItem {
    fn default() -> &'a LineItem {
        <LineItem as ::protobuf::Message>::default_instance()
    }
}

impl LineItem {
    pub fn new() -> LineItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string description = 2;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Offer offer = 3;


    pub fn get_offer(&self) -> &Offer {
        self.offer.as_ref().unwrap_or_else(|| <Offer as ::protobuf::Message>::default_instance())
    }

    // optional .Money amount = 4;


    pub fn get_amount(&self) -> &Money {
        self.amount.as_ref().unwrap_or_else(|| <Money as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LineItem {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LineItem {
        LineItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LineItem| { &m.name },
                |m: &mut LineItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &LineItem| { &m.description },
                |m: &mut LineItem| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &LineItem| { &m.offer },
                |m: &mut LineItem| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>>(
                "amount",
                |m: &LineItem| { &m.amount },
                |m: &mut LineItem| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LineItem>(
                "LineItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LineItem {
        static instance: ::protobuf::rt::LazyV2<LineItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LineItem::new)
    }
}

impl ::protobuf::Clear for LineItem {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.offer.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Money {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Money {
    fn default() -> &'a Money {
        <Money as ::protobuf::Message>::default_instance()
    }
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;


    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Money {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Money {
        Money::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &Money| { &m.micros },
                |m: &mut Money| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &Money| { &m.currencyCode },
                |m: &mut Money| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedAmount",
                |m: &Money| { &m.formattedAmount },
                |m: &mut Money| { &mut m.formattedAmount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Money>(
                "Money",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Money {
        static instance: ::protobuf::rt::LazyV2<Money> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Money::new)
    }
}

impl ::protobuf::Clear for Money {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseNotificationResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub debugInfo: ::protobuf::SingularPtrField<DebugInfo>,
    pub localizedErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub purchaseId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseNotificationResponse {
    fn default() -> &'a PurchaseNotificationResponse {
        <PurchaseNotificationResponse as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseNotificationResponse {
    pub fn new() -> PurchaseNotificationResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional .DebugInfo debugInfo = 2;


    pub fn get_debugInfo(&self) -> &DebugInfo {
        self.debugInfo.as_ref().unwrap_or_else(|| <DebugInfo as ::protobuf::Message>::default_instance())
    }

    // optional string localizedErrorMessage = 3;


    pub fn get_localizedErrorMessage(&self) -> &str {
        match self.localizedErrorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseId = 4;


    pub fn get_purchaseId(&self) -> &str {
        match self.purchaseId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseNotificationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.debugInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debugInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedErrorMessage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.debugInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.localizedErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.purchaseId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.debugInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.localizedErrorMessage.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.purchaseId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseNotificationResponse {
        PurchaseNotificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &PurchaseNotificationResponse| { &m.status },
                |m: &mut PurchaseNotificationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugInfo>>(
                "debugInfo",
                |m: &PurchaseNotificationResponse| { &m.debugInfo },
                |m: &mut PurchaseNotificationResponse| { &mut m.debugInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedErrorMessage",
                |m: &PurchaseNotificationResponse| { &m.localizedErrorMessage },
                |m: &mut PurchaseNotificationResponse| { &mut m.localizedErrorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseId",
                |m: &PurchaseNotificationResponse| { &m.purchaseId },
                |m: &mut PurchaseNotificationResponse| { &mut m.purchaseId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseNotificationResponse>(
                "PurchaseNotificationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseNotificationResponse {
        static instance: ::protobuf::rt::LazyV2<PurchaseNotificationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseNotificationResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseNotificationResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.debugInfo.clear();
        self.localizedErrorMessage.clear();
        self.purchaseId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseNotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseNotificationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseStatusResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub statusMsg: ::protobuf::SingularField<::std::string::String>,
    pub statusTitle: ::protobuf::SingularField<::std::string::String>,
    pub briefMessage: ::protobuf::SingularField<::std::string::String>,
    pub infoUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub rejectedInstrument: ::protobuf::SingularPtrField<Instrument>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseStatusResponse {
    fn default() -> &'a PurchaseStatusResponse {
        <PurchaseStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseStatusResponse {
    pub fn new() -> PurchaseStatusResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional string statusMsg = 2;


    pub fn get_statusMsg(&self) -> &str {
        match self.statusMsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string statusTitle = 3;


    pub fn get_statusTitle(&self) -> &str {
        match self.statusTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string briefMessage = 4;


    pub fn get_briefMessage(&self) -> &str {
        match self.briefMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string infoUrl = 5;


    pub fn get_infoUrl(&self) -> &str {
        match self.infoUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .LibraryUpdate libraryUpdate = 6;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }

    // optional .Instrument rejectedInstrument = 7;


    pub fn get_rejectedInstrument(&self) -> &Instrument {
        self.rejectedInstrument.as_ref().unwrap_or_else(|| <Instrument as ::protobuf::Message>::default_instance())
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 8;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchaseStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rejectedInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusMsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.briefMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.infoUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rejectedInstrument)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.statusMsg.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.statusTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.briefMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.infoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rejectedInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.statusMsg.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.statusTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.briefMessage.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.infoUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rejectedInstrument.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseStatusResponse {
        PurchaseStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &PurchaseStatusResponse| { &m.status },
                |m: &mut PurchaseStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statusMsg",
                |m: &PurchaseStatusResponse| { &m.statusMsg },
                |m: &mut PurchaseStatusResponse| { &mut m.statusMsg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statusTitle",
                |m: &PurchaseStatusResponse| { &m.statusTitle },
                |m: &mut PurchaseStatusResponse| { &mut m.statusTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "briefMessage",
                |m: &PurchaseStatusResponse| { &m.briefMessage },
                |m: &mut PurchaseStatusResponse| { &mut m.briefMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "infoUrl",
                |m: &PurchaseStatusResponse| { &m.infoUrl },
                |m: &mut PurchaseStatusResponse| { &mut m.infoUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &PurchaseStatusResponse| { &m.libraryUpdate },
                |m: &mut PurchaseStatusResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "rejectedInstrument",
                |m: &PurchaseStatusResponse| { &m.rejectedInstrument },
                |m: &mut PurchaseStatusResponse| { &mut m.rejectedInstrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &PurchaseStatusResponse| { &m.appDeliveryData },
                |m: &mut PurchaseStatusResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseStatusResponse>(
                "PurchaseStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseStatusResponse {
        static instance: ::protobuf::rt::LazyV2<PurchaseStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseStatusResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseStatusResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.statusMsg.clear();
        self.statusTitle.clear();
        self.briefMessage.clear();
        self.infoUrl.clear();
        self.libraryUpdate.clear();
        self.rejectedInstrument.clear();
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingProfileResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub billingProfile: ::protobuf::SingularPtrField<BillingProfile>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingProfileResponse {
    fn default() -> &'a BillingProfileResponse {
        <BillingProfileResponse as ::protobuf::Message>::default_instance()
    }
}

impl BillingProfileResponse {
    pub fn new() -> BillingProfileResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional .BillingProfile billingProfile = 2;


    pub fn get_billingProfile(&self) -> &BillingProfile {
        self.billingProfile.as_ref().unwrap_or_else(|| <BillingProfile as ::protobuf::Message>::default_instance())
    }

    // optional string userMessageHtml = 3;


    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BillingProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.billingProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingProfile)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.billingProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.billingProfile.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfileResponse {
        BillingProfileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &BillingProfileResponse| { &m.result },
                |m: &mut BillingProfileResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfile>>(
                "billingProfile",
                |m: &BillingProfileResponse| { &m.billingProfile },
                |m: &mut BillingProfileResponse| { &mut m.billingProfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userMessageHtml",
                |m: &BillingProfileResponse| { &m.userMessageHtml },
                |m: &mut BillingProfileResponse| { &mut m.userMessageHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingProfileResponse>(
                "BillingProfileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfileResponse {
        static instance: ::protobuf::rt::LazyV2<BillingProfileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingProfileResponse::new)
    }
}

impl ::protobuf::Clear for BillingProfileResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.billingProfile.clear();
        self.userMessageHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckInstrumentResponse {
    // message fields
    pub userHasValidInstrument: ::std::option::Option<bool>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub instrument: ::protobuf::RepeatedField<Instrument>,
    pub eligibleInstrument: ::protobuf::RepeatedField<Instrument>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckInstrumentResponse {
    fn default() -> &'a CheckInstrumentResponse {
        <CheckInstrumentResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckInstrumentResponse {
    pub fn new() -> CheckInstrumentResponse {
        ::std::default::Default::default()
    }

    // optional bool userHasValidInstrument = 1;


    pub fn get_userHasValidInstrument(&self) -> bool {
        self.userHasValidInstrument.unwrap_or(false)
    }

    // optional bool checkoutTokenRequired = 2;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }

    // repeated .Instrument instrument = 4;


    pub fn get_instrument(&self) -> &[Instrument] {
        &self.instrument
    }

    // repeated .Instrument eligibleInstrument = 5;


    pub fn get_eligibleInstrument(&self) -> &[Instrument] {
        &self.eligibleInstrument
    }
}

impl ::protobuf::Message for CheckInstrumentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eligibleInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userHasValidInstrument = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instrument)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.eligibleInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userHasValidInstrument {
            my_size += 2;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        for value in &self.instrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.eligibleInstrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userHasValidInstrument {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(2, v)?;
        }
        for v in &self.instrument {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.eligibleInstrument {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckInstrumentResponse {
        CheckInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "userHasValidInstrument",
                |m: &CheckInstrumentResponse| { &m.userHasValidInstrument },
                |m: &mut CheckInstrumentResponse| { &mut m.userHasValidInstrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &CheckInstrumentResponse| { &m.checkoutTokenRequired },
                |m: &mut CheckInstrumentResponse| { &mut m.checkoutTokenRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &CheckInstrumentResponse| { &m.instrument },
                |m: &mut CheckInstrumentResponse| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "eligibleInstrument",
                |m: &CheckInstrumentResponse| { &m.eligibleInstrument },
                |m: &mut CheckInstrumentResponse| { &mut m.eligibleInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckInstrumentResponse>(
                "CheckInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckInstrumentResponse {
        static instance: ::protobuf::rt::LazyV2<CheckInstrumentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for CheckInstrumentResponse {
    fn clear(&mut self) {
        self.userHasValidInstrument = ::std::option::Option::None;
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.instrument.clear();
        self.eligibleInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckInstrumentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InstrumentSetupInfoResponse {
    // message fields
    pub setupInfo: ::protobuf::RepeatedField<InstrumentSetupInfo>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentSetupInfoResponse {
    fn default() -> &'a InstrumentSetupInfoResponse {
        <InstrumentSetupInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentSetupInfoResponse {
    pub fn new() -> InstrumentSetupInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .InstrumentSetupInfo setupInfo = 1;


    pub fn get_setupInfo(&self) -> &[InstrumentSetupInfo] {
        &self.setupInfo
    }

    // optional bool checkoutTokenRequired = 2;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for InstrumentSetupInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.setupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.setupInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.setupInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.setupInfo {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentSetupInfoResponse {
        InstrumentSetupInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentSetupInfo>>(
                "setupInfo",
                |m: &InstrumentSetupInfoResponse| { &m.setupInfo },
                |m: &mut InstrumentSetupInfoResponse| { &mut m.setupInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &InstrumentSetupInfoResponse| { &m.checkoutTokenRequired },
                |m: &mut InstrumentSetupInfoResponse| { &mut m.checkoutTokenRequired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentSetupInfoResponse>(
                "InstrumentSetupInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentSetupInfoResponse {
        static instance: ::protobuf::rt::LazyV2<InstrumentSetupInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentSetupInfoResponse::new)
    }
}

impl ::protobuf::Clear for InstrumentSetupInfoResponse {
    fn clear(&mut self) {
        self.setupInfo.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentSetupInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentSetupInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedeemGiftCardRequest {
    // message fields
    pub giftCardPin: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<Address>,
    pub acceptedLegalDocumentId: ::protobuf::RepeatedField<::std::string::String>,
    pub checkoutToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedeemGiftCardRequest {
    fn default() -> &'a RedeemGiftCardRequest {
        <RedeemGiftCardRequest as ::protobuf::Message>::default_instance()
    }
}

impl RedeemGiftCardRequest {
    pub fn new() -> RedeemGiftCardRequest {
        ::std::default::Default::default()
    }

    // optional string giftCardPin = 1;


    pub fn get_giftCardPin(&self) -> &str {
        match self.giftCardPin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Address address = 2;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // repeated string acceptedLegalDocumentId = 3;


    pub fn get_acceptedLegalDocumentId(&self) -> &[::std::string::String] {
        &self.acceptedLegalDocumentId
    }

    // optional string checkoutToken = 4;


    pub fn get_checkoutToken(&self) -> &str {
        match self.checkoutToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RedeemGiftCardRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.giftCardPin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.acceptedLegalDocumentId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.giftCardPin.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.acceptedLegalDocumentId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.checkoutToken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.giftCardPin.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.acceptedLegalDocumentId {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.checkoutToken.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCardRequest {
        RedeemGiftCardRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "giftCardPin",
                |m: &RedeemGiftCardRequest| { &m.giftCardPin },
                |m: &mut RedeemGiftCardRequest| { &mut m.giftCardPin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &RedeemGiftCardRequest| { &m.address },
                |m: &mut RedeemGiftCardRequest| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acceptedLegalDocumentId",
                |m: &RedeemGiftCardRequest| { &m.acceptedLegalDocumentId },
                |m: &mut RedeemGiftCardRequest| { &mut m.acceptedLegalDocumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutToken",
                |m: &RedeemGiftCardRequest| { &m.checkoutToken },
                |m: &mut RedeemGiftCardRequest| { &mut m.checkoutToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedeemGiftCardRequest>(
                "RedeemGiftCardRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCardRequest {
        static instance: ::protobuf::rt::LazyV2<RedeemGiftCardRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedeemGiftCardRequest::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCardRequest {
    fn clear(&mut self) {
        self.giftCardPin.clear();
        self.address.clear();
        self.acceptedLegalDocumentId.clear();
        self.checkoutToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedeemGiftCardResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub balanceHtml: ::protobuf::SingularField<::std::string::String>,
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedeemGiftCardResponse {
    fn default() -> &'a RedeemGiftCardResponse {
        <RedeemGiftCardResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedeemGiftCardResponse {
    pub fn new() -> RedeemGiftCardResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string userMessageHtml = 2;


    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string balanceHtml = 3;


    pub fn get_balanceHtml(&self) -> &str {
        match self.balanceHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AddressChallenge addressChallenge = 4;


    pub fn get_addressChallenge(&self) -> &AddressChallenge {
        self.addressChallenge.as_ref().unwrap_or_else(|| <AddressChallenge as ::protobuf::Message>::default_instance())
    }

    // optional bool checkoutTokenRequired = 5;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for RedeemGiftCardResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.balanceHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressChallenge)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.balanceHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.balanceHtml.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.addressChallenge.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCardResponse {
        RedeemGiftCardResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &RedeemGiftCardResponse| { &m.result },
                |m: &mut RedeemGiftCardResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userMessageHtml",
                |m: &RedeemGiftCardResponse| { &m.userMessageHtml },
                |m: &mut RedeemGiftCardResponse| { &mut m.userMessageHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "balanceHtml",
                |m: &RedeemGiftCardResponse| { &m.balanceHtml },
                |m: &mut RedeemGiftCardResponse| { &mut m.balanceHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>>(
                "addressChallenge",
                |m: &RedeemGiftCardResponse| { &m.addressChallenge },
                |m: &mut RedeemGiftCardResponse| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &RedeemGiftCardResponse| { &m.checkoutTokenRequired },
                |m: &mut RedeemGiftCardResponse| { &mut m.checkoutTokenRequired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedeemGiftCardResponse>(
                "RedeemGiftCardResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCardResponse {
        static instance: ::protobuf::rt::LazyV2<RedeemGiftCardResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedeemGiftCardResponse::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCardResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.userMessageHtml.clear();
        self.balanceHtml.clear();
        self.addressChallenge.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateInstrumentRequest {
    // message fields
    pub instrument: ::protobuf::SingularPtrField<Instrument>,
    pub checkoutToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateInstrumentRequest {
    fn default() -> &'a UpdateInstrumentRequest {
        <UpdateInstrumentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInstrumentRequest {
    pub fn new() -> UpdateInstrumentRequest {
        ::std::default::Default::default()
    }

    // optional .Instrument instrument = 1;


    pub fn get_instrument(&self) -> &Instrument {
        self.instrument.as_ref().unwrap_or_else(|| <Instrument as ::protobuf::Message>::default_instance())
    }

    // optional string checkoutToken = 2;


    pub fn get_checkoutToken(&self) -> &str {
        match self.checkoutToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UpdateInstrumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrument)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkoutToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrument.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkoutToken.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInstrumentRequest {
        UpdateInstrumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &UpdateInstrumentRequest| { &m.instrument },
                |m: &mut UpdateInstrumentRequest| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutToken",
                |m: &UpdateInstrumentRequest| { &m.checkoutToken },
                |m: &mut UpdateInstrumentRequest| { &mut m.checkoutToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateInstrumentRequest>(
                "UpdateInstrumentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateInstrumentRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateInstrumentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateInstrumentRequest::new)
    }
}

impl ::protobuf::Clear for UpdateInstrumentRequest {
    fn clear(&mut self) {
        self.instrument.clear();
        self.checkoutToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInstrumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInstrumentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateInstrumentResponse {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub instrumentId: ::protobuf::SingularField<::std::string::String>,
    pub userMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub redeemedOffer: ::protobuf::SingularPtrField<RedeemedPromoOffer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateInstrumentResponse {
    fn default() -> &'a UpdateInstrumentResponse {
        <UpdateInstrumentResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateInstrumentResponse {
    pub fn new() -> UpdateInstrumentResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional string instrumentId = 2;


    pub fn get_instrumentId(&self) -> &str {
        match self.instrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userMessageHtml = 3;


    pub fn get_userMessageHtml(&self) -> &str {
        match self.userMessageHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .InputValidationError errorInputField = 4;


    pub fn get_errorInputField(&self) -> &[InputValidationError] {
        &self.errorInputField
    }

    // optional bool checkoutTokenRequired = 5;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }

    // optional .RedeemedPromoOffer redeemedOffer = 6;


    pub fn get_redeemedOffer(&self) -> &RedeemedPromoOffer {
        self.redeemedOffer.as_ref().unwrap_or_else(|| <RedeemedPromoOffer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for UpdateInstrumentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemedOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userMessageHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errorInputField)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeemedOffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.instrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.redeemedOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.instrumentId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.userMessageHtml.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.errorInputField {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.redeemedOffer.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateInstrumentResponse {
        UpdateInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &UpdateInstrumentResponse| { &m.result },
                |m: &mut UpdateInstrumentResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentId",
                |m: &UpdateInstrumentResponse| { &m.instrumentId },
                |m: &mut UpdateInstrumentResponse| { &mut m.instrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userMessageHtml",
                |m: &UpdateInstrumentResponse| { &m.userMessageHtml },
                |m: &mut UpdateInstrumentResponse| { &mut m.userMessageHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &UpdateInstrumentResponse| { &m.errorInputField },
                |m: &mut UpdateInstrumentResponse| { &mut m.errorInputField },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &UpdateInstrumentResponse| { &m.checkoutTokenRequired },
                |m: &mut UpdateInstrumentResponse| { &mut m.checkoutTokenRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemedPromoOffer>>(
                "redeemedOffer",
                |m: &UpdateInstrumentResponse| { &m.redeemedOffer },
                |m: &mut UpdateInstrumentResponse| { &mut m.redeemedOffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateInstrumentResponse>(
                "UpdateInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateInstrumentResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateInstrumentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for UpdateInstrumentResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.instrumentId.clear();
        self.userMessageHtml.clear();
        self.errorInputField.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.redeemedOffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateInstrumentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InitiateAssociationResponse {
    // message fields
    pub userToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitiateAssociationResponse {
    fn default() -> &'a InitiateAssociationResponse {
        <InitiateAssociationResponse as ::protobuf::Message>::default_instance()
    }
}

impl InitiateAssociationResponse {
    pub fn new() -> InitiateAssociationResponse {
        ::std::default::Default::default()
    }

    // optional string userToken = 1;


    pub fn get_userToken(&self) -> &str {
        match self.userToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InitiateAssociationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.userToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.userToken.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitiateAssociationResponse {
        InitiateAssociationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userToken",
                |m: &InitiateAssociationResponse| { &m.userToken },
                |m: &mut InitiateAssociationResponse| { &mut m.userToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InitiateAssociationResponse>(
                "InitiateAssociationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InitiateAssociationResponse {
        static instance: ::protobuf::rt::LazyV2<InitiateAssociationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InitiateAssociationResponse::new)
    }
}

impl ::protobuf::Clear for InitiateAssociationResponse {
    fn clear(&mut self) {
        self.userToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitiateAssociationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitiateAssociationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VerifyAssociationResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub billingAddress: ::protobuf::SingularPtrField<Address>,
    pub carrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    pub carrierErrorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyAssociationResponse {
    fn default() -> &'a VerifyAssociationResponse {
        <VerifyAssociationResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyAssociationResponse {
    pub fn new() -> VerifyAssociationResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional .Address billingAddress = 2;


    pub fn get_billingAddress(&self) -> &Address {
        self.billingAddress.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierTos carrierTos = 3;


    pub fn get_carrierTos(&self) -> &CarrierTos {
        self.carrierTos.as_ref().unwrap_or_else(|| <CarrierTos as ::protobuf::Message>::default_instance())
    }

    // optional string carrierErrorMessage = 4;


    pub fn get_carrierErrorMessage(&self) -> &str {
        match self.carrierErrorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VerifyAssociationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierTos)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierErrorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierTos.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierErrorMessage.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyAssociationResponse {
        VerifyAssociationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VerifyAssociationResponse| { &m.status },
                |m: &mut VerifyAssociationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "billingAddress",
                |m: &VerifyAssociationResponse| { &m.billingAddress },
                |m: &mut VerifyAssociationResponse| { &mut m.billingAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>>(
                "carrierTos",
                |m: &VerifyAssociationResponse| { &m.carrierTos },
                |m: &mut VerifyAssociationResponse| { &mut m.carrierTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "carrierErrorMessage",
                |m: &VerifyAssociationResponse| { &m.carrierErrorMessage },
                |m: &mut VerifyAssociationResponse| { &mut m.carrierErrorMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyAssociationResponse>(
                "VerifyAssociationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyAssociationResponse {
        static instance: ::protobuf::rt::LazyV2<VerifyAssociationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyAssociationResponse::new)
    }
}

impl ::protobuf::Clear for VerifyAssociationResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.billingAddress.clear();
        self.carrierTos.clear();
        self.carrierErrorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyAssociationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyAssociationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddressChallenge {
    // message fields
    pub responseAddressParam: ::protobuf::SingularField<::std::string::String>,
    pub responseCheckboxesParam: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub checkbox: ::protobuf::RepeatedField<FormCheckbox>,
    pub address: ::protobuf::SingularPtrField<Address>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    pub errorHtml: ::protobuf::SingularField<::std::string::String>,
    pub requiredField: ::std::vec::Vec<i32>,
    pub supportedCountry: ::protobuf::RepeatedField<Country>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressChallenge {
    fn default() -> &'a AddressChallenge {
        <AddressChallenge as ::protobuf::Message>::default_instance()
    }
}

impl AddressChallenge {
    pub fn new() -> AddressChallenge {
        ::std::default::Default::default()
    }

    // optional string responseAddressParam = 1;


    pub fn get_responseAddressParam(&self) -> &str {
        match self.responseAddressParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string responseCheckboxesParam = 2;


    pub fn get_responseCheckboxesParam(&self) -> &str {
        match self.responseCheckboxesParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .FormCheckbox checkbox = 5;


    pub fn get_checkbox(&self) -> &[FormCheckbox] {
        &self.checkbox
    }

    // optional .Address address = 6;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // repeated .InputValidationError errorInputField = 7;


    pub fn get_errorInputField(&self) -> &[InputValidationError] {
        &self.errorInputField
    }

    // optional string errorHtml = 8;


    pub fn get_errorHtml(&self) -> &str {
        match self.errorHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 requiredField = 9;


    pub fn get_requiredField(&self) -> &[i32] {
        &self.requiredField
    }

    // repeated .Country supportedCountry = 10;


    pub fn get_supportedCountry(&self) -> &[Country] {
        &self.supportedCountry
    }
}

impl ::protobuf::Message for AddressChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.checkbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.supportedCountry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAddressParam)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseCheckboxesParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.checkbox)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errorInputField)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorHtml)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.supportedCountry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.responseAddressParam.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.responseCheckboxesParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.checkbox {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.errorHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.supportedCountry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.responseAddressParam.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.responseCheckboxesParam.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.checkbox {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errorInputField {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.errorHtml.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.requiredField {
            os.write_int32(9, *v)?;
        };
        for v in &self.supportedCountry {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressChallenge {
        AddressChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseAddressParam",
                |m: &AddressChallenge| { &m.responseAddressParam },
                |m: &mut AddressChallenge| { &mut m.responseAddressParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseCheckboxesParam",
                |m: &AddressChallenge| { &m.responseCheckboxesParam },
                |m: &mut AddressChallenge| { &mut m.responseCheckboxesParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &AddressChallenge| { &m.title },
                |m: &mut AddressChallenge| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &AddressChallenge| { &m.descriptionHtml },
                |m: &mut AddressChallenge| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FormCheckbox>>(
                "checkbox",
                |m: &AddressChallenge| { &m.checkbox },
                |m: &mut AddressChallenge| { &mut m.checkbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &AddressChallenge| { &m.address },
                |m: &mut AddressChallenge| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &AddressChallenge| { &m.errorInputField },
                |m: &mut AddressChallenge| { &mut m.errorInputField },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorHtml",
                |m: &AddressChallenge| { &m.errorHtml },
                |m: &mut AddressChallenge| { &mut m.errorHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &AddressChallenge| { &m.requiredField },
                |m: &mut AddressChallenge| { &mut m.requiredField },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Country>>(
                "supportedCountry",
                |m: &AddressChallenge| { &m.supportedCountry },
                |m: &mut AddressChallenge| { &mut m.supportedCountry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressChallenge>(
                "AddressChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressChallenge {
        static instance: ::protobuf::rt::LazyV2<AddressChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressChallenge::new)
    }
}

impl ::protobuf::Clear for AddressChallenge {
    fn clear(&mut self) {
        self.responseAddressParam.clear();
        self.responseCheckboxesParam.clear();
        self.title.clear();
        self.descriptionHtml.clear();
        self.checkbox.clear();
        self.address.clear();
        self.errorInputField.clear();
        self.errorHtml.clear();
        self.requiredField.clear();
        self.supportedCountry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AuthenticationChallenge {
    // message fields
    pub authenticationType: ::std::option::Option<i32>,
    pub responseAuthenticationTypeParam: ::protobuf::SingularField<::std::string::String>,
    pub responseRetryCountParam: ::protobuf::SingularField<::std::string::String>,
    pub gaiaHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub gaiaDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub gaiaFooterTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub gaiaOptOutCheckbox: ::protobuf::SingularPtrField<FormCheckbox>,
    pub gaiaOptOutDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticationChallenge {
    fn default() -> &'a AuthenticationChallenge {
        <AuthenticationChallenge as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationChallenge {
    pub fn new() -> AuthenticationChallenge {
        ::std::default::Default::default()
    }

    // optional int32 authenticationType = 1;


    pub fn get_authenticationType(&self) -> i32 {
        self.authenticationType.unwrap_or(0)
    }

    // optional string responseAuthenticationTypeParam = 2;


    pub fn get_responseAuthenticationTypeParam(&self) -> &str {
        match self.responseAuthenticationTypeParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string responseRetryCountParam = 3;


    pub fn get_responseRetryCountParam(&self) -> &str {
        match self.responseRetryCountParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gaiaHeaderText = 6;


    pub fn get_gaiaHeaderText(&self) -> &str {
        match self.gaiaHeaderText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gaiaDescriptionTextHtml = 7;


    pub fn get_gaiaDescriptionTextHtml(&self) -> &str {
        match self.gaiaDescriptionTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gaiaFooterTextHtml = 8;


    pub fn get_gaiaFooterTextHtml(&self) -> &str {
        match self.gaiaFooterTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .FormCheckbox gaiaOptOutCheckbox = 9;


    pub fn get_gaiaOptOutCheckbox(&self) -> &FormCheckbox {
        self.gaiaOptOutCheckbox.as_ref().unwrap_or_else(|| <FormCheckbox as ::protobuf::Message>::default_instance())
    }

    // optional string gaiaOptOutDescriptionTextHtml = 10;


    pub fn get_gaiaOptOutDescriptionTextHtml(&self) -> &str {
        match self.gaiaOptOutDescriptionTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AuthenticationChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.gaiaOptOutCheckbox {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.authenticationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAuthenticationTypeParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseRetryCountParam)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaHeaderText)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaDescriptionTextHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaFooterTextHtml)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gaiaOptOutCheckbox)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaOptOutDescriptionTextHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authenticationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.responseAuthenticationTypeParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.responseRetryCountParam.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.gaiaHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.gaiaDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.gaiaFooterTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.gaiaOptOutCheckbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gaiaOptOutDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authenticationType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.responseAuthenticationTypeParam.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.responseRetryCountParam.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.gaiaHeaderText.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.gaiaDescriptionTextHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.gaiaFooterTextHtml.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.gaiaOptOutCheckbox.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gaiaOptOutDescriptionTextHtml.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationChallenge {
        AuthenticationChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "authenticationType",
                |m: &AuthenticationChallenge| { &m.authenticationType },
                |m: &mut AuthenticationChallenge| { &mut m.authenticationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseAuthenticationTypeParam",
                |m: &AuthenticationChallenge| { &m.responseAuthenticationTypeParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseAuthenticationTypeParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseRetryCountParam",
                |m: &AuthenticationChallenge| { &m.responseRetryCountParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseRetryCountParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaHeaderText",
                |m: &AuthenticationChallenge| { &m.gaiaHeaderText },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaHeaderText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaDescriptionTextHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaFooterTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaFooterTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaFooterTextHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FormCheckbox>>(
                "gaiaOptOutCheckbox",
                |m: &AuthenticationChallenge| { &m.gaiaOptOutCheckbox },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaOptOutCheckbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaOptOutDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaOptOutDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaOptOutDescriptionTextHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticationChallenge>(
                "AuthenticationChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationChallenge {
        static instance: ::protobuf::rt::LazyV2<AuthenticationChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticationChallenge::new)
    }
}

impl ::protobuf::Clear for AuthenticationChallenge {
    fn clear(&mut self) {
        self.authenticationType = ::std::option::Option::None;
        self.responseAuthenticationTypeParam.clear();
        self.responseRetryCountParam.clear();
        self.gaiaHeaderText.clear();
        self.gaiaDescriptionTextHtml.clear();
        self.gaiaFooterTextHtml.clear();
        self.gaiaOptOutCheckbox.clear();
        self.gaiaOptOutDescriptionTextHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Challenge {
    // message fields
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub authenticationChallenge: ::protobuf::SingularPtrField<AuthenticationChallenge>,
    pub webViewChallenge: ::protobuf::SingularPtrField<WebViewChallenge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Challenge {
    fn default() -> &'a Challenge {
        <Challenge as ::protobuf::Message>::default_instance()
    }
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }

    // optional .AddressChallenge addressChallenge = 1;


    pub fn get_addressChallenge(&self) -> &AddressChallenge {
        self.addressChallenge.as_ref().unwrap_or_else(|| <AddressChallenge as ::protobuf::Message>::default_instance())
    }

    // optional .AuthenticationChallenge authenticationChallenge = 2;


    pub fn get_authenticationChallenge(&self) -> &AuthenticationChallenge {
        self.authenticationChallenge.as_ref().unwrap_or_else(|| <AuthenticationChallenge as ::protobuf::Message>::default_instance())
    }

    // optional .WebViewChallenge webViewChallenge = 3;


    pub fn get_webViewChallenge(&self) -> &WebViewChallenge {
        self.webViewChallenge.as_ref().unwrap_or_else(|| <WebViewChallenge as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Challenge {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticationChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.webViewChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressChallenge)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticationChallenge)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.webViewChallenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authenticationChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.webViewChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addressChallenge.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authenticationChallenge.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.webViewChallenge.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>>(
                "addressChallenge",
                |m: &Challenge| { &m.addressChallenge },
                |m: &mut Challenge| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationChallenge>>(
                "authenticationChallenge",
                |m: &Challenge| { &m.authenticationChallenge },
                |m: &mut Challenge| { &mut m.authenticationChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WebViewChallenge>>(
                "webViewChallenge",
                |m: &Challenge| { &m.webViewChallenge },
                |m: &mut Challenge| { &mut m.webViewChallenge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Challenge>(
                "Challenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Challenge {
        static instance: ::protobuf::rt::LazyV2<Challenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Challenge::new)
    }
}

impl ::protobuf::Clear for Challenge {
    fn clear(&mut self) {
        self.addressChallenge.clear();
        self.authenticationChallenge.clear();
        self.webViewChallenge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Country {
    // message fields
    pub regionCode: ::protobuf::SingularField<::std::string::String>,
    pub displayName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Country {
    fn default() -> &'a Country {
        <Country as ::protobuf::Message>::default_instance()
    }
}

impl Country {
    pub fn new() -> Country {
        ::std::default::Default::default()
    }

    // optional string regionCode = 1;


    pub fn get_regionCode(&self) -> &str {
        match self.regionCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string displayName = 2;


    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Country {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.regionCode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.regionCode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.regionCode.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.displayName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Country {
        Country::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "regionCode",
                |m: &Country| { &m.regionCode },
                |m: &mut Country| { &mut m.regionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayName",
                |m: &Country| { &m.displayName },
                |m: &mut Country| { &mut m.displayName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Country>(
                "Country",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Country {
        static instance: ::protobuf::rt::LazyV2<Country> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Country::new)
    }
}

impl ::protobuf::Clear for Country {
    fn clear(&mut self) {
        self.regionCode.clear();
        self.displayName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Country {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Country {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FormCheckbox {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub checked: ::std::option::Option<bool>,
    pub required: ::std::option::Option<bool>,
    pub id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormCheckbox {
    fn default() -> &'a FormCheckbox {
        <FormCheckbox as ::protobuf::Message>::default_instance()
    }
}

impl FormCheckbox {
    pub fn new() -> FormCheckbox {
        ::std::default::Default::default()
    }

    // optional string description = 1;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool checked = 2;


    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    // optional bool required = 3;


    pub fn get_required(&self) -> bool {
        self.required.unwrap_or(false)
    }

    // optional string id = 4;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FormCheckbox {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        if let Some(v) = self.required {
            my_size += 2;
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FormCheckbox {
        FormCheckbox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &FormCheckbox| { &m.description },
                |m: &mut FormCheckbox| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checked",
                |m: &FormCheckbox| { &m.checked },
                |m: &mut FormCheckbox| { &mut m.checked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "required",
                |m: &FormCheckbox| { &m.required },
                |m: &mut FormCheckbox| { &mut m.required },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &FormCheckbox| { &m.id },
                |m: &mut FormCheckbox| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FormCheckbox>(
                "FormCheckbox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FormCheckbox {
        static instance: ::protobuf::rt::LazyV2<FormCheckbox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FormCheckbox::new)
    }
}

impl ::protobuf::Clear for FormCheckbox {
    fn clear(&mut self) {
        self.description.clear();
        self.checked = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormCheckbox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormCheckbox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InputValidationError {
    // message fields
    pub inputField: ::std::option::Option<i32>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputValidationError {
    fn default() -> &'a InputValidationError {
        <InputValidationError as ::protobuf::Message>::default_instance()
    }
}

impl InputValidationError {
    pub fn new() -> InputValidationError {
        ::std::default::Default::default()
    }

    // optional int32 inputField = 1;


    pub fn get_inputField(&self) -> i32 {
        self.inputField.unwrap_or(0)
    }

    // optional string errorMessage = 2;


    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InputValidationError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inputField = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inputField {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inputField {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputValidationError {
        InputValidationError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "inputField",
                |m: &InputValidationError| { &m.inputField },
                |m: &mut InputValidationError| { &mut m.inputField },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessage",
                |m: &InputValidationError| { &m.errorMessage },
                |m: &mut InputValidationError| { &mut m.errorMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputValidationError>(
                "InputValidationError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputValidationError {
        static instance: ::protobuf::rt::LazyV2<InputValidationError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputValidationError::new)
    }
}

impl ::protobuf::Clear for InputValidationError {
    fn clear(&mut self) {
        self.inputField = ::std::option::Option::None;
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputValidationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputValidationError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WebViewChallenge {
    // message fields
    pub startUrl: ::protobuf::SingularField<::std::string::String>,
    pub targetUrlRegexp: ::protobuf::SingularField<::std::string::String>,
    pub cancelButtonDisplayLabel: ::protobuf::SingularField<::std::string::String>,
    pub responseTargetUrlParam: ::protobuf::SingularField<::std::string::String>,
    pub cancelUrlRegexp: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebViewChallenge {
    fn default() -> &'a WebViewChallenge {
        <WebViewChallenge as ::protobuf::Message>::default_instance()
    }
}

impl WebViewChallenge {
    pub fn new() -> WebViewChallenge {
        ::std::default::Default::default()
    }

    // optional string startUrl = 1;


    pub fn get_startUrl(&self) -> &str {
        match self.startUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string targetUrlRegexp = 2;


    pub fn get_targetUrlRegexp(&self) -> &str {
        match self.targetUrlRegexp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string cancelButtonDisplayLabel = 3;


    pub fn get_cancelButtonDisplayLabel(&self) -> &str {
        match self.cancelButtonDisplayLabel.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string responseTargetUrlParam = 4;


    pub fn get_responseTargetUrlParam(&self) -> &str {
        match self.responseTargetUrlParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string cancelUrlRegexp = 5;


    pub fn get_cancelUrlRegexp(&self) -> &str {
        match self.cancelUrlRegexp.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 6;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for WebViewChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.startUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetUrlRegexp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cancelButtonDisplayLabel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseTargetUrlParam)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cancelUrlRegexp)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.startUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.targetUrlRegexp.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.cancelButtonDisplayLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.responseTargetUrlParam.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.cancelUrlRegexp.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.startUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.targetUrlRegexp.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.cancelButtonDisplayLabel.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.responseTargetUrlParam.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.cancelUrlRegexp.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebViewChallenge {
        WebViewChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "startUrl",
                |m: &WebViewChallenge| { &m.startUrl },
                |m: &mut WebViewChallenge| { &mut m.startUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetUrlRegexp",
                |m: &WebViewChallenge| { &m.targetUrlRegexp },
                |m: &mut WebViewChallenge| { &mut m.targetUrlRegexp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cancelButtonDisplayLabel",
                |m: &WebViewChallenge| { &m.cancelButtonDisplayLabel },
                |m: &mut WebViewChallenge| { &mut m.cancelButtonDisplayLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseTargetUrlParam",
                |m: &WebViewChallenge| { &m.responseTargetUrlParam },
                |m: &mut WebViewChallenge| { &mut m.responseTargetUrlParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cancelUrlRegexp",
                |m: &WebViewChallenge| { &m.cancelUrlRegexp },
                |m: &mut WebViewChallenge| { &mut m.cancelUrlRegexp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &WebViewChallenge| { &m.title },
                |m: &mut WebViewChallenge| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WebViewChallenge>(
                "WebViewChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WebViewChallenge {
        static instance: ::protobuf::rt::LazyV2<WebViewChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebViewChallenge::new)
    }
}

impl ::protobuf::Clear for WebViewChallenge {
    fn clear(&mut self) {
        self.startUrl.clear();
        self.targetUrlRegexp.clear();
        self.cancelButtonDisplayLabel.clear();
        self.responseTargetUrlParam.clear();
        self.cancelUrlRegexp.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WebViewChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebViewChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddCreditCardPromoOffer {
    // message fields
    pub headerText: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub introductoryTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub offerTitle: ::protobuf::SingularField<::std::string::String>,
    pub noActionDescription: ::protobuf::SingularField<::std::string::String>,
    pub termsAndConditionsHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCreditCardPromoOffer {
    fn default() -> &'a AddCreditCardPromoOffer {
        <AddCreditCardPromoOffer as ::protobuf::Message>::default_instance()
    }
}

impl AddCreditCardPromoOffer {
    pub fn new() -> AddCreditCardPromoOffer {
        ::std::default::Default::default()
    }

    // optional string headerText = 1;


    pub fn get_headerText(&self) -> &str {
        match self.headerText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 3;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional string introductoryTextHtml = 4;


    pub fn get_introductoryTextHtml(&self) -> &str {
        match self.introductoryTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string offerTitle = 5;


    pub fn get_offerTitle(&self) -> &str {
        match self.offerTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string noActionDescription = 6;


    pub fn get_noActionDescription(&self) -> &str {
        match self.noActionDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string termsAndConditionsHtml = 7;


    pub fn get_termsAndConditionsHtml(&self) -> &str {
        match self.termsAndConditionsHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AddCreditCardPromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.introductoryTextHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerTitle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.noActionDescription)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsAndConditionsHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.headerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.introductoryTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.offerTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.noActionDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.termsAndConditionsHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.headerText.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.introductoryTextHtml.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.offerTitle.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.noActionDescription.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.termsAndConditionsHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCreditCardPromoOffer {
        AddCreditCardPromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerText",
                |m: &AddCreditCardPromoOffer| { &m.headerText },
                |m: &mut AddCreditCardPromoOffer| { &mut m.headerText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &AddCreditCardPromoOffer| { &m.descriptionHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &AddCreditCardPromoOffer| { &m.image },
                |m: &mut AddCreditCardPromoOffer| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "introductoryTextHtml",
                |m: &AddCreditCardPromoOffer| { &m.introductoryTextHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.introductoryTextHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offerTitle",
                |m: &AddCreditCardPromoOffer| { &m.offerTitle },
                |m: &mut AddCreditCardPromoOffer| { &mut m.offerTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "noActionDescription",
                |m: &AddCreditCardPromoOffer| { &m.noActionDescription },
                |m: &mut AddCreditCardPromoOffer| { &mut m.noActionDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsAndConditionsHtml",
                |m: &AddCreditCardPromoOffer| { &m.termsAndConditionsHtml },
                |m: &mut AddCreditCardPromoOffer| { &mut m.termsAndConditionsHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddCreditCardPromoOffer>(
                "AddCreditCardPromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCreditCardPromoOffer {
        static instance: ::protobuf::rt::LazyV2<AddCreditCardPromoOffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCreditCardPromoOffer::new)
    }
}

impl ::protobuf::Clear for AddCreditCardPromoOffer {
    fn clear(&mut self) {
        self.headerText.clear();
        self.descriptionHtml.clear();
        self.image.clear();
        self.introductoryTextHtml.clear();
        self.offerTitle.clear();
        self.noActionDescription.clear();
        self.termsAndConditionsHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCreditCardPromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCreditCardPromoOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AvailablePromoOffer {
    // message fields
    pub addCreditCardOffer: ::protobuf::SingularPtrField<AddCreditCardPromoOffer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AvailablePromoOffer {
    fn default() -> &'a AvailablePromoOffer {
        <AvailablePromoOffer as ::protobuf::Message>::default_instance()
    }
}

impl AvailablePromoOffer {
    pub fn new() -> AvailablePromoOffer {
        ::std::default::Default::default()
    }

    // optional .AddCreditCardPromoOffer addCreditCardOffer = 1;


    pub fn get_addCreditCardOffer(&self) -> &AddCreditCardPromoOffer {
        self.addCreditCardOffer.as_ref().unwrap_or_else(|| <AddCreditCardPromoOffer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AvailablePromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.addCreditCardOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addCreditCardOffer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addCreditCardOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addCreditCardOffer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvailablePromoOffer {
        AvailablePromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddCreditCardPromoOffer>>(
                "addCreditCardOffer",
                |m: &AvailablePromoOffer| { &m.addCreditCardOffer },
                |m: &mut AvailablePromoOffer| { &mut m.addCreditCardOffer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AvailablePromoOffer>(
                "AvailablePromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvailablePromoOffer {
        static instance: ::protobuf::rt::LazyV2<AvailablePromoOffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AvailablePromoOffer::new)
    }
}

impl ::protobuf::Clear for AvailablePromoOffer {
    fn clear(&mut self) {
        self.addCreditCardOffer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvailablePromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailablePromoOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckPromoOfferResponse {
    // message fields
    pub availableOffer: ::protobuf::RepeatedField<AvailablePromoOffer>,
    pub redeemedOffer: ::protobuf::SingularPtrField<RedeemedPromoOffer>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckPromoOfferResponse {
    fn default() -> &'a CheckPromoOfferResponse {
        <CheckPromoOfferResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckPromoOfferResponse {
    pub fn new() -> CheckPromoOfferResponse {
        ::std::default::Default::default()
    }

    // repeated .AvailablePromoOffer availableOffer = 1;


    pub fn get_availableOffer(&self) -> &[AvailablePromoOffer] {
        &self.availableOffer
    }

    // optional .RedeemedPromoOffer redeemedOffer = 2;


    pub fn get_redeemedOffer(&self) -> &RedeemedPromoOffer {
        self.redeemedOffer.as_ref().unwrap_or_else(|| <RedeemedPromoOffer as ::protobuf::Message>::default_instance())
    }

    // optional bool checkoutTokenRequired = 3;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for CheckPromoOfferResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.availableOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemedOffer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.availableOffer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeemedOffer)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.availableOffer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.redeemedOffer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.availableOffer {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.redeemedOffer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckPromoOfferResponse {
        CheckPromoOfferResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AvailablePromoOffer>>(
                "availableOffer",
                |m: &CheckPromoOfferResponse| { &m.availableOffer },
                |m: &mut CheckPromoOfferResponse| { &mut m.availableOffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemedPromoOffer>>(
                "redeemedOffer",
                |m: &CheckPromoOfferResponse| { &m.redeemedOffer },
                |m: &mut CheckPromoOfferResponse| { &mut m.redeemedOffer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &CheckPromoOfferResponse| { &m.checkoutTokenRequired },
                |m: &mut CheckPromoOfferResponse| { &mut m.checkoutTokenRequired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckPromoOfferResponse>(
                "CheckPromoOfferResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckPromoOfferResponse {
        static instance: ::protobuf::rt::LazyV2<CheckPromoOfferResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckPromoOfferResponse::new)
    }
}

impl ::protobuf::Clear for CheckPromoOfferResponse {
    fn clear(&mut self) {
        self.availableOffer.clear();
        self.redeemedOffer.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckPromoOfferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckPromoOfferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedeemedPromoOffer {
    // message fields
    pub headerText: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedeemedPromoOffer {
    fn default() -> &'a RedeemedPromoOffer {
        <RedeemedPromoOffer as ::protobuf::Message>::default_instance()
    }
}

impl RedeemedPromoOffer {
    pub fn new() -> RedeemedPromoOffer {
        ::std::default::Default::default()
    }

    // optional string headerText = 1;


    pub fn get_headerText(&self) -> &str {
        match self.headerText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 3;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RedeemedPromoOffer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.headerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.headerText.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemedPromoOffer {
        RedeemedPromoOffer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerText",
                |m: &RedeemedPromoOffer| { &m.headerText },
                |m: &mut RedeemedPromoOffer| { &mut m.headerText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &RedeemedPromoOffer| { &m.descriptionHtml },
                |m: &mut RedeemedPromoOffer| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &RedeemedPromoOffer| { &m.image },
                |m: &mut RedeemedPromoOffer| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedeemedPromoOffer>(
                "RedeemedPromoOffer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemedPromoOffer {
        static instance: ::protobuf::rt::LazyV2<RedeemedPromoOffer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedeemedPromoOffer::new)
    }
}

impl ::protobuf::Clear for RedeemedPromoOffer {
    fn clear(&mut self) {
        self.headerText.clear();
        self.descriptionHtml.clear();
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemedPromoOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemedPromoOffer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ActiveExperiments {
    // message fields
    pub clientAlteringExperiment: ::protobuf::RepeatedField<::std::string::String>,
    pub otherExperiment: ::protobuf::RepeatedField<::std::string::String>,
    pub gwsExperiment: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActiveExperiments {
    fn default() -> &'a ActiveExperiments {
        <ActiveExperiments as ::protobuf::Message>::default_instance()
    }
}

impl ActiveExperiments {
    pub fn new() -> ActiveExperiments {
        ::std::default::Default::default()
    }

    // repeated string clientAlteringExperiment = 1;


    pub fn get_clientAlteringExperiment(&self) -> &[::std::string::String] {
        &self.clientAlteringExperiment
    }

    // repeated string otherExperiment = 2;


    pub fn get_otherExperiment(&self) -> &[::std::string::String] {
        &self.otherExperiment
    }

    // repeated int32 gwsExperiment = 3;


    pub fn get_gwsExperiment(&self) -> &[i32] {
        &self.gwsExperiment
    }
}

impl ::protobuf::Message for ActiveExperiments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientAlteringExperiment)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.otherExperiment)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.gwsExperiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clientAlteringExperiment {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.otherExperiment {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.gwsExperiment {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clientAlteringExperiment {
            os.write_string(1, &v)?;
        };
        for v in &self.otherExperiment {
            os.write_string(2, &v)?;
        };
        for v in &self.gwsExperiment {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActiveExperiments {
        ActiveExperiments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientAlteringExperiment",
                |m: &ActiveExperiments| { &m.clientAlteringExperiment },
                |m: &mut ActiveExperiments| { &mut m.clientAlteringExperiment },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otherExperiment",
                |m: &ActiveExperiments| { &m.otherExperiment },
                |m: &mut ActiveExperiments| { &mut m.otherExperiment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gwsExperiment",
                |m: &ActiveExperiments| { &m.gwsExperiment },
                |m: &mut ActiveExperiments| { &mut m.gwsExperiment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActiveExperiments>(
                "ActiveExperiments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActiveExperiments {
        static instance: ::protobuf::rt::LazyV2<ActiveExperiments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActiveExperiments::new)
    }
}

impl ::protobuf::Clear for ActiveExperiments {
    fn clear(&mut self) {
        self.clientAlteringExperiment.clear();
        self.otherExperiment.clear();
        self.gwsExperiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActiveExperiments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActiveExperiments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidClientInfo {
    // message fields
    pub androidId: ::std::option::Option<i64>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub sdkVersion: ::std::option::Option<i32>,
    pub model: ::protobuf::SingularField<::std::string::String>,
    pub product: ::protobuf::SingularField<::std::string::String>,
    pub osBuild: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    pub hardware: ::protobuf::SingularField<::std::string::String>,
    pub device: ::protobuf::SingularField<::std::string::String>,
    pub mccMnc: ::protobuf::SingularField<::std::string::String>,
    pub locale: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidClientInfo {
    fn default() -> &'a AndroidClientInfo {
        <AndroidClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl AndroidClientInfo {
    pub fn new() -> AndroidClientInfo {
        ::std::default::Default::default()
    }

    // optional int64 androidId = 1;


    pub fn get_androidId(&self) -> i64 {
        self.androidId.unwrap_or(0)
    }

    // optional string loggingId = 2;


    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 sdkVersion = 3;


    pub fn get_sdkVersion(&self) -> i32 {
        self.sdkVersion.unwrap_or(0)
    }

    // optional string model = 4;


    pub fn get_model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string product = 5;


    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string osBuild = 6;


    pub fn get_osBuild(&self) -> &str {
        match self.osBuild.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string applicationBuild = 7;


    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hardware = 8;


    pub fn get_hardware(&self) -> &str {
        match self.hardware.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string device = 9;


    pub fn get_device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string mccMnc = 10;


    pub fn get_mccMnc(&self) -> &str {
        match self.mccMnc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string locale = 11;


    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string country = 12;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdkVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osBuild)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hardware)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mccMnc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdkVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.osBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.hardware.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.mccMnc.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.sdkVersion {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.product.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.osBuild.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.hardware.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.device.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.mccMnc.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.locale.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidClientInfo {
        AndroidClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "androidId",
                |m: &AndroidClientInfo| { &m.androidId },
                |m: &mut AndroidClientInfo| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loggingId",
                |m: &AndroidClientInfo| { &m.loggingId },
                |m: &mut AndroidClientInfo| { &mut m.loggingId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdkVersion",
                |m: &AndroidClientInfo| { &m.sdkVersion },
                |m: &mut AndroidClientInfo| { &mut m.sdkVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &AndroidClientInfo| { &m.model },
                |m: &mut AndroidClientInfo| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &AndroidClientInfo| { &m.product },
                |m: &mut AndroidClientInfo| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osBuild",
                |m: &AndroidClientInfo| { &m.osBuild },
                |m: &mut AndroidClientInfo| { &mut m.osBuild },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationBuild",
                |m: &AndroidClientInfo| { &m.applicationBuild },
                |m: &mut AndroidClientInfo| { &mut m.applicationBuild },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hardware",
                |m: &AndroidClientInfo| { &m.hardware },
                |m: &mut AndroidClientInfo| { &mut m.hardware },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &AndroidClientInfo| { &m.device },
                |m: &mut AndroidClientInfo| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mccMnc",
                |m: &AndroidClientInfo| { &m.mccMnc },
                |m: &mut AndroidClientInfo| { &mut m.mccMnc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locale",
                |m: &AndroidClientInfo| { &m.locale },
                |m: &mut AndroidClientInfo| { &mut m.locale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &AndroidClientInfo| { &m.country },
                |m: &mut AndroidClientInfo| { &mut m.country },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidClientInfo>(
                "AndroidClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidClientInfo {
        static instance: ::protobuf::rt::LazyV2<AndroidClientInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidClientInfo::new)
    }
}

impl ::protobuf::Clear for AndroidClientInfo {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.loggingId.clear();
        self.sdkVersion = ::std::option::Option::None;
        self.model.clear();
        self.product.clear();
        self.osBuild.clear();
        self.applicationBuild.clear();
        self.hardware.clear();
        self.device.clear();
        self.mccMnc.clear();
        self.locale.clear();
        self.country.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientInfo {
    // message fields
    pub clientType: ::std::option::Option<i32>,
    pub androidClientInfo: ::protobuf::SingularPtrField<AndroidClientInfo>,
    pub desktopClientInfo: ::protobuf::SingularPtrField<DesktopClientInfo>,
    pub iosClientInfo: ::protobuf::SingularPtrField<IosClientInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientInfo {
    fn default() -> &'a ClientInfo {
        <ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl ClientInfo {
    pub fn new() -> ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 clientType = 1;


    pub fn get_clientType(&self) -> i32 {
        self.clientType.unwrap_or(0)
    }

    // optional .AndroidClientInfo androidClientInfo = 2;


    pub fn get_androidClientInfo(&self) -> &AndroidClientInfo {
        self.androidClientInfo.as_ref().unwrap_or_else(|| <AndroidClientInfo as ::protobuf::Message>::default_instance())
    }

    // optional .DesktopClientInfo desktopClientInfo = 3;


    pub fn get_desktopClientInfo(&self) -> &DesktopClientInfo {
        self.desktopClientInfo.as_ref().unwrap_or_else(|| <DesktopClientInfo as ::protobuf::Message>::default_instance())
    }

    // optional .IosClientInfo iosClientInfo = 4;


    pub fn get_iosClientInfo(&self) -> &IosClientInfo {
        self.iosClientInfo.as_ref().unwrap_or_else(|| <IosClientInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ClientInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.androidClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desktopClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iosClientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.clientType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.androidClientInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desktopClientInfo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iosClientInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clientType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.androidClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desktopClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iosClientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clientType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.androidClientInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desktopClientInfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iosClientInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientInfo {
        ClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "clientType",
                |m: &ClientInfo| { &m.clientType },
                |m: &mut ClientInfo| { &mut m.clientType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidClientInfo>>(
                "androidClientInfo",
                |m: &ClientInfo| { &m.androidClientInfo },
                |m: &mut ClientInfo| { &mut m.androidClientInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DesktopClientInfo>>(
                "desktopClientInfo",
                |m: &ClientInfo| { &m.desktopClientInfo },
                |m: &mut ClientInfo| { &mut m.desktopClientInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IosClientInfo>>(
                "iosClientInfo",
                |m: &ClientInfo| { &m.iosClientInfo },
                |m: &mut ClientInfo| { &mut m.iosClientInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientInfo>(
                "ClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientInfo {
        static instance: ::protobuf::rt::LazyV2<ClientInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientInfo::new)
    }
}

impl ::protobuf::Clear for ClientInfo {
    fn clear(&mut self) {
        self.clientType = ::std::option::Option::None;
        self.androidClientInfo.clear();
        self.desktopClientInfo.clear();
        self.iosClientInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DesktopClientInfo {
    // message fields
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub os: ::protobuf::SingularField<::std::string::String>,
    pub osMajorVersion: ::protobuf::SingularField<::std::string::String>,
    pub osFullVersion: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DesktopClientInfo {
    fn default() -> &'a DesktopClientInfo {
        <DesktopClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl DesktopClientInfo {
    pub fn new() -> DesktopClientInfo {
        ::std::default::Default::default()
    }

    // optional string clientId = 1;


    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string loggingId = 2;


    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string os = 3;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string osMajorVersion = 4;


    pub fn get_osMajorVersion(&self) -> &str {
        match self.osMajorVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string osFullVersion = 5;


    pub fn get_osFullVersion(&self) -> &str {
        match self.osFullVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string applicationBuild = 6;


    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DesktopClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osMajorVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osFullVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.osMajorVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.osFullVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.osMajorVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.osFullVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DesktopClientInfo {
        DesktopClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientId",
                |m: &DesktopClientInfo| { &m.clientId },
                |m: &mut DesktopClientInfo| { &mut m.clientId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loggingId",
                |m: &DesktopClientInfo| { &m.loggingId },
                |m: &mut DesktopClientInfo| { &mut m.loggingId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &DesktopClientInfo| { &m.os },
                |m: &mut DesktopClientInfo| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osMajorVersion",
                |m: &DesktopClientInfo| { &m.osMajorVersion },
                |m: &mut DesktopClientInfo| { &mut m.osMajorVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osFullVersion",
                |m: &DesktopClientInfo| { &m.osFullVersion },
                |m: &mut DesktopClientInfo| { &mut m.osFullVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationBuild",
                |m: &DesktopClientInfo| { &m.applicationBuild },
                |m: &mut DesktopClientInfo| { &mut m.applicationBuild },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DesktopClientInfo>(
                "DesktopClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DesktopClientInfo {
        static instance: ::protobuf::rt::LazyV2<DesktopClientInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DesktopClientInfo::new)
    }
}

impl ::protobuf::Clear for DesktopClientInfo {
    fn clear(&mut self) {
        self.clientId.clear();
        self.loggingId.clear();
        self.os.clear();
        self.osMajorVersion.clear();
        self.osFullVersion.clear();
        self.applicationBuild.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DesktopClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DesktopClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExperimentIdList {
    // message fields
    pub id: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExperimentIdList {
    fn default() -> &'a ExperimentIdList {
        <ExperimentIdList as ::protobuf::Message>::default_instance()
    }
}

impl ExperimentIdList {
    pub fn new() -> ExperimentIdList {
        ::std::default::Default::default()
    }

    // repeated string id = 1;


    pub fn get_id(&self) -> &[::std::string::String] {
        &self.id
    }
}

impl ::protobuf::Message for ExperimentIdList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.id {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExperimentIdList {
        ExperimentIdList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ExperimentIdList| { &m.id },
                |m: &mut ExperimentIdList| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExperimentIdList>(
                "ExperimentIdList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExperimentIdList {
        static instance: ::protobuf::rt::LazyV2<ExperimentIdList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExperimentIdList::new)
    }
}

impl ::protobuf::Clear for ExperimentIdList {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExperimentIdList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperimentIdList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IosClientInfo {
    // message fields
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    pub osMajorVersion: ::protobuf::SingularField<::std::string::String>,
    pub osFullVersion: ::protobuf::SingularField<::std::string::String>,
    pub applicationBuild: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IosClientInfo {
    fn default() -> &'a IosClientInfo {
        <IosClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl IosClientInfo {
    pub fn new() -> IosClientInfo {
        ::std::default::Default::default()
    }

    // optional string clientId = 1;


    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string loggingId = 2;


    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string osMajorVersion = 3;


    pub fn get_osMajorVersion(&self) -> &str {
        match self.osMajorVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string osFullVersion = 4;


    pub fn get_osFullVersion(&self) -> &str {
        match self.osFullVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string applicationBuild = 5;


    pub fn get_applicationBuild(&self) -> &str {
        match self.applicationBuild.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for IosClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osMajorVersion)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osFullVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationBuild)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.osMajorVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.osFullVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.osMajorVersion.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.osFullVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.applicationBuild.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IosClientInfo {
        IosClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientId",
                |m: &IosClientInfo| { &m.clientId },
                |m: &mut IosClientInfo| { &mut m.clientId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loggingId",
                |m: &IosClientInfo| { &m.loggingId },
                |m: &mut IosClientInfo| { &mut m.loggingId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osMajorVersion",
                |m: &IosClientInfo| { &m.osMajorVersion },
                |m: &mut IosClientInfo| { &mut m.osMajorVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osFullVersion",
                |m: &IosClientInfo| { &m.osFullVersion },
                |m: &mut IosClientInfo| { &mut m.osFullVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationBuild",
                |m: &IosClientInfo| { &m.applicationBuild },
                |m: &mut IosClientInfo| { &mut m.applicationBuild },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IosClientInfo>(
                "IosClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IosClientInfo {
        static instance: ::protobuf::rt::LazyV2<IosClientInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IosClientInfo::new)
    }
}

impl ::protobuf::Clear for IosClientInfo {
    fn clear(&mut self) {
        self.clientId.clear();
        self.loggingId.clear();
        self.osMajorVersion.clear();
        self.osFullVersion.clear();
        self.applicationBuild.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IosClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IosClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LogEvent {
    // message fields
    pub eventTimeMs: ::std::option::Option<i64>,
    pub tag: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::RepeatedField<LogEventKeyValues>,
    pub store: ::protobuf::SingularPtrField<PlayStoreLogEvent>,
    pub sourceExtension: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub exp: ::protobuf::SingularPtrField<ActiveExperiments>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogEvent {
    fn default() -> &'a LogEvent {
        <LogEvent as ::protobuf::Message>::default_instance()
    }
}

impl LogEvent {
    pub fn new() -> LogEvent {
        ::std::default::Default::default()
    }

    // optional int64 eventTimeMs = 1;


    pub fn get_eventTimeMs(&self) -> i64 {
        self.eventTimeMs.unwrap_or(0)
    }

    // optional string tag = 2;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .LogEventKeyValues value = 3;


    pub fn get_value(&self) -> &[LogEventKeyValues] {
        &self.value
    }

    // optional .PlayStoreLogEvent store = 4;


    pub fn get_store(&self) -> &PlayStoreLogEvent {
        self.store.as_ref().unwrap_or_else(|| <PlayStoreLogEvent as ::protobuf::Message>::default_instance())
    }

    // optional bytes sourceExtension = 6;


    pub fn get_sourceExtension(&self) -> &[u8] {
        match self.sourceExtension.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .ActiveExperiments exp = 7;


    pub fn get_exp(&self) -> &ActiveExperiments {
        self.exp.as_ref().unwrap_or_else(|| <ActiveExperiments as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LogEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.store {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.eventTimeMs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.store)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sourceExtension)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventTimeMs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.store.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sourceExtension.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.exp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventTimeMs {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.value {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.store.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sourceExtension.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.exp.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEvent {
        LogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "eventTimeMs",
                |m: &LogEvent| { &m.eventTimeMs },
                |m: &mut LogEvent| { &mut m.eventTimeMs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &LogEvent| { &m.tag },
                |m: &mut LogEvent| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEventKeyValues>>(
                "value",
                |m: &LogEvent| { &m.value },
                |m: &mut LogEvent| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreLogEvent>>(
                "store",
                |m: &LogEvent| { &m.store },
                |m: &mut LogEvent| { &mut m.store },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sourceExtension",
                |m: &LogEvent| { &m.sourceExtension },
                |m: &mut LogEvent| { &mut m.sourceExtension },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActiveExperiments>>(
                "exp",
                |m: &LogEvent| { &m.exp },
                |m: &mut LogEvent| { &mut m.exp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogEvent>(
                "LogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogEvent {
        static instance: ::protobuf::rt::LazyV2<LogEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogEvent::new)
    }
}

impl ::protobuf::Clear for LogEvent {
    fn clear(&mut self) {
        self.eventTimeMs = ::std::option::Option::None;
        self.tag.clear();
        self.value.clear();
        self.store.clear();
        self.sourceExtension.clear();
        self.exp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LogEventKeyValues {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogEventKeyValues {
    fn default() -> &'a LogEventKeyValues {
        <LogEventKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl LogEventKeyValues {
    pub fn new() -> LogEventKeyValues {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LogEventKeyValues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogEventKeyValues {
        LogEventKeyValues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &LogEventKeyValues| { &m.key },
                |m: &mut LogEventKeyValues| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &LogEventKeyValues| { &m.value },
                |m: &mut LogEventKeyValues| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogEventKeyValues>(
                "LogEventKeyValues",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogEventKeyValues {
        static instance: ::protobuf::rt::LazyV2<LogEventKeyValues> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogEventKeyValues::new)
    }
}

impl ::protobuf::Clear for LogEventKeyValues {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogEventKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEventKeyValues {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LogRequest {
    // message fields
    pub clientInfo: ::protobuf::SingularPtrField<ClientInfo>,
    pub logSource: ::std::option::Option<i32>,
    pub logEvent: ::protobuf::RepeatedField<LogEvent>,
    pub requestTimeMs: ::std::option::Option<i64>,
    pub serializedLogEvents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogRequest {
    fn default() -> &'a LogRequest {
        <LogRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogRequest {
    pub fn new() -> LogRequest {
        ::std::default::Default::default()
    }

    // optional .ClientInfo clientInfo = 1;


    pub fn get_clientInfo(&self) -> &ClientInfo {
        self.clientInfo.as_ref().unwrap_or_else(|| <ClientInfo as ::protobuf::Message>::default_instance())
    }

    // optional int32 logSource = 2;


    pub fn get_logSource(&self) -> i32 {
        self.logSource.unwrap_or(0)
    }

    // repeated .LogEvent logEvent = 3;


    pub fn get_logEvent(&self) -> &[LogEvent] {
        &self.logEvent
    }

    // optional int64 requestTimeMs = 4;


    pub fn get_requestTimeMs(&self) -> i64 {
        self.requestTimeMs.unwrap_or(0)
    }

    // optional bytes serializedLogEvents = 5;


    pub fn get_serializedLogEvents(&self) -> &[u8] {
        match self.serializedLogEvents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for LogRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.clientInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logEvent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clientInfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.logSource = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logEvent)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requestTimeMs = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serializedLogEvents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.logSource {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.logEvent {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.requestTimeMs {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serializedLogEvents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.logSource {
            os.write_int32(2, v)?;
        }
        for v in &self.logEvent {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.requestTimeMs {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.serializedLogEvents.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRequest {
        LogRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientInfo>>(
                "clientInfo",
                |m: &LogRequest| { &m.clientInfo },
                |m: &mut LogRequest| { &mut m.clientInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "logSource",
                |m: &LogRequest| { &m.logSource },
                |m: &mut LogRequest| { &mut m.logSource },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogEvent>>(
                "logEvent",
                |m: &LogRequest| { &m.logEvent },
                |m: &mut LogRequest| { &mut m.logEvent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "requestTimeMs",
                |m: &LogRequest| { &m.requestTimeMs },
                |m: &mut LogRequest| { &mut m.requestTimeMs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serializedLogEvents",
                |m: &LogRequest| { &m.serializedLogEvents },
                |m: &mut LogRequest| { &mut m.serializedLogEvents },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogRequest>(
                "LogRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogRequest {
        static instance: ::protobuf::rt::LazyV2<LogRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogRequest::new)
    }
}

impl ::protobuf::Clear for LogRequest {
    fn clear(&mut self) {
        self.clientInfo.clear();
        self.logSource = ::std::option::Option::None;
        self.logEvent.clear();
        self.requestTimeMs = ::std::option::Option::None;
        self.serializedLogEvents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LogResponse {
    // message fields
    pub nextRequestWaitMillis: ::std::option::Option<i64>,
    pub experiments: ::protobuf::SingularPtrField<ExperimentIdList>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogResponse {
    fn default() -> &'a LogResponse {
        <LogResponse as ::protobuf::Message>::default_instance()
    }
}

impl LogResponse {
    pub fn new() -> LogResponse {
        ::std::default::Default::default()
    }

    // optional int64 nextRequestWaitMillis = 1;


    pub fn get_nextRequestWaitMillis(&self) -> i64 {
        self.nextRequestWaitMillis.unwrap_or(0)
    }

    // optional .ExperimentIdList experiments = 2;


    pub fn get_experiments(&self) -> &ExperimentIdList {
        self.experiments.as_ref().unwrap_or_else(|| <ExperimentIdList as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LogResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.experiments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nextRequestWaitMillis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experiments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nextRequestWaitMillis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.experiments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nextRequestWaitMillis {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.experiments.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogResponse {
        LogResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nextRequestWaitMillis",
                |m: &LogResponse| { &m.nextRequestWaitMillis },
                |m: &mut LogResponse| { &mut m.nextRequestWaitMillis },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExperimentIdList>>(
                "experiments",
                |m: &LogResponse| { &m.experiments },
                |m: &mut LogResponse| { &mut m.experiments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogResponse>(
                "LogResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogResponse {
        static instance: ::protobuf::rt::LazyV2<LogResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogResponse::new)
    }
}

impl ::protobuf::Clear for LogResponse {
    fn clear(&mut self) {
        self.nextRequestWaitMillis = ::std::option::Option::None;
        self.experiments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Docid {
    // message fields
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub backend: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Docid {
    fn default() -> &'a Docid {
        <Docid as ::protobuf::Message>::default_instance()
    }
}

impl Docid {
    pub fn new() -> Docid {
        ::std::default::Default::default()
    }

    // optional string backendDocid = 1;


    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional int32 backend = 3;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }
}

impl ::protobuf::Message for Docid {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backendDocid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.backend {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Docid {
        Docid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendDocid",
                |m: &Docid| { &m.backendDocid },
                |m: &mut Docid| { &mut m.backendDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &Docid| { &m.field_type },
                |m: &mut Docid| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &Docid| { &m.backend },
                |m: &mut Docid| { &mut m.backend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Docid>(
                "Docid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Docid {
        static instance: ::protobuf::rt::LazyV2<Docid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Docid::new)
    }
}

impl ::protobuf::Clear for Docid {
    fn clear(&mut self) {
        self.backendDocid.clear();
        self.field_type = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Docid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Docid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Install {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub version: ::std::option::Option<i32>,
    pub bundled: ::std::option::Option<bool>,
    pub pending: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Install {
    fn default() -> &'a Install {
        <Install as ::protobuf::Message>::default_instance()
    }
}

impl Install {
    pub fn new() -> Install {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 1;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional bool bundled = 3;


    pub fn get_bundled(&self) -> bool {
        self.bundled.unwrap_or(false)
    }

    // optional bool pending = 4;


    pub fn get_pending(&self) -> bool {
        self.pending.unwrap_or(false)
    }
}

impl ::protobuf::Message for Install {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bundled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bundled {
            my_size += 2;
        }
        if let Some(v) = self.pending {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bundled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.pending {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Install {
        Install::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &Install| { &m.androidId },
                |m: &mut Install| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &Install| { &m.version },
                |m: &mut Install| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bundled",
                |m: &Install| { &m.bundled },
                |m: &mut Install| { &mut m.bundled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pending",
                |m: &Install| { &m.pending },
                |m: &mut Install| { &mut m.pending },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Install>(
                "Install",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Install {
        static instance: ::protobuf::rt::LazyV2<Install> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Install::new)
    }
}

impl ::protobuf::Clear for Install {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.bundled = ::std::option::Option::None;
        self.pending = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Install {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Install {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupLicenseKey {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupLicenseKey {
    fn default() -> &'a GroupLicenseKey {
        <GroupLicenseKey as ::protobuf::Message>::default_instance()
    }
}

impl GroupLicenseKey {
    pub fn new() -> GroupLicenseKey {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GroupLicenseKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupLicenseKey {
        GroupLicenseKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupLicenseKey>(
                "GroupLicenseKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupLicenseKey {
        static instance: ::protobuf::rt::LazyV2<GroupLicenseKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupLicenseKey::new)
    }
}

impl ::protobuf::Clear for GroupLicenseKey {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupLicenseKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupLicenseKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LicenseTerms {
    // message fields
    pub groupLicenseKey: ::protobuf::SingularPtrField<GroupLicenseKey>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LicenseTerms {
    fn default() -> &'a LicenseTerms {
        <LicenseTerms as ::protobuf::Message>::default_instance()
    }
}

impl LicenseTerms {
    pub fn new() -> LicenseTerms {
        ::std::default::Default::default()
    }

    // optional .GroupLicenseKey groupLicenseKey = 1;


    pub fn get_groupLicenseKey(&self) -> &GroupLicenseKey {
        self.groupLicenseKey.as_ref().unwrap_or_else(|| <GroupLicenseKey as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LicenseTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.groupLicenseKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupLicenseKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.groupLicenseKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.groupLicenseKey.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LicenseTerms {
        LicenseTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupLicenseKey>>(
                "groupLicenseKey",
                |m: &LicenseTerms| { &m.groupLicenseKey },
                |m: &mut LicenseTerms| { &mut m.groupLicenseKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LicenseTerms>(
                "LicenseTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LicenseTerms {
        static instance: ::protobuf::rt::LazyV2<LicenseTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LicenseTerms::new)
    }
}

impl ::protobuf::Clear for LicenseTerms {
    fn clear(&mut self) {
        self.groupLicenseKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LicenseTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LicenseTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Offer {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    pub convertedPrice: ::protobuf::RepeatedField<Offer>,
    pub checkoutFlowRequired: ::std::option::Option<bool>,
    pub fullPriceMicros: ::std::option::Option<i64>,
    pub formattedFullAmount: ::protobuf::SingularField<::std::string::String>,
    pub offerType: ::std::option::Option<i32>,
    pub rentalTerms: ::protobuf::SingularPtrField<RentalTerms>,
    pub onSaleDate: ::std::option::Option<i64>,
    pub promotionLabel: ::protobuf::RepeatedField<::std::string::String>,
    pub subscriptionTerms: ::protobuf::SingularPtrField<SubscriptionTerms>,
    pub formattedName: ::protobuf::SingularField<::std::string::String>,
    pub formattedDescription: ::protobuf::SingularField<::std::string::String>,
    pub preorder: ::std::option::Option<bool>,
    pub onSaleDateDisplayTimeZoneOffsetMsec: ::std::option::Option<i32>,
    pub licensedOfferType: ::std::option::Option<i32>,
    pub subscriptionContentTerms: ::protobuf::SingularPtrField<SubscriptionContentTerms>,
    pub offerId: ::protobuf::SingularField<::std::string::String>,
    pub preorderFulfillmentDisplayDate: ::std::option::Option<i64>,
    pub licenseTerms: ::protobuf::SingularPtrField<LicenseTerms>,
    pub temporarilyFree: ::std::option::Option<bool>,
    pub voucherTerms: ::protobuf::SingularPtrField<VoucherTerms>,
    pub offerPayment: ::protobuf::RepeatedField<OfferPayment>,
    pub repeatLastPayment: ::std::option::Option<bool>,
    pub buyButtonLabel: ::protobuf::SingularField<::std::string::String>,
    pub instantPurchaseEnabled: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Offer {
    fn default() -> &'a Offer {
        <Offer as ::protobuf::Message>::default_instance()
    }
}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;


    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Offer convertedPrice = 4;


    pub fn get_convertedPrice(&self) -> &[Offer] {
        &self.convertedPrice
    }

    // optional bool checkoutFlowRequired = 5;


    pub fn get_checkoutFlowRequired(&self) -> bool {
        self.checkoutFlowRequired.unwrap_or(false)
    }

    // optional int64 fullPriceMicros = 6;


    pub fn get_fullPriceMicros(&self) -> i64 {
        self.fullPriceMicros.unwrap_or(0)
    }

    // optional string formattedFullAmount = 7;


    pub fn get_formattedFullAmount(&self) -> &str {
        match self.formattedFullAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 offerType = 8;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional .RentalTerms rentalTerms = 9;


    pub fn get_rentalTerms(&self) -> &RentalTerms {
        self.rentalTerms.as_ref().unwrap_or_else(|| <RentalTerms as ::protobuf::Message>::default_instance())
    }

    // optional int64 onSaleDate = 10;


    pub fn get_onSaleDate(&self) -> i64 {
        self.onSaleDate.unwrap_or(0)
    }

    // repeated string promotionLabel = 11;


    pub fn get_promotionLabel(&self) -> &[::std::string::String] {
        &self.promotionLabel
    }

    // optional .SubscriptionTerms subscriptionTerms = 12;


    pub fn get_subscriptionTerms(&self) -> &SubscriptionTerms {
        self.subscriptionTerms.as_ref().unwrap_or_else(|| <SubscriptionTerms as ::protobuf::Message>::default_instance())
    }

    // optional string formattedName = 13;


    pub fn get_formattedName(&self) -> &str {
        match self.formattedName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedDescription = 14;


    pub fn get_formattedDescription(&self) -> &str {
        match self.formattedDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool preorder = 15;


    pub fn get_preorder(&self) -> bool {
        self.preorder.unwrap_or(false)
    }

    // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;


    pub fn get_onSaleDateDisplayTimeZoneOffsetMsec(&self) -> i32 {
        self.onSaleDateDisplayTimeZoneOffsetMsec.unwrap_or(0)
    }

    // optional int32 licensedOfferType = 17;


    pub fn get_licensedOfferType(&self) -> i32 {
        self.licensedOfferType.unwrap_or(0)
    }

    // optional .SubscriptionContentTerms subscriptionContentTerms = 18;


    pub fn get_subscriptionContentTerms(&self) -> &SubscriptionContentTerms {
        self.subscriptionContentTerms.as_ref().unwrap_or_else(|| <SubscriptionContentTerms as ::protobuf::Message>::default_instance())
    }

    // optional string offerId = 19;


    pub fn get_offerId(&self) -> &str {
        match self.offerId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 preorderFulfillmentDisplayDate = 20;


    pub fn get_preorderFulfillmentDisplayDate(&self) -> i64 {
        self.preorderFulfillmentDisplayDate.unwrap_or(0)
    }

    // optional .LicenseTerms licenseTerms = 21;


    pub fn get_licenseTerms(&self) -> &LicenseTerms {
        self.licenseTerms.as_ref().unwrap_or_else(|| <LicenseTerms as ::protobuf::Message>::default_instance())
    }

    // optional bool temporarilyFree = 22;


    pub fn get_temporarilyFree(&self) -> bool {
        self.temporarilyFree.unwrap_or(false)
    }

    // optional .VoucherTerms voucherTerms = 23;


    pub fn get_voucherTerms(&self) -> &VoucherTerms {
        self.voucherTerms.as_ref().unwrap_or_else(|| <VoucherTerms as ::protobuf::Message>::default_instance())
    }

    // repeated .OfferPayment offerPayment = 24;


    pub fn get_offerPayment(&self) -> &[OfferPayment] {
        &self.offerPayment
    }

    // optional bool repeatLastPayment = 25;


    pub fn get_repeatLastPayment(&self) -> bool {
        self.repeatLastPayment.unwrap_or(false)
    }

    // optional string buyButtonLabel = 26;


    pub fn get_buyButtonLabel(&self) -> &str {
        match self.buyButtonLabel.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool instantPurchaseEnabled = 27;


    pub fn get_instantPurchaseEnabled(&self) -> bool {
        self.instantPurchaseEnabled.unwrap_or(false)
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        for v in &self.convertedPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionContentTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licenseTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voucherTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offerPayment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.convertedPrice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutFlowRequired = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fullPriceMicros = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedFullAmount)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rentalTerms)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.onSaleDate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotionLabel)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionTerms)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedDescription)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preorder = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.onSaleDateDisplayTimeZoneOffsetMsec = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.licensedOfferType = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionContentTerms)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerId)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.preorderFulfillmentDisplayDate = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.licenseTerms)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temporarilyFree = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voucherTerms)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offerPayment)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.repeatLastPayment = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buyButtonLabel)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.instantPurchaseEnabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.convertedPrice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutFlowRequired {
            my_size += 2;
        }
        if let Some(v) = self.fullPriceMicros {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.formattedFullAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.onSaleDate {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.promotionLabel {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.subscriptionTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.formattedName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.formattedDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.preorder {
            my_size += 2;
        }
        if let Some(v) = self.onSaleDateDisplayTimeZoneOffsetMsec {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.licensedOfferType {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscriptionContentTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.offerId.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.preorderFulfillmentDisplayDate {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.licenseTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.temporarilyFree {
            my_size += 3;
        }
        if let Some(ref v) = self.voucherTerms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offerPayment {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.repeatLastPayment {
            my_size += 3;
        }
        if let Some(ref v) = self.buyButtonLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.instantPurchaseEnabled {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.convertedPrice {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.checkoutFlowRequired {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.fullPriceMicros {
            os.write_int64(6, v)?;
        }
        if let Some(ref v) = self.formattedFullAmount.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.onSaleDate {
            os.write_int64(10, v)?;
        }
        for v in &self.promotionLabel {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.subscriptionTerms.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.formattedName.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.formattedDescription.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.preorder {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.onSaleDateDisplayTimeZoneOffsetMsec {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.licensedOfferType {
            os.write_int32(17, v)?;
        }
        if let Some(ref v) = self.subscriptionContentTerms.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.offerId.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(v) = self.preorderFulfillmentDisplayDate {
            os.write_int64(20, v)?;
        }
        if let Some(ref v) = self.licenseTerms.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.temporarilyFree {
            os.write_bool(22, v)?;
        }
        if let Some(ref v) = self.voucherTerms.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.offerPayment {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.repeatLastPayment {
            os.write_bool(25, v)?;
        }
        if let Some(ref v) = self.buyButtonLabel.as_ref() {
            os.write_string(26, &v)?;
        }
        if let Some(v) = self.instantPurchaseEnabled {
            os.write_bool(27, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &Offer| { &m.micros },
                |m: &mut Offer| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &Offer| { &m.currencyCode },
                |m: &mut Offer| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedAmount",
                |m: &Offer| { &m.formattedAmount },
                |m: &mut Offer| { &mut m.formattedAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "convertedPrice",
                |m: &Offer| { &m.convertedPrice },
                |m: &mut Offer| { &mut m.convertedPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutFlowRequired",
                |m: &Offer| { &m.checkoutFlowRequired },
                |m: &mut Offer| { &mut m.checkoutFlowRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fullPriceMicros",
                |m: &Offer| { &m.fullPriceMicros },
                |m: &mut Offer| { &mut m.fullPriceMicros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedFullAmount",
                |m: &Offer| { &m.formattedFullAmount },
                |m: &mut Offer| { &mut m.formattedFullAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &Offer| { &m.offerType },
                |m: &mut Offer| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RentalTerms>>(
                "rentalTerms",
                |m: &Offer| { &m.rentalTerms },
                |m: &mut Offer| { &mut m.rentalTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "onSaleDate",
                |m: &Offer| { &m.onSaleDate },
                |m: &mut Offer| { &mut m.onSaleDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotionLabel",
                |m: &Offer| { &m.promotionLabel },
                |m: &mut Offer| { &mut m.promotionLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionTerms>>(
                "subscriptionTerms",
                |m: &Offer| { &m.subscriptionTerms },
                |m: &mut Offer| { &mut m.subscriptionTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedName",
                |m: &Offer| { &m.formattedName },
                |m: &mut Offer| { &mut m.formattedName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedDescription",
                |m: &Offer| { &m.formattedDescription },
                |m: &mut Offer| { &mut m.formattedDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "preorder",
                |m: &Offer| { &m.preorder },
                |m: &mut Offer| { &mut m.preorder },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "onSaleDateDisplayTimeZoneOffsetMsec",
                |m: &Offer| { &m.onSaleDateDisplayTimeZoneOffsetMsec },
                |m: &mut Offer| { &mut m.onSaleDateDisplayTimeZoneOffsetMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "licensedOfferType",
                |m: &Offer| { &m.licensedOfferType },
                |m: &mut Offer| { &mut m.licensedOfferType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionContentTerms>>(
                "subscriptionContentTerms",
                |m: &Offer| { &m.subscriptionContentTerms },
                |m: &mut Offer| { &mut m.subscriptionContentTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offerId",
                |m: &Offer| { &m.offerId },
                |m: &mut Offer| { &mut m.offerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "preorderFulfillmentDisplayDate",
                |m: &Offer| { &m.preorderFulfillmentDisplayDate },
                |m: &mut Offer| { &mut m.preorderFulfillmentDisplayDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicenseTerms>>(
                "licenseTerms",
                |m: &Offer| { &m.licenseTerms },
                |m: &mut Offer| { &mut m.licenseTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "temporarilyFree",
                |m: &Offer| { &m.temporarilyFree },
                |m: &mut Offer| { &mut m.temporarilyFree },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoucherTerms>>(
                "voucherTerms",
                |m: &Offer| { &m.voucherTerms },
                |m: &mut Offer| { &mut m.voucherTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPayment>>(
                "offerPayment",
                |m: &Offer| { &m.offerPayment },
                |m: &mut Offer| { &mut m.offerPayment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "repeatLastPayment",
                |m: &Offer| { &m.repeatLastPayment },
                |m: &mut Offer| { &mut m.repeatLastPayment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "buyButtonLabel",
                |m: &Offer| { &m.buyButtonLabel },
                |m: &mut Offer| { &mut m.buyButtonLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "instantPurchaseEnabled",
                |m: &Offer| { &m.instantPurchaseEnabled },
                |m: &mut Offer| { &mut m.instantPurchaseEnabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Offer>(
                "Offer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Offer {
        static instance: ::protobuf::rt::LazyV2<Offer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Offer::new)
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.convertedPrice.clear();
        self.checkoutFlowRequired = ::std::option::Option::None;
        self.fullPriceMicros = ::std::option::Option::None;
        self.formattedFullAmount.clear();
        self.offerType = ::std::option::Option::None;
        self.rentalTerms.clear();
        self.onSaleDate = ::std::option::Option::None;
        self.promotionLabel.clear();
        self.subscriptionTerms.clear();
        self.formattedName.clear();
        self.formattedDescription.clear();
        self.preorder = ::std::option::Option::None;
        self.onSaleDateDisplayTimeZoneOffsetMsec = ::std::option::Option::None;
        self.licensedOfferType = ::std::option::Option::None;
        self.subscriptionContentTerms.clear();
        self.offerId.clear();
        self.preorderFulfillmentDisplayDate = ::std::option::Option::None;
        self.licenseTerms.clear();
        self.temporarilyFree = ::std::option::Option::None;
        self.voucherTerms.clear();
        self.offerPayment.clear();
        self.repeatLastPayment = ::std::option::Option::None;
        self.buyButtonLabel.clear();
        self.instantPurchaseEnabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MonthAndDay {
    // message fields
    pub month: ::std::option::Option<u32>,
    pub day: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonthAndDay {
    fn default() -> &'a MonthAndDay {
        <MonthAndDay as ::protobuf::Message>::default_instance()
    }
}

impl MonthAndDay {
    pub fn new() -> MonthAndDay {
        ::std::default::Default::default()
    }

    // optional uint32 month = 1;


    pub fn get_month(&self) -> u32 {
        self.month.unwrap_or(0)
    }

    // optional uint32 day = 2;


    pub fn get_day(&self) -> u32 {
        self.day.unwrap_or(0)
    }
}

impl ::protobuf::Message for MonthAndDay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.month = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.day = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.day {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.month {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.day {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonthAndDay {
        MonthAndDay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "month",
                |m: &MonthAndDay| { &m.month },
                |m: &mut MonthAndDay| { &mut m.month },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "day",
                |m: &MonthAndDay| { &m.day },
                |m: &mut MonthAndDay| { &mut m.day },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MonthAndDay>(
                "MonthAndDay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MonthAndDay {
        static instance: ::protobuf::rt::LazyV2<MonthAndDay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MonthAndDay::new)
    }
}

impl ::protobuf::Clear for MonthAndDay {
    fn clear(&mut self) {
        self.month = ::std::option::Option::None;
        self.day = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonthAndDay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonthAndDay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OfferPaymentPeriod {
    // message fields
    pub duration: ::protobuf::SingularPtrField<TimePeriod>,
    pub start: ::protobuf::SingularPtrField<MonthAndDay>,
    pub end: ::protobuf::SingularPtrField<MonthAndDay>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferPaymentPeriod {
    fn default() -> &'a OfferPaymentPeriod {
        <OfferPaymentPeriod as ::protobuf::Message>::default_instance()
    }
}

impl OfferPaymentPeriod {
    pub fn new() -> OfferPaymentPeriod {
        ::std::default::Default::default()
    }

    // optional .TimePeriod duration = 1;


    pub fn get_duration(&self) -> &TimePeriod {
        self.duration.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }

    // optional .MonthAndDay start = 2;


    pub fn get_start(&self) -> &MonthAndDay {
        self.start.as_ref().unwrap_or_else(|| <MonthAndDay as ::protobuf::Message>::default_instance())
    }

    // optional .MonthAndDay end = 3;


    pub fn get_end(&self) -> &MonthAndDay {
        self.end.as_ref().unwrap_or_else(|| <MonthAndDay as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for OfferPaymentPeriod {
    fn is_initialized(&self) -> bool {
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPaymentPeriod {
        OfferPaymentPeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "duration",
                |m: &OfferPaymentPeriod| { &m.duration },
                |m: &mut OfferPaymentPeriod| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>>(
                "start",
                |m: &OfferPaymentPeriod| { &m.start },
                |m: &mut OfferPaymentPeriod| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>>(
                "end",
                |m: &OfferPaymentPeriod| { &m.end },
                |m: &mut OfferPaymentPeriod| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OfferPaymentPeriod>(
                "OfferPaymentPeriod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPaymentPeriod {
        static instance: ::protobuf::rt::LazyV2<OfferPaymentPeriod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OfferPaymentPeriod::new)
    }
}

impl ::protobuf::Clear for OfferPaymentPeriod {
    fn clear(&mut self) {
        self.duration.clear();
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPaymentPeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPaymentPeriod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OfferPaymentOverride {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub start: ::protobuf::SingularPtrField<MonthAndDay>,
    pub end: ::protobuf::SingularPtrField<MonthAndDay>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferPaymentOverride {
    fn default() -> &'a OfferPaymentOverride {
        <OfferPaymentOverride as ::protobuf::Message>::default_instance()
    }
}

impl OfferPaymentOverride {
    pub fn new() -> OfferPaymentOverride {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional .MonthAndDay start = 2;


    pub fn get_start(&self) -> &MonthAndDay {
        self.start.as_ref().unwrap_or_else(|| <MonthAndDay as ::protobuf::Message>::default_instance())
    }

    // optional .MonthAndDay end = 3;


    pub fn get_end(&self) -> &MonthAndDay {
        self.end.as_ref().unwrap_or_else(|| <MonthAndDay as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for OfferPaymentOverride {
    fn is_initialized(&self) -> bool {
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPaymentOverride {
        OfferPaymentOverride::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &OfferPaymentOverride| { &m.micros },
                |m: &mut OfferPaymentOverride| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>>(
                "start",
                |m: &OfferPaymentOverride| { &m.start },
                |m: &mut OfferPaymentOverride| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonthAndDay>>(
                "end",
                |m: &OfferPaymentOverride| { &m.end },
                |m: &mut OfferPaymentOverride| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OfferPaymentOverride>(
                "OfferPaymentOverride",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPaymentOverride {
        static instance: ::protobuf::rt::LazyV2<OfferPaymentOverride> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OfferPaymentOverride::new)
    }
}

impl ::protobuf::Clear for OfferPaymentOverride {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPaymentOverride {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPaymentOverride {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OfferPayment {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub offerPaymentPeriod: ::protobuf::SingularPtrField<OfferPaymentPeriod>,
    pub offerPaymentOverride: ::protobuf::RepeatedField<OfferPaymentOverride>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OfferPayment {
    fn default() -> &'a OfferPayment {
        <OfferPayment as ::protobuf::Message>::default_instance()
    }
}

impl OfferPayment {
    pub fn new() -> OfferPayment {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .OfferPaymentPeriod offerPaymentPeriod = 3;


    pub fn get_offerPaymentPeriod(&self) -> &OfferPaymentPeriod {
        self.offerPaymentPeriod.as_ref().unwrap_or_else(|| <OfferPaymentPeriod as ::protobuf::Message>::default_instance())
    }

    // repeated .OfferPaymentOverride offerPaymentOverride = 4;


    pub fn get_offerPaymentOverride(&self) -> &[OfferPaymentOverride] {
        &self.offerPaymentOverride
    }
}

impl ::protobuf::Message for OfferPayment {
    fn is_initialized(&self) -> bool {
        for v in &self.offerPaymentPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offerPaymentOverride {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offerPaymentPeriod)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offerPaymentOverride)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.offerPaymentPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offerPaymentOverride {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.offerPaymentPeriod.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.offerPaymentOverride {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OfferPayment {
        OfferPayment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &OfferPayment| { &m.micros },
                |m: &mut OfferPayment| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &OfferPayment| { &m.currencyCode },
                |m: &mut OfferPayment| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPaymentPeriod>>(
                "offerPaymentPeriod",
                |m: &OfferPayment| { &m.offerPaymentPeriod },
                |m: &mut OfferPayment| { &mut m.offerPaymentPeriod },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OfferPaymentOverride>>(
                "offerPaymentOverride",
                |m: &OfferPayment| { &m.offerPaymentOverride },
                |m: &mut OfferPayment| { &mut m.offerPaymentOverride },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OfferPayment>(
                "OfferPayment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OfferPayment {
        static instance: ::protobuf::rt::LazyV2<OfferPayment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OfferPayment::new)
    }
}

impl ::protobuf::Clear for OfferPayment {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.offerPaymentPeriod.clear();
        self.offerPaymentOverride.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OfferPayment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OfferPayment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VoucherTerms {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoucherTerms {
    fn default() -> &'a VoucherTerms {
        <VoucherTerms as ::protobuf::Message>::default_instance()
    }
}

impl VoucherTerms {
    pub fn new() -> VoucherTerms {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VoucherTerms {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoucherTerms {
        VoucherTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoucherTerms>(
                "VoucherTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoucherTerms {
        static instance: ::protobuf::rt::LazyV2<VoucherTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoucherTerms::new)
    }
}

impl ::protobuf::Clear for VoucherTerms {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoucherTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoucherTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RentalTerms {
    // message fields
    pub dEPRECATEDGrantPeriodSeconds: ::std::option::Option<i32>,
    pub dEPRECATEDActivatePeriodSeconds: ::std::option::Option<i32>,
    pub grantPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    pub activatePeriod: ::protobuf::SingularPtrField<TimePeriod>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RentalTerms {
    fn default() -> &'a RentalTerms {
        <RentalTerms as ::protobuf::Message>::default_instance()
    }
}

impl RentalTerms {
    pub fn new() -> RentalTerms {
        ::std::default::Default::default()
    }

    // optional int32 dEPRECATEDGrantPeriodSeconds = 1;


    pub fn get_dEPRECATEDGrantPeriodSeconds(&self) -> i32 {
        self.dEPRECATEDGrantPeriodSeconds.unwrap_or(0)
    }

    // optional int32 dEPRECATEDActivatePeriodSeconds = 2;


    pub fn get_dEPRECATEDActivatePeriodSeconds(&self) -> i32 {
        self.dEPRECATEDActivatePeriodSeconds.unwrap_or(0)
    }

    // optional .TimePeriod grantPeriod = 3;


    pub fn get_grantPeriod(&self) -> &TimePeriod {
        self.grantPeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }

    // optional .TimePeriod activatePeriod = 4;


    pub fn get_activatePeriod(&self) -> &TimePeriod {
        self.activatePeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RentalTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.grantPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activatePeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dEPRECATEDGrantPeriodSeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dEPRECATEDActivatePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grantPeriod)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activatePeriod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dEPRECATEDGrantPeriodSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dEPRECATEDActivatePeriodSeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.grantPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activatePeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dEPRECATEDGrantPeriodSeconds {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.dEPRECATEDActivatePeriodSeconds {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.grantPeriod.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activatePeriod.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RentalTerms {
        RentalTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dEPRECATEDGrantPeriodSeconds",
                |m: &RentalTerms| { &m.dEPRECATEDGrantPeriodSeconds },
                |m: &mut RentalTerms| { &mut m.dEPRECATEDGrantPeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dEPRECATEDActivatePeriodSeconds",
                |m: &RentalTerms| { &m.dEPRECATEDActivatePeriodSeconds },
                |m: &mut RentalTerms| { &mut m.dEPRECATEDActivatePeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "grantPeriod",
                |m: &RentalTerms| { &m.grantPeriod },
                |m: &mut RentalTerms| { &mut m.grantPeriod },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "activatePeriod",
                |m: &RentalTerms| { &m.activatePeriod },
                |m: &mut RentalTerms| { &mut m.activatePeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RentalTerms>(
                "RentalTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RentalTerms {
        static instance: ::protobuf::rt::LazyV2<RentalTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RentalTerms::new)
    }
}

impl ::protobuf::Clear for RentalTerms {
    fn clear(&mut self) {
        self.dEPRECATEDGrantPeriodSeconds = ::std::option::Option::None;
        self.dEPRECATEDActivatePeriodSeconds = ::std::option::Option::None;
        self.grantPeriod.clear();
        self.activatePeriod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RentalTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RentalTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SignedData {
    // message fields
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedData {
    fn default() -> &'a SignedData {
        <SignedData as ::protobuf::Message>::default_instance()
    }
}

impl SignedData {
    pub fn new() -> SignedData {
        ::std::default::Default::default()
    }

    // optional string signedData = 1;


    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 2;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SignedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedData.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedData {
        SignedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedData",
                |m: &SignedData| { &m.signedData },
                |m: &mut SignedData| { &mut m.signedData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &SignedData| { &m.signature },
                |m: &mut SignedData| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedData>(
                "SignedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedData {
        static instance: ::protobuf::rt::LazyV2<SignedData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedData::new)
    }
}

impl ::protobuf::Clear for SignedData {
    fn clear(&mut self) {
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscriptionContentTerms {
    // message fields
    pub requiredSubscription: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionContentTerms {
    fn default() -> &'a SubscriptionContentTerms {
        <SubscriptionContentTerms as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionContentTerms {
    pub fn new() -> SubscriptionContentTerms {
        ::std::default::Default::default()
    }

    // optional .Docid requiredSubscription = 1;


    pub fn get_requiredSubscription(&self) -> &Docid {
        self.requiredSubscription.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SubscriptionContentTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredSubscription {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requiredSubscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requiredSubscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requiredSubscription.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionContentTerms {
        SubscriptionContentTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "requiredSubscription",
                |m: &SubscriptionContentTerms| { &m.requiredSubscription },
                |m: &mut SubscriptionContentTerms| { &mut m.requiredSubscription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscriptionContentTerms>(
                "SubscriptionContentTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionContentTerms {
        static instance: ::protobuf::rt::LazyV2<SubscriptionContentTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscriptionContentTerms::new)
    }
}

impl ::protobuf::Clear for SubscriptionContentTerms {
    fn clear(&mut self) {
        self.requiredSubscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionContentTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionContentTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscriptionTerms {
    // message fields
    pub recurringPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    pub trialPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionTerms {
    fn default() -> &'a SubscriptionTerms {
        <SubscriptionTerms as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionTerms {
    pub fn new() -> SubscriptionTerms {
        ::std::default::Default::default()
    }

    // optional .TimePeriod recurringPeriod = 1;


    pub fn get_recurringPeriod(&self) -> &TimePeriod {
        self.recurringPeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }

    // optional .TimePeriod trialPeriod = 2;


    pub fn get_trialPeriod(&self) -> &TimePeriod {
        self.trialPeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SubscriptionTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.recurringPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trialPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recurringPeriod)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trialPeriod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recurringPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trialPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recurringPeriod.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trialPeriod.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionTerms {
        SubscriptionTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "recurringPeriod",
                |m: &SubscriptionTerms| { &m.recurringPeriod },
                |m: &mut SubscriptionTerms| { &mut m.recurringPeriod },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "trialPeriod",
                |m: &SubscriptionTerms| { &m.trialPeriod },
                |m: &mut SubscriptionTerms| { &mut m.trialPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscriptionTerms>(
                "SubscriptionTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionTerms {
        static instance: ::protobuf::rt::LazyV2<SubscriptionTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscriptionTerms::new)
    }
}

impl ::protobuf::Clear for SubscriptionTerms {
    fn clear(&mut self) {
        self.recurringPeriod.clear();
        self.trialPeriod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TimePeriod {
    // message fields
    pub unit: ::std::option::Option<i32>,
    pub count: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimePeriod {
    fn default() -> &'a TimePeriod {
        <TimePeriod as ::protobuf::Message>::default_instance()
    }
}

impl TimePeriod {
    pub fn new() -> TimePeriod {
        ::std::default::Default::default()
    }

    // optional int32 unit = 1;


    pub fn get_unit(&self) -> i32 {
        self.unit.unwrap_or(0)
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
}

impl ::protobuf::Message for TimePeriod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimePeriod {
        TimePeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit",
                |m: &TimePeriod| { &m.unit },
                |m: &mut TimePeriod| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &TimePeriod| { &m.count },
                |m: &mut TimePeriod| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimePeriod>(
                "TimePeriod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimePeriod {
        static instance: ::protobuf::rt::LazyV2<TimePeriod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimePeriod::new)
    }
}

impl ::protobuf::Clear for TimePeriod {
    fn clear(&mut self) {
        self.unit = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimePeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimePeriod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingAddressSpec {
    // message fields
    pub billingAddressType: ::std::option::Option<i32>,
    pub requiredField: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingAddressSpec {
    fn default() -> &'a BillingAddressSpec {
        <BillingAddressSpec as ::protobuf::Message>::default_instance()
    }
}

impl BillingAddressSpec {
    pub fn new() -> BillingAddressSpec {
        ::std::default::Default::default()
    }

    // optional int32 billingAddressType = 1;


    pub fn get_billingAddressType(&self) -> i32 {
        self.billingAddressType.unwrap_or(0)
    }

    // repeated int32 requiredField = 2;


    pub fn get_requiredField(&self) -> &[i32] {
        &self.requiredField
    }
}

impl ::protobuf::Message for BillingAddressSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingAddressType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.billingAddressType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.billingAddressType {
            os.write_int32(1, v)?;
        }
        for v in &self.requiredField {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingAddressSpec {
        BillingAddressSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingAddressType",
                |m: &BillingAddressSpec| { &m.billingAddressType },
                |m: &mut BillingAddressSpec| { &mut m.billingAddressType },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &BillingAddressSpec| { &m.requiredField },
                |m: &mut BillingAddressSpec| { &mut m.requiredField },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingAddressSpec>(
                "BillingAddressSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingAddressSpec {
        static instance: ::protobuf::rt::LazyV2<BillingAddressSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingAddressSpec::new)
    }
}

impl ::protobuf::Clear for BillingAddressSpec {
    fn clear(&mut self) {
        self.billingAddressType = ::std::option::Option::None;
        self.requiredField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingAddressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingAddressSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingProfile {
    // message fields
    pub instrument: ::protobuf::RepeatedField<Instrument>,
    pub selectedExternalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub billingProfileOption: ::protobuf::RepeatedField<BillingProfileOption>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingProfile {
    fn default() -> &'a BillingProfile {
        <BillingProfile as ::protobuf::Message>::default_instance()
    }
}

impl BillingProfile {
    pub fn new() -> BillingProfile {
        ::std::default::Default::default()
    }

    // repeated .Instrument instrument = 1;


    pub fn get_instrument(&self) -> &[Instrument] {
        &self.instrument
    }

    // optional string selectedExternalInstrumentId = 2;


    pub fn get_selectedExternalInstrumentId(&self) -> &str {
        match self.selectedExternalInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .BillingProfileOption billingProfileOption = 3;


    pub fn get_billingProfileOption(&self) -> &[BillingProfileOption] {
        &self.billingProfileOption
    }
}

impl ::protobuf::Message for BillingProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingProfileOption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instrument)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.selectedExternalInstrumentId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.billingProfileOption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.instrument {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.selectedExternalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.billingProfileOption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.instrument {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.selectedExternalInstrumentId.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.billingProfileOption {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfile {
        BillingProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &BillingProfile| { &m.instrument },
                |m: &mut BillingProfile| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selectedExternalInstrumentId",
                |m: &BillingProfile| { &m.selectedExternalInstrumentId },
                |m: &mut BillingProfile| { &mut m.selectedExternalInstrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfileOption>>(
                "billingProfileOption",
                |m: &BillingProfile| { &m.billingProfileOption },
                |m: &mut BillingProfile| { &mut m.billingProfileOption },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingProfile>(
                "BillingProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfile {
        static instance: ::protobuf::rt::LazyV2<BillingProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingProfile::new)
    }
}

impl ::protobuf::Clear for BillingProfile {
    fn clear(&mut self) {
        self.instrument.clear();
        self.selectedExternalInstrumentId.clear();
        self.billingProfileOption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingProfileOption {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub displayTitle: ::protobuf::SingularField<::std::string::String>,
    pub externalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub topupInfo: ::protobuf::SingularPtrField<TopupInfo>,
    pub carrierBillingInstrumentStatus: ::protobuf::SingularPtrField<CarrierBillingInstrumentStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingProfileOption {
    fn default() -> &'a BillingProfileOption {
        <BillingProfileOption as ::protobuf::Message>::default_instance()
    }
}

impl BillingProfileOption {
    pub fn new() -> BillingProfileOption {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string displayTitle = 2;


    pub fn get_displayTitle(&self) -> &str {
        match self.displayTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string externalInstrumentId = 3;


    pub fn get_externalInstrumentId(&self) -> &str {
        match self.externalInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .TopupInfo topupInfo = 4;


    pub fn get_topupInfo(&self) -> &TopupInfo {
        self.topupInfo.as_ref().unwrap_or_else(|| <TopupInfo as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierBillingInstrumentStatus carrierBillingInstrumentStatus = 5;


    pub fn get_carrierBillingInstrumentStatus(&self) -> &CarrierBillingInstrumentStatus {
        self.carrierBillingInstrumentStatus.as_ref().unwrap_or_else(|| <CarrierBillingInstrumentStatus as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BillingProfileOption {
    fn is_initialized(&self) -> bool {
        for v in &self.topupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBillingInstrumentStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalInstrumentId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topupInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingInstrumentStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.externalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.topupInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierBillingInstrumentStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.externalInstrumentId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.topupInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierBillingInstrumentStatus.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingProfileOption {
        BillingProfileOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BillingProfileOption| { &m.field_type },
                |m: &mut BillingProfileOption| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayTitle",
                |m: &BillingProfileOption| { &m.displayTitle },
                |m: &mut BillingProfileOption| { &mut m.displayTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalInstrumentId",
                |m: &BillingProfileOption| { &m.externalInstrumentId },
                |m: &mut BillingProfileOption| { &mut m.externalInstrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>>(
                "topupInfo",
                |m: &BillingProfileOption| { &m.topupInfo },
                |m: &mut BillingProfileOption| { &mut m.topupInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrumentStatus>>(
                "carrierBillingInstrumentStatus",
                |m: &BillingProfileOption| { &m.carrierBillingInstrumentStatus },
                |m: &mut BillingProfileOption| { &mut m.carrierBillingInstrumentStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingProfileOption>(
                "BillingProfileOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingProfileOption {
        static instance: ::protobuf::rt::LazyV2<BillingProfileOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingProfileOption::new)
    }
}

impl ::protobuf::Clear for BillingProfileOption {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.displayTitle.clear();
        self.externalInstrumentId.clear();
        self.topupInfo.clear();
        self.carrierBillingInstrumentStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingProfileOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingProfileOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingCredentials {
    // message fields
    pub value: ::protobuf::SingularField<::std::string::String>,
    pub expiration: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingCredentials {
    fn default() -> &'a CarrierBillingCredentials {
        <CarrierBillingCredentials as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingCredentials {
    pub fn new() -> CarrierBillingCredentials {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 expiration = 2;


    pub fn get_expiration(&self) -> i64 {
        self.expiration.unwrap_or(0)
    }
}

impl ::protobuf::Message for CarrierBillingCredentials {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingCredentials {
        CarrierBillingCredentials::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CarrierBillingCredentials| { &m.value },
                |m: &mut CarrierBillingCredentials| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiration",
                |m: &CarrierBillingCredentials| { &m.expiration },
                |m: &mut CarrierBillingCredentials| { &mut m.expiration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingCredentials>(
                "CarrierBillingCredentials",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingCredentials {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingCredentials> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingCredentials::new)
    }
}

impl ::protobuf::Clear for CarrierBillingCredentials {
    fn clear(&mut self) {
        self.value.clear();
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingCredentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingCredentials {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingInstrument {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub accountType: ::protobuf::SingularField<::std::string::String>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub transactionLimit: ::std::option::Option<i64>,
    pub subscriberIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    pub credentials: ::protobuf::SingularPtrField<CarrierBillingCredentials>,
    pub acceptedCarrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingInstrument {
    fn default() -> &'a CarrierBillingInstrument {
        <CarrierBillingInstrument as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingInstrument {
    pub fn new() -> CarrierBillingInstrument {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;


    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string accountType = 2;


    pub fn get_accountType(&self) -> &str {
        match self.accountType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string currencyCode = 3;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 transactionLimit = 4;


    pub fn get_transactionLimit(&self) -> i64 {
        self.transactionLimit.unwrap_or(0)
    }

    // optional string subscriberIdentifier = 5;


    pub fn get_subscriberIdentifier(&self) -> &str {
        match self.subscriberIdentifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .EncryptedSubscriberInfo encryptedSubscriberInfo = 6;


    pub fn get_encryptedSubscriberInfo(&self) -> &EncryptedSubscriberInfo {
        self.encryptedSubscriberInfo.as_ref().unwrap_or_else(|| <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierBillingCredentials credentials = 7;


    pub fn get_credentials(&self) -> &CarrierBillingCredentials {
        self.credentials.as_ref().unwrap_or_else(|| <CarrierBillingCredentials as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierTos acceptedCarrierTos = 8;


    pub fn get_acceptedCarrierTos(&self) -> &CarrierTos {
        self.acceptedCarrierTos.as_ref().unwrap_or_else(|| <CarrierTos as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for CarrierBillingInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptedCarrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transactionLimit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberIdentifier)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.credentials)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acceptedCarrierTos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.accountType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.transactionLimit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acceptedCarrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.accountType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.transactionLimit {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.credentials.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acceptedCarrierTos.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrument {
        CarrierBillingInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentKey",
                |m: &CarrierBillingInstrument| { &m.instrumentKey },
                |m: &mut CarrierBillingInstrument| { &mut m.instrumentKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountType",
                |m: &CarrierBillingInstrument| { &m.accountType },
                |m: &mut CarrierBillingInstrument| { &mut m.accountType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &CarrierBillingInstrument| { &m.currencyCode },
                |m: &mut CarrierBillingInstrument| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "transactionLimit",
                |m: &CarrierBillingInstrument| { &m.transactionLimit },
                |m: &mut CarrierBillingInstrument| { &mut m.transactionLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriberIdentifier",
                |m: &CarrierBillingInstrument| { &m.subscriberIdentifier },
                |m: &mut CarrierBillingInstrument| { &mut m.subscriberIdentifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>>(
                "encryptedSubscriberInfo",
                |m: &CarrierBillingInstrument| { &m.encryptedSubscriberInfo },
                |m: &mut CarrierBillingInstrument| { &mut m.encryptedSubscriberInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingCredentials>>(
                "credentials",
                |m: &CarrierBillingInstrument| { &m.credentials },
                |m: &mut CarrierBillingInstrument| { &mut m.credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>>(
                "acceptedCarrierTos",
                |m: &CarrierBillingInstrument| { &m.acceptedCarrierTos },
                |m: &mut CarrierBillingInstrument| { &mut m.acceptedCarrierTos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingInstrument>(
                "CarrierBillingInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrument {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingInstrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingInstrument::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrument {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.accountType.clear();
        self.currencyCode.clear();
        self.transactionLimit = ::std::option::Option::None;
        self.subscriberIdentifier.clear();
        self.encryptedSubscriberInfo.clear();
        self.credentials.clear();
        self.acceptedCarrierTos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingInstrumentStatus {
    // message fields
    pub carrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    pub associationRequired: ::std::option::Option<bool>,
    pub passwordRequired: ::std::option::Option<bool>,
    pub carrierPasswordPrompt: ::protobuf::SingularPtrField<PasswordPrompt>,
    pub apiVersion: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub deviceAssociation: ::protobuf::SingularPtrField<DeviceAssociation>,
    pub carrierSupportPhoneNumber: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingInstrumentStatus {
    fn default() -> &'a CarrierBillingInstrumentStatus {
        <CarrierBillingInstrumentStatus as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingInstrumentStatus {
    pub fn new() -> CarrierBillingInstrumentStatus {
        ::std::default::Default::default()
    }

    // optional .CarrierTos carrierTos = 1;


    pub fn get_carrierTos(&self) -> &CarrierTos {
        self.carrierTos.as_ref().unwrap_or_else(|| <CarrierTos as ::protobuf::Message>::default_instance())
    }

    // optional bool associationRequired = 2;


    pub fn get_associationRequired(&self) -> bool {
        self.associationRequired.unwrap_or(false)
    }

    // optional bool passwordRequired = 3;


    pub fn get_passwordRequired(&self) -> bool {
        self.passwordRequired.unwrap_or(false)
    }

    // optional .PasswordPrompt carrierPasswordPrompt = 4;


    pub fn get_carrierPasswordPrompt(&self) -> &PasswordPrompt {
        self.carrierPasswordPrompt.as_ref().unwrap_or_else(|| <PasswordPrompt as ::protobuf::Message>::default_instance())
    }

    // optional int32 apiVersion = 5;


    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string name = 6;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DeviceAssociation deviceAssociation = 7;


    pub fn get_deviceAssociation(&self) -> &DeviceAssociation {
        self.deviceAssociation.as_ref().unwrap_or_else(|| <DeviceAssociation as ::protobuf::Message>::default_instance())
    }

    // optional string carrierSupportPhoneNumber = 8;


    pub fn get_carrierSupportPhoneNumber(&self) -> &str {
        match self.carrierSupportPhoneNumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierBillingInstrumentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierPasswordPrompt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deviceAssociation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierTos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.associationRequired = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passwordRequired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierPasswordPrompt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceAssociation)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierSupportPhoneNumber)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.carrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.associationRequired {
            my_size += 2;
        }
        if let Some(v) = self.passwordRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.carrierPasswordPrompt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.deviceAssociation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierSupportPhoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.carrierTos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.associationRequired {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.passwordRequired {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.carrierPasswordPrompt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.deviceAssociation.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierSupportPhoneNumber.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrumentStatus {
        CarrierBillingInstrumentStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>>(
                "carrierTos",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierTos },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "associationRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.associationRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.associationRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passwordRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.passwordRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.passwordRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PasswordPrompt>>(
                "carrierPasswordPrompt",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierPasswordPrompt },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierPasswordPrompt },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "apiVersion",
                |m: &CarrierBillingInstrumentStatus| { &m.apiVersion },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CarrierBillingInstrumentStatus| { &m.name },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAssociation>>(
                "deviceAssociation",
                |m: &CarrierBillingInstrumentStatus| { &m.deviceAssociation },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.deviceAssociation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "carrierSupportPhoneNumber",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierSupportPhoneNumber },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierSupportPhoneNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingInstrumentStatus>(
                "CarrierBillingInstrumentStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrumentStatus {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingInstrumentStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingInstrumentStatus::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrumentStatus {
    fn clear(&mut self) {
        self.carrierTos.clear();
        self.associationRequired = ::std::option::Option::None;
        self.passwordRequired = ::std::option::Option::None;
        self.carrierPasswordPrompt.clear();
        self.apiVersion = ::std::option::Option::None;
        self.name.clear();
        self.deviceAssociation.clear();
        self.carrierSupportPhoneNumber.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrumentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrumentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierTos {
    // message fields
    pub dcbTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub piiTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub needsDcbTosAcceptance: ::std::option::Option<bool>,
    pub needsPiiTosAcceptance: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierTos {
    fn default() -> &'a CarrierTos {
        <CarrierTos as ::protobuf::Message>::default_instance()
    }
}

impl CarrierTos {
    pub fn new() -> CarrierTos {
        ::std::default::Default::default()
    }

    // optional .CarrierTosEntry dcbTos = 1;


    pub fn get_dcbTos(&self) -> &CarrierTosEntry {
        self.dcbTos.as_ref().unwrap_or_else(|| <CarrierTosEntry as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierTosEntry piiTos = 2;


    pub fn get_piiTos(&self) -> &CarrierTosEntry {
        self.piiTos.as_ref().unwrap_or_else(|| <CarrierTosEntry as ::protobuf::Message>::default_instance())
    }

    // optional bool needsDcbTosAcceptance = 3;


    pub fn get_needsDcbTosAcceptance(&self) -> bool {
        self.needsDcbTosAcceptance.unwrap_or(false)
    }

    // optional bool needsPiiTosAcceptance = 4;


    pub fn get_needsPiiTosAcceptance(&self) -> bool {
        self.needsPiiTosAcceptance.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierTos {
    fn is_initialized(&self) -> bool {
        for v in &self.dcbTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.piiTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dcbTos)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.piiTos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsDcbTosAcceptance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsPiiTosAcceptance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dcbTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.piiTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            my_size += 2;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dcbTos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.piiTos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTos {
        CarrierTos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>>(
                "dcbTos",
                |m: &CarrierTos| { &m.dcbTos },
                |m: &mut CarrierTos| { &mut m.dcbTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>>(
                "piiTos",
                |m: &CarrierTos| { &m.piiTos },
                |m: &mut CarrierTos| { &mut m.piiTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needsDcbTosAcceptance",
                |m: &CarrierTos| { &m.needsDcbTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsDcbTosAcceptance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needsPiiTosAcceptance",
                |m: &CarrierTos| { &m.needsPiiTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsPiiTosAcceptance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierTos>(
                "CarrierTos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTos {
        static instance: ::protobuf::rt::LazyV2<CarrierTos> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierTos::new)
    }
}

impl ::protobuf::Clear for CarrierTos {
    fn clear(&mut self) {
        self.dcbTos.clear();
        self.piiTos.clear();
        self.needsDcbTosAcceptance = ::std::option::Option::None;
        self.needsPiiTosAcceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTos {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierTosEntry {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierTosEntry {
    fn default() -> &'a CarrierTosEntry {
        <CarrierTosEntry as ::protobuf::Message>::default_instance()
    }
}

impl CarrierTosEntry {
    pub fn new() -> CarrierTosEntry {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierTosEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTosEntry {
        CarrierTosEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CarrierTosEntry| { &m.url },
                |m: &mut CarrierTosEntry| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &CarrierTosEntry| { &m.version },
                |m: &mut CarrierTosEntry| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierTosEntry>(
                "CarrierTosEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTosEntry {
        static instance: ::protobuf::rt::LazyV2<CarrierTosEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierTosEntry::new)
    }
}

impl ::protobuf::Clear for CarrierTosEntry {
    fn clear(&mut self) {
        self.url.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTosEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTosEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CreditCardInstrument {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub escrowHandle: ::protobuf::SingularField<::std::string::String>,
    pub lastDigits: ::protobuf::SingularField<::std::string::String>,
    pub expirationMonth: ::std::option::Option<i32>,
    pub expirationYear: ::std::option::Option<i32>,
    pub escrowEfeParam: ::protobuf::RepeatedField<EfeParam>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreditCardInstrument {
    fn default() -> &'a CreditCardInstrument {
        <CreditCardInstrument as ::protobuf::Message>::default_instance()
    }
}

impl CreditCardInstrument {
    pub fn new() -> CreditCardInstrument {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string escrowHandle = 2;


    pub fn get_escrowHandle(&self) -> &str {
        match self.escrowHandle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastDigits = 3;


    pub fn get_lastDigits(&self) -> &str {
        match self.lastDigits.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 expirationMonth = 4;


    pub fn get_expirationMonth(&self) -> i32 {
        self.expirationMonth.unwrap_or(0)
    }

    // optional int32 expirationYear = 5;


    pub fn get_expirationYear(&self) -> i32 {
        self.expirationYear.unwrap_or(0)
    }

    // repeated .EfeParam escrowEfeParam = 6;


    pub fn get_escrowEfeParam(&self) -> &[EfeParam] {
        &self.escrowEfeParam
    }
}

impl ::protobuf::Message for CreditCardInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.escrowEfeParam {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.escrowHandle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastDigits)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationMonth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationYear = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.escrowEfeParam)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.escrowHandle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expirationMonth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expirationYear {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.escrowEfeParam {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.escrowHandle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.expirationMonth {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.expirationYear {
            os.write_int32(5, v)?;
        }
        for v in &self.escrowEfeParam {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreditCardInstrument {
        CreditCardInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CreditCardInstrument| { &m.field_type },
                |m: &mut CreditCardInstrument| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "escrowHandle",
                |m: &CreditCardInstrument| { &m.escrowHandle },
                |m: &mut CreditCardInstrument| { &mut m.escrowHandle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastDigits",
                |m: &CreditCardInstrument| { &m.lastDigits },
                |m: &mut CreditCardInstrument| { &mut m.lastDigits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expirationMonth",
                |m: &CreditCardInstrument| { &m.expirationMonth },
                |m: &mut CreditCardInstrument| { &mut m.expirationMonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expirationYear",
                |m: &CreditCardInstrument| { &m.expirationYear },
                |m: &mut CreditCardInstrument| { &mut m.expirationYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EfeParam>>(
                "escrowEfeParam",
                |m: &CreditCardInstrument| { &m.escrowEfeParam },
                |m: &mut CreditCardInstrument| { &mut m.escrowEfeParam },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreditCardInstrument>(
                "CreditCardInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreditCardInstrument {
        static instance: ::protobuf::rt::LazyV2<CreditCardInstrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreditCardInstrument::new)
    }
}

impl ::protobuf::Clear for CreditCardInstrument {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.escrowHandle.clear();
        self.lastDigits.clear();
        self.expirationMonth = ::std::option::Option::None;
        self.expirationYear = ::std::option::Option::None;
        self.escrowEfeParam.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreditCardInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreditCardInstrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeviceAssociation {
    // message fields
    pub userTokenRequestMessage: ::protobuf::SingularField<::std::string::String>,
    pub userTokenRequestAddress: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceAssociation {
    fn default() -> &'a DeviceAssociation {
        <DeviceAssociation as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAssociation {
    pub fn new() -> DeviceAssociation {
        ::std::default::Default::default()
    }

    // optional string userTokenRequestMessage = 1;


    pub fn get_userTokenRequestMessage(&self) -> &str {
        match self.userTokenRequestMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userTokenRequestAddress = 2;


    pub fn get_userTokenRequestAddress(&self) -> &str {
        match self.userTokenRequestAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DeviceAssociation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestMessage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.userTokenRequestMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.userTokenRequestAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.userTokenRequestMessage.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.userTokenRequestAddress.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceAssociation {
        DeviceAssociation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userTokenRequestMessage",
                |m: &DeviceAssociation| { &m.userTokenRequestMessage },
                |m: &mut DeviceAssociation| { &mut m.userTokenRequestMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userTokenRequestAddress",
                |m: &DeviceAssociation| { &m.userTokenRequestAddress },
                |m: &mut DeviceAssociation| { &mut m.userTokenRequestAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceAssociation>(
                "DeviceAssociation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceAssociation {
        static instance: ::protobuf::rt::LazyV2<DeviceAssociation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceAssociation::new)
    }
}

impl ::protobuf::Clear for DeviceAssociation {
    fn clear(&mut self) {
        self.userTokenRequestMessage.clear();
        self.userTokenRequestAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAssociation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAssociation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DisabledInfo {
    // message fields
    pub disabledReason: ::std::option::Option<i32>,
    pub disabledMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisabledInfo {
    fn default() -> &'a DisabledInfo {
        <DisabledInfo as ::protobuf::Message>::default_instance()
    }
}

impl DisabledInfo {
    pub fn new() -> DisabledInfo {
        ::std::default::Default::default()
    }

    // optional int32 disabledReason = 1;


    pub fn get_disabledReason(&self) -> i32 {
        self.disabledReason.unwrap_or(0)
    }

    // optional string disabledMessageHtml = 2;


    pub fn get_disabledMessageHtml(&self) -> &str {
        match self.disabledMessageHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string errorMessage = 3;


    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DisabledInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.disabledReason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disabledMessageHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.disabledReason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.disabledMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.disabledReason {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.disabledMessageHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisabledInfo {
        DisabledInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "disabledReason",
                |m: &DisabledInfo| { &m.disabledReason },
                |m: &mut DisabledInfo| { &mut m.disabledReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disabledMessageHtml",
                |m: &DisabledInfo| { &m.disabledMessageHtml },
                |m: &mut DisabledInfo| { &mut m.disabledMessageHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessage",
                |m: &DisabledInfo| { &m.errorMessage },
                |m: &mut DisabledInfo| { &mut m.errorMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisabledInfo>(
                "DisabledInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisabledInfo {
        static instance: ::protobuf::rt::LazyV2<DisabledInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisabledInfo::new)
    }
}

impl ::protobuf::Clear for DisabledInfo {
    fn clear(&mut self) {
        self.disabledReason = ::std::option::Option::None;
        self.disabledMessageHtml.clear();
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisabledInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisabledInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EfeParam {
    // message fields
    pub key: ::std::option::Option<i32>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EfeParam {
    fn default() -> &'a EfeParam {
        <EfeParam as ::protobuf::Message>::default_instance()
    }
}

impl EfeParam {
    pub fn new() -> EfeParam {
        ::std::default::Default::default()
    }

    // optional int32 key = 1;


    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EfeParam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EfeParam {
        EfeParam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key",
                |m: &EfeParam| { &m.key },
                |m: &mut EfeParam| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &EfeParam| { &m.value },
                |m: &mut EfeParam| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EfeParam>(
                "EfeParam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EfeParam {
        static instance: ::protobuf::rt::LazyV2<EfeParam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EfeParam::new)
    }
}

impl ::protobuf::Clear for EfeParam {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EfeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EfeParam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Instrument {
    // message fields
    pub externalInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub billingAddress: ::protobuf::SingularPtrField<Address>,
    pub creditCard: ::protobuf::SingularPtrField<CreditCardInstrument>,
    pub carrierBilling: ::protobuf::SingularPtrField<CarrierBillingInstrument>,
    pub billingAddressSpec: ::protobuf::SingularPtrField<BillingAddressSpec>,
    pub instrumentFamily: ::std::option::Option<i32>,
    pub carrierBillingStatus: ::protobuf::SingularPtrField<CarrierBillingInstrumentStatus>,
    pub displayTitle: ::protobuf::SingularField<::std::string::String>,
    pub topupInfoDeprecated: ::protobuf::SingularPtrField<TopupInfo>,
    pub version: ::std::option::Option<i32>,
    pub storedValue: ::protobuf::SingularPtrField<StoredValueInstrument>,
    pub disabledInfo: ::protobuf::RepeatedField<DisabledInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Instrument {
    fn default() -> &'a Instrument {
        <Instrument as ::protobuf::Message>::default_instance()
    }
}

impl Instrument {
    pub fn new() -> Instrument {
        ::std::default::Default::default()
    }

    // optional string externalInstrumentId = 1;


    pub fn get_externalInstrumentId(&self) -> &str {
        match self.externalInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Address billingAddress = 2;


    pub fn get_billingAddress(&self) -> &Address {
        self.billingAddress.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // optional .CreditCardInstrument creditCard = 3;


    pub fn get_creditCard(&self) -> &CreditCardInstrument {
        self.creditCard.as_ref().unwrap_or_else(|| <CreditCardInstrument as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierBillingInstrument carrierBilling = 4;


    pub fn get_carrierBilling(&self) -> &CarrierBillingInstrument {
        self.carrierBilling.as_ref().unwrap_or_else(|| <CarrierBillingInstrument as ::protobuf::Message>::default_instance())
    }

    // optional .BillingAddressSpec billingAddressSpec = 5;


    pub fn get_billingAddressSpec(&self) -> &BillingAddressSpec {
        self.billingAddressSpec.as_ref().unwrap_or_else(|| <BillingAddressSpec as ::protobuf::Message>::default_instance())
    }

    // optional int32 instrumentFamily = 6;


    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional .CarrierBillingInstrumentStatus carrierBillingStatus = 7;


    pub fn get_carrierBillingStatus(&self) -> &CarrierBillingInstrumentStatus {
        self.carrierBillingStatus.as_ref().unwrap_or_else(|| <CarrierBillingInstrumentStatus as ::protobuf::Message>::default_instance())
    }

    // optional string displayTitle = 8;


    pub fn get_displayTitle(&self) -> &str {
        match self.displayTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .TopupInfo topupInfoDeprecated = 9;


    pub fn get_topupInfoDeprecated(&self) -> &TopupInfo {
        self.topupInfoDeprecated.as_ref().unwrap_or_else(|| <TopupInfo as ::protobuf::Message>::default_instance())
    }

    // optional int32 version = 10;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional .StoredValueInstrument storedValue = 11;


    pub fn get_storedValue(&self) -> &StoredValueInstrument {
        self.storedValue.as_ref().unwrap_or_else(|| <StoredValueInstrument as ::protobuf::Message>::default_instance())
    }

    // repeated .DisabledInfo disabledInfo = 12;


    pub fn get_disabledInfo(&self) -> &[DisabledInfo] {
        &self.disabledInfo
    }
}

impl ::protobuf::Message for Instrument {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creditCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBilling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingAddressSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBillingStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topupInfoDeprecated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storedValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disabledInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalInstrumentId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creditCard)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBilling)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingAddressSpec)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingStatus)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayTitle)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topupInfoDeprecated)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storedValue)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.disabledInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.externalInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierBilling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingAddressSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.carrierBillingStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.topupInfoDeprecated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.storedValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.disabledInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.externalInstrumentId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierBilling.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingAddressSpec.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.instrumentFamily {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.carrierBillingStatus.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.topupInfoDeprecated.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.version {
            os.write_int32(10, v)?;
        }
        if let Some(ref v) = self.storedValue.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.disabledInfo {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instrument {
        Instrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalInstrumentId",
                |m: &Instrument| { &m.externalInstrumentId },
                |m: &mut Instrument| { &mut m.externalInstrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "billingAddress",
                |m: &Instrument| { &m.billingAddress },
                |m: &mut Instrument| { &mut m.billingAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreditCardInstrument>>(
                "creditCard",
                |m: &Instrument| { &m.creditCard },
                |m: &mut Instrument| { &mut m.creditCard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrument>>(
                "carrierBilling",
                |m: &Instrument| { &m.carrierBilling },
                |m: &mut Instrument| { &mut m.carrierBilling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingAddressSpec>>(
                "billingAddressSpec",
                |m: &Instrument| { &m.billingAddressSpec },
                |m: &mut Instrument| { &mut m.billingAddressSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instrumentFamily",
                |m: &Instrument| { &m.instrumentFamily },
                |m: &mut Instrument| { &mut m.instrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrumentStatus>>(
                "carrierBillingStatus",
                |m: &Instrument| { &m.carrierBillingStatus },
                |m: &mut Instrument| { &mut m.carrierBillingStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayTitle",
                |m: &Instrument| { &m.displayTitle },
                |m: &mut Instrument| { &mut m.displayTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>>(
                "topupInfoDeprecated",
                |m: &Instrument| { &m.topupInfoDeprecated },
                |m: &mut Instrument| { &mut m.topupInfoDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &Instrument| { &m.version },
                |m: &mut Instrument| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoredValueInstrument>>(
                "storedValue",
                |m: &Instrument| { &m.storedValue },
                |m: &mut Instrument| { &mut m.storedValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DisabledInfo>>(
                "disabledInfo",
                |m: &Instrument| { &m.disabledInfo },
                |m: &mut Instrument| { &mut m.disabledInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Instrument>(
                "Instrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instrument {
        static instance: ::protobuf::rt::LazyV2<Instrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Instrument::new)
    }
}

impl ::protobuf::Clear for Instrument {
    fn clear(&mut self) {
        self.externalInstrumentId.clear();
        self.billingAddress.clear();
        self.creditCard.clear();
        self.carrierBilling.clear();
        self.billingAddressSpec.clear();
        self.instrumentFamily = ::std::option::Option::None;
        self.carrierBillingStatus.clear();
        self.displayTitle.clear();
        self.topupInfoDeprecated.clear();
        self.version = ::std::option::Option::None;
        self.storedValue.clear();
        self.disabledInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InstrumentSetupInfo {
    // message fields
    pub instrumentFamily: ::std::option::Option<i32>,
    pub supported: ::std::option::Option<bool>,
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub balance: ::protobuf::SingularPtrField<Money>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstrumentSetupInfo {
    fn default() -> &'a InstrumentSetupInfo {
        <InstrumentSetupInfo as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentSetupInfo {
    pub fn new() -> InstrumentSetupInfo {
        ::std::default::Default::default()
    }

    // optional int32 instrumentFamily = 1;


    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional bool supported = 2;


    pub fn get_supported(&self) -> bool {
        self.supported.unwrap_or(false)
    }

    // optional .AddressChallenge addressChallenge = 3;


    pub fn get_addressChallenge(&self) -> &AddressChallenge {
        self.addressChallenge.as_ref().unwrap_or_else(|| <AddressChallenge as ::protobuf::Message>::default_instance())
    }

    // optional .Money balance = 4;


    pub fn get_balance(&self) -> &Money {
        self.balance.as_ref().unwrap_or_else(|| <Money as ::protobuf::Message>::default_instance())
    }

    // repeated string footerHtml = 5;


    pub fn get_footerHtml(&self) -> &[::std::string::String] {
        &self.footerHtml
    }
}

impl ::protobuf::Message for InstrumentSetupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supported = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressChallenge)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supported {
            my_size += 2;
        }
        if let Some(ref v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentFamily {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.supported {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.addressChallenge.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.footerHtml {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstrumentSetupInfo {
        InstrumentSetupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instrumentFamily",
                |m: &InstrumentSetupInfo| { &m.instrumentFamily },
                |m: &mut InstrumentSetupInfo| { &mut m.instrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supported",
                |m: &InstrumentSetupInfo| { &m.supported },
                |m: &mut InstrumentSetupInfo| { &mut m.supported },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>>(
                "addressChallenge",
                |m: &InstrumentSetupInfo| { &m.addressChallenge },
                |m: &mut InstrumentSetupInfo| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>>(
                "balance",
                |m: &InstrumentSetupInfo| { &m.balance },
                |m: &mut InstrumentSetupInfo| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &InstrumentSetupInfo| { &m.footerHtml },
                |m: &mut InstrumentSetupInfo| { &mut m.footerHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstrumentSetupInfo>(
                "InstrumentSetupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstrumentSetupInfo {
        static instance: ::protobuf::rt::LazyV2<InstrumentSetupInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstrumentSetupInfo::new)
    }
}

impl ::protobuf::Clear for InstrumentSetupInfo {
    fn clear(&mut self) {
        self.instrumentFamily = ::std::option::Option::None;
        self.supported = ::std::option::Option::None;
        self.addressChallenge.clear();
        self.balance.clear();
        self.footerHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstrumentSetupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentSetupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PasswordPrompt {
    // message fields
    pub prompt: ::protobuf::SingularField<::std::string::String>,
    pub forgotPasswordUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PasswordPrompt {
    fn default() -> &'a PasswordPrompt {
        <PasswordPrompt as ::protobuf::Message>::default_instance()
    }
}

impl PasswordPrompt {
    pub fn new() -> PasswordPrompt {
        ::std::default::Default::default()
    }

    // optional string prompt = 1;


    pub fn get_prompt(&self) -> &str {
        match self.prompt.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string forgotPasswordUrl = 2;


    pub fn get_forgotPasswordUrl(&self) -> &str {
        match self.forgotPasswordUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PasswordPrompt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prompt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.forgotPasswordUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prompt.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.forgotPasswordUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prompt.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.forgotPasswordUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PasswordPrompt {
        PasswordPrompt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prompt",
                |m: &PasswordPrompt| { &m.prompt },
                |m: &mut PasswordPrompt| { &mut m.prompt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forgotPasswordUrl",
                |m: &PasswordPrompt| { &m.forgotPasswordUrl },
                |m: &mut PasswordPrompt| { &mut m.forgotPasswordUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PasswordPrompt>(
                "PasswordPrompt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PasswordPrompt {
        static instance: ::protobuf::rt::LazyV2<PasswordPrompt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PasswordPrompt::new)
    }
}

impl ::protobuf::Clear for PasswordPrompt {
    fn clear(&mut self) {
        self.prompt.clear();
        self.forgotPasswordUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PasswordPrompt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordPrompt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StoredValueInstrument {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub balance: ::protobuf::SingularPtrField<Money>,
    pub topupInfo: ::protobuf::SingularPtrField<TopupInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoredValueInstrument {
    fn default() -> &'a StoredValueInstrument {
        <StoredValueInstrument as ::protobuf::Message>::default_instance()
    }
}

impl StoredValueInstrument {
    pub fn new() -> StoredValueInstrument {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional .Money balance = 2;


    pub fn get_balance(&self) -> &Money {
        self.balance.as_ref().unwrap_or_else(|| <Money as ::protobuf::Message>::default_instance())
    }

    // optional .TopupInfo topupInfo = 3;


    pub fn get_topupInfo(&self) -> &TopupInfo {
        self.topupInfo.as_ref().unwrap_or_else(|| <TopupInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for StoredValueInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topupInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topupInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.topupInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.topupInfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoredValueInstrument {
        StoredValueInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &StoredValueInstrument| { &m.field_type },
                |m: &mut StoredValueInstrument| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>>(
                "balance",
                |m: &StoredValueInstrument| { &m.balance },
                |m: &mut StoredValueInstrument| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopupInfo>>(
                "topupInfo",
                |m: &StoredValueInstrument| { &m.topupInfo },
                |m: &mut StoredValueInstrument| { &mut m.topupInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StoredValueInstrument>(
                "StoredValueInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StoredValueInstrument {
        static instance: ::protobuf::rt::LazyV2<StoredValueInstrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StoredValueInstrument::new)
    }
}

impl ::protobuf::Clear for StoredValueInstrument {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.balance.clear();
        self.topupInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoredValueInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoredValueInstrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TopupInfo {
    // message fields
    pub optionsContainerDocidDeprecated: ::protobuf::SingularField<::std::string::String>,
    pub optionsListUrl: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub optionsContainerDocid: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TopupInfo {
    fn default() -> &'a TopupInfo {
        <TopupInfo as ::protobuf::Message>::default_instance()
    }
}

impl TopupInfo {
    pub fn new() -> TopupInfo {
        ::std::default::Default::default()
    }

    // optional string optionsContainerDocidDeprecated = 1;


    pub fn get_optionsContainerDocidDeprecated(&self) -> &str {
        match self.optionsContainerDocidDeprecated.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string optionsListUrl = 2;


    pub fn get_optionsListUrl(&self) -> &str {
        match self.optionsListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subtitle = 3;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Docid optionsContainerDocid = 4;


    pub fn get_optionsContainerDocid(&self) -> &Docid {
        self.optionsContainerDocid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for TopupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.optionsContainerDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optionsContainerDocidDeprecated)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.optionsListUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optionsContainerDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.optionsContainerDocidDeprecated.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.optionsListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.optionsContainerDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.optionsContainerDocidDeprecated.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.optionsListUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.optionsContainerDocid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopupInfo {
        TopupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "optionsContainerDocidDeprecated",
                |m: &TopupInfo| { &m.optionsContainerDocidDeprecated },
                |m: &mut TopupInfo| { &mut m.optionsContainerDocidDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "optionsListUrl",
                |m: &TopupInfo| { &m.optionsListUrl },
                |m: &mut TopupInfo| { &mut m.optionsListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &TopupInfo| { &m.subtitle },
                |m: &mut TopupInfo| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "optionsContainerDocid",
                |m: &TopupInfo| { &m.optionsContainerDocid },
                |m: &mut TopupInfo| { &mut m.optionsContainerDocid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TopupInfo>(
                "TopupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TopupInfo {
        static instance: ::protobuf::rt::LazyV2<TopupInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TopupInfo::new)
    }
}

impl ::protobuf::Clear for TopupInfo {
    fn clear(&mut self) {
        self.optionsContainerDocidDeprecated.clear();
        self.optionsListUrl.clear();
        self.subtitle.clear();
        self.optionsContainerDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ConsumePurchaseResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub status: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsumePurchaseResponse {
    fn default() -> &'a ConsumePurchaseResponse {
        <ConsumePurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConsumePurchaseResponse {
    pub fn new() -> ConsumePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional .LibraryUpdate libraryUpdate = 1;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }

    // optional int32 status = 2;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }
}

impl ::protobuf::Message for ConsumePurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.status {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsumePurchaseResponse {
        ConsumePurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &ConsumePurchaseResponse| { &m.libraryUpdate },
                |m: &mut ConsumePurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ConsumePurchaseResponse| { &m.status },
                |m: &mut ConsumePurchaseResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsumePurchaseResponse>(
                "ConsumePurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsumePurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<ConsumePurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsumePurchaseResponse::new)
    }
}

impl ::protobuf::Clear for ConsumePurchaseResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsumePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsumePurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContainerMetadata {
    // message fields
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    pub containerView: ::protobuf::RepeatedField<ContainerView>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerMetadata {
    fn default() -> &'a ContainerMetadata {
        <ContainerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ContainerMetadata {
    pub fn new() -> ContainerMetadata {
        ::std::default::Default::default()
    }

    // optional string browseUrl = 1;


    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string nextPageUrl = 2;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double relevance = 3;


    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 4;


    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 5;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ordered = 6;


    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }

    // repeated .ContainerView containerView = 7;


    pub fn get_containerView(&self) -> &[ContainerView] {
        &self.containerView
    }
}

impl ::protobuf::Message for ContainerMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.containerView {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containerView)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        for value in &self.containerView {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.browseUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(6, v)?;
        }
        for v in &self.containerView {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerMetadata {
        ContainerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "browseUrl",
                |m: &ContainerMetadata| { &m.browseUrl },
                |m: &mut ContainerMetadata| { &mut m.browseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &ContainerMetadata| { &m.nextPageUrl },
                |m: &mut ContainerMetadata| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "relevance",
                |m: &ContainerMetadata| { &m.relevance },
                |m: &mut ContainerMetadata| { &mut m.relevance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "estimatedResults",
                |m: &ContainerMetadata| { &m.estimatedResults },
                |m: &mut ContainerMetadata| { &mut m.estimatedResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &ContainerMetadata| { &m.analyticsCookie },
                |m: &mut ContainerMetadata| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ordered",
                |m: &ContainerMetadata| { &m.ordered },
                |m: &mut ContainerMetadata| { &mut m.ordered },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerView>>(
                "containerView",
                |m: &ContainerMetadata| { &m.containerView },
                |m: &mut ContainerMetadata| { &mut m.containerView },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerMetadata>(
                "ContainerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerMetadata {
        static instance: ::protobuf::rt::LazyV2<ContainerMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerMetadata::new)
    }
}

impl ::protobuf::Clear for ContainerMetadata {
    fn clear(&mut self) {
        self.browseUrl.clear();
        self.nextPageUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.ordered = ::std::option::Option::None;
        self.containerView.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContainerView {
    // message fields
    pub selected: ::std::option::Option<bool>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub listUrl: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerView {
    fn default() -> &'a ContainerView {
        <ContainerView as ::protobuf::Message>::default_instance()
    }
}

impl ContainerView {
    pub fn new() -> ContainerView {
        ::std::default::Default::default()
    }

    // optional bool selected = 1;


    pub fn get_selected(&self) -> bool {
        self.selected.unwrap_or(false)
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string listUrl = 3;


    pub fn get_listUrl(&self) -> &str {
        match self.listUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 4;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ContainerView {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selected {
            my_size += 2;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.listUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selected {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.listUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerView {
        ContainerView::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "selected",
                |m: &ContainerView| { &m.selected },
                |m: &mut ContainerView| { &mut m.selected },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ContainerView| { &m.title },
                |m: &mut ContainerView| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listUrl",
                |m: &ContainerView| { &m.listUrl },
                |m: &mut ContainerView| { &mut m.listUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &ContainerView| { &m.serverLogsCookie },
                |m: &mut ContainerView| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerView>(
                "ContainerView",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerView {
        static instance: ::protobuf::rt::LazyV2<ContainerView> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerView::new)
    }
}

impl ::protobuf::Clear for ContainerView {
    fn clear(&mut self) {
        self.selected = ::std::option::Option::None;
        self.title.clear();
        self.listUrl.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FlagContentResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlagContentResponse {
    fn default() -> &'a FlagContentResponse {
        <FlagContentResponse as ::protobuf::Message>::default_instance()
    }
}

impl FlagContentResponse {
    pub fn new() -> FlagContentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FlagContentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlagContentResponse {
        FlagContentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlagContentResponse>(
                "FlagContentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlagContentResponse {
        static instance: ::protobuf::rt::LazyV2<FlagContentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlagContentResponse::new)
    }
}

impl ::protobuf::Clear for FlagContentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlagContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagContentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub digests: ::protobuf::SingularPtrField<ClientDownloadRequest_Digests>,
    pub length: ::std::option::Option<i64>,
    pub resources: ::protobuf::RepeatedField<ClientDownloadRequest_Resource>,
    pub signature: ::protobuf::SingularPtrField<ClientDownloadRequest_SignatureInfo>,
    pub userInitiated: ::std::option::Option<bool>,
    pub clientAsn: ::protobuf::RepeatedField<::std::string::String>,
    pub fileBasename: ::protobuf::SingularField<::std::string::String>,
    pub downloadType: ::std::option::Option<i32>,
    pub locale: ::protobuf::SingularField<::std::string::String>,
    pub apkInfo: ::protobuf::SingularPtrField<ClientDownloadRequest_ApkInfo>,
    pub androidId: ::std::option::Option<u64>,
    pub originatingPackages: ::protobuf::RepeatedField<::std::string::String>,
    pub originatingSignature: ::protobuf::SingularPtrField<ClientDownloadRequest_SignatureInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest {
    fn default() -> &'a ClientDownloadRequest {
        <ClientDownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest {
    pub fn new() -> ClientDownloadRequest {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ClientDownloadRequest.Digests digests = 2;


    pub fn get_digests(&self) -> &ClientDownloadRequest_Digests {
        self.digests.as_ref().unwrap_or_else(|| <ClientDownloadRequest_Digests as ::protobuf::Message>::default_instance())
    }

    // optional int64 length = 3;


    pub fn get_length(&self) -> i64 {
        self.length.unwrap_or(0)
    }

    // repeated .ClientDownloadRequest.Resource resources = 4;


    pub fn get_resources(&self) -> &[ClientDownloadRequest_Resource] {
        &self.resources
    }

    // optional .ClientDownloadRequest.SignatureInfo signature = 5;


    pub fn get_signature(&self) -> &ClientDownloadRequest_SignatureInfo {
        self.signature.as_ref().unwrap_or_else(|| <ClientDownloadRequest_SignatureInfo as ::protobuf::Message>::default_instance())
    }

    // optional bool userInitiated = 6;


    pub fn get_userInitiated(&self) -> bool {
        self.userInitiated.unwrap_or(false)
    }

    // repeated string clientAsn = 8;


    pub fn get_clientAsn(&self) -> &[::std::string::String] {
        &self.clientAsn
    }

    // optional string fileBasename = 9;


    pub fn get_fileBasename(&self) -> &str {
        match self.fileBasename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 downloadType = 10;


    pub fn get_downloadType(&self) -> i32 {
        self.downloadType.unwrap_or(0)
    }

    // optional string locale = 11;


    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ClientDownloadRequest.ApkInfo apkInfo = 12;


    pub fn get_apkInfo(&self) -> &ClientDownloadRequest_ApkInfo {
        self.apkInfo.as_ref().unwrap_or_else(|| <ClientDownloadRequest_ApkInfo as ::protobuf::Message>::default_instance())
    }

    // optional fixed64 androidId = 13;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // repeated string originatingPackages = 15;


    pub fn get_originatingPackages(&self) -> &[::std::string::String] {
        &self.originatingPackages
    }

    // optional .ClientDownloadRequest.SignatureInfo originatingSignature = 17;


    pub fn get_originatingSignature(&self) -> &ClientDownloadRequest_SignatureInfo {
        self.originatingSignature.as_ref().unwrap_or_else(|| <ClientDownloadRequest_SignatureInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ClientDownloadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.digests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apkInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.originatingSignature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.digests)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userInitiated = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientAsn)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fileBasename)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.downloadType = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apkInfo)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.originatingPackages)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.originatingSignature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.digests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.userInitiated {
            my_size += 2;
        }
        for value in &self.clientAsn {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(ref v) = self.fileBasename.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.downloadType {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.apkInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        for value in &self.originatingPackages {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(ref v) = self.originatingSignature.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.digests.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.length {
            os.write_int64(3, v)?;
        }
        for v in &self.resources {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.userInitiated {
            os.write_bool(6, v)?;
        }
        for v in &self.clientAsn {
            os.write_string(8, &v)?;
        };
        if let Some(ref v) = self.fileBasename.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.downloadType {
            os.write_int32(10, v)?;
        }
        if let Some(ref v) = self.locale.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.apkInfo.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.androidId {
            os.write_fixed64(13, v)?;
        }
        for v in &self.originatingPackages {
            os.write_string(15, &v)?;
        };
        if let Some(ref v) = self.originatingSignature.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest {
        ClientDownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ClientDownloadRequest| { &m.url },
                |m: &mut ClientDownloadRequest| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_Digests>>(
                "digests",
                |m: &ClientDownloadRequest| { &m.digests },
                |m: &mut ClientDownloadRequest| { &mut m.digests },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "length",
                |m: &ClientDownloadRequest| { &m.length },
                |m: &mut ClientDownloadRequest| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_Resource>>(
                "resources",
                |m: &ClientDownloadRequest| { &m.resources },
                |m: &mut ClientDownloadRequest| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_SignatureInfo>>(
                "signature",
                |m: &ClientDownloadRequest| { &m.signature },
                |m: &mut ClientDownloadRequest| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "userInitiated",
                |m: &ClientDownloadRequest| { &m.userInitiated },
                |m: &mut ClientDownloadRequest| { &mut m.userInitiated },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientAsn",
                |m: &ClientDownloadRequest| { &m.clientAsn },
                |m: &mut ClientDownloadRequest| { &mut m.clientAsn },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fileBasename",
                |m: &ClientDownloadRequest| { &m.fileBasename },
                |m: &mut ClientDownloadRequest| { &mut m.fileBasename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "downloadType",
                |m: &ClientDownloadRequest| { &m.downloadType },
                |m: &mut ClientDownloadRequest| { &mut m.downloadType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locale",
                |m: &ClientDownloadRequest| { &m.locale },
                |m: &mut ClientDownloadRequest| { &mut m.locale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_ApkInfo>>(
                "apkInfo",
                |m: &ClientDownloadRequest| { &m.apkInfo },
                |m: &mut ClientDownloadRequest| { &mut m.apkInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &ClientDownloadRequest| { &m.androidId },
                |m: &mut ClientDownloadRequest| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originatingPackages",
                |m: &ClientDownloadRequest| { &m.originatingPackages },
                |m: &mut ClientDownloadRequest| { &mut m.originatingPackages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_SignatureInfo>>(
                "originatingSignature",
                |m: &ClientDownloadRequest| { &m.originatingSignature },
                |m: &mut ClientDownloadRequest| { &mut m.originatingSignature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest>(
                "ClientDownloadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest {
    fn clear(&mut self) {
        self.url.clear();
        self.digests.clear();
        self.length = ::std::option::Option::None;
        self.resources.clear();
        self.signature.clear();
        self.userInitiated = ::std::option::Option::None;
        self.clientAsn.clear();
        self.fileBasename.clear();
        self.downloadType = ::std::option::Option::None;
        self.locale.clear();
        self.apkInfo.clear();
        self.androidId = ::std::option::Option::None;
        self.originatingPackages.clear();
        self.originatingSignature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_ApkInfo {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_ApkInfo {
    fn default() -> &'a ClientDownloadRequest_ApkInfo {
        <ClientDownloadRequest_ApkInfo as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_ApkInfo {
    pub fn new() -> ClientDownloadRequest_ApkInfo {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_ApkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_ApkInfo {
        ClientDownloadRequest_ApkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &ClientDownloadRequest_ApkInfo| { &m.packageName },
                |m: &mut ClientDownloadRequest_ApkInfo| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &ClientDownloadRequest_ApkInfo| { &m.versionCode },
                |m: &mut ClientDownloadRequest_ApkInfo| { &mut m.versionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_ApkInfo>(
                "ClientDownloadRequest.ApkInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_ApkInfo {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_ApkInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_ApkInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_ApkInfo {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_ApkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_ApkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_CertificateChain {
    // message fields
    pub element: ::protobuf::RepeatedField<ClientDownloadRequest_CertificateChain_Element>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_CertificateChain {
    fn default() -> &'a ClientDownloadRequest_CertificateChain {
        <ClientDownloadRequest_CertificateChain as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_CertificateChain {
    pub fn new() -> ClientDownloadRequest_CertificateChain {
        ::std::default::Default::default()
    }

    // repeated .ClientDownloadRequest.CertificateChain.Element element = 1;


    pub fn get_element(&self) -> &[ClientDownloadRequest_CertificateChain_Element] {
        &self.element
    }
}

impl ::protobuf::Message for ClientDownloadRequest_CertificateChain {
    fn is_initialized(&self) -> bool {
        for v in &self.element {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.element)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.element {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.element {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_CertificateChain {
        ClientDownloadRequest_CertificateChain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_CertificateChain_Element>>(
                "element",
                |m: &ClientDownloadRequest_CertificateChain| { &m.element },
                |m: &mut ClientDownloadRequest_CertificateChain| { &mut m.element },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_CertificateChain>(
                "ClientDownloadRequest.CertificateChain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_CertificateChain {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_CertificateChain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_CertificateChain::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_CertificateChain {
    fn clear(&mut self) {
        self.element.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_CertificateChain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_CertificateChain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_CertificateChain_Element {
    // message fields
    pub certificate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub parsedSuccessfully: ::std::option::Option<bool>,
    pub subject: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub issuer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub fingerprint: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub expiryTime: ::std::option::Option<i64>,
    pub startTime: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_CertificateChain_Element {
    fn default() -> &'a ClientDownloadRequest_CertificateChain_Element {
        <ClientDownloadRequest_CertificateChain_Element as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_CertificateChain_Element {
    pub fn new() -> ClientDownloadRequest_CertificateChain_Element {
        ::std::default::Default::default()
    }

    // optional bytes certificate = 1;


    pub fn get_certificate(&self) -> &[u8] {
        match self.certificate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool parsedSuccessfully = 2;


    pub fn get_parsedSuccessfully(&self) -> bool {
        self.parsedSuccessfully.unwrap_or(false)
    }

    // optional bytes subject = 3;


    pub fn get_subject(&self) -> &[u8] {
        match self.subject.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes issuer = 4;


    pub fn get_issuer(&self) -> &[u8] {
        match self.issuer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes fingerprint = 5;


    pub fn get_fingerprint(&self) -> &[u8] {
        match self.fingerprint.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int64 expiryTime = 6;


    pub fn get_expiryTime(&self) -> i64 {
        self.expiryTime.unwrap_or(0)
    }

    // optional int64 startTime = 7;


    pub fn get_startTime(&self) -> i64 {
        self.startTime.unwrap_or(0)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_CertificateChain_Element {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.certificate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.parsedSuccessfully = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.issuer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fingerprint)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiryTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.parsedSuccessfully {
            my_size += 2;
        }
        if let Some(ref v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.fingerprint.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.expiryTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificate.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.parsedSuccessfully {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.subject.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.issuer.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.fingerprint.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.expiryTime {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.startTime {
            os.write_int64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_CertificateChain_Element {
        ClientDownloadRequest_CertificateChain_Element::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "certificate",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.certificate },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "parsedSuccessfully",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.parsedSuccessfully },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.parsedSuccessfully },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "subject",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.subject },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "issuer",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.issuer },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.issuer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fingerprint",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.fingerprint },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.fingerprint },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiryTime",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.expiryTime },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.expiryTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startTime",
                |m: &ClientDownloadRequest_CertificateChain_Element| { &m.startTime },
                |m: &mut ClientDownloadRequest_CertificateChain_Element| { &mut m.startTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_CertificateChain_Element>(
                "ClientDownloadRequest.CertificateChain.Element",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_CertificateChain_Element {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_CertificateChain_Element> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_CertificateChain_Element::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_CertificateChain_Element {
    fn clear(&mut self) {
        self.certificate.clear();
        self.parsedSuccessfully = ::std::option::Option::None;
        self.subject.clear();
        self.issuer.clear();
        self.fingerprint.clear();
        self.expiryTime = ::std::option::Option::None;
        self.startTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_CertificateChain_Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_CertificateChain_Element {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_Digests {
    // message fields
    pub sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub sha1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub md5: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_Digests {
    fn default() -> &'a ClientDownloadRequest_Digests {
        <ClientDownloadRequest_Digests as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_Digests {
    pub fn new() -> ClientDownloadRequest_Digests {
        ::std::default::Default::default()
    }

    // optional bytes sha256 = 1;


    pub fn get_sha256(&self) -> &[u8] {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes sha1 = 2;


    pub fn get_sha1(&self) -> &[u8] {
        match self.sha1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes md5 = 3;


    pub fn get_md5(&self) -> &[u8] {
        match self.md5.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadRequest_Digests {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.md5)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.sha1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.md5.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.sha1.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.md5.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_Digests {
        ClientDownloadRequest_Digests::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha256",
                |m: &ClientDownloadRequest_Digests| { &m.sha256 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.sha256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha1",
                |m: &ClientDownloadRequest_Digests| { &m.sha1 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.sha1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "md5",
                |m: &ClientDownloadRequest_Digests| { &m.md5 },
                |m: &mut ClientDownloadRequest_Digests| { &mut m.md5 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_Digests>(
                "ClientDownloadRequest.Digests",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_Digests {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_Digests> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_Digests::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_Digests {
    fn clear(&mut self) {
        self.sha256.clear();
        self.sha1.clear();
        self.md5.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_Digests {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_Digests {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_Resource {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub remoteIp: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub referrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_Resource {
    fn default() -> &'a ClientDownloadRequest_Resource {
        <ClientDownloadRequest_Resource as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_Resource {
    pub fn new() -> ClientDownloadRequest_Resource {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional bytes remoteIp = 3;


    pub fn get_remoteIp(&self) -> &[u8] {
        match self.remoteIp.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string referrer = 4;


    pub fn get_referrer(&self) -> &str {
        match self.referrer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientDownloadRequest_Resource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.remoteIp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.remoteIp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.referrer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.remoteIp.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.referrer.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_Resource {
        ClientDownloadRequest_Resource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ClientDownloadRequest_Resource| { &m.url },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &ClientDownloadRequest_Resource| { &m.field_type },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "remoteIp",
                |m: &ClientDownloadRequest_Resource| { &m.remoteIp },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.remoteIp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referrer",
                |m: &ClientDownloadRequest_Resource| { &m.referrer },
                |m: &mut ClientDownloadRequest_Resource| { &mut m.referrer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_Resource>(
                "ClientDownloadRequest.Resource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_Resource {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_Resource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_Resource::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_Resource {
    fn clear(&mut self) {
        self.url.clear();
        self.field_type = ::std::option::Option::None;
        self.remoteIp.clear();
        self.referrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_Resource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadRequest_SignatureInfo {
    // message fields
    pub certificateChain: ::protobuf::RepeatedField<ClientDownloadRequest_CertificateChain>,
    pub trusted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadRequest_SignatureInfo {
    fn default() -> &'a ClientDownloadRequest_SignatureInfo {
        <ClientDownloadRequest_SignatureInfo as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadRequest_SignatureInfo {
    pub fn new() -> ClientDownloadRequest_SignatureInfo {
        ::std::default::Default::default()
    }

    // repeated .ClientDownloadRequest.CertificateChain certificateChain = 1;


    pub fn get_certificateChain(&self) -> &[ClientDownloadRequest_CertificateChain] {
        &self.certificateChain
    }

    // optional bool trusted = 2;


    pub fn get_trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }
}

impl ::protobuf::Message for ClientDownloadRequest_SignatureInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.certificateChain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.certificateChain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.certificateChain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.trusted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.certificateChain {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadRequest_SignatureInfo {
        ClientDownloadRequest_SignatureInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadRequest_CertificateChain>>(
                "certificateChain",
                |m: &ClientDownloadRequest_SignatureInfo| { &m.certificateChain },
                |m: &mut ClientDownloadRequest_SignatureInfo| { &mut m.certificateChain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trusted",
                |m: &ClientDownloadRequest_SignatureInfo| { &m.trusted },
                |m: &mut ClientDownloadRequest_SignatureInfo| { &mut m.trusted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadRequest_SignatureInfo>(
                "ClientDownloadRequest.SignatureInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadRequest_SignatureInfo {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadRequest_SignatureInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadRequest_SignatureInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadRequest_SignatureInfo {
    fn clear(&mut self) {
        self.certificateChain.clear();
        self.trusted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadRequest_SignatureInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadRequest_SignatureInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadResponse {
    // message fields
    pub verdict: ::std::option::Option<i32>,
    pub moreInfo: ::protobuf::SingularPtrField<ClientDownloadResponse_MoreInfo>,
    pub token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadResponse {
    fn default() -> &'a ClientDownloadResponse {
        <ClientDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadResponse {
    pub fn new() -> ClientDownloadResponse {
        ::std::default::Default::default()
    }

    // optional int32 verdict = 1;


    pub fn get_verdict(&self) -> i32 {
        self.verdict.unwrap_or(0)
    }

    // optional .ClientDownloadResponse.MoreInfo moreInfo = 2;


    pub fn get_moreInfo(&self) -> &ClientDownloadResponse_MoreInfo {
        self.moreInfo.as_ref().unwrap_or_else(|| <ClientDownloadResponse_MoreInfo as ::protobuf::Message>::default_instance())
    }

    // optional bytes token = 3;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.moreInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.verdict = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.moreInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.moreInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.verdict {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.moreInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadResponse {
        ClientDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "verdict",
                |m: &ClientDownloadResponse| { &m.verdict },
                |m: &mut ClientDownloadResponse| { &mut m.verdict },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientDownloadResponse_MoreInfo>>(
                "moreInfo",
                |m: &ClientDownloadResponse| { &m.moreInfo },
                |m: &mut ClientDownloadResponse| { &mut m.moreInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &ClientDownloadResponse| { &m.token },
                |m: &mut ClientDownloadResponse| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadResponse>(
                "ClientDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadResponse {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadResponse::new)
    }
}

impl ::protobuf::Clear for ClientDownloadResponse {
    fn clear(&mut self) {
        self.verdict = ::std::option::Option::None;
        self.moreInfo.clear();
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadResponse_MoreInfo {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadResponse_MoreInfo {
    fn default() -> &'a ClientDownloadResponse_MoreInfo {
        <ClientDownloadResponse_MoreInfo as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadResponse_MoreInfo {
    pub fn new() -> ClientDownloadResponse_MoreInfo {
        ::std::default::Default::default()
    }

    // optional string description = 1;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientDownloadResponse_MoreInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadResponse_MoreInfo {
        ClientDownloadResponse_MoreInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ClientDownloadResponse_MoreInfo| { &m.description },
                |m: &mut ClientDownloadResponse_MoreInfo| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ClientDownloadResponse_MoreInfo| { &m.url },
                |m: &mut ClientDownloadResponse_MoreInfo| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadResponse_MoreInfo>(
                "ClientDownloadResponse.MoreInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadResponse_MoreInfo {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadResponse_MoreInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadResponse_MoreInfo::new)
    }
}

impl ::protobuf::Clear for ClientDownloadResponse_MoreInfo {
    fn clear(&mut self) {
        self.description.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadResponse_MoreInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadResponse_MoreInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientDownloadStatsRequest {
    // message fields
    pub userDecision: ::std::option::Option<i32>,
    pub token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientDownloadStatsRequest {
    fn default() -> &'a ClientDownloadStatsRequest {
        <ClientDownloadStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClientDownloadStatsRequest {
    pub fn new() -> ClientDownloadStatsRequest {
        ::std::default::Default::default()
    }

    // optional int32 userDecision = 1;


    pub fn get_userDecision(&self) -> i32 {
        self.userDecision.unwrap_or(0)
    }

    // optional bytes token = 2;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ClientDownloadStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userDecision = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.userDecision {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.userDecision {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientDownloadStatsRequest {
        ClientDownloadStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userDecision",
                |m: &ClientDownloadStatsRequest| { &m.userDecision },
                |m: &mut ClientDownloadStatsRequest| { &mut m.userDecision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &ClientDownloadStatsRequest| { &m.token },
                |m: &mut ClientDownloadStatsRequest| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientDownloadStatsRequest>(
                "ClientDownloadStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientDownloadStatsRequest {
        static instance: ::protobuf::rt::LazyV2<ClientDownloadStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientDownloadStatsRequest::new)
    }
}

impl ::protobuf::Clear for ClientDownloadStatsRequest {
    fn clear(&mut self) {
        self.userDecision = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientDownloadStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientDownloadStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugInfo {
    // message fields
    pub message: ::protobuf::RepeatedField<::std::string::String>,
    // timing: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugInfo {
    fn default() -> &'a DebugInfo {
        <DebugInfo as ::protobuf::Message>::default_instance()
    }
}

impl DebugInfo {
    pub fn new() -> DebugInfo {
        ::std::default::Default::default()
    }

    // repeated string message = 1;


    pub fn get_message(&self) -> &[::std::string::String] {
        &self.message
    }
}

impl ::protobuf::Message for DebugInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo {
        DebugInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &DebugInfo| { &m.message },
                |m: &mut DebugInfo| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugInfo>(
                "DebugInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo {
        static instance: ::protobuf::rt::LazyV2<DebugInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugInfo::new)
    }
}

impl ::protobuf::Clear for DebugInfo {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugInfo_Timing {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub timeInMs: ::std::option::Option<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugInfo_Timing {
    fn default() -> &'a DebugInfo_Timing {
        <DebugInfo_Timing as ::protobuf::Message>::default_instance()
    }
}

impl DebugInfo_Timing {
    pub fn new() -> DebugInfo_Timing {
        ::std::default::Default::default()
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double timeInMs = 4;


    pub fn get_timeInMs(&self) -> f64 {
        self.timeInMs.unwrap_or(0.)
    }
}

impl ::protobuf::Message for DebugInfo_Timing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timeInMs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeInMs {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timeInMs {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo_Timing {
        DebugInfo_Timing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DebugInfo_Timing| { &m.name },
                |m: &mut DebugInfo_Timing| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "timeInMs",
                |m: &DebugInfo_Timing| { &m.timeInMs },
                |m: &mut DebugInfo_Timing| { &mut m.timeInMs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugInfo_Timing>(
                "DebugInfo.Timing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo_Timing {
        static instance: ::protobuf::rt::LazyV2<DebugInfo_Timing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugInfo_Timing::new)
    }
}

impl ::protobuf::Clear for DebugInfo_Timing {
    fn clear(&mut self) {
        self.name.clear();
        self.timeInMs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo_Timing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo_Timing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugSettingsResponse {
    // message fields
    pub playCountryOverride: ::protobuf::SingularField<::std::string::String>,
    pub playCountryDebugInfo: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugSettingsResponse {
    fn default() -> &'a DebugSettingsResponse {
        <DebugSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DebugSettingsResponse {
    pub fn new() -> DebugSettingsResponse {
        ::std::default::Default::default()
    }

    // optional string playCountryOverride = 1;


    pub fn get_playCountryOverride(&self) -> &str {
        match self.playCountryOverride.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string playCountryDebugInfo = 2;


    pub fn get_playCountryDebugInfo(&self) -> &str {
        match self.playCountryDebugInfo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DebugSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.playCountryOverride)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.playCountryDebugInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.playCountryOverride.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.playCountryDebugInfo.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.playCountryOverride.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.playCountryDebugInfo.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugSettingsResponse {
        DebugSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "playCountryOverride",
                |m: &DebugSettingsResponse| { &m.playCountryOverride },
                |m: &mut DebugSettingsResponse| { &mut m.playCountryOverride },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "playCountryDebugInfo",
                |m: &DebugSettingsResponse| { &m.playCountryDebugInfo },
                |m: &mut DebugSettingsResponse| { &mut m.playCountryDebugInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugSettingsResponse>(
                "DebugSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugSettingsResponse {
        static instance: ::protobuf::rt::LazyV2<DebugSettingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugSettingsResponse::new)
    }
}

impl ::protobuf::Clear for DebugSettingsResponse {
    fn clear(&mut self) {
        self.playCountryOverride.clear();
        self.playCountryDebugInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeliveryResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeliveryResponse {
    fn default() -> &'a DeliveryResponse {
        <DeliveryResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeliveryResponse {
    pub fn new() -> DeliveryResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 2;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for DeliveryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeliveryResponse {
        DeliveryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &DeliveryResponse| { &m.status },
                |m: &mut DeliveryResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &DeliveryResponse| { &m.appDeliveryData },
                |m: &mut DeliveryResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeliveryResponse>(
                "DeliveryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeliveryResponse {
        static instance: ::protobuf::rt::LazyV2<DeliveryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeliveryResponse::new)
    }
}

impl ::protobuf::Clear for DeliveryResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeliveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeliveryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsEntry {
    // message fields
    pub doc: ::protobuf::SingularPtrField<DocV2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsEntry {
    fn default() -> &'a BulkDetailsEntry {
        <BulkDetailsEntry as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsEntry {
    pub fn new() -> BulkDetailsEntry {
        ::std::default::Default::default()
    }

    // optional .DocV2 doc = 1;


    pub fn get_doc(&self) -> &DocV2 {
        self.doc.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BulkDetailsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsEntry {
        BulkDetailsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &BulkDetailsEntry| { &m.doc },
                |m: &mut BulkDetailsEntry| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsEntry>(
                "BulkDetailsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsEntry {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsEntry::new)
    }
}

impl ::protobuf::Clear for BulkDetailsEntry {
    fn clear(&mut self) {
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsRequest {
    // message fields
    pub docid: ::protobuf::RepeatedField<::std::string::String>,
    pub includeChildDocs: ::std::option::Option<bool>,
    pub includeDetails: ::std::option::Option<bool>,
    pub sourcePackageName: ::protobuf::SingularField<::std::string::String>,
    pub installedVersionCode: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsRequest {
    fn default() -> &'a BulkDetailsRequest {
        <BulkDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsRequest {
    pub fn new() -> BulkDetailsRequest {
        ::std::default::Default::default()
    }

    // repeated string docid = 1;


    pub fn get_docid(&self) -> &[::std::string::String] {
        &self.docid
    }

    // optional bool includeChildDocs = 2;


    pub fn get_includeChildDocs(&self) -> bool {
        self.includeChildDocs.unwrap_or(false)
    }

    // optional bool includeDetails = 3;


    pub fn get_includeDetails(&self) -> bool {
        self.includeDetails.unwrap_or(false)
    }

    // optional string sourcePackageName = 4;


    pub fn get_sourcePackageName(&self) -> &str {
        match self.sourcePackageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 installedVersionCode = 5;


    pub fn get_installedVersionCode(&self) -> &[i32] {
        &self.installedVersionCode
    }
}

impl ::protobuf::Message for BulkDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeChildDocs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeDetails = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourcePackageName)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.installedVersionCode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.docid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.includeChildDocs {
            my_size += 2;
        }
        if let Some(v) = self.includeDetails {
            my_size += 2;
        }
        if let Some(ref v) = self.sourcePackageName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.installedVersionCode {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.docid {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.includeChildDocs {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.includeDetails {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.sourcePackageName.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.installedVersionCode {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsRequest {
        BulkDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &BulkDetailsRequest| { &m.docid },
                |m: &mut BulkDetailsRequest| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "includeChildDocs",
                |m: &BulkDetailsRequest| { &m.includeChildDocs },
                |m: &mut BulkDetailsRequest| { &mut m.includeChildDocs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "includeDetails",
                |m: &BulkDetailsRequest| { &m.includeDetails },
                |m: &mut BulkDetailsRequest| { &mut m.includeDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourcePackageName",
                |m: &BulkDetailsRequest| { &m.sourcePackageName },
                |m: &mut BulkDetailsRequest| { &mut m.sourcePackageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "installedVersionCode",
                |m: &BulkDetailsRequest| { &m.installedVersionCode },
                |m: &mut BulkDetailsRequest| { &mut m.installedVersionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsRequest>(
                "BulkDetailsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsRequest {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsRequest::new)
    }
}

impl ::protobuf::Clear for BulkDetailsRequest {
    fn clear(&mut self) {
        self.docid.clear();
        self.includeChildDocs = ::std::option::Option::None;
        self.includeDetails = ::std::option::Option::None;
        self.sourcePackageName.clear();
        self.installedVersionCode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsResponse {
    // message fields
    pub entry: ::protobuf::RepeatedField<BulkDetailsEntry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsResponse {
    fn default() -> &'a BulkDetailsResponse {
        <BulkDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsResponse {
    pub fn new() -> BulkDetailsResponse {
        ::std::default::Default::default()
    }

    // repeated .BulkDetailsEntry entry = 1;


    pub fn get_entry(&self) -> &[BulkDetailsEntry] {
        &self.entry
    }
}

impl ::protobuf::Message for BulkDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsResponse {
        BulkDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsEntry>>(
                "entry",
                |m: &BulkDetailsResponse| { &m.entry },
                |m: &mut BulkDetailsResponse| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsResponse>(
                "BulkDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsResponse::new)
    }
}

impl ::protobuf::Clear for BulkDetailsResponse {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DetailsResponse {
    // message fields
    pub docV1: ::protobuf::SingularPtrField<DocV1>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub userReview: ::protobuf::SingularPtrField<Review>,
    pub docV2: ::protobuf::SingularPtrField<DocV2>,
    pub footerHtml: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub discoveryBadge: ::protobuf::RepeatedField<DiscoveryBadge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetailsResponse {
    fn default() -> &'a DetailsResponse {
        <DetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DetailsResponse {
    pub fn new() -> DetailsResponse {
        ::std::default::Default::default()
    }

    // optional .DocV1 docV1 = 1;


    pub fn get_docV1(&self) -> &DocV1 {
        self.docV1.as_ref().unwrap_or_else(|| <DocV1 as ::protobuf::Message>::default_instance())
    }

    // optional string analyticsCookie = 2;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Review userReview = 3;


    pub fn get_userReview(&self) -> &Review {
        self.userReview.as_ref().unwrap_or_else(|| <Review as ::protobuf::Message>::default_instance())
    }

    // optional .DocV2 docV2 = 4;


    pub fn get_docV2(&self) -> &DocV2 {
        self.docV2.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }

    // optional string footerHtml = 5;


    pub fn get_footerHtml(&self) -> &str {
        match self.footerHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 6;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .DiscoveryBadge discoveryBadge = 7;


    pub fn get_discoveryBadge(&self) -> &[DiscoveryBadge] {
        &self.discoveryBadge
    }
}

impl ::protobuf::Message for DetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.docV1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docV2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discoveryBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docV1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userReview)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docV2)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.discoveryBadge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docV1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.userReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.footerHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        for value in &self.discoveryBadge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docV1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.userReview.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docV2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.footerHtml.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, &v)?;
        }
        for v in &self.discoveryBadge {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailsResponse {
        DetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>>(
                "docV1",
                |m: &DetailsResponse| { &m.docV1 },
                |m: &mut DetailsResponse| { &mut m.docV1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &DetailsResponse| { &m.analyticsCookie },
                |m: &mut DetailsResponse| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "userReview",
                |m: &DetailsResponse| { &m.userReview },
                |m: &mut DetailsResponse| { &mut m.userReview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "docV2",
                |m: &DetailsResponse| { &m.docV2 },
                |m: &mut DetailsResponse| { &mut m.docV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &DetailsResponse| { &m.footerHtml },
                |m: &mut DetailsResponse| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &DetailsResponse| { &m.serverLogsCookie },
                |m: &mut DetailsResponse| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryBadge>>(
                "discoveryBadge",
                |m: &DetailsResponse| { &m.discoveryBadge },
                |m: &mut DetailsResponse| { &mut m.discoveryBadge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetailsResponse>(
                "DetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetailsResponse {
        static instance: ::protobuf::rt::LazyV2<DetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetailsResponse::new)
    }
}

impl ::protobuf::Clear for DetailsResponse {
    fn clear(&mut self) {
        self.docV1.clear();
        self.analyticsCookie.clear();
        self.userReview.clear();
        self.docV2.clear();
        self.footerHtml.clear();
        self.serverLogsCookie.clear();
        self.discoveryBadge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DiscoveryBadge {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub backgroundColor: ::std::option::Option<i32>,
    pub discoveryBadgeLink: ::protobuf::SingularPtrField<DiscoveryBadgeLink>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub isPlusOne: ::std::option::Option<bool>,
    pub aggregateRating: ::std::option::Option<f32>,
    pub userStarRating: ::std::option::Option<i32>,
    pub downloadCount: ::protobuf::SingularField<::std::string::String>,
    pub downloadUnits: ::protobuf::SingularField<::std::string::String>,
    pub contentDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoveryBadge {
    fn default() -> &'a DiscoveryBadge {
        <DiscoveryBadge as ::protobuf::Message>::default_instance()
    }
}

impl DiscoveryBadge {
    pub fn new() -> DiscoveryBadge {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 2;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional int32 backgroundColor = 3;


    pub fn get_backgroundColor(&self) -> i32 {
        self.backgroundColor.unwrap_or(0)
    }

    // optional .DiscoveryBadgeLink discoveryBadgeLink = 4;


    pub fn get_discoveryBadgeLink(&self) -> &DiscoveryBadgeLink {
        self.discoveryBadgeLink.as_ref().unwrap_or_else(|| <DiscoveryBadgeLink as ::protobuf::Message>::default_instance())
    }

    // optional bytes serverLogsCookie = 5;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool isPlusOne = 6;


    pub fn get_isPlusOne(&self) -> bool {
        self.isPlusOne.unwrap_or(false)
    }

    // optional float aggregateRating = 7;


    pub fn get_aggregateRating(&self) -> f32 {
        self.aggregateRating.unwrap_or(0.)
    }

    // optional int32 userStarRating = 8;


    pub fn get_userStarRating(&self) -> i32 {
        self.userStarRating.unwrap_or(0)
    }

    // optional string downloadCount = 9;


    pub fn get_downloadCount(&self) -> &str {
        match self.downloadCount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUnits = 10;


    pub fn get_downloadUnits(&self) -> &str {
        match self.downloadUnits.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contentDescription = 11;


    pub fn get_contentDescription(&self) -> &str {
        match self.contentDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DiscoveryBadge {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.discoveryBadgeLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backgroundColor = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discoveryBadgeLink)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPlusOne = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.aggregateRating = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userStarRating = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadCount)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUnits)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.backgroundColor {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.discoveryBadgeLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.isPlusOne {
            my_size += 2;
        }
        if let Some(v) = self.aggregateRating {
            my_size += 5;
        }
        if let Some(v) = self.userStarRating {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadCount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.downloadUnits.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.contentDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.backgroundColor {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.discoveryBadgeLink.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.isPlusOne {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.aggregateRating {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.userStarRating {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.downloadCount.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.downloadUnits.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.contentDescription.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveryBadge {
        DiscoveryBadge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DiscoveryBadge| { &m.title },
                |m: &mut DiscoveryBadge| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DiscoveryBadge| { &m.image },
                |m: &mut DiscoveryBadge| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backgroundColor",
                |m: &DiscoveryBadge| { &m.backgroundColor },
                |m: &mut DiscoveryBadge| { &mut m.backgroundColor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiscoveryBadgeLink>>(
                "discoveryBadgeLink",
                |m: &DiscoveryBadge| { &m.discoveryBadgeLink },
                |m: &mut DiscoveryBadge| { &mut m.discoveryBadgeLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &DiscoveryBadge| { &m.serverLogsCookie },
                |m: &mut DiscoveryBadge| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isPlusOne",
                |m: &DiscoveryBadge| { &m.isPlusOne },
                |m: &mut DiscoveryBadge| { &mut m.isPlusOne },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "aggregateRating",
                |m: &DiscoveryBadge| { &m.aggregateRating },
                |m: &mut DiscoveryBadge| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userStarRating",
                |m: &DiscoveryBadge| { &m.userStarRating },
                |m: &mut DiscoveryBadge| { &mut m.userStarRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadCount",
                |m: &DiscoveryBadge| { &m.downloadCount },
                |m: &mut DiscoveryBadge| { &mut m.downloadCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUnits",
                |m: &DiscoveryBadge| { &m.downloadUnits },
                |m: &mut DiscoveryBadge| { &mut m.downloadUnits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentDescription",
                |m: &DiscoveryBadge| { &m.contentDescription },
                |m: &mut DiscoveryBadge| { &mut m.contentDescription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoveryBadge>(
                "DiscoveryBadge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveryBadge {
        static instance: ::protobuf::rt::LazyV2<DiscoveryBadge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoveryBadge::new)
    }
}

impl ::protobuf::Clear for DiscoveryBadge {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.backgroundColor = ::std::option::Option::None;
        self.discoveryBadgeLink.clear();
        self.serverLogsCookie.clear();
        self.isPlusOne = ::std::option::Option::None;
        self.aggregateRating = ::std::option::Option::None;
        self.userStarRating = ::std::option::Option::None;
        self.downloadCount.clear();
        self.downloadUnits.clear();
        self.contentDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveryBadge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryBadge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DiscoveryBadgeLink {
    // message fields
    pub link: ::protobuf::SingularPtrField<Link>,
    pub userReviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub criticReviewsUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiscoveryBadgeLink {
    fn default() -> &'a DiscoveryBadgeLink {
        <DiscoveryBadgeLink as ::protobuf::Message>::default_instance()
    }
}

impl DiscoveryBadgeLink {
    pub fn new() -> DiscoveryBadgeLink {
        ::std::default::Default::default()
    }

    // optional .Link link = 1;


    pub fn get_link(&self) -> &Link {
        self.link.as_ref().unwrap_or_else(|| <Link as ::protobuf::Message>::default_instance())
    }

    // optional string userReviewsUrl = 2;


    pub fn get_userReviewsUrl(&self) -> &str {
        match self.userReviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string criticReviewsUrl = 3;


    pub fn get_criticReviewsUrl(&self) -> &str {
        match self.criticReviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DiscoveryBadgeLink {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userReviewsUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.criticReviewsUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userReviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.criticReviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userReviewsUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.criticReviewsUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscoveryBadgeLink {
        DiscoveryBadgeLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>>(
                "link",
                |m: &DiscoveryBadgeLink| { &m.link },
                |m: &mut DiscoveryBadgeLink| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userReviewsUrl",
                |m: &DiscoveryBadgeLink| { &m.userReviewsUrl },
                |m: &mut DiscoveryBadgeLink| { &mut m.userReviewsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "criticReviewsUrl",
                |m: &DiscoveryBadgeLink| { &m.criticReviewsUrl },
                |m: &mut DiscoveryBadgeLink| { &mut m.criticReviewsUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiscoveryBadgeLink>(
                "DiscoveryBadgeLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiscoveryBadgeLink {
        static instance: ::protobuf::rt::LazyV2<DiscoveryBadgeLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiscoveryBadgeLink::new)
    }
}

impl ::protobuf::Clear for DiscoveryBadgeLink {
    fn clear(&mut self) {
        self.link.clear();
        self.userReviewsUrl.clear();
        self.criticReviewsUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscoveryBadgeLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscoveryBadgeLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeviceConfigurationProto {
    // message fields
    pub touchScreen: ::std::option::Option<i32>,
    pub keyboard: ::std::option::Option<i32>,
    pub navigation: ::std::option::Option<i32>,
    pub screenLayout: ::std::option::Option<i32>,
    pub hasHardKeyboard: ::std::option::Option<bool>,
    pub hasFiveWayNavigation: ::std::option::Option<bool>,
    pub screenDensity: ::std::option::Option<i32>,
    pub glEsVersion: ::std::option::Option<i32>,
    pub systemSharedLibrary: ::protobuf::RepeatedField<::std::string::String>,
    pub systemAvailableFeature: ::protobuf::RepeatedField<::std::string::String>,
    pub nativePlatform: ::protobuf::RepeatedField<::std::string::String>,
    pub screenWidth: ::std::option::Option<i32>,
    pub screenHeight: ::std::option::Option<i32>,
    pub systemSupportedLocale: ::protobuf::RepeatedField<::std::string::String>,
    pub glExtension: ::protobuf::RepeatedField<::std::string::String>,
    pub deviceClass: ::std::option::Option<i32>,
    pub maxApkDownloadSizeMb: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceConfigurationProto {
    fn default() -> &'a DeviceConfigurationProto {
        <DeviceConfigurationProto as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConfigurationProto {
    pub fn new() -> DeviceConfigurationProto {
        ::std::default::Default::default()
    }

    // optional int32 touchScreen = 1;


    pub fn get_touchScreen(&self) -> i32 {
        self.touchScreen.unwrap_or(0)
    }

    // optional int32 keyboard = 2;


    pub fn get_keyboard(&self) -> i32 {
        self.keyboard.unwrap_or(0)
    }

    // optional int32 navigation = 3;


    pub fn get_navigation(&self) -> i32 {
        self.navigation.unwrap_or(0)
    }

    // optional int32 screenLayout = 4;


    pub fn get_screenLayout(&self) -> i32 {
        self.screenLayout.unwrap_or(0)
    }

    // optional bool hasHardKeyboard = 5;


    pub fn get_hasHardKeyboard(&self) -> bool {
        self.hasHardKeyboard.unwrap_or(false)
    }

    // optional bool hasFiveWayNavigation = 6;


    pub fn get_hasFiveWayNavigation(&self) -> bool {
        self.hasFiveWayNavigation.unwrap_or(false)
    }

    // optional int32 screenDensity = 7;


    pub fn get_screenDensity(&self) -> i32 {
        self.screenDensity.unwrap_or(0)
    }

    // optional int32 glEsVersion = 8;


    pub fn get_glEsVersion(&self) -> i32 {
        self.glEsVersion.unwrap_or(0)
    }

    // repeated string systemSharedLibrary = 9;


    pub fn get_systemSharedLibrary(&self) -> &[::std::string::String] {
        &self.systemSharedLibrary
    }

    // repeated string systemAvailableFeature = 10;


    pub fn get_systemAvailableFeature(&self) -> &[::std::string::String] {
        &self.systemAvailableFeature
    }

    // repeated string nativePlatform = 11;


    pub fn get_nativePlatform(&self) -> &[::std::string::String] {
        &self.nativePlatform
    }

    // optional int32 screenWidth = 12;


    pub fn get_screenWidth(&self) -> i32 {
        self.screenWidth.unwrap_or(0)
    }

    // optional int32 screenHeight = 13;


    pub fn get_screenHeight(&self) -> i32 {
        self.screenHeight.unwrap_or(0)
    }

    // repeated string systemSupportedLocale = 14;


    pub fn get_systemSupportedLocale(&self) -> &[::std::string::String] {
        &self.systemSupportedLocale
    }

    // repeated string glExtension = 15;


    pub fn get_glExtension(&self) -> &[::std::string::String] {
        &self.glExtension
    }

    // optional int32 deviceClass = 16;


    pub fn get_deviceClass(&self) -> i32 {
        self.deviceClass.unwrap_or(0)
    }

    // optional int32 maxApkDownloadSizeMb = 17;


    pub fn get_maxApkDownloadSizeMb(&self) -> i32 {
        self.maxApkDownloadSizeMb.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeviceConfigurationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.touchScreen = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.keyboard = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.navigation = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenLayout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasHardKeyboard = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasFiveWayNavigation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenDensity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.glEsVersion = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSharedLibrary)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemAvailableFeature)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nativePlatform)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenWidth = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenHeight = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSupportedLocale)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glExtension)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceClass = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxApkDownloadSizeMb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.touchScreen {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyboard {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.navigation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenLayout {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasHardKeyboard {
            my_size += 2;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            my_size += 2;
        }
        if let Some(v) = self.screenDensity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.glEsVersion {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSharedLibrary {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.systemAvailableFeature {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.nativePlatform {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.screenWidth {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenHeight {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSupportedLocale {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.glExtension {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.deviceClass {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.touchScreen {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.keyboard {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.navigation {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.screenLayout {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hasHardKeyboard {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.screenDensity {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.glEsVersion {
            os.write_int32(8, v)?;
        }
        for v in &self.systemSharedLibrary {
            os.write_string(9, &v)?;
        };
        for v in &self.systemAvailableFeature {
            os.write_string(10, &v)?;
        };
        for v in &self.nativePlatform {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.screenWidth {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.screenHeight {
            os.write_int32(13, v)?;
        }
        for v in &self.systemSupportedLocale {
            os.write_string(14, &v)?;
        };
        for v in &self.glExtension {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.deviceClass {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            os.write_int32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceConfigurationProto {
        DeviceConfigurationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "touchScreen",
                |m: &DeviceConfigurationProto| { &m.touchScreen },
                |m: &mut DeviceConfigurationProto| { &mut m.touchScreen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "keyboard",
                |m: &DeviceConfigurationProto| { &m.keyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.keyboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "navigation",
                |m: &DeviceConfigurationProto| { &m.navigation },
                |m: &mut DeviceConfigurationProto| { &mut m.navigation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenLayout",
                |m: &DeviceConfigurationProto| { &m.screenLayout },
                |m: &mut DeviceConfigurationProto| { &mut m.screenLayout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasHardKeyboard",
                |m: &DeviceConfigurationProto| { &m.hasHardKeyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.hasHardKeyboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasFiveWayNavigation",
                |m: &DeviceConfigurationProto| { &m.hasFiveWayNavigation },
                |m: &mut DeviceConfigurationProto| { &mut m.hasFiveWayNavigation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenDensity",
                |m: &DeviceConfigurationProto| { &m.screenDensity },
                |m: &mut DeviceConfigurationProto| { &mut m.screenDensity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "glEsVersion",
                |m: &DeviceConfigurationProto| { &m.glEsVersion },
                |m: &mut DeviceConfigurationProto| { &mut m.glEsVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSharedLibrary",
                |m: &DeviceConfigurationProto| { &m.systemSharedLibrary },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSharedLibrary },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemAvailableFeature",
                |m: &DeviceConfigurationProto| { &m.systemAvailableFeature },
                |m: &mut DeviceConfigurationProto| { &mut m.systemAvailableFeature },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nativePlatform",
                |m: &DeviceConfigurationProto| { &m.nativePlatform },
                |m: &mut DeviceConfigurationProto| { &mut m.nativePlatform },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenWidth",
                |m: &DeviceConfigurationProto| { &m.screenWidth },
                |m: &mut DeviceConfigurationProto| { &mut m.screenWidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenHeight",
                |m: &DeviceConfigurationProto| { &m.screenHeight },
                |m: &mut DeviceConfigurationProto| { &mut m.screenHeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSupportedLocale",
                |m: &DeviceConfigurationProto| { &m.systemSupportedLocale },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSupportedLocale },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glExtension",
                |m: &DeviceConfigurationProto| { &m.glExtension },
                |m: &mut DeviceConfigurationProto| { &mut m.glExtension },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceClass",
                |m: &DeviceConfigurationProto| { &m.deviceClass },
                |m: &mut DeviceConfigurationProto| { &mut m.deviceClass },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxApkDownloadSizeMb",
                |m: &DeviceConfigurationProto| { &m.maxApkDownloadSizeMb },
                |m: &mut DeviceConfigurationProto| { &mut m.maxApkDownloadSizeMb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceConfigurationProto>(
                "DeviceConfigurationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceConfigurationProto {
        static instance: ::protobuf::rt::LazyV2<DeviceConfigurationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceConfigurationProto::new)
    }
}

impl ::protobuf::Clear for DeviceConfigurationProto {
    fn clear(&mut self) {
        self.touchScreen = ::std::option::Option::None;
        self.keyboard = ::std::option::Option::None;
        self.navigation = ::std::option::Option::None;
        self.screenLayout = ::std::option::Option::None;
        self.hasHardKeyboard = ::std::option::Option::None;
        self.hasFiveWayNavigation = ::std::option::Option::None;
        self.screenDensity = ::std::option::Option::None;
        self.glEsVersion = ::std::option::Option::None;
        self.systemSharedLibrary.clear();
        self.systemAvailableFeature.clear();
        self.nativePlatform.clear();
        self.screenWidth = ::std::option::Option::None;
        self.screenHeight = ::std::option::Option::None;
        self.systemSupportedLocale.clear();
        self.glExtension.clear();
        self.deviceClass = ::std::option::Option::None;
        self.maxApkDownloadSizeMb = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceConfigurationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfigurationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Document {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub fetchDocid: ::protobuf::SingularPtrField<Docid>,
    pub sampleDocid: ::protobuf::SingularPtrField<Docid>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub priceDeprecated: ::protobuf::SingularPtrField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub translatedSnippet: ::protobuf::RepeatedField<TranslatedText>,
    pub documentVariant: ::protobuf::RepeatedField<DocumentVariant>,
    pub categoryId: ::protobuf::RepeatedField<::std::string::String>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    pub parent: ::protobuf::RepeatedField<Document>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    pub consumptionUrl: ::protobuf::SingularField<::std::string::String>,
    pub estimatedNumChildren: ::std::option::Option<i32>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Document {
    fn default() -> &'a Document {
        <Document as ::protobuf::Message>::default_instance()
    }
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // optional .Docid docid = 1;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional .Docid fetchDocid = 2;


    pub fn get_fetchDocid(&self) -> &Docid {
        self.fetchDocid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional .Docid sampleDocid = 3;


    pub fn get_sampleDocid(&self) -> &Docid {
        self.sampleDocid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional string title = 4;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 5;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string snippet = 6;


    pub fn get_snippet(&self) -> &[::std::string::String] {
        &self.snippet
    }

    // optional .Offer priceDeprecated = 7;


    pub fn get_priceDeprecated(&self) -> &Offer {
        self.priceDeprecated.as_ref().unwrap_or_else(|| <Offer as ::protobuf::Message>::default_instance())
    }

    // optional .Availability availability = 9;


    pub fn get_availability(&self) -> &Availability {
        self.availability.as_ref().unwrap_or_else(|| <Availability as ::protobuf::Message>::default_instance())
    }

    // repeated .Image image = 10;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated .Document child = 11;


    pub fn get_child(&self) -> &[Document] {
        &self.child
    }

    // optional .AggregateRating aggregateRating = 13;


    pub fn get_aggregateRating(&self) -> &AggregateRating {
        self.aggregateRating.as_ref().unwrap_or_else(|| <AggregateRating as ::protobuf::Message>::default_instance())
    }

    // repeated .Offer offer = 14;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // repeated .TranslatedText translatedSnippet = 15;


    pub fn get_translatedSnippet(&self) -> &[TranslatedText] {
        &self.translatedSnippet
    }

    // repeated .DocumentVariant documentVariant = 16;


    pub fn get_documentVariant(&self) -> &[DocumentVariant] {
        &self.documentVariant
    }

    // repeated string categoryId = 17;


    pub fn get_categoryId(&self) -> &[::std::string::String] {
        &self.categoryId
    }

    // repeated .Document decoration = 18;


    pub fn get_decoration(&self) -> &[Document] {
        &self.decoration
    }

    // repeated .Document parent = 19;


    pub fn get_parent(&self) -> &[Document] {
        &self.parent
    }

    // optional string privacyPolicyUrl = 20;


    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string consumptionUrl = 21;


    pub fn get_consumptionUrl(&self) -> &str {
        match self.consumptionUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 estimatedNumChildren = 22;


    pub fn get_estimatedNumChildren(&self) -> i32 {
        self.estimatedNumChildren.unwrap_or(0)
    }

    // optional string subtitle = 23;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fetchDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sampleDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.priceDeprecated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translatedSnippet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.documentVariant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fetchDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sampleDocid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.priceDeprecated)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregateRating)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.translatedSnippet)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documentVariant)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categoryId)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decoration)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parent)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumptionUrl)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumChildren = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fetchDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sampleDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.priceDeprecated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.translatedSnippet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.documentVariant {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.categoryId {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parent {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.consumptionUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.estimatedNumChildren {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fetchDocid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sampleDocid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.snippet {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.priceDeprecated.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.availability.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.image {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.child {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.aggregateRating.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.offer {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.translatedSnippet {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.documentVariant {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.categoryId {
            os.write_string(17, &v)?;
        };
        for v in &self.decoration {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.parent {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.consumptionUrl.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.estimatedNumChildren {
            os.write_int32(22, v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(23, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &Document| { &m.docid },
                |m: &mut Document| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "fetchDocid",
                |m: &Document| { &m.fetchDocid },
                |m: &mut Document| { &mut m.fetchDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "sampleDocid",
                |m: &Document| { &m.sampleDocid },
                |m: &mut Document| { &mut m.sampleDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Document| { &m.title },
                |m: &mut Document| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Document| { &m.url },
                |m: &mut Document| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &Document| { &m.snippet },
                |m: &mut Document| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "priceDeprecated",
                |m: &Document| { &m.priceDeprecated },
                |m: &mut Document| { &mut m.priceDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                "availability",
                |m: &Document| { &m.availability },
                |m: &mut Document| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Document| { &m.image },
                |m: &mut Document| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &Document| { &m.child },
                |m: &mut Document| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>>(
                "aggregateRating",
                |m: &Document| { &m.aggregateRating },
                |m: &mut Document| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &Document| { &m.offer },
                |m: &mut Document| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "translatedSnippet",
                |m: &Document| { &m.translatedSnippet },
                |m: &mut Document| { &mut m.translatedSnippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentVariant>>(
                "documentVariant",
                |m: &Document| { &m.documentVariant },
                |m: &mut Document| { &mut m.documentVariant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &Document| { &m.categoryId },
                |m: &mut Document| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &Document| { &m.decoration },
                |m: &mut Document| { &mut m.decoration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "parent",
                |m: &Document| { &m.parent },
                |m: &mut Document| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privacyPolicyUrl",
                |m: &Document| { &m.privacyPolicyUrl },
                |m: &mut Document| { &mut m.privacyPolicyUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumptionUrl",
                |m: &Document| { &m.consumptionUrl },
                |m: &mut Document| { &mut m.consumptionUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "estimatedNumChildren",
                |m: &Document| { &m.estimatedNumChildren },
                |m: &mut Document| { &mut m.estimatedNumChildren },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &Document| { &m.subtitle },
                |m: &mut Document| { &mut m.subtitle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Document>(
                "Document",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Document {
        static instance: ::protobuf::rt::LazyV2<Document> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Document::new)
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.docid.clear();
        self.fetchDocid.clear();
        self.sampleDocid.clear();
        self.title.clear();
        self.url.clear();
        self.snippet.clear();
        self.priceDeprecated.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.aggregateRating.clear();
        self.offer.clear();
        self.translatedSnippet.clear();
        self.documentVariant.clear();
        self.categoryId.clear();
        self.decoration.clear();
        self.parent.clear();
        self.privacyPolicyUrl.clear();
        self.consumptionUrl.clear();
        self.estimatedNumChildren = ::std::option::Option::None;
        self.subtitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocumentVariant {
    // message fields
    pub variationType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub recentChanges: ::protobuf::SingularField<::std::string::String>,
    pub autoTranslation: ::protobuf::RepeatedField<TranslatedText>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub channelId: ::std::option::Option<i64>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub categoryId: ::protobuf::RepeatedField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentVariant {
    fn default() -> &'a DocumentVariant {
        <DocumentVariant as ::protobuf::Message>::default_instance()
    }
}

impl DocumentVariant {
    pub fn new() -> DocumentVariant {
        ::std::default::Default::default()
    }

    // optional int32 variationType = 1;


    pub fn get_variationType(&self) -> i32 {
        self.variationType.unwrap_or(0)
    }

    // optional .Rule rule = 2;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string snippet = 4;


    pub fn get_snippet(&self) -> &[::std::string::String] {
        &self.snippet
    }

    // optional string recentChanges = 5;


    pub fn get_recentChanges(&self) -> &str {
        match self.recentChanges.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .TranslatedText autoTranslation = 6;


    pub fn get_autoTranslation(&self) -> &[TranslatedText] {
        &self.autoTranslation
    }

    // repeated .Offer offer = 7;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // optional int64 channelId = 9;


    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }

    // repeated .Document child = 10;


    pub fn get_child(&self) -> &[Document] {
        &self.child
    }

    // repeated .Document decoration = 11;


    pub fn get_decoration(&self) -> &[Document] {
        &self.decoration
    }

    // repeated .Image image = 12;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated string categoryId = 13;


    pub fn get_categoryId(&self) -> &[::std::string::String] {
        &self.categoryId
    }

    // optional string subtitle = 14;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocumentVariant {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoTranslation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.variationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChanges)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.autoTranslation)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decoration)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categoryId)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.variationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.recentChanges.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.autoTranslation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.categoryId {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.variationType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.snippet {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.recentChanges.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.autoTranslation {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.offer {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.channelId {
            os.write_int64(9, v)?;
        }
        for v in &self.child {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.decoration {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.image {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.categoryId {
            os.write_string(13, &v)?;
        };
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(14, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentVariant {
        DocumentVariant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "variationType",
                |m: &DocumentVariant| { &m.variationType },
                |m: &mut DocumentVariant| { &mut m.variationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &DocumentVariant| { &m.rule },
                |m: &mut DocumentVariant| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocumentVariant| { &m.title },
                |m: &mut DocumentVariant| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &DocumentVariant| { &m.snippet },
                |m: &mut DocumentVariant| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recentChanges",
                |m: &DocumentVariant| { &m.recentChanges },
                |m: &mut DocumentVariant| { &mut m.recentChanges },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "autoTranslation",
                |m: &DocumentVariant| { &m.autoTranslation },
                |m: &mut DocumentVariant| { &mut m.autoTranslation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocumentVariant| { &m.offer },
                |m: &mut DocumentVariant| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "channelId",
                |m: &DocumentVariant| { &m.channelId },
                |m: &mut DocumentVariant| { &mut m.channelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &DocumentVariant| { &m.child },
                |m: &mut DocumentVariant| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &DocumentVariant| { &m.decoration },
                |m: &mut DocumentVariant| { &mut m.decoration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DocumentVariant| { &m.image },
                |m: &mut DocumentVariant| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &DocumentVariant| { &m.categoryId },
                |m: &mut DocumentVariant| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &DocumentVariant| { &m.subtitle },
                |m: &mut DocumentVariant| { &mut m.subtitle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentVariant>(
                "DocumentVariant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentVariant {
        static instance: ::protobuf::rt::LazyV2<DocumentVariant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentVariant::new)
    }
}

impl ::protobuf::Clear for DocumentVariant {
    fn clear(&mut self) {
        self.variationType = ::std::option::Option::None;
        self.rule.clear();
        self.title.clear();
        self.snippet.clear();
        self.recentChanges.clear();
        self.autoTranslation.clear();
        self.offer.clear();
        self.channelId = ::std::option::Option::None;
        self.child.clear();
        self.decoration.clear();
        self.image.clear();
        self.categoryId.clear();
        self.subtitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentVariant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image {
    // message fields
    pub imageType: ::std::option::Option<i32>,
    // dimension: <group>
    pub imageUrl: ::protobuf::SingularField<::std::string::String>,
    pub altTextLocalized: ::protobuf::SingularField<::std::string::String>,
    pub secureUrl: ::protobuf::SingularField<::std::string::String>,
    pub positionInSequence: ::std::option::Option<i32>,
    pub supportsFifeUrlOptions: ::std::option::Option<bool>,
    // citation: <group>
    pub durationSeconds: ::std::option::Option<i32>,
    pub fillColorRgb: ::protobuf::SingularField<::std::string::String>,
    pub autogen: ::std::option::Option<bool>,
    pub attribution: ::protobuf::SingularPtrField<Attribution>,
    pub backgroundColorRgb: ::protobuf::SingularField<::std::string::String>,
    pub palette: ::protobuf::SingularPtrField<ImagePalette>,
    pub deviceClass: ::std::option::Option<i32>,
    pub supportsFifeMonogramOption: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // optional int32 imageType = 1;


    pub fn get_imageType(&self) -> i32 {
        self.imageType.unwrap_or(0)
    }

    // optional string imageUrl = 5;


    pub fn get_imageUrl(&self) -> &str {
        match self.imageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string altTextLocalized = 6;


    pub fn get_altTextLocalized(&self) -> &str {
        match self.altTextLocalized.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string secureUrl = 7;


    pub fn get_secureUrl(&self) -> &str {
        match self.secureUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 positionInSequence = 8;


    pub fn get_positionInSequence(&self) -> i32 {
        self.positionInSequence.unwrap_or(0)
    }

    // optional bool supportsFifeUrlOptions = 9;


    pub fn get_supportsFifeUrlOptions(&self) -> bool {
        self.supportsFifeUrlOptions.unwrap_or(false)
    }

    // optional int32 durationSeconds = 14;


    pub fn get_durationSeconds(&self) -> i32 {
        self.durationSeconds.unwrap_or(0)
    }

    // optional string fillColorRgb = 15;


    pub fn get_fillColorRgb(&self) -> &str {
        match self.fillColorRgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool autogen = 16;


    pub fn get_autogen(&self) -> bool {
        self.autogen.unwrap_or(false)
    }

    // optional .Attribution attribution = 17;


    pub fn get_attribution(&self) -> &Attribution {
        self.attribution.as_ref().unwrap_or_else(|| <Attribution as ::protobuf::Message>::default_instance())
    }

    // optional string backgroundColorRgb = 19;


    pub fn get_backgroundColorRgb(&self) -> &str {
        match self.backgroundColorRgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ImagePalette palette = 20;


    pub fn get_palette(&self) -> &ImagePalette {
        self.palette.as_ref().unwrap_or_else(|| <ImagePalette as ::protobuf::Message>::default_instance())
    }

    // optional int32 deviceClass = 21;


    pub fn get_deviceClass(&self) -> i32 {
        self.deviceClass.unwrap_or(0)
    }

    // optional bool supportsFifeMonogramOption = 22;


    pub fn get_supportsFifeMonogramOption(&self) -> bool {
        self.supportsFifeMonogramOption.unwrap_or(false)
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        for v in &self.attribution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.palette {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.altTextLocalized)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secureUrl)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.positionInSequence = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsFifeUrlOptions = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.durationSeconds = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fillColorRgb)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autogen = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attribution)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backgroundColorRgb)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.palette)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceClass = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsFifeMonogramOption = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.imageType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.imageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.altTextLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.secureUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.positionInSequence {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            my_size += 2;
        }
        if let Some(v) = self.durationSeconds {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fillColorRgb.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.autogen {
            my_size += 3;
        }
        if let Some(ref v) = self.attribution.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.backgroundColorRgb.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.palette.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deviceClass {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supportsFifeMonogramOption {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.imageType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.imageUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.altTextLocalized.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.secureUrl.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.positionInSequence {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.durationSeconds {
            os.write_int32(14, v)?;
        }
        if let Some(ref v) = self.fillColorRgb.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.autogen {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.attribution.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.backgroundColorRgb.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.palette.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deviceClass {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.supportsFifeMonogramOption {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "imageType",
                |m: &Image| { &m.imageType },
                |m: &mut Image| { &mut m.imageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imageUrl",
                |m: &Image| { &m.imageUrl },
                |m: &mut Image| { &mut m.imageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "altTextLocalized",
                |m: &Image| { &m.altTextLocalized },
                |m: &mut Image| { &mut m.altTextLocalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secureUrl",
                |m: &Image| { &m.secureUrl },
                |m: &mut Image| { &mut m.secureUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "positionInSequence",
                |m: &Image| { &m.positionInSequence },
                |m: &mut Image| { &mut m.positionInSequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supportsFifeUrlOptions",
                |m: &Image| { &m.supportsFifeUrlOptions },
                |m: &mut Image| { &mut m.supportsFifeUrlOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "durationSeconds",
                |m: &Image| { &m.durationSeconds },
                |m: &mut Image| { &mut m.durationSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fillColorRgb",
                |m: &Image| { &m.fillColorRgb },
                |m: &mut Image| { &mut m.fillColorRgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autogen",
                |m: &Image| { &m.autogen },
                |m: &mut Image| { &mut m.autogen },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attribution>>(
                "attribution",
                |m: &Image| { &m.attribution },
                |m: &mut Image| { &mut m.attribution },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backgroundColorRgb",
                |m: &Image| { &m.backgroundColorRgb },
                |m: &mut Image| { &mut m.backgroundColorRgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImagePalette>>(
                "palette",
                |m: &Image| { &m.palette },
                |m: &mut Image| { &mut m.palette },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceClass",
                |m: &Image| { &m.deviceClass },
                |m: &mut Image| { &mut m.deviceClass },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supportsFifeMonogramOption",
                |m: &Image| { &m.supportsFifeMonogramOption },
                |m: &mut Image| { &mut m.supportsFifeMonogramOption },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.imageType = ::std::option::Option::None;
        self.imageUrl.clear();
        self.altTextLocalized.clear();
        self.secureUrl.clear();
        self.positionInSequence = ::std::option::Option::None;
        self.supportsFifeUrlOptions = ::std::option::Option::None;
        self.durationSeconds = ::std::option::Option::None;
        self.fillColorRgb.clear();
        self.autogen = ::std::option::Option::None;
        self.attribution.clear();
        self.backgroundColorRgb.clear();
        self.palette.clear();
        self.deviceClass = ::std::option::Option::None;
        self.supportsFifeMonogramOption = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image_Dimension {
    // message fields
    pub width: ::std::option::Option<i32>,
    pub height: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image_Dimension {
    fn default() -> &'a Image_Dimension {
        <Image_Dimension as ::protobuf::Message>::default_instance()
    }
}

impl Image_Dimension {
    pub fn new() -> Image_Dimension {
        ::std::default::Default::default()
    }

    // optional int32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    // optional int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
}

impl ::protobuf::Message for Image_Dimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Dimension {
        Image_Dimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &Image_Dimension| { &m.width },
                |m: &mut Image_Dimension| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &Image_Dimension| { &m.height },
                |m: &mut Image_Dimension| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image_Dimension>(
                "Image.Dimension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Dimension {
        static instance: ::protobuf::rt::LazyV2<Image_Dimension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image_Dimension::new)
    }
}

impl ::protobuf::Clear for Image_Dimension {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Dimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Dimension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image_Citation {
    // message fields
    pub titleLocalized: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image_Citation {
    fn default() -> &'a Image_Citation {
        <Image_Citation as ::protobuf::Message>::default_instance()
    }
}

impl Image_Citation {
    pub fn new() -> Image_Citation {
        ::std::default::Default::default()
    }

    // optional string titleLocalized = 11;


    pub fn get_titleLocalized(&self) -> &str {
        match self.titleLocalized.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 12;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Image_Citation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.titleLocalized)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.titleLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.titleLocalized.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Citation {
        Image_Citation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "titleLocalized",
                |m: &Image_Citation| { &m.titleLocalized },
                |m: &mut Image_Citation| { &mut m.titleLocalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Image_Citation| { &m.url },
                |m: &mut Image_Citation| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image_Citation>(
                "Image.Citation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Citation {
        static instance: ::protobuf::rt::LazyV2<Image_Citation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image_Citation::new)
    }
}

impl ::protobuf::Clear for Image_Citation {
    fn clear(&mut self) {
        self.titleLocalized.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Citation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Citation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ImagePalette {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImagePalette {
    fn default() -> &'a ImagePalette {
        <ImagePalette as ::protobuf::Message>::default_instance()
    }
}

impl ImagePalette {
    pub fn new() -> ImagePalette {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ImagePalette {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImagePalette {
        ImagePalette::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImagePalette>(
                "ImagePalette",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImagePalette {
        static instance: ::protobuf::rt::LazyV2<ImagePalette> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImagePalette::new)
    }
}

impl ::protobuf::Clear for ImagePalette {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImagePalette {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImagePalette {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Attribution {
    // message fields
    pub sourceTitle: ::protobuf::SingularField<::std::string::String>,
    pub sourceUrl: ::protobuf::SingularField<::std::string::String>,
    pub licenseTitle: ::protobuf::SingularField<::std::string::String>,
    pub licenseUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribution {
    fn default() -> &'a Attribution {
        <Attribution as ::protobuf::Message>::default_instance()
    }
}

impl Attribution {
    pub fn new() -> Attribution {
        ::std::default::Default::default()
    }

    // optional string sourceTitle = 1;


    pub fn get_sourceTitle(&self) -> &str {
        match self.sourceTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sourceUrl = 2;


    pub fn get_sourceUrl(&self) -> &str {
        match self.sourceUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string licenseTitle = 3;


    pub fn get_licenseTitle(&self) -> &str {
        match self.licenseTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string licenseUrl = 4;


    pub fn get_licenseUrl(&self) -> &str {
        match self.licenseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Attribution {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.licenseTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.licenseUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sourceTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sourceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.licenseTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.licenseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sourceTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sourceUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.licenseTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.licenseUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribution {
        Attribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceTitle",
                |m: &Attribution| { &m.sourceTitle },
                |m: &mut Attribution| { &mut m.sourceTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceUrl",
                |m: &Attribution| { &m.sourceUrl },
                |m: &mut Attribution| { &mut m.sourceUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "licenseTitle",
                |m: &Attribution| { &m.licenseTitle },
                |m: &mut Attribution| { &mut m.licenseTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "licenseUrl",
                |m: &Attribution| { &m.licenseUrl },
                |m: &mut Attribution| { &mut m.licenseUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Attribution>(
                "Attribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Attribution {
        static instance: ::protobuf::rt::LazyV2<Attribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Attribution::new)
    }
}

impl ::protobuf::Clear for Attribution {
    fn clear(&mut self) {
        self.sourceTitle.clear();
        self.sourceUrl.clear();
        self.licenseTitle.clear();
        self.licenseUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TranslatedText {
    // message fields
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub sourceLocale: ::protobuf::SingularField<::std::string::String>,
    pub targetLocale: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TranslatedText {
    fn default() -> &'a TranslatedText {
        <TranslatedText as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedText {
    pub fn new() -> TranslatedText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sourceLocale = 2;


    pub fn get_sourceLocale(&self) -> &str {
        match self.sourceLocale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string targetLocale = 3;


    pub fn get_targetLocale(&self) -> &str {
        match self.targetLocale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TranslatedText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceLocale)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetLocale)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sourceLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.targetLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sourceLocale.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.targetLocale.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TranslatedText {
        TranslatedText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &TranslatedText| { &m.text },
                |m: &mut TranslatedText| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceLocale",
                |m: &TranslatedText| { &m.sourceLocale },
                |m: &mut TranslatedText| { &mut m.sourceLocale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetLocale",
                |m: &TranslatedText| { &m.targetLocale },
                |m: &mut TranslatedText| { &mut m.targetLocale },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TranslatedText>(
                "TranslatedText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TranslatedText {
        static instance: ::protobuf::rt::LazyV2<TranslatedText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TranslatedText::new)
    }
}

impl ::protobuf::Clear for TranslatedText {
    fn clear(&mut self) {
        self.text.clear();
        self.sourceLocale.clear();
        self.targetLocale.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TranslatedText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Badge {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Badge {
    fn default() -> &'a Badge {
        <Badge as ::protobuf::Message>::default_instance()
    }
}

impl Badge {
    pub fn new() -> Badge {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Image image = 2;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // optional string browseUrl = 3;


    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string description = 4;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Badge {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.image {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.browseUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Badge {
        Badge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Badge| { &m.title },
                |m: &mut Badge| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Badge| { &m.image },
                |m: &mut Badge| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "browseUrl",
                |m: &Badge| { &m.browseUrl },
                |m: &mut Badge| { &mut m.browseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Badge| { &m.description },
                |m: &mut Badge| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Badge>(
                "Badge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Badge {
        static instance: ::protobuf::rt::LazyV2<Badge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Badge::new)
    }
}

impl ::protobuf::Clear for Badge {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.browseUrl.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Badge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Badge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BadgeContainer {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub badge: ::protobuf::RepeatedField<Badge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BadgeContainer {
    fn default() -> &'a BadgeContainer {
        <BadgeContainer as ::protobuf::Message>::default_instance()
    }
}

impl BadgeContainer {
    pub fn new() -> BadgeContainer {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Image image = 2;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated .Badge badge = 3;


    pub fn get_badge(&self) -> &[Badge] {
        &self.badge
    }
}

impl ::protobuf::Message for BadgeContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.badge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.image {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.badge {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BadgeContainer {
        BadgeContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &BadgeContainer| { &m.title },
                |m: &mut BadgeContainer| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &BadgeContainer| { &m.image },
                |m: &mut BadgeContainer| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badge",
                |m: &BadgeContainer| { &m.badge },
                |m: &mut BadgeContainer| { &mut m.badge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BadgeContainer>(
                "BadgeContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BadgeContainer {
        static instance: ::protobuf::rt::LazyV2<BadgeContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BadgeContainer::new)
    }
}

impl ::protobuf::Clear for BadgeContainer {
    fn clear(&mut self) {
        self.title.clear();
        self.image.clear();
        self.badge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BadgeContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContainerWithBanner {
    // message fields
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerWithBanner {
    fn default() -> &'a ContainerWithBanner {
        <ContainerWithBanner as ::protobuf::Message>::default_instance()
    }
}

impl ContainerWithBanner {
    pub fn new() -> ContainerWithBanner {
        ::std::default::Default::default()
    }

    // optional string colorThemeArgb = 1;


    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerWithBanner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerWithBanner {
        ContainerWithBanner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorThemeArgb",
                |m: &ContainerWithBanner| { &m.colorThemeArgb },
                |m: &mut ContainerWithBanner| { &mut m.colorThemeArgb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerWithBanner>(
                "ContainerWithBanner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerWithBanner {
        static instance: ::protobuf::rt::LazyV2<ContainerWithBanner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerWithBanner::new)
    }
}

impl ::protobuf::Clear for ContainerWithBanner {
    fn clear(&mut self) {
        self.colorThemeArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerWithBanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerWithBanner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DealOfTheDay {
    // message fields
    pub featuredHeader: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DealOfTheDay {
    fn default() -> &'a DealOfTheDay {
        <DealOfTheDay as ::protobuf::Message>::default_instance()
    }
}

impl DealOfTheDay {
    pub fn new() -> DealOfTheDay {
        ::std::default::Default::default()
    }

    // optional string featuredHeader = 1;


    pub fn get_featuredHeader(&self) -> &str {
        match self.featuredHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 2;


    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DealOfTheDay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.featuredHeader)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.featuredHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.featuredHeader.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DealOfTheDay {
        DealOfTheDay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "featuredHeader",
                |m: &DealOfTheDay| { &m.featuredHeader },
                |m: &mut DealOfTheDay| { &mut m.featuredHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorThemeArgb",
                |m: &DealOfTheDay| { &m.colorThemeArgb },
                |m: &mut DealOfTheDay| { &mut m.colorThemeArgb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DealOfTheDay>(
                "DealOfTheDay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DealOfTheDay {
        static instance: ::protobuf::rt::LazyV2<DealOfTheDay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DealOfTheDay::new)
    }
}

impl ::protobuf::Clear for DealOfTheDay {
    fn clear(&mut self) {
        self.featuredHeader.clear();
        self.colorThemeArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DealOfTheDay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DealOfTheDay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Dismissal {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dismissal {
    fn default() -> &'a Dismissal {
        <Dismissal as ::protobuf::Message>::default_instance()
    }
}

impl Dismissal {
    pub fn new() -> Dismissal {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 2;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Dismissal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dismissal {
        Dismissal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Dismissal| { &m.url },
                |m: &mut Dismissal| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &Dismissal| { &m.descriptionHtml },
                |m: &mut Dismissal| { &mut m.descriptionHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dismissal>(
                "Dismissal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dismissal {
        static instance: ::protobuf::rt::LazyV2<Dismissal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dismissal::new)
    }
}

impl ::protobuf::Clear for Dismissal {
    fn clear(&mut self) {
        self.url.clear();
        self.descriptionHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dismissal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dismissal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EditorialSeriesContainer {
    // message fields
    pub seriesTitle: ::protobuf::SingularField<::std::string::String>,
    pub seriesSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeTitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub videoSnippet: ::protobuf::RepeatedField<VideoSnippet>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EditorialSeriesContainer {
    fn default() -> &'a EditorialSeriesContainer {
        <EditorialSeriesContainer as ::protobuf::Message>::default_instance()
    }
}

impl EditorialSeriesContainer {
    pub fn new() -> EditorialSeriesContainer {
        ::std::default::Default::default()
    }

    // optional string seriesTitle = 1;


    pub fn get_seriesTitle(&self) -> &str {
        match self.seriesTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string seriesSubtitle = 2;


    pub fn get_seriesSubtitle(&self) -> &str {
        match self.seriesSubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string episodeTitle = 3;


    pub fn get_episodeTitle(&self) -> &str {
        match self.episodeTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string episodeSubtitle = 4;


    pub fn get_episodeSubtitle(&self) -> &str {
        match self.episodeSubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 5;


    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .VideoSnippet videoSnippet = 6;


    pub fn get_videoSnippet(&self) -> &[VideoSnippet] {
        &self.videoSnippet
    }
}

impl ::protobuf::Message for EditorialSeriesContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.videoSnippet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesSubtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.videoSnippet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seriesTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.seriesSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.episodeTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.episodeSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.videoSnippet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seriesTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.seriesSubtitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.episodeTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.episodeSubtitle.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.videoSnippet {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EditorialSeriesContainer {
        EditorialSeriesContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seriesTitle",
                |m: &EditorialSeriesContainer| { &m.seriesTitle },
                |m: &mut EditorialSeriesContainer| { &mut m.seriesTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seriesSubtitle",
                |m: &EditorialSeriesContainer| { &m.seriesSubtitle },
                |m: &mut EditorialSeriesContainer| { &mut m.seriesSubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "episodeTitle",
                |m: &EditorialSeriesContainer| { &m.episodeTitle },
                |m: &mut EditorialSeriesContainer| { &mut m.episodeTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "episodeSubtitle",
                |m: &EditorialSeriesContainer| { &m.episodeSubtitle },
                |m: &mut EditorialSeriesContainer| { &mut m.episodeSubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorThemeArgb",
                |m: &EditorialSeriesContainer| { &m.colorThemeArgb },
                |m: &mut EditorialSeriesContainer| { &mut m.colorThemeArgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoSnippet>>(
                "videoSnippet",
                |m: &EditorialSeriesContainer| { &m.videoSnippet },
                |m: &mut EditorialSeriesContainer| { &mut m.videoSnippet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EditorialSeriesContainer>(
                "EditorialSeriesContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EditorialSeriesContainer {
        static instance: ::protobuf::rt::LazyV2<EditorialSeriesContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EditorialSeriesContainer::new)
    }
}

impl ::protobuf::Clear for EditorialSeriesContainer {
    fn clear(&mut self) {
        self.seriesTitle.clear();
        self.seriesSubtitle.clear();
        self.episodeTitle.clear();
        self.episodeSubtitle.clear();
        self.colorThemeArgb.clear();
        self.videoSnippet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EditorialSeriesContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EditorialSeriesContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Link {
    // message fields
    pub uri: ::protobuf::SingularField<::std::string::String>,
    pub resolvedLink: ::protobuf::SingularPtrField<ResolvedLink>,
    pub uriBackend: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Link {
    fn default() -> &'a Link {
        <Link as ::protobuf::Message>::default_instance()
    }
}

impl Link {
    pub fn new() -> Link {
        ::std::default::Default::default()
    }

    // optional string uri = 1;


    pub fn get_uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ResolvedLink resolvedLink = 2;


    pub fn get_resolvedLink(&self) -> &ResolvedLink {
        self.resolvedLink.as_ref().unwrap_or_else(|| <ResolvedLink as ::protobuf::Message>::default_instance())
    }

    // optional int32 uriBackend = 3;


    pub fn get_uriBackend(&self) -> i32 {
        self.uriBackend.unwrap_or(0)
    }
}

impl ::protobuf::Message for Link {
    fn is_initialized(&self) -> bool {
        for v in &self.resolvedLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resolvedLink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.uriBackend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resolvedLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.uriBackend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uri.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resolvedLink.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.uriBackend {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Link {
        Link::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &Link| { &m.uri },
                |m: &mut Link| { &mut m.uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>>(
                "resolvedLink",
                |m: &Link| { &m.resolvedLink },
                |m: &mut Link| { &mut m.resolvedLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "uriBackend",
                |m: &Link| { &m.uriBackend },
                |m: &mut Link| { &mut m.uriBackend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Link>(
                "Link",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Link {
        static instance: ::protobuf::rt::LazyV2<Link> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Link::new)
    }
}

impl ::protobuf::Clear for Link {
    fn clear(&mut self) {
        self.uri.clear();
        self.resolvedLink.clear();
        self.uriBackend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Link {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Link {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NextBanner {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorTextArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextBanner {
    fn default() -> &'a NextBanner {
        <NextBanner as ::protobuf::Message>::default_instance()
    }
}

impl NextBanner {
    pub fn new() -> NextBanner {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subtitle = 2;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string colorTextArgb = 3;


    pub fn get_colorTextArgb(&self) -> &str {
        match self.colorTextArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NextBanner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorTextArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.colorTextArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.colorTextArgb.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextBanner {
        NextBanner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &NextBanner| { &m.title },
                |m: &mut NextBanner| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &NextBanner| { &m.subtitle },
                |m: &mut NextBanner| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorTextArgb",
                |m: &NextBanner| { &m.colorTextArgb },
                |m: &mut NextBanner| { &mut m.colorTextArgb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NextBanner>(
                "NextBanner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NextBanner {
        static instance: ::protobuf::rt::LazyV2<NextBanner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NextBanner::new)
    }
}

impl ::protobuf::Clear for NextBanner {
    fn clear(&mut self) {
        self.title.clear();
        self.subtitle.clear();
        self.colorTextArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextBanner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextBanner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OBSOLETE_Reason {
    // message fields
    pub briefReason: ::protobuf::SingularField<::std::string::String>,
    pub oBSOLETEDetailedReason: ::protobuf::SingularField<::std::string::String>,
    pub uniqueId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OBSOLETE_Reason {
    fn default() -> &'a OBSOLETE_Reason {
        <OBSOLETE_Reason as ::protobuf::Message>::default_instance()
    }
}

impl OBSOLETE_Reason {
    pub fn new() -> OBSOLETE_Reason {
        ::std::default::Default::default()
    }

    // optional string briefReason = 1;


    pub fn get_briefReason(&self) -> &str {
        match self.briefReason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string oBSOLETEDetailedReason = 2;


    pub fn get_oBSOLETEDetailedReason(&self) -> &str {
        match self.oBSOLETEDetailedReason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string uniqueId = 3;


    pub fn get_uniqueId(&self) -> &str {
        match self.uniqueId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OBSOLETE_Reason {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.briefReason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oBSOLETEDetailedReason)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uniqueId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.briefReason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.oBSOLETEDetailedReason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.uniqueId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.briefReason.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.oBSOLETEDetailedReason.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.uniqueId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OBSOLETE_Reason {
        OBSOLETE_Reason::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "briefReason",
                |m: &OBSOLETE_Reason| { &m.briefReason },
                |m: &mut OBSOLETE_Reason| { &mut m.briefReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oBSOLETEDetailedReason",
                |m: &OBSOLETE_Reason| { &m.oBSOLETEDetailedReason },
                |m: &mut OBSOLETE_Reason| { &mut m.oBSOLETEDetailedReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uniqueId",
                |m: &OBSOLETE_Reason| { &m.uniqueId },
                |m: &mut OBSOLETE_Reason| { &mut m.uniqueId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OBSOLETE_Reason>(
                "OBSOLETE_Reason",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OBSOLETE_Reason {
        static instance: ::protobuf::rt::LazyV2<OBSOLETE_Reason> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OBSOLETE_Reason::new)
    }
}

impl ::protobuf::Clear for OBSOLETE_Reason {
    fn clear(&mut self) {
        self.briefReason.clear();
        self.oBSOLETEDetailedReason.clear();
        self.uniqueId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OBSOLETE_Reason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OBSOLETE_Reason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusOneData {
    // message fields
    pub setByUser: ::std::option::Option<bool>,
    pub total: ::std::option::Option<i64>,
    pub circlesTotal: ::std::option::Option<i64>,
    pub circlesProfiles: ::protobuf::RepeatedField<PlusProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusOneData {
    fn default() -> &'a PlusOneData {
        <PlusOneData as ::protobuf::Message>::default_instance()
    }
}

impl PlusOneData {
    pub fn new() -> PlusOneData {
        ::std::default::Default::default()
    }

    // optional bool setByUser = 1;


    pub fn get_setByUser(&self) -> bool {
        self.setByUser.unwrap_or(false)
    }

    // optional int64 total = 2;


    pub fn get_total(&self) -> i64 {
        self.total.unwrap_or(0)
    }

    // optional int64 circlesTotal = 3;


    pub fn get_circlesTotal(&self) -> i64 {
        self.circlesTotal.unwrap_or(0)
    }

    // repeated .PlusProfile circlesProfiles = 4;


    pub fn get_circlesProfiles(&self) -> &[PlusProfile] {
        &self.circlesProfiles
    }
}

impl ::protobuf::Message for PlusOneData {
    fn is_initialized(&self) -> bool {
        for v in &self.circlesProfiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.setByUser = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.circlesTotal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.circlesProfiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.setByUser {
            my_size += 2;
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.circlesTotal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.circlesProfiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.setByUser {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.circlesTotal {
            os.write_int64(3, v)?;
        }
        for v in &self.circlesProfiles {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusOneData {
        PlusOneData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "setByUser",
                |m: &PlusOneData| { &m.setByUser },
                |m: &mut PlusOneData| { &mut m.setByUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total",
                |m: &PlusOneData| { &m.total },
                |m: &mut PlusOneData| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "circlesTotal",
                |m: &PlusOneData| { &m.circlesTotal },
                |m: &mut PlusOneData| { &mut m.circlesTotal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "circlesProfiles",
                |m: &PlusOneData| { &m.circlesProfiles },
                |m: &mut PlusOneData| { &mut m.circlesProfiles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusOneData>(
                "PlusOneData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusOneData {
        static instance: ::protobuf::rt::LazyV2<PlusOneData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusOneData::new)
    }
}

impl ::protobuf::Clear for PlusOneData {
    fn clear(&mut self) {
        self.setByUser = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.circlesTotal = ::std::option::Option::None;
        self.circlesProfiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusOneData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusOneData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PromotedDoc {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PromotedDoc {
    fn default() -> &'a PromotedDoc {
        <PromotedDoc as ::protobuf::Message>::default_instance()
    }
}

impl PromotedDoc {
    pub fn new() -> PromotedDoc {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subtitle = 2;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Image image = 3;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // optional string descriptionHtml = 4;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string detailsUrl = 5;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PromotedDoc {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.image {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PromotedDoc {
        PromotedDoc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &PromotedDoc| { &m.title },
                |m: &mut PromotedDoc| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &PromotedDoc| { &m.subtitle },
                |m: &mut PromotedDoc| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &PromotedDoc| { &m.image },
                |m: &mut PromotedDoc| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &PromotedDoc| { &m.descriptionHtml },
                |m: &mut PromotedDoc| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &PromotedDoc| { &m.detailsUrl },
                |m: &mut PromotedDoc| { &mut m.detailsUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PromotedDoc>(
                "PromotedDoc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PromotedDoc {
        static instance: ::protobuf::rt::LazyV2<PromotedDoc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PromotedDoc::new)
    }
}

impl ::protobuf::Clear for PromotedDoc {
    fn clear(&mut self) {
        self.title.clear();
        self.subtitle.clear();
        self.image.clear();
        self.descriptionHtml.clear();
        self.detailsUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PromotedDoc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PromotedDoc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Reason {
    // message fields
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub reasonPlusProfiles: ::protobuf::SingularPtrField<ReasonPlusProfiles>,
    pub reasonReview: ::protobuf::SingularPtrField<ReasonReview>,
    pub dismissal: ::protobuf::SingularPtrField<Dismissal>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reason {
    fn default() -> &'a Reason {
        <Reason as ::protobuf::Message>::default_instance()
    }
}

impl Reason {
    pub fn new() -> Reason {
        ::std::default::Default::default()
    }

    // optional string descriptionHtml = 3;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ReasonPlusProfiles reasonPlusProfiles = 4;


    pub fn get_reasonPlusProfiles(&self) -> &ReasonPlusProfiles {
        self.reasonPlusProfiles.as_ref().unwrap_or_else(|| <ReasonPlusProfiles as ::protobuf::Message>::default_instance())
    }

    // optional .ReasonReview reasonReview = 5;


    pub fn get_reasonReview(&self) -> &ReasonReview {
        self.reasonReview.as_ref().unwrap_or_else(|| <ReasonReview as ::protobuf::Message>::default_instance())
    }

    // optional .Dismissal dismissal = 7;


    pub fn get_dismissal(&self) -> &Dismissal {
        self.dismissal.as_ref().unwrap_or_else(|| <Dismissal as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Reason {
    fn is_initialized(&self) -> bool {
        for v in &self.reasonPlusProfiles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reasonReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reasonPlusProfiles)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reasonReview)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dismissal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reasonPlusProfiles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reasonReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reasonPlusProfiles.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reasonReview.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dismissal.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reason {
        Reason::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &Reason| { &m.descriptionHtml },
                |m: &mut Reason| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReasonPlusProfiles>>(
                "reasonPlusProfiles",
                |m: &Reason| { &m.reasonPlusProfiles },
                |m: &mut Reason| { &mut m.reasonPlusProfiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReasonReview>>(
                "reasonReview",
                |m: &Reason| { &m.reasonReview },
                |m: &mut Reason| { &mut m.reasonReview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>>(
                "dismissal",
                |m: &Reason| { &m.dismissal },
                |m: &mut Reason| { &mut m.dismissal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Reason>(
                "Reason",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Reason {
        static instance: ::protobuf::rt::LazyV2<Reason> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reason::new)
    }
}

impl ::protobuf::Clear for Reason {
    fn clear(&mut self) {
        self.descriptionHtml.clear();
        self.reasonPlusProfiles.clear();
        self.reasonReview.clear();
        self.dismissal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReasonPlusProfiles {
    // message fields
    pub localizedDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub plusProfile: ::protobuf::RepeatedField<PlusProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReasonPlusProfiles {
    fn default() -> &'a ReasonPlusProfiles {
        <ReasonPlusProfiles as ::protobuf::Message>::default_instance()
    }
}

impl ReasonPlusProfiles {
    pub fn new() -> ReasonPlusProfiles {
        ::std::default::Default::default()
    }

    // optional string localizedDescriptionHtml = 1;


    pub fn get_localizedDescriptionHtml(&self) -> &str {
        match self.localizedDescriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .PlusProfile plusProfile = 2;


    pub fn get_plusProfile(&self) -> &[PlusProfile] {
        &self.plusProfile
    }
}

impl ::protobuf::Message for ReasonPlusProfiles {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedDescriptionHtml)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plusProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localizedDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.plusProfile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localizedDescriptionHtml.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.plusProfile {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReasonPlusProfiles {
        ReasonPlusProfiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedDescriptionHtml",
                |m: &ReasonPlusProfiles| { &m.localizedDescriptionHtml },
                |m: &mut ReasonPlusProfiles| { &mut m.localizedDescriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "plusProfile",
                |m: &ReasonPlusProfiles| { &m.plusProfile },
                |m: &mut ReasonPlusProfiles| { &mut m.plusProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReasonPlusProfiles>(
                "ReasonPlusProfiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReasonPlusProfiles {
        static instance: ::protobuf::rt::LazyV2<ReasonPlusProfiles> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReasonPlusProfiles::new)
    }
}

impl ::protobuf::Clear for ReasonPlusProfiles {
    fn clear(&mut self) {
        self.localizedDescriptionHtml.clear();
        self.plusProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReasonPlusProfiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonPlusProfiles {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReasonReview {
    // message fields
    pub review: ::protobuf::SingularPtrField<Review>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReasonReview {
    fn default() -> &'a ReasonReview {
        <ReasonReview as ::protobuf::Message>::default_instance()
    }
}

impl ReasonReview {
    pub fn new() -> ReasonReview {
        ::std::default::Default::default()
    }

    // optional .Review review = 1;


    pub fn get_review(&self) -> &Review {
        self.review.as_ref().unwrap_or_else(|| <Review as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ReasonReview {
    fn is_initialized(&self) -> bool {
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.review)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.review.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.review.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReasonReview {
        ReasonReview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &ReasonReview| { &m.review },
                |m: &mut ReasonReview| { &mut m.review },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReasonReview>(
                "ReasonReview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReasonReview {
        static instance: ::protobuf::rt::LazyV2<ReasonReview> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReasonReview::new)
    }
}

impl ::protobuf::Clear for ReasonReview {
    fn clear(&mut self) {
        self.review.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReasonReview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonReview {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RecommendationsContainer {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecommendationsContainer {
    fn default() -> &'a RecommendationsContainer {
        <RecommendationsContainer as ::protobuf::Message>::default_instance()
    }
}

impl RecommendationsContainer {
    pub fn new() -> RecommendationsContainer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecommendationsContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecommendationsContainer {
        RecommendationsContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecommendationsContainer>(
                "RecommendationsContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecommendationsContainer {
        static instance: ::protobuf::rt::LazyV2<RecommendationsContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecommendationsContainer::new)
    }
}

impl ::protobuf::Clear for RecommendationsContainer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecommendationsContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecommendationsContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SectionMetadata {
    // message fields
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub listUrl: ::protobuf::SingularField<::std::string::String>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SectionMetadata {
    fn default() -> &'a SectionMetadata {
        <SectionMetadata as ::protobuf::Message>::default_instance()
    }
}

impl SectionMetadata {
    pub fn new() -> SectionMetadata {
        ::std::default::Default::default()
    }

    // optional string header = 1;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string listUrl = 2;


    pub fn get_listUrl(&self) -> &str {
        match self.listUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string browseUrl = 3;


    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SectionMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.listUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.listUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.browseUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SectionMetadata {
        SectionMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &SectionMetadata| { &m.header },
                |m: &mut SectionMetadata| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listUrl",
                |m: &SectionMetadata| { &m.listUrl },
                |m: &mut SectionMetadata| { &mut m.listUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "browseUrl",
                |m: &SectionMetadata| { &m.browseUrl },
                |m: &mut SectionMetadata| { &mut m.browseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &SectionMetadata| { &m.descriptionHtml },
                |m: &mut SectionMetadata| { &mut m.descriptionHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SectionMetadata>(
                "SectionMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SectionMetadata {
        static instance: ::protobuf::rt::LazyV2<SectionMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SectionMetadata::new)
    }
}

impl ::protobuf::Clear for SectionMetadata {
    fn clear(&mut self) {
        self.header.clear();
        self.listUrl.clear();
        self.browseUrl.clear();
        self.descriptionHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SectionMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SectionMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SeriesAntenna {
    // message fields
    pub seriesTitle: ::protobuf::SingularField<::std::string::String>,
    pub seriesSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeTitle: ::protobuf::SingularField<::std::string::String>,
    pub episodeSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub sectionTracks: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionAlbums: ::protobuf::SingularPtrField<SectionMetadata>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeriesAntenna {
    fn default() -> &'a SeriesAntenna {
        <SeriesAntenna as ::protobuf::Message>::default_instance()
    }
}

impl SeriesAntenna {
    pub fn new() -> SeriesAntenna {
        ::std::default::Default::default()
    }

    // optional string seriesTitle = 1;


    pub fn get_seriesTitle(&self) -> &str {
        match self.seriesTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string seriesSubtitle = 2;


    pub fn get_seriesSubtitle(&self) -> &str {
        match self.seriesSubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string episodeTitle = 3;


    pub fn get_episodeTitle(&self) -> &str {
        match self.episodeTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string episodeSubtitle = 4;


    pub fn get_episodeSubtitle(&self) -> &str {
        match self.episodeSubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string colorThemeArgb = 5;


    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SectionMetadata sectionTracks = 6;


    pub fn get_sectionTracks(&self) -> &SectionMetadata {
        self.sectionTracks.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionAlbums = 7;


    pub fn get_sectionAlbums(&self) -> &SectionMetadata {
        self.sectionAlbums.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SeriesAntenna {
    fn is_initialized(&self) -> bool {
        for v in &self.sectionTracks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionAlbums {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.seriesSubtitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.episodeSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionTracks)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionAlbums)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seriesTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.seriesSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.episodeTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.episodeSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.sectionTracks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionAlbums.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seriesTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.seriesSubtitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.episodeTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.episodeSubtitle.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.sectionTracks.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionAlbums.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeriesAntenna {
        SeriesAntenna::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seriesTitle",
                |m: &SeriesAntenna| { &m.seriesTitle },
                |m: &mut SeriesAntenna| { &mut m.seriesTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "seriesSubtitle",
                |m: &SeriesAntenna| { &m.seriesSubtitle },
                |m: &mut SeriesAntenna| { &mut m.seriesSubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "episodeTitle",
                |m: &SeriesAntenna| { &m.episodeTitle },
                |m: &mut SeriesAntenna| { &mut m.episodeTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "episodeSubtitle",
                |m: &SeriesAntenna| { &m.episodeSubtitle },
                |m: &mut SeriesAntenna| { &mut m.episodeSubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorThemeArgb",
                |m: &SeriesAntenna| { &m.colorThemeArgb },
                |m: &mut SeriesAntenna| { &mut m.colorThemeArgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionTracks",
                |m: &SeriesAntenna| { &m.sectionTracks },
                |m: &mut SeriesAntenna| { &mut m.sectionTracks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionAlbums",
                |m: &SeriesAntenna| { &m.sectionAlbums },
                |m: &mut SeriesAntenna| { &mut m.sectionAlbums },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeriesAntenna>(
                "SeriesAntenna",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeriesAntenna {
        static instance: ::protobuf::rt::LazyV2<SeriesAntenna> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeriesAntenna::new)
    }
}

impl ::protobuf::Clear for SeriesAntenna {
    fn clear(&mut self) {
        self.seriesTitle.clear();
        self.seriesSubtitle.clear();
        self.episodeTitle.clear();
        self.episodeSubtitle.clear();
        self.colorThemeArgb.clear();
        self.sectionTracks.clear();
        self.sectionAlbums.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeriesAntenna {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeriesAntenna {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SuggestionReasons {
    // message fields
    pub reason: ::protobuf::RepeatedField<Reason>,
    pub neutralDismissal: ::protobuf::SingularPtrField<Dismissal>,
    pub positiveDismissal: ::protobuf::SingularPtrField<Dismissal>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuggestionReasons {
    fn default() -> &'a SuggestionReasons {
        <SuggestionReasons as ::protobuf::Message>::default_instance()
    }
}

impl SuggestionReasons {
    pub fn new() -> SuggestionReasons {
        ::std::default::Default::default()
    }

    // repeated .Reason reason = 2;


    pub fn get_reason(&self) -> &[Reason] {
        &self.reason
    }

    // optional .Dismissal neutralDismissal = 4;


    pub fn get_neutralDismissal(&self) -> &Dismissal {
        self.neutralDismissal.as_ref().unwrap_or_else(|| <Dismissal as ::protobuf::Message>::default_instance())
    }

    // optional .Dismissal positiveDismissal = 5;


    pub fn get_positiveDismissal(&self) -> &Dismissal {
        self.positiveDismissal.as_ref().unwrap_or_else(|| <Dismissal as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SuggestionReasons {
    fn is_initialized(&self) -> bool {
        for v in &self.reason {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.neutralDismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.positiveDismissal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.neutralDismissal)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.positiveDismissal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reason {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.neutralDismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.positiveDismissal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reason {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.neutralDismissal.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.positiveDismissal.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SuggestionReasons {
        SuggestionReasons::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Reason>>(
                "reason",
                |m: &SuggestionReasons| { &m.reason },
                |m: &mut SuggestionReasons| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>>(
                "neutralDismissal",
                |m: &SuggestionReasons| { &m.neutralDismissal },
                |m: &mut SuggestionReasons| { &mut m.neutralDismissal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dismissal>>(
                "positiveDismissal",
                |m: &SuggestionReasons| { &m.positiveDismissal },
                |m: &mut SuggestionReasons| { &mut m.positiveDismissal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SuggestionReasons>(
                "SuggestionReasons",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SuggestionReasons {
        static instance: ::protobuf::rt::LazyV2<SuggestionReasons> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SuggestionReasons::new)
    }
}

impl ::protobuf::Clear for SuggestionReasons {
    fn clear(&mut self) {
        self.reason.clear();
        self.neutralDismissal.clear();
        self.positiveDismissal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuggestionReasons {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuggestionReasons {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Template {
    // message fields
    pub seriesAntenna: ::protobuf::SingularPtrField<SeriesAntenna>,
    pub tileGraphic2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphic4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphicColoredTitle2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileGraphicUpperLeftTitle2X1: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileDetailsReflectedGraphic2X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub tileFourBlock4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub containerWithBanner: ::protobuf::SingularPtrField<ContainerWithBanner>,
    pub dealOfTheDay: ::protobuf::SingularPtrField<DealOfTheDay>,
    pub tileGraphicColoredTitle4X2: ::protobuf::SingularPtrField<TileTemplate>,
    pub editorialSeriesContainer: ::protobuf::SingularPtrField<EditorialSeriesContainer>,
    pub recommendationsContainer: ::protobuf::SingularPtrField<RecommendationsContainer>,
    pub nextBanner: ::protobuf::SingularPtrField<NextBanner>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Template {
    fn default() -> &'a Template {
        <Template as ::protobuf::Message>::default_instance()
    }
}

impl Template {
    pub fn new() -> Template {
        ::std::default::Default::default()
    }

    // optional .SeriesAntenna seriesAntenna = 1;


    pub fn get_seriesAntenna(&self) -> &SeriesAntenna {
        self.seriesAntenna.as_ref().unwrap_or_else(|| <SeriesAntenna as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileGraphic2X1 = 2;


    pub fn get_tileGraphic2X1(&self) -> &TileTemplate {
        self.tileGraphic2X1.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileGraphic4X2 = 3;


    pub fn get_tileGraphic4X2(&self) -> &TileTemplate {
        self.tileGraphic4X2.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileGraphicColoredTitle2X1 = 4;


    pub fn get_tileGraphicColoredTitle2X1(&self) -> &TileTemplate {
        self.tileGraphicColoredTitle2X1.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileGraphicUpperLeftTitle2X1 = 5;


    pub fn get_tileGraphicUpperLeftTitle2X1(&self) -> &TileTemplate {
        self.tileGraphicUpperLeftTitle2X1.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileDetailsReflectedGraphic2X2 = 6;


    pub fn get_tileDetailsReflectedGraphic2X2(&self) -> &TileTemplate {
        self.tileDetailsReflectedGraphic2X2.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileFourBlock4X2 = 7;


    pub fn get_tileFourBlock4X2(&self) -> &TileTemplate {
        self.tileFourBlock4X2.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .ContainerWithBanner containerWithBanner = 8;


    pub fn get_containerWithBanner(&self) -> &ContainerWithBanner {
        self.containerWithBanner.as_ref().unwrap_or_else(|| <ContainerWithBanner as ::protobuf::Message>::default_instance())
    }

    // optional .DealOfTheDay dealOfTheDay = 9;


    pub fn get_dealOfTheDay(&self) -> &DealOfTheDay {
        self.dealOfTheDay.as_ref().unwrap_or_else(|| <DealOfTheDay as ::protobuf::Message>::default_instance())
    }

    // optional .TileTemplate tileGraphicColoredTitle4X2 = 10;


    pub fn get_tileGraphicColoredTitle4X2(&self) -> &TileTemplate {
        self.tileGraphicColoredTitle4X2.as_ref().unwrap_or_else(|| <TileTemplate as ::protobuf::Message>::default_instance())
    }

    // optional .EditorialSeriesContainer editorialSeriesContainer = 11;


    pub fn get_editorialSeriesContainer(&self) -> &EditorialSeriesContainer {
        self.editorialSeriesContainer.as_ref().unwrap_or_else(|| <EditorialSeriesContainer as ::protobuf::Message>::default_instance())
    }

    // optional .RecommendationsContainer recommendationsContainer = 12;


    pub fn get_recommendationsContainer(&self) -> &RecommendationsContainer {
        self.recommendationsContainer.as_ref().unwrap_or_else(|| <RecommendationsContainer as ::protobuf::Message>::default_instance())
    }

    // optional .NextBanner nextBanner = 13;


    pub fn get_nextBanner(&self) -> &NextBanner {
        self.nextBanner.as_ref().unwrap_or_else(|| <NextBanner as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Template {
    fn is_initialized(&self) -> bool {
        for v in &self.seriesAntenna {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphic2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphic4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicColoredTitle2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicUpperLeftTitle2X1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileDetailsReflectedGraphic2X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileFourBlock4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerWithBanner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dealOfTheDay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tileGraphicColoredTitle4X2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.editorialSeriesContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recommendationsContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nextBanner {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seriesAntenna)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileGraphic2X1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileGraphic4X2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileGraphicColoredTitle2X1)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileGraphicUpperLeftTitle2X1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileDetailsReflectedGraphic2X2)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileFourBlock4X2)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.containerWithBanner)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dealOfTheDay)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tileGraphicColoredTitle4X2)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.editorialSeriesContainer)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recommendationsContainer)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nextBanner)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seriesAntenna.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileGraphic2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileGraphic4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileGraphicColoredTitle2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileGraphicUpperLeftTitle2X1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileDetailsReflectedGraphic2X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileFourBlock4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.containerWithBanner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dealOfTheDay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tileGraphicColoredTitle4X2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.editorialSeriesContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recommendationsContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nextBanner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seriesAntenna.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileGraphic2X1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileGraphic4X2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileGraphicColoredTitle2X1.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileGraphicUpperLeftTitle2X1.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileDetailsReflectedGraphic2X2.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileFourBlock4X2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.containerWithBanner.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dealOfTheDay.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tileGraphicColoredTitle4X2.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.editorialSeriesContainer.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recommendationsContainer.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nextBanner.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Template {
        Template::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SeriesAntenna>>(
                "seriesAntenna",
                |m: &Template| { &m.seriesAntenna },
                |m: &mut Template| { &mut m.seriesAntenna },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileGraphic2X1",
                |m: &Template| { &m.tileGraphic2X1 },
                |m: &mut Template| { &mut m.tileGraphic2X1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileGraphic4X2",
                |m: &Template| { &m.tileGraphic4X2 },
                |m: &mut Template| { &mut m.tileGraphic4X2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileGraphicColoredTitle2X1",
                |m: &Template| { &m.tileGraphicColoredTitle2X1 },
                |m: &mut Template| { &mut m.tileGraphicColoredTitle2X1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileGraphicUpperLeftTitle2X1",
                |m: &Template| { &m.tileGraphicUpperLeftTitle2X1 },
                |m: &mut Template| { &mut m.tileGraphicUpperLeftTitle2X1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileDetailsReflectedGraphic2X2",
                |m: &Template| { &m.tileDetailsReflectedGraphic2X2 },
                |m: &mut Template| { &mut m.tileDetailsReflectedGraphic2X2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileFourBlock4X2",
                |m: &Template| { &m.tileFourBlock4X2 },
                |m: &mut Template| { &mut m.tileFourBlock4X2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerWithBanner>>(
                "containerWithBanner",
                |m: &Template| { &m.containerWithBanner },
                |m: &mut Template| { &mut m.containerWithBanner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DealOfTheDay>>(
                "dealOfTheDay",
                |m: &Template| { &m.dealOfTheDay },
                |m: &mut Template| { &mut m.dealOfTheDay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileTemplate>>(
                "tileGraphicColoredTitle4X2",
                |m: &Template| { &m.tileGraphicColoredTitle4X2 },
                |m: &mut Template| { &mut m.tileGraphicColoredTitle4X2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EditorialSeriesContainer>>(
                "editorialSeriesContainer",
                |m: &Template| { &m.editorialSeriesContainer },
                |m: &mut Template| { &mut m.editorialSeriesContainer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecommendationsContainer>>(
                "recommendationsContainer",
                |m: &Template| { &m.recommendationsContainer },
                |m: &mut Template| { &mut m.recommendationsContainer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NextBanner>>(
                "nextBanner",
                |m: &Template| { &m.nextBanner },
                |m: &mut Template| { &mut m.nextBanner },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Template>(
                "Template",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Template {
        static instance: ::protobuf::rt::LazyV2<Template> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Template::new)
    }
}

impl ::protobuf::Clear for Template {
    fn clear(&mut self) {
        self.seriesAntenna.clear();
        self.tileGraphic2X1.clear();
        self.tileGraphic4X2.clear();
        self.tileGraphicColoredTitle2X1.clear();
        self.tileGraphicUpperLeftTitle2X1.clear();
        self.tileDetailsReflectedGraphic2X2.clear();
        self.tileFourBlock4X2.clear();
        self.containerWithBanner.clear();
        self.dealOfTheDay.clear();
        self.tileGraphicColoredTitle4X2.clear();
        self.editorialSeriesContainer.clear();
        self.recommendationsContainer.clear();
        self.nextBanner.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Template {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Template {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TileTemplate {
    // message fields
    pub colorThemeArgb: ::protobuf::SingularField<::std::string::String>,
    pub colorTextArgb: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TileTemplate {
    fn default() -> &'a TileTemplate {
        <TileTemplate as ::protobuf::Message>::default_instance()
    }
}

impl TileTemplate {
    pub fn new() -> TileTemplate {
        ::std::default::Default::default()
    }

    // optional string colorThemeArgb = 1;


    pub fn get_colorThemeArgb(&self) -> &str {
        match self.colorThemeArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string colorTextArgb = 2;


    pub fn get_colorTextArgb(&self) -> &str {
        match self.colorTextArgb.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TileTemplate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorThemeArgb)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.colorTextArgb)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.colorTextArgb.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.colorThemeArgb.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.colorTextArgb.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TileTemplate {
        TileTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorThemeArgb",
                |m: &TileTemplate| { &m.colorThemeArgb },
                |m: &mut TileTemplate| { &mut m.colorThemeArgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "colorTextArgb",
                |m: &TileTemplate| { &m.colorTextArgb },
                |m: &mut TileTemplate| { &mut m.colorTextArgb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TileTemplate>(
                "TileTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TileTemplate {
        static instance: ::protobuf::rt::LazyV2<TileTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TileTemplate::new)
    }
}

impl ::protobuf::Clear for TileTemplate {
    fn clear(&mut self) {
        self.colorThemeArgb.clear();
        self.colorTextArgb.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TileTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TileTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoSnippet {
    // message fields
    pub image: ::protobuf::RepeatedField<Image>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoSnippet {
    fn default() -> &'a VideoSnippet {
        <VideoSnippet as ::protobuf::Message>::default_instance()
    }
}

impl VideoSnippet {
    pub fn new() -> VideoSnippet {
        ::std::default::Default::default()
    }

    // repeated .Image image = 1;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string description = 3;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoSnippet {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.image {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoSnippet {
        VideoSnippet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &VideoSnippet| { &m.image },
                |m: &mut VideoSnippet| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &VideoSnippet| { &m.title },
                |m: &mut VideoSnippet| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &VideoSnippet| { &m.description },
                |m: &mut VideoSnippet| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoSnippet>(
                "VideoSnippet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoSnippet {
        static instance: ::protobuf::rt::LazyV2<VideoSnippet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoSnippet::new)
    }
}

impl ::protobuf::Clear for VideoSnippet {
    fn clear(&mut self) {
        self.image.clear();
        self.title.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoSnippet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoSnippet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Warning {
    // message fields
    pub localizedMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Warning {
    fn default() -> &'a Warning {
        <Warning as ::protobuf::Message>::default_instance()
    }
}

impl Warning {
    pub fn new() -> Warning {
        ::std::default::Default::default()
    }

    // optional string localizedMessage = 1;


    pub fn get_localizedMessage(&self) -> &str {
        match self.localizedMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Warning {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localizedMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localizedMessage.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Warning {
        Warning::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedMessage",
                |m: &Warning| { &m.localizedMessage },
                |m: &mut Warning| { &mut m.localizedMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Warning>(
                "Warning",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Warning {
        static instance: ::protobuf::rt::LazyV2<Warning> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Warning::new)
    }
}

impl ::protobuf::Clear for Warning {
    fn clear(&mut self) {
        self.localizedMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Warning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Warning {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AlbumDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlbumDetails {
    fn default() -> &'a AlbumDetails {
        <AlbumDetails as ::protobuf::Message>::default_instance()
    }
}

impl AlbumDetails {
    pub fn new() -> AlbumDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .MusicDetails details = 2;


    pub fn get_details(&self) -> &MusicDetails {
        self.details.as_ref().unwrap_or_else(|| <MusicDetails as ::protobuf::Message>::default_instance())
    }

    // optional .ArtistDetails displayArtist = 3;


    pub fn get_displayArtist(&self) -> &ArtistDetails {
        self.displayArtist.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AlbumDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.displayArtist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlbumDetails {
        AlbumDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AlbumDetails| { &m.name },
                |m: &mut AlbumDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>>(
                "details",
                |m: &AlbumDetails| { &m.details },
                |m: &mut AlbumDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "displayArtist",
                |m: &AlbumDetails| { &m.displayArtist },
                |m: &mut AlbumDetails| { &mut m.displayArtist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlbumDetails>(
                "AlbumDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlbumDetails {
        static instance: ::protobuf::rt::LazyV2<AlbumDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlbumDetails::new)
    }
}

impl ::protobuf::Clear for AlbumDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.displayArtist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlbumDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlbumDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Dependency {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub minVersionCode: ::std::option::Option<i32>,
    pub versionCodeMask: ::std::option::Option<i32>,
    pub skipPermissions: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dependency {
    fn default() -> &'a Dependency {
        <Dependency as ::protobuf::Message>::default_instance()
    }
}

impl Dependency {
    pub fn new() -> Dependency {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 minVersionCode = 2;


    pub fn get_minVersionCode(&self) -> i32 {
        self.minVersionCode.unwrap_or(0)
    }

    // optional int32 versionCodeMask = 3;


    pub fn get_versionCodeMask(&self) -> i32 {
        self.versionCodeMask.unwrap_or(0)
    }

    // optional bool skipPermissions = 4;


    pub fn get_skipPermissions(&self) -> bool {
        self.skipPermissions.unwrap_or(false)
    }
}

impl ::protobuf::Message for Dependency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minVersionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCodeMask = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skipPermissions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.minVersionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCodeMask {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skipPermissions {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.minVersionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.versionCodeMask {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.skipPermissions {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dependency {
        Dependency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &Dependency| { &m.packageName },
                |m: &mut Dependency| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minVersionCode",
                |m: &Dependency| { &m.minVersionCode },
                |m: &mut Dependency| { &mut m.minVersionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCodeMask",
                |m: &Dependency| { &m.versionCodeMask },
                |m: &mut Dependency| { &mut m.versionCodeMask },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skipPermissions",
                |m: &Dependency| { &m.skipPermissions },
                |m: &mut Dependency| { &mut m.skipPermissions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dependency>(
                "Dependency",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dependency {
        static instance: ::protobuf::rt::LazyV2<Dependency> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dependency::new)
    }
}

impl ::protobuf::Clear for Dependency {
    fn clear(&mut self) {
        self.packageName.clear();
        self.minVersionCode = ::std::option::Option::None;
        self.versionCodeMask = ::std::option::Option::None;
        self.skipPermissions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dependency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InstallDetails {
    // message fields
    pub installLocation: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub dependency: ::protobuf::SingularPtrField<Dependency>,
    pub targetSdkVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallDetails {
    fn default() -> &'a InstallDetails {
        <InstallDetails as ::protobuf::Message>::default_instance()
    }
}

impl InstallDetails {
    pub fn new() -> InstallDetails {
        ::std::default::Default::default()
    }

    // optional int32 installLocation = 1;


    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }

    // optional int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional .Dependency dependency = 3;


    pub fn get_dependency(&self) -> &Dependency {
        self.dependency.as_ref().unwrap_or_else(|| <Dependency as ::protobuf::Message>::default_instance())
    }

    // optional int32 targetSdkVersion = 4;


    pub fn get_targetSdkVersion(&self) -> i32 {
        self.targetSdkVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InstallDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.dependency {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dependency)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetSdkVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dependency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.targetSdkVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.installLocation {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.dependency.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.targetSdkVersion {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallDetails {
        InstallDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "installLocation",
                |m: &InstallDetails| { &m.installLocation },
                |m: &mut InstallDetails| { &mut m.installLocation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &InstallDetails| { &m.size },
                |m: &mut InstallDetails| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependency>>(
                "dependency",
                |m: &InstallDetails| { &m.dependency },
                |m: &mut InstallDetails| { &mut m.dependency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "targetSdkVersion",
                |m: &InstallDetails| { &m.targetSdkVersion },
                |m: &mut InstallDetails| { &mut m.targetSdkVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstallDetails>(
                "InstallDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstallDetails {
        static instance: ::protobuf::rt::LazyV2<InstallDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallDetails::new)
    }
}

impl ::protobuf::Clear for InstallDetails {
    fn clear(&mut self) {
        self.installLocation = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.dependency.clear();
        self.targetSdkVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstallDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppDetails {
    // message fields
    pub developerName: ::protobuf::SingularField<::std::string::String>,
    pub majorVersionNumber: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub versionString: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub appCategory: ::protobuf::RepeatedField<::std::string::String>,
    pub contentRating: ::std::option::Option<i32>,
    pub installationSize: ::std::option::Option<i64>,
    pub permission: ::protobuf::RepeatedField<::std::string::String>,
    pub developerEmail: ::protobuf::SingularField<::std::string::String>,
    pub developerWebsite: ::protobuf::SingularField<::std::string::String>,
    pub numDownloads: ::protobuf::SingularField<::std::string::String>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub recentChangesHtml: ::protobuf::SingularField<::std::string::String>,
    pub uploadDate: ::protobuf::SingularField<::std::string::String>,
    pub file: ::protobuf::RepeatedField<FileMetadata>,
    pub appType: ::protobuf::SingularField<::std::string::String>,
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    pub variesByAccount: ::std::option::Option<bool>,
    pub certificateSet: ::protobuf::RepeatedField<CertificateSet>,
    pub autoAcquireFreeAppIfHigherVersionAvailableTag: ::protobuf::RepeatedField<::std::string::String>,
    pub declaresIab: ::std::option::Option<bool>,
    pub splitId: ::protobuf::RepeatedField<::std::string::String>,
    pub gamepadRequired: ::std::option::Option<bool>,
    pub externallyHosted: ::std::option::Option<bool>,
    pub everExternallyHosted: ::std::option::Option<bool>,
    pub installNotes: ::protobuf::SingularField<::std::string::String>,
    pub installLocation: ::std::option::Option<i32>,
    pub targetSdkVersion: ::std::option::Option<i32>,
    pub hasPreregistrationPromoCode: ::protobuf::SingularField<::std::string::String>,
    pub installDetails: ::protobuf::SingularPtrField<InstallDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDetails {
    fn default() -> &'a AppDetails {
        <AppDetails as ::protobuf::Message>::default_instance()
    }
}

impl AppDetails {
    pub fn new() -> AppDetails {
        ::std::default::Default::default()
    }

    // optional string developerName = 1;


    pub fn get_developerName(&self) -> &str {
        match self.developerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 majorVersionNumber = 2;


    pub fn get_majorVersionNumber(&self) -> i32 {
        self.majorVersionNumber.unwrap_or(0)
    }

    // optional int32 versionCode = 3;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string versionString = 4;


    pub fn get_versionString(&self) -> &str {
        match self.versionString.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string appCategory = 7;


    pub fn get_appCategory(&self) -> &[::std::string::String] {
        &self.appCategory
    }

    // optional int32 contentRating = 8;


    pub fn get_contentRating(&self) -> i32 {
        self.contentRating.unwrap_or(0)
    }

    // optional int64 installationSize = 9;


    pub fn get_installationSize(&self) -> i64 {
        self.installationSize.unwrap_or(0)
    }

    // repeated string permission = 10;


    pub fn get_permission(&self) -> &[::std::string::String] {
        &self.permission
    }

    // optional string developerEmail = 11;


    pub fn get_developerEmail(&self) -> &str {
        match self.developerEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string developerWebsite = 12;


    pub fn get_developerWebsite(&self) -> &str {
        match self.developerWebsite.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string numDownloads = 13;


    pub fn get_numDownloads(&self) -> &str {
        match self.numDownloads.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string packageName = 14;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string recentChangesHtml = 15;


    pub fn get_recentChangesHtml(&self) -> &str {
        match self.recentChangesHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string uploadDate = 16;


    pub fn get_uploadDate(&self) -> &str {
        match self.uploadDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .FileMetadata file = 17;


    pub fn get_file(&self) -> &[FileMetadata] {
        &self.file
    }

    // optional string appType = 18;


    pub fn get_appType(&self) -> &str {
        match self.appType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string certificateHash = 19;


    pub fn get_certificateHash(&self) -> &[::std::string::String] {
        &self.certificateHash
    }

    // optional bool variesByAccount = 21;


    pub fn get_variesByAccount(&self) -> bool {
        self.variesByAccount.unwrap_or(false)
    }

    // repeated .CertificateSet certificateSet = 22;


    pub fn get_certificateSet(&self) -> &[CertificateSet] {
        &self.certificateSet
    }

    // repeated string autoAcquireFreeAppIfHigherVersionAvailableTag = 23;


    pub fn get_autoAcquireFreeAppIfHigherVersionAvailableTag(&self) -> &[::std::string::String] {
        &self.autoAcquireFreeAppIfHigherVersionAvailableTag
    }

    // optional bool declaresIab = 24;


    pub fn get_declaresIab(&self) -> bool {
        self.declaresIab.unwrap_or(false)
    }

    // repeated string splitId = 25;


    pub fn get_splitId(&self) -> &[::std::string::String] {
        &self.splitId
    }

    // optional bool gamepadRequired = 26;


    pub fn get_gamepadRequired(&self) -> bool {
        self.gamepadRequired.unwrap_or(false)
    }

    // optional bool externallyHosted = 27;


    pub fn get_externallyHosted(&self) -> bool {
        self.externallyHosted.unwrap_or(false)
    }

    // optional bool everExternallyHosted = 28;


    pub fn get_everExternallyHosted(&self) -> bool {
        self.everExternallyHosted.unwrap_or(false)
    }

    // optional string installNotes = 30;


    pub fn get_installNotes(&self) -> &str {
        match self.installNotes.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 installLocation = 31;


    pub fn get_installLocation(&self) -> i32 {
        self.installLocation.unwrap_or(0)
    }

    // optional int32 targetSdkVersion = 32;


    pub fn get_targetSdkVersion(&self) -> i32 {
        self.targetSdkVersion.unwrap_or(0)
    }

    // optional string hasPreregistrationPromoCode = 33;


    pub fn get_hasPreregistrationPromoCode(&self) -> &str {
        match self.hasPreregistrationPromoCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .InstallDetails installDetails = 34;


    pub fn get_installDetails(&self) -> &InstallDetails {
        self.installDetails.as_ref().unwrap_or_else(|| <InstallDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AppDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.certificateSet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.installDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.majorVersionNumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.versionString)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.appCategory)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRating = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.installationSize = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.permission)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerEmail)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerWebsite)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.numDownloads)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChangesHtml)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDate)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appType)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.variesByAccount = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.certificateSet)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.autoAcquireFreeAppIfHigherVersionAvailableTag)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.declaresIab = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.splitId)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gamepadRequired = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.externallyHosted = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.everExternallyHosted = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.installNotes)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.installLocation = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetSdkVersion = ::std::option::Option::Some(tmp);
                },
                33 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hasPreregistrationPromoCode)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.installDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.developerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.majorVersionNumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.versionString.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.appCategory {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.contentRating {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installationSize {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.permission {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.developerEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.developerWebsite.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.numDownloads.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.recentChangesHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.uploadDate.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.appType.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(v) = self.variesByAccount {
            my_size += 3;
        }
        for value in &self.certificateSet {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.autoAcquireFreeAppIfHigherVersionAvailableTag {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        if let Some(v) = self.declaresIab {
            my_size += 3;
        }
        for value in &self.splitId {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        if let Some(v) = self.gamepadRequired {
            my_size += 3;
        }
        if let Some(v) = self.externallyHosted {
            my_size += 3;
        }
        if let Some(v) = self.everExternallyHosted {
            my_size += 3;
        }
        if let Some(ref v) = self.installNotes.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.installLocation {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.targetSdkVersion {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hasPreregistrationPromoCode.as_ref() {
            my_size += ::protobuf::rt::string_size(33, &v);
        }
        if let Some(ref v) = self.installDetails.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.developerName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.majorVersionNumber {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.versionString.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.appCategory {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.contentRating {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.installationSize {
            os.write_int64(9, v)?;
        }
        for v in &self.permission {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.developerEmail.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.developerWebsite.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.numDownloads.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.recentChangesHtml.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.uploadDate.as_ref() {
            os.write_string(16, &v)?;
        }
        for v in &self.file {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.appType.as_ref() {
            os.write_string(18, &v)?;
        }
        for v in &self.certificateHash {
            os.write_string(19, &v)?;
        };
        if let Some(v) = self.variesByAccount {
            os.write_bool(21, v)?;
        }
        for v in &self.certificateSet {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.autoAcquireFreeAppIfHigherVersionAvailableTag {
            os.write_string(23, &v)?;
        };
        if let Some(v) = self.declaresIab {
            os.write_bool(24, v)?;
        }
        for v in &self.splitId {
            os.write_string(25, &v)?;
        };
        if let Some(v) = self.gamepadRequired {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.externallyHosted {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.everExternallyHosted {
            os.write_bool(28, v)?;
        }
        if let Some(ref v) = self.installNotes.as_ref() {
            os.write_string(30, &v)?;
        }
        if let Some(v) = self.installLocation {
            os.write_int32(31, v)?;
        }
        if let Some(v) = self.targetSdkVersion {
            os.write_int32(32, v)?;
        }
        if let Some(ref v) = self.hasPreregistrationPromoCode.as_ref() {
            os.write_string(33, &v)?;
        }
        if let Some(ref v) = self.installDetails.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDetails {
        AppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerName",
                |m: &AppDetails| { &m.developerName },
                |m: &mut AppDetails| { &mut m.developerName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "majorVersionNumber",
                |m: &AppDetails| { &m.majorVersionNumber },
                |m: &mut AppDetails| { &mut m.majorVersionNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AppDetails| { &m.versionCode },
                |m: &mut AppDetails| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "versionString",
                |m: &AppDetails| { &m.versionString },
                |m: &mut AppDetails| { &mut m.versionString },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &AppDetails| { &m.title },
                |m: &mut AppDetails| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appCategory",
                |m: &AppDetails| { &m.appCategory },
                |m: &mut AppDetails| { &mut m.appCategory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "contentRating",
                |m: &AppDetails| { &m.contentRating },
                |m: &mut AppDetails| { &mut m.contentRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "installationSize",
                |m: &AppDetails| { &m.installationSize },
                |m: &mut AppDetails| { &mut m.installationSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permission",
                |m: &AppDetails| { &m.permission },
                |m: &mut AppDetails| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerEmail",
                |m: &AppDetails| { &m.developerEmail },
                |m: &mut AppDetails| { &mut m.developerEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerWebsite",
                |m: &AppDetails| { &m.developerWebsite },
                |m: &mut AppDetails| { &mut m.developerWebsite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "numDownloads",
                |m: &AppDetails| { &m.numDownloads },
                |m: &mut AppDetails| { &mut m.numDownloads },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &AppDetails| { &m.packageName },
                |m: &mut AppDetails| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recentChangesHtml",
                |m: &AppDetails| { &m.recentChangesHtml },
                |m: &mut AppDetails| { &mut m.recentChangesHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uploadDate",
                |m: &AppDetails| { &m.uploadDate },
                |m: &mut AppDetails| { &mut m.uploadDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadata>>(
                "file",
                |m: &AppDetails| { &m.file },
                |m: &mut AppDetails| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appType",
                |m: &AppDetails| { &m.appType },
                |m: &mut AppDetails| { &mut m.appType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &AppDetails| { &m.certificateHash },
                |m: &mut AppDetails| { &mut m.certificateHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "variesByAccount",
                |m: &AppDetails| { &m.variesByAccount },
                |m: &mut AppDetails| { &mut m.variesByAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CertificateSet>>(
                "certificateSet",
                |m: &AppDetails| { &m.certificateSet },
                |m: &mut AppDetails| { &mut m.certificateSet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "autoAcquireFreeAppIfHigherVersionAvailableTag",
                |m: &AppDetails| { &m.autoAcquireFreeAppIfHigherVersionAvailableTag },
                |m: &mut AppDetails| { &mut m.autoAcquireFreeAppIfHigherVersionAvailableTag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "declaresIab",
                |m: &AppDetails| { &m.declaresIab },
                |m: &mut AppDetails| { &mut m.declaresIab },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "splitId",
                |m: &AppDetails| { &m.splitId },
                |m: &mut AppDetails| { &mut m.splitId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "gamepadRequired",
                |m: &AppDetails| { &m.gamepadRequired },
                |m: &mut AppDetails| { &mut m.gamepadRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "externallyHosted",
                |m: &AppDetails| { &m.externallyHosted },
                |m: &mut AppDetails| { &mut m.externallyHosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "everExternallyHosted",
                |m: &AppDetails| { &m.everExternallyHosted },
                |m: &mut AppDetails| { &mut m.everExternallyHosted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "installNotes",
                |m: &AppDetails| { &m.installNotes },
                |m: &mut AppDetails| { &mut m.installNotes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "installLocation",
                |m: &AppDetails| { &m.installLocation },
                |m: &mut AppDetails| { &mut m.installLocation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "targetSdkVersion",
                |m: &AppDetails| { &m.targetSdkVersion },
                |m: &mut AppDetails| { &mut m.targetSdkVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hasPreregistrationPromoCode",
                |m: &AppDetails| { &m.hasPreregistrationPromoCode },
                |m: &mut AppDetails| { &mut m.hasPreregistrationPromoCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstallDetails>>(
                "installDetails",
                |m: &AppDetails| { &m.installDetails },
                |m: &mut AppDetails| { &mut m.installDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDetails>(
                "AppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDetails {
        static instance: ::protobuf::rt::LazyV2<AppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDetails::new)
    }
}

impl ::protobuf::Clear for AppDetails {
    fn clear(&mut self) {
        self.developerName.clear();
        self.majorVersionNumber = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.versionString.clear();
        self.title.clear();
        self.appCategory.clear();
        self.contentRating = ::std::option::Option::None;
        self.installationSize = ::std::option::Option::None;
        self.permission.clear();
        self.developerEmail.clear();
        self.developerWebsite.clear();
        self.numDownloads.clear();
        self.packageName.clear();
        self.recentChangesHtml.clear();
        self.uploadDate.clear();
        self.file.clear();
        self.appType.clear();
        self.certificateHash.clear();
        self.variesByAccount = ::std::option::Option::None;
        self.certificateSet.clear();
        self.autoAcquireFreeAppIfHigherVersionAvailableTag.clear();
        self.declaresIab = ::std::option::Option::None;
        self.splitId.clear();
        self.gamepadRequired = ::std::option::Option::None;
        self.externallyHosted = ::std::option::Option::None;
        self.everExternallyHosted = ::std::option::Option::None;
        self.installNotes.clear();
        self.installLocation = ::std::option::Option::None;
        self.targetSdkVersion = ::std::option::Option::None;
        self.hasPreregistrationPromoCode.clear();
        self.installDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CertificateSet {
    // message fields
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CertificateSet {
    fn default() -> &'a CertificateSet {
        <CertificateSet as ::protobuf::Message>::default_instance()
    }
}

impl CertificateSet {
    pub fn new() -> CertificateSet {
        ::std::default::Default::default()
    }

    // repeated string certificateHash = 1;


    pub fn get_certificateHash(&self) -> &[::std::string::String] {
        &self.certificateHash
    }
}

impl ::protobuf::Message for CertificateSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.certificateHash {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CertificateSet {
        CertificateSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &CertificateSet| { &m.certificateHash },
                |m: &mut CertificateSet| { &mut m.certificateHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CertificateSet>(
                "CertificateSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CertificateSet {
        static instance: ::protobuf::rt::LazyV2<CertificateSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CertificateSet::new)
    }
}

impl ::protobuf::Clear for CertificateSet {
    fn clear(&mut self) {
        self.certificateHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CertificateSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertificateSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppPermission {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub permissionRequired: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppPermission {
    fn default() -> &'a AppPermission {
        <AppPermission as ::protobuf::Message>::default_instance()
    }
}

impl AppPermission {
    pub fn new() -> AppPermission {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool permissionRequired = 2;


    pub fn get_permissionRequired(&self) -> bool {
        self.permissionRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for AppPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.permissionRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.permissionRequired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.permissionRequired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppPermission {
        AppPermission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &AppPermission| { &m.key },
                |m: &mut AppPermission| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "permissionRequired",
                |m: &AppPermission| { &m.permissionRequired },
                |m: &mut AppPermission| { &mut m.permissionRequired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppPermission>(
                "AppPermission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppPermission {
        static instance: ::protobuf::rt::LazyV2<AppPermission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppPermission::new)
    }
}

impl ::protobuf::Clear for AppPermission {
    fn clear(&mut self) {
        self.key.clear();
        self.permissionRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ArtistDetails {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub externalLinks: ::protobuf::SingularPtrField<ArtistExternalLinks>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtistDetails {
    fn default() -> &'a ArtistDetails {
        <ArtistDetails as ::protobuf::Message>::default_instance()
    }
}

impl ArtistDetails {
    pub fn new() -> ArtistDetails {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ArtistExternalLinks externalLinks = 3;


    pub fn get_externalLinks(&self) -> &ArtistExternalLinks {
        self.externalLinks.as_ref().unwrap_or_else(|| <ArtistExternalLinks as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ArtistDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.externalLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.externalLinks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.externalLinks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.externalLinks.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistDetails {
        ArtistDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &ArtistDetails| { &m.detailsUrl },
                |m: &mut ArtistDetails| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ArtistDetails| { &m.name },
                |m: &mut ArtistDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistExternalLinks>>(
                "externalLinks",
                |m: &ArtistDetails| { &m.externalLinks },
                |m: &mut ArtistDetails| { &mut m.externalLinks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtistDetails>(
                "ArtistDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistDetails {
        static instance: ::protobuf::rt::LazyV2<ArtistDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtistDetails::new)
    }
}

impl ::protobuf::Clear for ArtistDetails {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.name.clear();
        self.externalLinks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ArtistExternalLinks {
    // message fields
    pub websiteUrl: ::protobuf::RepeatedField<::std::string::String>,
    pub googlePlusProfileUrl: ::protobuf::SingularField<::std::string::String>,
    pub youtubeChannelUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtistExternalLinks {
    fn default() -> &'a ArtistExternalLinks {
        <ArtistExternalLinks as ::protobuf::Message>::default_instance()
    }
}

impl ArtistExternalLinks {
    pub fn new() -> ArtistExternalLinks {
        ::std::default::Default::default()
    }

    // repeated string websiteUrl = 1;


    pub fn get_websiteUrl(&self) -> &[::std::string::String] {
        &self.websiteUrl
    }

    // optional string googlePlusProfileUrl = 2;


    pub fn get_googlePlusProfileUrl(&self) -> &str {
        match self.googlePlusProfileUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string youtubeChannelUrl = 3;


    pub fn get_youtubeChannelUrl(&self) -> &str {
        match self.youtubeChannelUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ArtistExternalLinks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.websiteUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.googlePlusProfileUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubeChannelUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.websiteUrl {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.googlePlusProfileUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.youtubeChannelUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.websiteUrl {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.googlePlusProfileUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.youtubeChannelUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistExternalLinks {
        ArtistExternalLinks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "websiteUrl",
                |m: &ArtistExternalLinks| { &m.websiteUrl },
                |m: &mut ArtistExternalLinks| { &mut m.websiteUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "googlePlusProfileUrl",
                |m: &ArtistExternalLinks| { &m.googlePlusProfileUrl },
                |m: &mut ArtistExternalLinks| { &mut m.googlePlusProfileUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtubeChannelUrl",
                |m: &ArtistExternalLinks| { &m.youtubeChannelUrl },
                |m: &mut ArtistExternalLinks| { &mut m.youtubeChannelUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtistExternalLinks>(
                "ArtistExternalLinks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistExternalLinks {
        static instance: ::protobuf::rt::LazyV2<ArtistExternalLinks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtistExternalLinks::new)
    }
}

impl ::protobuf::Clear for ArtistExternalLinks {
    fn clear(&mut self) {
        self.websiteUrl.clear();
        self.googlePlusProfileUrl.clear();
        self.youtubeChannelUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistExternalLinks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistExternalLinks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocumentDetails {
    // message fields
    pub appDetails: ::protobuf::SingularPtrField<AppDetails>,
    pub albumDetails: ::protobuf::SingularPtrField<AlbumDetails>,
    pub artistDetails: ::protobuf::SingularPtrField<ArtistDetails>,
    pub songDetails: ::protobuf::SingularPtrField<SongDetails>,
    pub bookDetails: ::protobuf::SingularPtrField<BookDetails>,
    pub videoDetails: ::protobuf::SingularPtrField<VideoDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<SubscriptionDetails>,
    pub magazineDetails: ::protobuf::SingularPtrField<MagazineDetails>,
    pub tvShowDetails: ::protobuf::SingularPtrField<TvShowDetails>,
    pub tvSeasonDetails: ::protobuf::SingularPtrField<TvSeasonDetails>,
    pub tvEpisodeDetails: ::protobuf::SingularPtrField<TvEpisodeDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDetails {
    fn default() -> &'a DocumentDetails {
        <DocumentDetails as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDetails {
    pub fn new() -> DocumentDetails {
        ::std::default::Default::default()
    }

    // optional .AppDetails appDetails = 1;


    pub fn get_appDetails(&self) -> &AppDetails {
        self.appDetails.as_ref().unwrap_or_else(|| <AppDetails as ::protobuf::Message>::default_instance())
    }

    // optional .AlbumDetails albumDetails = 2;


    pub fn get_albumDetails(&self) -> &AlbumDetails {
        self.albumDetails.as_ref().unwrap_or_else(|| <AlbumDetails as ::protobuf::Message>::default_instance())
    }

    // optional .ArtistDetails artistDetails = 3;


    pub fn get_artistDetails(&self) -> &ArtistDetails {
        self.artistDetails.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }

    // optional .SongDetails songDetails = 4;


    pub fn get_songDetails(&self) -> &SongDetails {
        self.songDetails.as_ref().unwrap_or_else(|| <SongDetails as ::protobuf::Message>::default_instance())
    }

    // optional .BookDetails bookDetails = 5;


    pub fn get_bookDetails(&self) -> &BookDetails {
        self.bookDetails.as_ref().unwrap_or_else(|| <BookDetails as ::protobuf::Message>::default_instance())
    }

    // optional .VideoDetails videoDetails = 6;


    pub fn get_videoDetails(&self) -> &VideoDetails {
        self.videoDetails.as_ref().unwrap_or_else(|| <VideoDetails as ::protobuf::Message>::default_instance())
    }

    // optional .SubscriptionDetails subscriptionDetails = 7;


    pub fn get_subscriptionDetails(&self) -> &SubscriptionDetails {
        self.subscriptionDetails.as_ref().unwrap_or_else(|| <SubscriptionDetails as ::protobuf::Message>::default_instance())
    }

    // optional .MagazineDetails magazineDetails = 8;


    pub fn get_magazineDetails(&self) -> &MagazineDetails {
        self.magazineDetails.as_ref().unwrap_or_else(|| <MagazineDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvShowDetails tvShowDetails = 9;


    pub fn get_tvShowDetails(&self) -> &TvShowDetails {
        self.tvShowDetails.as_ref().unwrap_or_else(|| <TvShowDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvSeasonDetails tvSeasonDetails = 10;


    pub fn get_tvSeasonDetails(&self) -> &TvSeasonDetails {
        self.tvSeasonDetails.as_ref().unwrap_or_else(|| <TvSeasonDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvEpisodeDetails tvEpisodeDetails = 11;


    pub fn get_tvEpisodeDetails(&self) -> &TvEpisodeDetails {
        self.tvEpisodeDetails.as_ref().unwrap_or_else(|| <TvEpisodeDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for DocumentDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.albumDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artistDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.songDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bookDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.videoDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.magazineDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvShowDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvSeasonDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvEpisodeDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDetails)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.albumDetails)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artistDetails)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.songDetails)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bookDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.videoDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionDetails)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.magazineDetails)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvShowDetails)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvSeasonDetails)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvEpisodeDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.albumDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.artistDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.songDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bookDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.videoDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.magazineDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvShowDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvSeasonDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvEpisodeDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.appDetails.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.albumDetails.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.artistDetails.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.songDetails.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bookDetails.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.videoDetails.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.magazineDetails.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvShowDetails.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvSeasonDetails.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvEpisodeDetails.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDetails {
        DocumentDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDetails>>(
                "appDetails",
                |m: &DocumentDetails| { &m.appDetails },
                |m: &mut DocumentDetails| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumDetails>>(
                "albumDetails",
                |m: &DocumentDetails| { &m.albumDetails },
                |m: &mut DocumentDetails| { &mut m.albumDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "artistDetails",
                |m: &DocumentDetails| { &m.artistDetails },
                |m: &mut DocumentDetails| { &mut m.artistDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SongDetails>>(
                "songDetails",
                |m: &DocumentDetails| { &m.songDetails },
                |m: &mut DocumentDetails| { &mut m.songDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookDetails>>(
                "bookDetails",
                |m: &DocumentDetails| { &m.bookDetails },
                |m: &mut DocumentDetails| { &mut m.bookDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoDetails>>(
                "videoDetails",
                |m: &DocumentDetails| { &m.videoDetails },
                |m: &mut DocumentDetails| { &mut m.videoDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionDetails>>(
                "subscriptionDetails",
                |m: &DocumentDetails| { &m.subscriptionDetails },
                |m: &mut DocumentDetails| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MagazineDetails>>(
                "magazineDetails",
                |m: &DocumentDetails| { &m.magazineDetails },
                |m: &mut DocumentDetails| { &mut m.magazineDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvShowDetails>>(
                "tvShowDetails",
                |m: &DocumentDetails| { &m.tvShowDetails },
                |m: &mut DocumentDetails| { &mut m.tvShowDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvSeasonDetails>>(
                "tvSeasonDetails",
                |m: &DocumentDetails| { &m.tvSeasonDetails },
                |m: &mut DocumentDetails| { &mut m.tvSeasonDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvEpisodeDetails>>(
                "tvEpisodeDetails",
                |m: &DocumentDetails| { &m.tvEpisodeDetails },
                |m: &mut DocumentDetails| { &mut m.tvEpisodeDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDetails>(
                "DocumentDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentDetails {
        static instance: ::protobuf::rt::LazyV2<DocumentDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentDetails::new)
    }
}

impl ::protobuf::Clear for DocumentDetails {
    fn clear(&mut self) {
        self.appDetails.clear();
        self.albumDetails.clear();
        self.artistDetails.clear();
        self.songDetails.clear();
        self.bookDetails.clear();
        self.videoDetails.clear();
        self.subscriptionDetails.clear();
        self.magazineDetails.clear();
        self.tvShowDetails.clear();
        self.tvSeasonDetails.clear();
        self.tvEpisodeDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PatchDetails {
    // message fields
    pub baseVersionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchDetails {
    fn default() -> &'a PatchDetails {
        <PatchDetails as ::protobuf::Message>::default_instance()
    }
}

impl PatchDetails {
    pub fn new() -> PatchDetails {
        ::std::default::Default::default()
    }

    // optional int32 baseVersionCode = 1;


    pub fn get_baseVersionCode(&self) -> i32 {
        self.baseVersionCode.unwrap_or(0)
    }

    // optional int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for PatchDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baseVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchDetails {
        PatchDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "baseVersionCode",
                |m: &PatchDetails| { &m.baseVersionCode },
                |m: &mut PatchDetails| { &mut m.baseVersionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &PatchDetails| { &m.size },
                |m: &mut PatchDetails| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchDetails>(
                "PatchDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchDetails {
        static instance: ::protobuf::rt::LazyV2<PatchDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchDetails::new)
    }
}

impl ::protobuf::Clear for PatchDetails {
    fn clear(&mut self) {
        self.baseVersionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub splitId: ::protobuf::SingularField<::std::string::String>,
    pub compressedSize: ::std::option::Option<i64>,
    pub patchDetails: ::protobuf::RepeatedField<PatchDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileMetadata {
    fn default() -> &'a FileMetadata {
        <FileMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FileMetadata {
    pub fn new() -> FileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;


    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string splitId = 4;


    pub fn get_splitId(&self) -> &str {
        match self.splitId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 compressedSize = 5;


    pub fn get_compressedSize(&self) -> i64 {
        self.compressedSize.unwrap_or(0)
    }

    // repeated .PatchDetails patchDetails = 6;


    pub fn get_patchDetails(&self) -> &[PatchDetails] {
        &self.patchDetails
    }
}

impl ::protobuf::Message for FileMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.patchDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.splitId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compressedSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.patchDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.splitId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.compressedSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.patchDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.splitId.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.compressedSize {
            os.write_int64(5, v)?;
        }
        for v in &self.patchDetails {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileMetadata {
        FileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fileType",
                |m: &FileMetadata| { &m.fileType },
                |m: &mut FileMetadata| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &FileMetadata| { &m.versionCode },
                |m: &mut FileMetadata| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &FileMetadata| { &m.size },
                |m: &mut FileMetadata| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "splitId",
                |m: &FileMetadata| { &m.splitId },
                |m: &mut FileMetadata| { &mut m.splitId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compressedSize",
                |m: &FileMetadata| { &m.compressedSize },
                |m: &mut FileMetadata| { &mut m.compressedSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PatchDetails>>(
                "patchDetails",
                |m: &FileMetadata| { &m.patchDetails },
                |m: &mut FileMetadata| { &mut m.patchDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileMetadata>(
                "FileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileMetadata {
        static instance: ::protobuf::rt::LazyV2<FileMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileMetadata::new)
    }
}

impl ::protobuf::Clear for FileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.splitId.clear();
        self.compressedSize = ::std::option::Option::None;
        self.patchDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MagazineDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub deviceAvailabilityDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub psvDescription: ::protobuf::SingularField<::std::string::String>,
    pub deliveryFrequencyDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MagazineDetails {
    fn default() -> &'a MagazineDetails {
        <MagazineDetails as ::protobuf::Message>::default_instance()
    }
}

impl MagazineDetails {
    pub fn new() -> MagazineDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deviceAvailabilityDescriptionHtml = 2;


    pub fn get_deviceAvailabilityDescriptionHtml(&self) -> &str {
        match self.deviceAvailabilityDescriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string psvDescription = 3;


    pub fn get_psvDescription(&self) -> &str {
        match self.psvDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deliveryFrequencyDescription = 4;


    pub fn get_deliveryFrequencyDescription(&self) -> &str {
        match self.deliveryFrequencyDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MagazineDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceAvailabilityDescriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.psvDescription)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deliveryFrequencyDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.deliveryFrequencyDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.deliveryFrequencyDescription.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MagazineDetails {
        MagazineDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &MagazineDetails| { &m.parentDetailsUrl },
                |m: &mut MagazineDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceAvailabilityDescriptionHtml",
                |m: &MagazineDetails| { &m.deviceAvailabilityDescriptionHtml },
                |m: &mut MagazineDetails| { &mut m.deviceAvailabilityDescriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "psvDescription",
                |m: &MagazineDetails| { &m.psvDescription },
                |m: &mut MagazineDetails| { &mut m.psvDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deliveryFrequencyDescription",
                |m: &MagazineDetails| { &m.deliveryFrequencyDescription },
                |m: &mut MagazineDetails| { &mut m.deliveryFrequencyDescription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MagazineDetails>(
                "MagazineDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MagazineDetails {
        static instance: ::protobuf::rt::LazyV2<MagazineDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MagazineDetails::new)
    }
}

impl ::protobuf::Clear for MagazineDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.deviceAvailabilityDescriptionHtml.clear();
        self.psvDescription.clear();
        self.deliveryFrequencyDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MagazineDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MagazineDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MusicDetails {
    // message fields
    pub censoring: ::std::option::Option<i32>,
    pub durationSec: ::std::option::Option<i32>,
    pub originalReleaseDate: ::protobuf::SingularField<::std::string::String>,
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub artist: ::protobuf::RepeatedField<ArtistDetails>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub releaseType: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MusicDetails {
    fn default() -> &'a MusicDetails {
        <MusicDetails as ::protobuf::Message>::default_instance()
    }
}

impl MusicDetails {
    pub fn new() -> MusicDetails {
        ::std::default::Default::default()
    }

    // optional int32 censoring = 1;


    pub fn get_censoring(&self) -> i32 {
        self.censoring.unwrap_or(0)
    }

    // optional int32 durationSec = 2;


    pub fn get_durationSec(&self) -> i32 {
        self.durationSec.unwrap_or(0)
    }

    // optional string originalReleaseDate = 3;


    pub fn get_originalReleaseDate(&self) -> &str {
        match self.originalReleaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string label = 4;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ArtistDetails artist = 5;


    pub fn get_artist(&self) -> &[ArtistDetails] {
        &self.artist
    }

    // repeated string genre = 6;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }

    // optional string releaseDate = 7;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 releaseType = 8;


    pub fn get_releaseType(&self) -> &[i32] {
        &self.releaseType
    }
}

impl ::protobuf::Message for MusicDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.artist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.censoring = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.durationSec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalReleaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.artist)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.releaseType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.censoring {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.durationSec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.originalReleaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.releaseType {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.censoring {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.durationSec {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.originalReleaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.artist {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.genre {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.releaseType {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MusicDetails {
        MusicDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "censoring",
                |m: &MusicDetails| { &m.censoring },
                |m: &mut MusicDetails| { &mut m.censoring },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "durationSec",
                |m: &MusicDetails| { &m.durationSec },
                |m: &mut MusicDetails| { &mut m.durationSec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originalReleaseDate",
                |m: &MusicDetails| { &m.originalReleaseDate },
                |m: &mut MusicDetails| { &mut m.originalReleaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &MusicDetails| { &m.label },
                |m: &mut MusicDetails| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "artist",
                |m: &MusicDetails| { &m.artist },
                |m: &mut MusicDetails| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &MusicDetails| { &m.genre },
                |m: &mut MusicDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &MusicDetails| { &m.releaseDate },
                |m: &mut MusicDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "releaseType",
                |m: &MusicDetails| { &m.releaseType },
                |m: &mut MusicDetails| { &mut m.releaseType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MusicDetails>(
                "MusicDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MusicDetails {
        static instance: ::protobuf::rt::LazyV2<MusicDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MusicDetails::new)
    }
}

impl ::protobuf::Clear for MusicDetails {
    fn clear(&mut self) {
        self.censoring = ::std::option::Option::None;
        self.durationSec = ::std::option::Option::None;
        self.originalReleaseDate.clear();
        self.label.clear();
        self.artist.clear();
        self.genre.clear();
        self.releaseDate.clear();
        self.releaseType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MusicDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MusicDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NewsDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub psvDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewsDetails {
    fn default() -> &'a NewsDetails {
        <NewsDetails as ::protobuf::Message>::default_instance()
    }
}

impl NewsDetails {
    pub fn new() -> NewsDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string psvDescription = 3;


    pub fn get_psvDescription(&self) -> &str {
        match self.psvDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NewsDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.psvDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewsDetails {
        NewsDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &NewsDetails| { &m.parentDetailsUrl },
                |m: &mut NewsDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "psvDescription",
                |m: &NewsDetails| { &m.psvDescription },
                |m: &mut NewsDetails| { &mut m.psvDescription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NewsDetails>(
                "NewsDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NewsDetails {
        static instance: ::protobuf::rt::LazyV2<NewsDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NewsDetails::new)
    }
}

impl ::protobuf::Clear for NewsDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.psvDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewsDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewsDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SongDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub albumName: ::protobuf::SingularField<::std::string::String>,
    pub trackNumber: ::std::option::Option<i32>,
    pub previewUrl: ::protobuf::SingularField<::std::string::String>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    pub badge: ::protobuf::SingularPtrField<Badge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SongDetails {
    fn default() -> &'a SongDetails {
        <SongDetails as ::protobuf::Message>::default_instance()
    }
}

impl SongDetails {
    pub fn new() -> SongDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .MusicDetails details = 2;


    pub fn get_details(&self) -> &MusicDetails {
        self.details.as_ref().unwrap_or_else(|| <MusicDetails as ::protobuf::Message>::default_instance())
    }

    // optional string albumName = 3;


    pub fn get_albumName(&self) -> &str {
        match self.albumName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 trackNumber = 4;


    pub fn get_trackNumber(&self) -> i32 {
        self.trackNumber.unwrap_or(0)
    }

    // optional string previewUrl = 5;


    pub fn get_previewUrl(&self) -> &str {
        match self.previewUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ArtistDetails displayArtist = 6;


    pub fn get_displayArtist(&self) -> &ArtistDetails {
        self.displayArtist.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }

    // optional .Badge badge = 7;


    pub fn get_badge(&self) -> &Badge {
        self.badge.as_ref().unwrap_or_else(|| <Badge as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SongDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.albumName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trackNumber = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.previewUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.displayArtist)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.badge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.albumName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.trackNumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.previewUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.badge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.albumName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.trackNumber {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.previewUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.badge.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SongDetails {
        SongDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SongDetails| { &m.name },
                |m: &mut SongDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>>(
                "details",
                |m: &SongDetails| { &m.details },
                |m: &mut SongDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "albumName",
                |m: &SongDetails| { &m.albumName },
                |m: &mut SongDetails| { &mut m.albumName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trackNumber",
                |m: &SongDetails| { &m.trackNumber },
                |m: &mut SongDetails| { &mut m.trackNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "previewUrl",
                |m: &SongDetails| { &m.previewUrl },
                |m: &mut SongDetails| { &mut m.previewUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "displayArtist",
                |m: &SongDetails| { &m.displayArtist },
                |m: &mut SongDetails| { &mut m.displayArtist },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badge",
                |m: &SongDetails| { &m.badge },
                |m: &mut SongDetails| { &mut m.badge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SongDetails>(
                "SongDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SongDetails {
        static instance: ::protobuf::rt::LazyV2<SongDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SongDetails::new)
    }
}

impl ::protobuf::Clear for SongDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.albumName.clear();
        self.trackNumber = ::std::option::Option::None;
        self.previewUrl.clear();
        self.displayArtist.clear();
        self.badge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SongDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SongDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscriptionDetails {
    // message fields
    pub subscriptionPeriod: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionDetails {
    fn default() -> &'a SubscriptionDetails {
        <SubscriptionDetails as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionDetails {
    pub fn new() -> SubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int32 subscriptionPeriod = 1;


    pub fn get_subscriptionPeriod(&self) -> i32 {
        self.subscriptionPeriod.unwrap_or(0)
    }
}

impl ::protobuf::Message for SubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subscriptionPeriod = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscriptionPeriod {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscriptionPeriod {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionDetails {
        SubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "subscriptionPeriod",
                |m: &SubscriptionDetails| { &m.subscriptionPeriod },
                |m: &mut SubscriptionDetails| { &mut m.subscriptionPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscriptionDetails>(
                "SubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionDetails {
        static instance: ::protobuf::rt::LazyV2<SubscriptionDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for SubscriptionDetails {
    fn clear(&mut self) {
        self.subscriptionPeriod = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Trailer {
    // message fields
    pub trailerId: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub thumbnailUrl: ::protobuf::SingularField<::std::string::String>,
    pub watchUrl: ::protobuf::SingularField<::std::string::String>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Trailer {
    fn default() -> &'a Trailer {
        <Trailer as ::protobuf::Message>::default_instance()
    }
}

impl Trailer {
    pub fn new() -> Trailer {
        ::std::default::Default::default()
    }

    // optional string trailerId = 1;


    pub fn get_trailerId(&self) -> &str {
        match self.trailerId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string thumbnailUrl = 3;


    pub fn get_thumbnailUrl(&self) -> &str {
        match self.thumbnailUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string watchUrl = 4;


    pub fn get_watchUrl(&self) -> &str {
        match self.watchUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string duration = 5;


    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Trailer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trailerId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnailUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.watchUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trailerId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbnailUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.watchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trailerId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbnailUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.watchUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trailer {
        Trailer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trailerId",
                |m: &Trailer| { &m.trailerId },
                |m: &mut Trailer| { &mut m.trailerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Trailer| { &m.title },
                |m: &mut Trailer| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnailUrl",
                |m: &Trailer| { &m.thumbnailUrl },
                |m: &mut Trailer| { &mut m.thumbnailUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "watchUrl",
                |m: &Trailer| { &m.watchUrl },
                |m: &mut Trailer| { &mut m.watchUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &Trailer| { &m.duration },
                |m: &mut Trailer| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Trailer>(
                "Trailer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Trailer {
        static instance: ::protobuf::rt::LazyV2<Trailer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Trailer::new)
    }
}

impl ::protobuf::Clear for Trailer {
    fn clear(&mut self) {
        self.trailerId.clear();
        self.title.clear();
        self.thumbnailUrl.clear();
        self.watchUrl.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trailer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trailer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvEpisodeDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub episodeIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvEpisodeDetails {
    fn default() -> &'a TvEpisodeDetails {
        <TvEpisodeDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvEpisodeDetails {
    pub fn new() -> TvEpisodeDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 episodeIndex = 2;


    pub fn get_episodeIndex(&self) -> i32 {
        self.episodeIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvEpisodeDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.episodeIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.episodeIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.episodeIndex {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvEpisodeDetails {
        TvEpisodeDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &TvEpisodeDetails| { &m.parentDetailsUrl },
                |m: &mut TvEpisodeDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "episodeIndex",
                |m: &TvEpisodeDetails| { &m.episodeIndex },
                |m: &mut TvEpisodeDetails| { &mut m.episodeIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &TvEpisodeDetails| { &m.releaseDate },
                |m: &mut TvEpisodeDetails| { &mut m.releaseDate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvEpisodeDetails>(
                "TvEpisodeDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvEpisodeDetails {
        static instance: ::protobuf::rt::LazyV2<TvEpisodeDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvEpisodeDetails::new)
    }
}

impl ::protobuf::Clear for TvEpisodeDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.episodeIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvEpisodeDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvEpisodeDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvSeasonDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub seasonIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    pub episodeCount: ::std::option::Option<i32>,
    pub expectedEpisodeCount: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvSeasonDetails {
    fn default() -> &'a TvSeasonDetails {
        <TvSeasonDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvSeasonDetails {
    pub fn new() -> TvSeasonDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 seasonIndex = 2;


    pub fn get_seasonIndex(&self) -> i32 {
        self.seasonIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string broadcaster = 4;


    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 episodeCount = 5;


    pub fn get_episodeCount(&self) -> i32 {
        self.episodeCount.unwrap_or(0)
    }

    // optional int32 expectedEpisodeCount = 6;


    pub fn get_expectedEpisodeCount(&self) -> i32 {
        self.expectedEpisodeCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for TvSeasonDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.episodeCount = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expectedEpisodeCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seasonIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.episodeCount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expectedEpisodeCount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.seasonIndex {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.episodeCount {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.expectedEpisodeCount {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvSeasonDetails {
        TvSeasonDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &TvSeasonDetails| { &m.parentDetailsUrl },
                |m: &mut TvSeasonDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seasonIndex",
                |m: &TvSeasonDetails| { &m.seasonIndex },
                |m: &mut TvSeasonDetails| { &mut m.seasonIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &TvSeasonDetails| { &m.releaseDate },
                |m: &mut TvSeasonDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcaster",
                |m: &TvSeasonDetails| { &m.broadcaster },
                |m: &mut TvSeasonDetails| { &mut m.broadcaster },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "episodeCount",
                |m: &TvSeasonDetails| { &m.episodeCount },
                |m: &mut TvSeasonDetails| { &mut m.episodeCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expectedEpisodeCount",
                |m: &TvSeasonDetails| { &m.expectedEpisodeCount },
                |m: &mut TvSeasonDetails| { &mut m.expectedEpisodeCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvSeasonDetails>(
                "TvSeasonDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvSeasonDetails {
        static instance: ::protobuf::rt::LazyV2<TvSeasonDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvSeasonDetails::new)
    }
}

impl ::protobuf::Clear for TvSeasonDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.seasonIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.broadcaster.clear();
        self.episodeCount = ::std::option::Option::None;
        self.expectedEpisodeCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvSeasonDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvSeasonDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvShowDetails {
    // message fields
    pub seasonCount: ::std::option::Option<i32>,
    pub startYear: ::std::option::Option<i32>,
    pub endYear: ::std::option::Option<i32>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvShowDetails {
    fn default() -> &'a TvShowDetails {
        <TvShowDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvShowDetails {
    pub fn new() -> TvShowDetails {
        ::std::default::Default::default()
    }

    // optional int32 seasonCount = 1;


    pub fn get_seasonCount(&self) -> i32 {
        self.seasonCount.unwrap_or(0)
    }

    // optional int32 startYear = 2;


    pub fn get_startYear(&self) -> i32 {
        self.startYear.unwrap_or(0)
    }

    // optional int32 endYear = 3;


    pub fn get_endYear(&self) -> i32 {
        self.endYear.unwrap_or(0)
    }

    // optional string broadcaster = 4;


    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvShowDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.startYear = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.endYear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seasonCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startYear {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endYear {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seasonCount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.startYear {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.endYear {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvShowDetails {
        TvShowDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seasonCount",
                |m: &TvShowDetails| { &m.seasonCount },
                |m: &mut TvShowDetails| { &mut m.seasonCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "startYear",
                |m: &TvShowDetails| { &m.startYear },
                |m: &mut TvShowDetails| { &mut m.startYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "endYear",
                |m: &TvShowDetails| { &m.endYear },
                |m: &mut TvShowDetails| { &mut m.endYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcaster",
                |m: &TvShowDetails| { &m.broadcaster },
                |m: &mut TvShowDetails| { &mut m.broadcaster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvShowDetails>(
                "TvShowDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvShowDetails {
        static instance: ::protobuf::rt::LazyV2<TvShowDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvShowDetails::new)
    }
}

impl ::protobuf::Clear for TvShowDetails {
    fn clear(&mut self) {
        self.seasonCount = ::std::option::Option::None;
        self.startYear = ::std::option::Option::None;
        self.endYear = ::std::option::Option::None;
        self.broadcaster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvShowDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvShowDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoCredit {
    // message fields
    pub creditType: ::std::option::Option<i32>,
    pub credit: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoCredit {
    fn default() -> &'a VideoCredit {
        <VideoCredit as ::protobuf::Message>::default_instance()
    }
}

impl VideoCredit {
    pub fn new() -> VideoCredit {
        ::std::default::Default::default()
    }

    // optional int32 creditType = 1;


    pub fn get_creditType(&self) -> i32 {
        self.creditType.unwrap_or(0)
    }

    // optional string credit = 2;


    pub fn get_credit(&self) -> &str {
        match self.credit.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string name = 3;


    pub fn get_name(&self) -> &[::std::string::String] {
        &self.name
    }
}

impl ::protobuf::Message for VideoCredit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creditType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credit)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.creditType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.credit.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.creditType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.credit.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.name {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoCredit {
        VideoCredit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "creditType",
                |m: &VideoCredit| { &m.creditType },
                |m: &mut VideoCredit| { &mut m.creditType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credit",
                |m: &VideoCredit| { &m.credit },
                |m: &mut VideoCredit| { &mut m.credit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VideoCredit| { &m.name },
                |m: &mut VideoCredit| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoCredit>(
                "VideoCredit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoCredit {
        static instance: ::protobuf::rt::LazyV2<VideoCredit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoCredit::new)
    }
}

impl ::protobuf::Clear for VideoCredit {
    fn clear(&mut self) {
        self.creditType = ::std::option::Option::None;
        self.credit.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoCredit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoCredit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoDetails {
    // message fields
    pub credit: ::protobuf::RepeatedField<VideoCredit>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub contentRating: ::protobuf::SingularField<::std::string::String>,
    pub likes: ::std::option::Option<i64>,
    pub dislikes: ::std::option::Option<i64>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub trailer: ::protobuf::RepeatedField<Trailer>,
    pub rentalTerm: ::protobuf::RepeatedField<VideoRentalTerm>,
    pub audioLanguage: ::protobuf::RepeatedField<::std::string::String>,
    pub captionLanguage: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoDetails {
    fn default() -> &'a VideoDetails {
        <VideoDetails as ::protobuf::Message>::default_instance()
    }
}

impl VideoDetails {
    pub fn new() -> VideoDetails {
        ::std::default::Default::default()
    }

    // repeated .VideoCredit credit = 1;


    pub fn get_credit(&self) -> &[VideoCredit] {
        &self.credit
    }

    // optional string duration = 2;


    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contentRating = 4;


    pub fn get_contentRating(&self) -> &str {
        match self.contentRating.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 likes = 5;


    pub fn get_likes(&self) -> i64 {
        self.likes.unwrap_or(0)
    }

    // optional int64 dislikes = 6;


    pub fn get_dislikes(&self) -> i64 {
        self.dislikes.unwrap_or(0)
    }

    // repeated string genre = 7;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }

    // repeated .Trailer trailer = 8;


    pub fn get_trailer(&self) -> &[Trailer] {
        &self.trailer
    }

    // repeated .VideoRentalTerm rentalTerm = 9;


    pub fn get_rentalTerm(&self) -> &[VideoRentalTerm] {
        &self.rentalTerm
    }

    // repeated string audioLanguage = 10;


    pub fn get_audioLanguage(&self) -> &[::std::string::String] {
        &self.audioLanguage
    }

    // repeated string captionLanguage = 11;


    pub fn get_captionLanguage(&self) -> &[::std::string::String] {
        &self.captionLanguage
    }
}

impl ::protobuf::Message for VideoDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.credit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trailer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.credit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentRating)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dislikes = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trailer)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rentalTerm)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audioLanguage)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.captionLanguage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.credit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.contentRating.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.likes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dislikes {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.trailer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rentalTerm {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.audioLanguage {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.captionLanguage {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.credit {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.duration.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.contentRating.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.likes {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dislikes {
            os.write_int64(6, v)?;
        }
        for v in &self.genre {
            os.write_string(7, &v)?;
        };
        for v in &self.trailer {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rentalTerm {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.audioLanguage {
            os.write_string(10, &v)?;
        };
        for v in &self.captionLanguage {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoDetails {
        VideoDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoCredit>>(
                "credit",
                |m: &VideoDetails| { &m.credit },
                |m: &mut VideoDetails| { &mut m.credit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &VideoDetails| { &m.duration },
                |m: &mut VideoDetails| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &VideoDetails| { &m.releaseDate },
                |m: &mut VideoDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentRating",
                |m: &VideoDetails| { &m.contentRating },
                |m: &mut VideoDetails| { &mut m.contentRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "likes",
                |m: &VideoDetails| { &m.likes },
                |m: &mut VideoDetails| { &mut m.likes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dislikes",
                |m: &VideoDetails| { &m.dislikes },
                |m: &mut VideoDetails| { &mut m.dislikes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &VideoDetails| { &m.genre },
                |m: &mut VideoDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Trailer>>(
                "trailer",
                |m: &VideoDetails| { &m.trailer },
                |m: &mut VideoDetails| { &mut m.trailer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoRentalTerm>>(
                "rentalTerm",
                |m: &VideoDetails| { &m.rentalTerm },
                |m: &mut VideoDetails| { &mut m.rentalTerm },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audioLanguage",
                |m: &VideoDetails| { &m.audioLanguage },
                |m: &mut VideoDetails| { &mut m.audioLanguage },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "captionLanguage",
                |m: &VideoDetails| { &m.captionLanguage },
                |m: &mut VideoDetails| { &mut m.captionLanguage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoDetails>(
                "VideoDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoDetails {
        static instance: ::protobuf::rt::LazyV2<VideoDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoDetails::new)
    }
}

impl ::protobuf::Clear for VideoDetails {
    fn clear(&mut self) {
        self.credit.clear();
        self.duration.clear();
        self.releaseDate.clear();
        self.contentRating.clear();
        self.likes = ::std::option::Option::None;
        self.dislikes = ::std::option::Option::None;
        self.genre.clear();
        self.trailer.clear();
        self.rentalTerm.clear();
        self.audioLanguage.clear();
        self.captionLanguage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoRentalTerm {
    // message fields
    pub offerType: ::std::option::Option<i32>,
    pub offerAbbreviation: ::protobuf::SingularField<::std::string::String>,
    pub rentalHeader: ::protobuf::SingularField<::std::string::String>,
    // term: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoRentalTerm {
    fn default() -> &'a VideoRentalTerm {
        <VideoRentalTerm as ::protobuf::Message>::default_instance()
    }
}

impl VideoRentalTerm {
    pub fn new() -> VideoRentalTerm {
        ::std::default::Default::default()
    }

    // optional int32 offerType = 1;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional string offerAbbreviation = 2;


    pub fn get_offerAbbreviation(&self) -> &str {
        match self.offerAbbreviation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string rentalHeader = 3;


    pub fn get_rentalHeader(&self) -> &str {
        match self.rentalHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerAbbreviation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rentalHeader)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.offerAbbreviation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.rentalHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offerType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.offerAbbreviation.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.rentalHeader.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm {
        VideoRentalTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &VideoRentalTerm| { &m.offerType },
                |m: &mut VideoRentalTerm| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offerAbbreviation",
                |m: &VideoRentalTerm| { &m.offerAbbreviation },
                |m: &mut VideoRentalTerm| { &mut m.offerAbbreviation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rentalHeader",
                |m: &VideoRentalTerm| { &m.rentalHeader },
                |m: &mut VideoRentalTerm| { &mut m.rentalHeader },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoRentalTerm>(
                "VideoRentalTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm {
        static instance: ::protobuf::rt::LazyV2<VideoRentalTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoRentalTerm::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm {
    fn clear(&mut self) {
        self.offerType = ::std::option::Option::None;
        self.offerAbbreviation.clear();
        self.rentalHeader.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoRentalTerm_Term {
    // message fields
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub body: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoRentalTerm_Term {
    fn default() -> &'a VideoRentalTerm_Term {
        <VideoRentalTerm_Term as ::protobuf::Message>::default_instance()
    }
}

impl VideoRentalTerm_Term {
    pub fn new() -> VideoRentalTerm_Term {
        ::std::default::Default::default()
    }

    // optional string header = 5;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string body = 6;


    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm_Term {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm_Term {
        VideoRentalTerm_Term::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &VideoRentalTerm_Term| { &m.header },
                |m: &mut VideoRentalTerm_Term| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &VideoRentalTerm_Term| { &m.body },
                |m: &mut VideoRentalTerm_Term| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoRentalTerm_Term>(
                "VideoRentalTerm.Term",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm_Term {
        static instance: ::protobuf::rt::LazyV2<VideoRentalTerm_Term> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoRentalTerm_Term::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm_Term {
    fn clear(&mut self) {
        self.header.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm_Term {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm_Term {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Bucket {
    // message fields
    pub document: ::protobuf::RepeatedField<DocV1>,
    pub multiCorpus: ::std::option::Option<bool>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub iconUrl: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsListUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket {
    fn default() -> &'a Bucket {
        <Bucket as ::protobuf::Message>::default_instance()
    }
}

impl Bucket {
    pub fn new() -> Bucket {
        ::std::default::Default::default()
    }

    // repeated .DocV1 document = 1;


    pub fn get_document(&self) -> &[DocV1] {
        &self.document
    }

    // optional bool multiCorpus = 2;


    pub fn get_multiCorpus(&self) -> bool {
        self.multiCorpus.unwrap_or(false)
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string iconUrl = 4;


    pub fn get_iconUrl(&self) -> &str {
        match self.iconUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string fullContentsUrl = 5;


    pub fn get_fullContentsUrl(&self) -> &str {
        match self.fullContentsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double relevance = 6;


    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 7;


    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 8;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string fullContentsListUrl = 9;


    pub fn get_fullContentsListUrl(&self) -> &str {
        match self.fullContentsListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string nextPageUrl = 10;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ordered = 11;


    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }
}

impl ::protobuf::Message for Bucket {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiCorpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsListUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.document {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.multiCorpus {
            my_size += 2;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.iconUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.fullContentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.fullContentsListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.document {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.multiCorpus {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.iconUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.fullContentsUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.fullContentsListUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket {
        Bucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>>(
                "document",
                |m: &Bucket| { &m.document },
                |m: &mut Bucket| { &mut m.document },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "multiCorpus",
                |m: &Bucket| { &m.multiCorpus },
                |m: &mut Bucket| { &mut m.multiCorpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Bucket| { &m.title },
                |m: &mut Bucket| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iconUrl",
                |m: &Bucket| { &m.iconUrl },
                |m: &mut Bucket| { &mut m.iconUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullContentsUrl",
                |m: &Bucket| { &m.fullContentsUrl },
                |m: &mut Bucket| { &mut m.fullContentsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "relevance",
                |m: &Bucket| { &m.relevance },
                |m: &mut Bucket| { &mut m.relevance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "estimatedResults",
                |m: &Bucket| { &m.estimatedResults },
                |m: &mut Bucket| { &mut m.estimatedResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &Bucket| { &m.analyticsCookie },
                |m: &mut Bucket| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullContentsListUrl",
                |m: &Bucket| { &m.fullContentsListUrl },
                |m: &mut Bucket| { &mut m.fullContentsListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &Bucket| { &m.nextPageUrl },
                |m: &mut Bucket| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ordered",
                |m: &Bucket| { &m.ordered },
                |m: &mut Bucket| { &mut m.ordered },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket>(
                "Bucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket {
        static instance: ::protobuf::rt::LazyV2<Bucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket::new)
    }
}

impl ::protobuf::Clear for Bucket {
    fn clear(&mut self) {
        self.document.clear();
        self.multiCorpus = ::std::option::Option::None;
        self.title.clear();
        self.iconUrl.clear();
        self.fullContentsUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.fullContentsListUrl.clear();
        self.nextPageUrl.clear();
        self.ordered = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListResponse {
    // message fields
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // repeated .Bucket bucket = 1;


    pub fn get_bucket(&self) -> &[Bucket] {
        &self.bucket
    }

    // repeated .DocV2 doc = 2;


    pub fn get_doc(&self) -> &[DocV2] {
        &self.doc
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bucket {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.doc {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &ListResponse| { &m.bucket },
                |m: &mut ListResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &ListResponse| { &m.doc },
                |m: &mut ListResponse| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListResponse>(
                "ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ::protobuf::rt::LazyV2<ListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListResponse::new)
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.bucket.clear();
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocV1 {
    // message fields
    pub finskyDoc: ::protobuf::SingularPtrField<Document>,
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedListUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByListUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub relatedBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedHeader: ::protobuf::SingularField<::std::string::String>,
    pub moreByHeader: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub plusOneData: ::protobuf::SingularPtrField<PlusOneData>,
    pub warningMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocV1 {
    fn default() -> &'a DocV1 {
        <DocV1 as ::protobuf::Message>::default_instance()
    }
}

impl DocV1 {
    pub fn new() -> DocV1 {
        ::std::default::Default::default()
    }

    // optional .Document finskyDoc = 1;


    pub fn get_finskyDoc(&self) -> &Document {
        self.finskyDoc.as_ref().unwrap_or_else(|| <Document as ::protobuf::Message>::default_instance())
    }

    // optional string docid = 2;


    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string detailsUrl = 3;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewsUrl = 4;


    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedListUrl = 5;


    pub fn get_relatedListUrl(&self) -> &str {
        match self.relatedListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByListUrl = 6;


    pub fn get_moreByListUrl(&self) -> &str {
        match self.moreByListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string shareUrl = 7;


    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string creator = 8;


    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DocumentDetails details = 9;


    pub fn get_details(&self) -> &DocumentDetails {
        self.details.as_ref().unwrap_or_else(|| <DocumentDetails as ::protobuf::Message>::default_instance())
    }

    // optional string descriptionHtml = 10;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedBrowseUrl = 11;


    pub fn get_relatedBrowseUrl(&self) -> &str {
        match self.relatedBrowseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByBrowseUrl = 12;


    pub fn get_moreByBrowseUrl(&self) -> &str {
        match self.moreByBrowseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedHeader = 13;


    pub fn get_relatedHeader(&self) -> &str {
        match self.relatedHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByHeader = 14;


    pub fn get_moreByHeader(&self) -> &str {
        match self.moreByHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 15;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .PlusOneData plusOneData = 16;


    pub fn get_plusOneData(&self) -> &PlusOneData {
        self.plusOneData.as_ref().unwrap_or_else(|| <PlusOneData as ::protobuf::Message>::default_instance())
    }

    // optional string warningMessage = 17;


    pub fn get_warningMessage(&self) -> &str {
        match self.warningMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocV1 {
    fn is_initialized(&self) -> bool {
        for v in &self.finskyDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finskyDoc)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedListUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByListUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedBrowseUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByBrowseUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedHeader)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByHeader)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusOneData)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.warningMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.finskyDoc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.relatedListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.moreByListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.relatedBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.moreByBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.relatedHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.moreByHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.finskyDoc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.relatedListUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.moreByListUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.creator.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.relatedBrowseUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.moreByBrowseUrl.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.relatedHeader.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.moreByHeader.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            os.write_string(17, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV1 {
        DocV1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "finskyDoc",
                |m: &DocV1| { &m.finskyDoc },
                |m: &mut DocV1| { &mut m.finskyDoc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &DocV1| { &m.docid },
                |m: &mut DocV1| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &DocV1| { &m.detailsUrl },
                |m: &mut DocV1| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewsUrl",
                |m: &DocV1| { &m.reviewsUrl },
                |m: &mut DocV1| { &mut m.reviewsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedListUrl",
                |m: &DocV1| { &m.relatedListUrl },
                |m: &mut DocV1| { &mut m.relatedListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByListUrl",
                |m: &DocV1| { &m.moreByListUrl },
                |m: &mut DocV1| { &mut m.moreByListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareUrl",
                |m: &DocV1| { &m.shareUrl },
                |m: &mut DocV1| { &mut m.shareUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creator",
                |m: &DocV1| { &m.creator },
                |m: &mut DocV1| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>>(
                "details",
                |m: &DocV1| { &m.details },
                |m: &mut DocV1| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &DocV1| { &m.descriptionHtml },
                |m: &mut DocV1| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedBrowseUrl",
                |m: &DocV1| { &m.relatedBrowseUrl },
                |m: &mut DocV1| { &mut m.relatedBrowseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByBrowseUrl",
                |m: &DocV1| { &m.moreByBrowseUrl },
                |m: &mut DocV1| { &mut m.moreByBrowseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedHeader",
                |m: &DocV1| { &m.relatedHeader },
                |m: &mut DocV1| { &mut m.relatedHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByHeader",
                |m: &DocV1| { &m.moreByHeader },
                |m: &mut DocV1| { &mut m.moreByHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocV1| { &m.title },
                |m: &mut DocV1| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneData>>(
                "plusOneData",
                |m: &DocV1| { &m.plusOneData },
                |m: &mut DocV1| { &mut m.plusOneData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "warningMessage",
                |m: &DocV1| { &m.warningMessage },
                |m: &mut DocV1| { &mut m.warningMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocV1>(
                "DocV1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV1 {
        static instance: ::protobuf::rt::LazyV2<DocV1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocV1::new)
    }
}

impl ::protobuf::Clear for DocV1 {
    fn clear(&mut self) {
        self.finskyDoc.clear();
        self.docid.clear();
        self.detailsUrl.clear();
        self.reviewsUrl.clear();
        self.relatedListUrl.clear();
        self.moreByListUrl.clear();
        self.shareUrl.clear();
        self.creator.clear();
        self.details.clear();
        self.descriptionHtml.clear();
        self.relatedBrowseUrl.clear();
        self.moreByBrowseUrl.clear();
        self.relatedHeader.clear();
        self.moreByHeader.clear();
        self.title.clear();
        self.plusOneData.clear();
        self.warningMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Annotations {
    // message fields
    pub sectionRelated: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionMoreBy: ::protobuf::SingularPtrField<SectionMetadata>,
    pub plusOneData: ::protobuf::SingularPtrField<PlusOneData>,
    pub warning: ::protobuf::RepeatedField<Warning>,
    pub sectionBodyOfWork: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionCoreContent: ::protobuf::SingularPtrField<SectionMetadata>,
    pub template: ::protobuf::SingularPtrField<Template>,
    pub badgeForCreator: ::protobuf::RepeatedField<Badge>,
    pub badgeForDoc: ::protobuf::RepeatedField<Badge>,
    pub link: ::protobuf::SingularPtrField<Link>,
    pub sectionCrossSell: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionRelatedDocType: ::protobuf::SingularPtrField<SectionMetadata>,
    pub promotedDoc: ::protobuf::RepeatedField<PromotedDoc>,
    pub offerNote: ::protobuf::SingularField<::std::string::String>,
    pub subscription: ::protobuf::RepeatedField<DocV2>,
    pub oBSOLETEReason: ::protobuf::SingularPtrField<OBSOLETE_Reason>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    pub suggestionReasons: ::protobuf::SingularPtrField<SuggestionReasons>,
    pub optimalDeviceClassWarning: ::protobuf::SingularPtrField<Warning>,
    pub docBadgeContainer: ::protobuf::RepeatedField<BadgeContainer>,
    pub sectionSuggestForRating: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionRateAndReview: ::protobuf::SingularPtrField<SectionMetadata>,
    pub sectionPurchaseCrossSell: ::protobuf::SingularPtrField<SectionMetadata>,
    pub overflowLink: ::protobuf::RepeatedField<OverflowLink>,
    pub creatorDoc: ::protobuf::SingularPtrField<DocV2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Annotations {
    fn default() -> &'a Annotations {
        <Annotations as ::protobuf::Message>::default_instance()
    }
}

impl Annotations {
    pub fn new() -> Annotations {
        ::std::default::Default::default()
    }

    // optional .SectionMetadata sectionRelated = 1;


    pub fn get_sectionRelated(&self) -> &SectionMetadata {
        self.sectionRelated.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionMoreBy = 2;


    pub fn get_sectionMoreBy(&self) -> &SectionMetadata {
        self.sectionMoreBy.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .PlusOneData plusOneData = 3;


    pub fn get_plusOneData(&self) -> &PlusOneData {
        self.plusOneData.as_ref().unwrap_or_else(|| <PlusOneData as ::protobuf::Message>::default_instance())
    }

    // repeated .Warning warning = 4;


    pub fn get_warning(&self) -> &[Warning] {
        &self.warning
    }

    // optional .SectionMetadata sectionBodyOfWork = 5;


    pub fn get_sectionBodyOfWork(&self) -> &SectionMetadata {
        self.sectionBodyOfWork.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionCoreContent = 6;


    pub fn get_sectionCoreContent(&self) -> &SectionMetadata {
        self.sectionCoreContent.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .Template template = 7;


    pub fn get_template(&self) -> &Template {
        self.template.as_ref().unwrap_or_else(|| <Template as ::protobuf::Message>::default_instance())
    }

    // repeated .Badge badgeForCreator = 8;


    pub fn get_badgeForCreator(&self) -> &[Badge] {
        &self.badgeForCreator
    }

    // repeated .Badge badgeForDoc = 9;


    pub fn get_badgeForDoc(&self) -> &[Badge] {
        &self.badgeForDoc
    }

    // optional .Link link = 10;


    pub fn get_link(&self) -> &Link {
        self.link.as_ref().unwrap_or_else(|| <Link as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionCrossSell = 11;


    pub fn get_sectionCrossSell(&self) -> &SectionMetadata {
        self.sectionCrossSell.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionRelatedDocType = 12;


    pub fn get_sectionRelatedDocType(&self) -> &SectionMetadata {
        self.sectionRelatedDocType.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // repeated .PromotedDoc promotedDoc = 13;


    pub fn get_promotedDoc(&self) -> &[PromotedDoc] {
        &self.promotedDoc
    }

    // optional string offerNote = 14;


    pub fn get_offerNote(&self) -> &str {
        match self.offerNote.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .DocV2 subscription = 16;


    pub fn get_subscription(&self) -> &[DocV2] {
        &self.subscription
    }

    // optional .OBSOLETE_Reason oBSOLETEReason = 17;


    pub fn get_oBSOLETEReason(&self) -> &OBSOLETE_Reason {
        self.oBSOLETEReason.as_ref().unwrap_or_else(|| <OBSOLETE_Reason as ::protobuf::Message>::default_instance())
    }

    // optional string privacyPolicyUrl = 18;


    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SuggestionReasons suggestionReasons = 19;


    pub fn get_suggestionReasons(&self) -> &SuggestionReasons {
        self.suggestionReasons.as_ref().unwrap_or_else(|| <SuggestionReasons as ::protobuf::Message>::default_instance())
    }

    // optional .Warning optimalDeviceClassWarning = 20;


    pub fn get_optimalDeviceClassWarning(&self) -> &Warning {
        self.optimalDeviceClassWarning.as_ref().unwrap_or_else(|| <Warning as ::protobuf::Message>::default_instance())
    }

    // repeated .BadgeContainer docBadgeContainer = 21;


    pub fn get_docBadgeContainer(&self) -> &[BadgeContainer] {
        &self.docBadgeContainer
    }

    // optional .SectionMetadata sectionSuggestForRating = 22;


    pub fn get_sectionSuggestForRating(&self) -> &SectionMetadata {
        self.sectionSuggestForRating.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionRateAndReview = 23;


    pub fn get_sectionRateAndReview(&self) -> &SectionMetadata {
        self.sectionRateAndReview.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .SectionMetadata sectionPurchaseCrossSell = 24;


    pub fn get_sectionPurchaseCrossSell(&self) -> &SectionMetadata {
        self.sectionPurchaseCrossSell.as_ref().unwrap_or_else(|| <SectionMetadata as ::protobuf::Message>::default_instance())
    }

    // repeated .OverflowLink overflowLink = 25;


    pub fn get_overflowLink(&self) -> &[OverflowLink] {
        &self.overflowLink
    }

    // optional .DocV2 creatorDoc = 26;


    pub fn get_creatorDoc(&self) -> &DocV2 {
        self.creatorDoc.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Annotations {
    fn is_initialized(&self) -> bool {
        for v in &self.sectionRelated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionMoreBy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warning {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionBodyOfWork {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionCoreContent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badgeForCreator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badgeForDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionCrossSell {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionRelatedDocType {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.promotedDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oBSOLETEReason {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.suggestionReasons {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.optimalDeviceClassWarning {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docBadgeContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionSuggestForRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionRateAndReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sectionPurchaseCrossSell {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overflowLink {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creatorDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionRelated)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionMoreBy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusOneData)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.warning)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionBodyOfWork)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionCoreContent)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badgeForCreator)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badgeForDoc)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionCrossSell)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionRelatedDocType)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.promotedDoc)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerNote)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscription)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oBSOLETEReason)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.suggestionReasons)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.optimalDeviceClassWarning)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.docBadgeContainer)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionSuggestForRating)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionRateAndReview)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sectionPurchaseCrossSell)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.overflowLink)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creatorDoc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sectionRelated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionMoreBy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.warning {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sectionBodyOfWork.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionCoreContent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.badgeForCreator {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.badgeForDoc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionCrossSell.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionRelatedDocType.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.promotedDoc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.offerNote.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.subscription {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.oBSOLETEReason.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.suggestionReasons.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.optimalDeviceClassWarning.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.docBadgeContainer {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sectionSuggestForRating.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionRateAndReview.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sectionPurchaseCrossSell.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.overflowLink {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.creatorDoc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sectionRelated.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionMoreBy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.warning {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sectionBodyOfWork.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionCoreContent.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.badgeForCreator {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.badgeForDoc {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionCrossSell.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionRelatedDocType.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.promotedDoc {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.offerNote.as_ref() {
            os.write_string(14, &v)?;
        }
        for v in &self.subscription {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.oBSOLETEReason.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.suggestionReasons.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.optimalDeviceClassWarning.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.docBadgeContainer {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sectionSuggestForRating.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionRateAndReview.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sectionPurchaseCrossSell.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.overflowLink {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.creatorDoc.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotations {
        Annotations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionRelated",
                |m: &Annotations| { &m.sectionRelated },
                |m: &mut Annotations| { &mut m.sectionRelated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionMoreBy",
                |m: &Annotations| { &m.sectionMoreBy },
                |m: &mut Annotations| { &mut m.sectionMoreBy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneData>>(
                "plusOneData",
                |m: &Annotations| { &m.plusOneData },
                |m: &mut Annotations| { &mut m.plusOneData },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Warning>>(
                "warning",
                |m: &Annotations| { &m.warning },
                |m: &mut Annotations| { &mut m.warning },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionBodyOfWork",
                |m: &Annotations| { &m.sectionBodyOfWork },
                |m: &mut Annotations| { &mut m.sectionBodyOfWork },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionCoreContent",
                |m: &Annotations| { &m.sectionCoreContent },
                |m: &mut Annotations| { &mut m.sectionCoreContent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Template>>(
                "template",
                |m: &Annotations| { &m.template },
                |m: &mut Annotations| { &mut m.template },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badgeForCreator",
                |m: &Annotations| { &m.badgeForCreator },
                |m: &mut Annotations| { &mut m.badgeForCreator },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badgeForDoc",
                |m: &Annotations| { &m.badgeForDoc },
                |m: &mut Annotations| { &mut m.badgeForDoc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>>(
                "link",
                |m: &Annotations| { &m.link },
                |m: &mut Annotations| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionCrossSell",
                |m: &Annotations| { &m.sectionCrossSell },
                |m: &mut Annotations| { &mut m.sectionCrossSell },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionRelatedDocType",
                |m: &Annotations| { &m.sectionRelatedDocType },
                |m: &mut Annotations| { &mut m.sectionRelatedDocType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PromotedDoc>>(
                "promotedDoc",
                |m: &Annotations| { &m.promotedDoc },
                |m: &mut Annotations| { &mut m.promotedDoc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offerNote",
                |m: &Annotations| { &m.offerNote },
                |m: &mut Annotations| { &mut m.offerNote },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "subscription",
                |m: &Annotations| { &m.subscription },
                |m: &mut Annotations| { &mut m.subscription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OBSOLETE_Reason>>(
                "oBSOLETEReason",
                |m: &Annotations| { &m.oBSOLETEReason },
                |m: &mut Annotations| { &mut m.oBSOLETEReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privacyPolicyUrl",
                |m: &Annotations| { &m.privacyPolicyUrl },
                |m: &mut Annotations| { &mut m.privacyPolicyUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SuggestionReasons>>(
                "suggestionReasons",
                |m: &Annotations| { &m.suggestionReasons },
                |m: &mut Annotations| { &mut m.suggestionReasons },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Warning>>(
                "optimalDeviceClassWarning",
                |m: &Annotations| { &m.optimalDeviceClassWarning },
                |m: &mut Annotations| { &mut m.optimalDeviceClassWarning },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BadgeContainer>>(
                "docBadgeContainer",
                |m: &Annotations| { &m.docBadgeContainer },
                |m: &mut Annotations| { &mut m.docBadgeContainer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionSuggestForRating",
                |m: &Annotations| { &m.sectionSuggestForRating },
                |m: &mut Annotations| { &mut m.sectionSuggestForRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionRateAndReview",
                |m: &Annotations| { &m.sectionRateAndReview },
                |m: &mut Annotations| { &mut m.sectionRateAndReview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SectionMetadata>>(
                "sectionPurchaseCrossSell",
                |m: &Annotations| { &m.sectionPurchaseCrossSell },
                |m: &mut Annotations| { &mut m.sectionPurchaseCrossSell },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OverflowLink>>(
                "overflowLink",
                |m: &Annotations| { &m.overflowLink },
                |m: &mut Annotations| { &mut m.overflowLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "creatorDoc",
                |m: &Annotations| { &m.creatorDoc },
                |m: &mut Annotations| { &mut m.creatorDoc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Annotations>(
                "Annotations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Annotations {
        static instance: ::protobuf::rt::LazyV2<Annotations> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Annotations::new)
    }
}

impl ::protobuf::Clear for Annotations {
    fn clear(&mut self) {
        self.sectionRelated.clear();
        self.sectionMoreBy.clear();
        self.plusOneData.clear();
        self.warning.clear();
        self.sectionBodyOfWork.clear();
        self.sectionCoreContent.clear();
        self.template.clear();
        self.badgeForCreator.clear();
        self.badgeForDoc.clear();
        self.link.clear();
        self.sectionCrossSell.clear();
        self.sectionRelatedDocType.clear();
        self.promotedDoc.clear();
        self.offerNote.clear();
        self.subscription.clear();
        self.oBSOLETEReason.clear();
        self.privacyPolicyUrl.clear();
        self.suggestionReasons.clear();
        self.optimalDeviceClassWarning.clear();
        self.docBadgeContainer.clear();
        self.sectionSuggestForRating.clear();
        self.sectionRateAndReview.clear();
        self.sectionPurchaseCrossSell.clear();
        self.overflowLink.clear();
        self.creatorDoc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OverflowLink {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub link: ::protobuf::SingularPtrField<Link>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OverflowLink {
    fn default() -> &'a OverflowLink {
        <OverflowLink as ::protobuf::Message>::default_instance()
    }
}

impl OverflowLink {
    pub fn new() -> OverflowLink {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Link link = 2;


    pub fn get_link(&self) -> &Link {
        self.link.as_ref().unwrap_or_else(|| <Link as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for OverflowLink {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OverflowLink {
        OverflowLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &OverflowLink| { &m.title },
                |m: &mut OverflowLink| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>>(
                "link",
                |m: &OverflowLink| { &m.link },
                |m: &mut OverflowLink| { &mut m.link },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OverflowLink>(
                "OverflowLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OverflowLink {
        static instance: ::protobuf::rt::LazyV2<OverflowLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OverflowLink::new)
    }
}

impl ::protobuf::Clear for OverflowLink {
    fn clear(&mut self) {
        self.title.clear();
        self.link.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OverflowLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OverflowLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReviewTip {
    // message fields
    pub tipUrl: ::protobuf::SingularField<::std::string::String>,
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub polarity: ::std::option::Option<i32>,
    pub reviewCount: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReviewTip {
    fn default() -> &'a ReviewTip {
        <ReviewTip as ::protobuf::Message>::default_instance()
    }
}

impl ReviewTip {
    pub fn new() -> ReviewTip {
        ::std::default::Default::default()
    }

    // optional string tipUrl = 1;


    pub fn get_tipUrl(&self) -> &str {
        match self.tipUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 polarity = 3;


    pub fn get_polarity(&self) -> i32 {
        self.polarity.unwrap_or(0)
    }

    // optional int64 reviewCount = 4;


    pub fn get_reviewCount(&self) -> i64 {
        self.reviewCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ReviewTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tipUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.polarity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.reviewCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tipUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.polarity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reviewCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tipUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.polarity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.reviewCount {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewTip {
        ReviewTip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tipUrl",
                |m: &ReviewTip| { &m.tipUrl },
                |m: &mut ReviewTip| { &mut m.tipUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &ReviewTip| { &m.text },
                |m: &mut ReviewTip| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "polarity",
                |m: &ReviewTip| { &m.polarity },
                |m: &mut ReviewTip| { &mut m.polarity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "reviewCount",
                |m: &ReviewTip| { &m.reviewCount },
                |m: &mut ReviewTip| { &mut m.reviewCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReviewTip>(
                "ReviewTip",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewTip {
        static instance: ::protobuf::rt::LazyV2<ReviewTip> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReviewTip::new)
    }
}

impl ::protobuf::Clear for ReviewTip {
    fn clear(&mut self) {
        self.tipUrl.clear();
        self.text.clear();
        self.polarity = ::std::option::Option::None;
        self.reviewCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewTip {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocV2 {
    // message fields
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub docType: ::std::option::Option<i32>,
    pub backendId: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<DocV2>,
    pub containerMetadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub annotations: ::protobuf::SingularPtrField<Annotations>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub backendUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub detailsReusable: ::std::option::Option<bool>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub translatedDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub productDetails: ::protobuf::SingularPtrField<ProductDetails>,
    pub mature: ::std::option::Option<bool>,
    pub promotionalDescription: ::protobuf::SingularField<::std::string::String>,
    pub availabileForPreregistration: ::std::option::Option<bool>,
    pub tip: ::protobuf::RepeatedField<ReviewTip>,
    pub snippetsUrl: ::protobuf::SingularField<::std::string::String>,
    pub forceShareability: ::std::option::Option<bool>,
    pub useWishlistAsPrimaryAction: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocV2 {
    fn default() -> &'a DocV2 {
        <DocV2 as ::protobuf::Message>::default_instance()
    }
}

impl DocV2 {
    pub fn new() -> DocV2 {
        ::std::default::Default::default()
    }

    // optional string docid = 1;


    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string backendDocid = 2;


    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 docType = 3;


    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional int32 backendId = 4;


    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string creator = 6;


    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 7;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Offer offer = 8;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // optional .Availability availability = 9;


    pub fn get_availability(&self) -> &Availability {
        self.availability.as_ref().unwrap_or_else(|| <Availability as ::protobuf::Message>::default_instance())
    }

    // repeated .Image image = 10;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated .DocV2 child = 11;


    pub fn get_child(&self) -> &[DocV2] {
        &self.child
    }

    // optional .ContainerMetadata containerMetadata = 12;


    pub fn get_containerMetadata(&self) -> &ContainerMetadata {
        self.containerMetadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .DocumentDetails details = 13;


    pub fn get_details(&self) -> &DocumentDetails {
        self.details.as_ref().unwrap_or_else(|| <DocumentDetails as ::protobuf::Message>::default_instance())
    }

    // optional .AggregateRating aggregateRating = 14;


    pub fn get_aggregateRating(&self) -> &AggregateRating {
        self.aggregateRating.as_ref().unwrap_or_else(|| <AggregateRating as ::protobuf::Message>::default_instance())
    }

    // optional .Annotations annotations = 15;


    pub fn get_annotations(&self) -> &Annotations {
        self.annotations.as_ref().unwrap_or_else(|| <Annotations as ::protobuf::Message>::default_instance())
    }

    // optional string detailsUrl = 16;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string shareUrl = 17;


    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewsUrl = 18;


    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string backendUrl = 19;


    pub fn get_backendUrl(&self) -> &str {
        match self.backendUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseDetailsUrl = 20;


    pub fn get_purchaseDetailsUrl(&self) -> &str {
        match self.purchaseDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool detailsReusable = 21;


    pub fn get_detailsReusable(&self) -> bool {
        self.detailsReusable.unwrap_or(false)
    }

    // optional string subtitle = 22;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string translatedDescriptionHtml = 23;


    pub fn get_translatedDescriptionHtml(&self) -> &str {
        match self.translatedDescriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 24;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .ProductDetails productDetails = 25;


    pub fn get_productDetails(&self) -> &ProductDetails {
        self.productDetails.as_ref().unwrap_or_else(|| <ProductDetails as ::protobuf::Message>::default_instance())
    }

    // optional bool mature = 26;


    pub fn get_mature(&self) -> bool {
        self.mature.unwrap_or(false)
    }

    // optional string promotionalDescription = 27;


    pub fn get_promotionalDescription(&self) -> &str {
        match self.promotionalDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool availabileForPreregistration = 29;


    pub fn get_availabileForPreregistration(&self) -> bool {
        self.availabileForPreregistration.unwrap_or(false)
    }

    // repeated .ReviewTip tip = 30;


    pub fn get_tip(&self) -> &[ReviewTip] {
        &self.tip
    }

    // optional string snippetsUrl = 31;


    pub fn get_snippetsUrl(&self) -> &str {
        match self.snippetsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool forceShareability = 32;


    pub fn get_forceShareability(&self) -> bool {
        self.forceShareability.unwrap_or(false)
    }

    // optional bool useWishlistAsPrimaryAction = 33;


    pub fn get_useWishlistAsPrimaryAction(&self) -> bool {
        self.useWishlistAsPrimaryAction.unwrap_or(false)
    }
}

impl ::protobuf::Message for DocV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.annotations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.productDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.containerMetadata)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregateRating)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.annotations)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseDetailsUrl)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detailsReusable = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.translatedDescriptionHtml)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.productDetails)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mature = ::std::option::Option::Some(tmp);
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promotionalDescription)?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.availabileForPreregistration = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tip)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snippetsUrl)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forceShareability = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.useWishlistAsPrimaryAction = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.containerMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.annotations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.backendUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.purchaseDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.detailsReusable {
            my_size += 3;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(ref v) = self.translatedDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(24, &v);
        }
        if let Some(ref v) = self.productDetails.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mature {
            my_size += 3;
        }
        if let Some(ref v) = self.promotionalDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.availabileForPreregistration {
            my_size += 3;
        }
        for value in &self.tip {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.snippetsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.forceShareability {
            my_size += 3;
        }
        if let Some(v) = self.useWishlistAsPrimaryAction {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.backendDocid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.creator.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.offer {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.availability.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.image {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.child {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.containerMetadata.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.aggregateRating.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.annotations.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.backendUrl.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.purchaseDetailsUrl.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.detailsReusable {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(22, &v)?;
        }
        if let Some(ref v) = self.translatedDescriptionHtml.as_ref() {
            os.write_string(23, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(24, &v)?;
        }
        if let Some(ref v) = self.productDetails.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mature {
            os.write_bool(26, v)?;
        }
        if let Some(ref v) = self.promotionalDescription.as_ref() {
            os.write_string(27, &v)?;
        }
        if let Some(v) = self.availabileForPreregistration {
            os.write_bool(29, v)?;
        }
        for v in &self.tip {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.snippetsUrl.as_ref() {
            os.write_string(31, &v)?;
        }
        if let Some(v) = self.forceShareability {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.useWishlistAsPrimaryAction {
            os.write_bool(33, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV2 {
        DocV2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &DocV2| { &m.docid },
                |m: &mut DocV2| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendDocid",
                |m: &DocV2| { &m.backendDocid },
                |m: &mut DocV2| { &mut m.backendDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "docType",
                |m: &DocV2| { &m.docType },
                |m: &mut DocV2| { &mut m.docType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backendId",
                |m: &DocV2| { &m.backendId },
                |m: &mut DocV2| { &mut m.backendId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocV2| { &m.title },
                |m: &mut DocV2| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creator",
                |m: &DocV2| { &m.creator },
                |m: &mut DocV2| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &DocV2| { &m.descriptionHtml },
                |m: &mut DocV2| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocV2| { &m.offer },
                |m: &mut DocV2| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                "availability",
                |m: &DocV2| { &m.availability },
                |m: &mut DocV2| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DocV2| { &m.image },
                |m: &mut DocV2| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "child",
                |m: &DocV2| { &m.child },
                |m: &mut DocV2| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "containerMetadata",
                |m: &DocV2| { &m.containerMetadata },
                |m: &mut DocV2| { &mut m.containerMetadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>>(
                "details",
                |m: &DocV2| { &m.details },
                |m: &mut DocV2| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>>(
                "aggregateRating",
                |m: &DocV2| { &m.aggregateRating },
                |m: &mut DocV2| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotations>>(
                "annotations",
                |m: &DocV2| { &m.annotations },
                |m: &mut DocV2| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &DocV2| { &m.detailsUrl },
                |m: &mut DocV2| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareUrl",
                |m: &DocV2| { &m.shareUrl },
                |m: &mut DocV2| { &mut m.shareUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewsUrl",
                |m: &DocV2| { &m.reviewsUrl },
                |m: &mut DocV2| { &mut m.reviewsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendUrl",
                |m: &DocV2| { &m.backendUrl },
                |m: &mut DocV2| { &mut m.backendUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseDetailsUrl",
                |m: &DocV2| { &m.purchaseDetailsUrl },
                |m: &mut DocV2| { &mut m.purchaseDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detailsReusable",
                |m: &DocV2| { &m.detailsReusable },
                |m: &mut DocV2| { &mut m.detailsReusable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &DocV2| { &m.subtitle },
                |m: &mut DocV2| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "translatedDescriptionHtml",
                |m: &DocV2| { &m.translatedDescriptionHtml },
                |m: &mut DocV2| { &mut m.translatedDescriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &DocV2| { &m.serverLogsCookie },
                |m: &mut DocV2| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetails>>(
                "productDetails",
                |m: &DocV2| { &m.productDetails },
                |m: &mut DocV2| { &mut m.productDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mature",
                |m: &DocV2| { &m.mature },
                |m: &mut DocV2| { &mut m.mature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotionalDescription",
                |m: &DocV2| { &m.promotionalDescription },
                |m: &mut DocV2| { &mut m.promotionalDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "availabileForPreregistration",
                |m: &DocV2| { &m.availabileForPreregistration },
                |m: &mut DocV2| { &mut m.availabileForPreregistration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewTip>>(
                "tip",
                |m: &DocV2| { &m.tip },
                |m: &mut DocV2| { &mut m.tip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippetsUrl",
                |m: &DocV2| { &m.snippetsUrl },
                |m: &mut DocV2| { &mut m.snippetsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forceShareability",
                |m: &DocV2| { &m.forceShareability },
                |m: &mut DocV2| { &mut m.forceShareability },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "useWishlistAsPrimaryAction",
                |m: &DocV2| { &m.useWishlistAsPrimaryAction },
                |m: &mut DocV2| { &mut m.useWishlistAsPrimaryAction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocV2>(
                "DocV2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV2 {
        static instance: ::protobuf::rt::LazyV2<DocV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocV2::new)
    }
}

impl ::protobuf::Clear for DocV2 {
    fn clear(&mut self) {
        self.docid.clear();
        self.backendDocid.clear();
        self.docType = ::std::option::Option::None;
        self.backendId = ::std::option::Option::None;
        self.title.clear();
        self.creator.clear();
        self.descriptionHtml.clear();
        self.offer.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.containerMetadata.clear();
        self.details.clear();
        self.aggregateRating.clear();
        self.annotations.clear();
        self.detailsUrl.clear();
        self.shareUrl.clear();
        self.reviewsUrl.clear();
        self.backendUrl.clear();
        self.purchaseDetailsUrl.clear();
        self.detailsReusable = ::std::option::Option::None;
        self.subtitle.clear();
        self.translatedDescriptionHtml.clear();
        self.serverLogsCookie.clear();
        self.productDetails.clear();
        self.mature = ::std::option::Option::None;
        self.promotionalDescription.clear();
        self.availabileForPreregistration = ::std::option::Option::None;
        self.tip.clear();
        self.snippetsUrl.clear();
        self.forceShareability = ::std::option::Option::None;
        self.useWishlistAsPrimaryAction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProductDetails {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub section: ::protobuf::RepeatedField<ProductDetailsSection>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductDetails {
    fn default() -> &'a ProductDetails {
        <ProductDetails as ::protobuf::Message>::default_instance()
    }
}

impl ProductDetails {
    pub fn new() -> ProductDetails {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ProductDetailsSection section = 2;


    pub fn get_section(&self) -> &[ProductDetailsSection] {
        &self.section
    }
}

impl ::protobuf::Message for ProductDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.section {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.section)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.section {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.section {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetails {
        ProductDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ProductDetails| { &m.title },
                |m: &mut ProductDetails| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetailsSection>>(
                "section",
                |m: &ProductDetails| { &m.section },
                |m: &mut ProductDetails| { &mut m.section },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductDetails>(
                "ProductDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetails {
        static instance: ::protobuf::rt::LazyV2<ProductDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductDetails::new)
    }
}

impl ::protobuf::Clear for ProductDetails {
    fn clear(&mut self) {
        self.title.clear();
        self.section.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProductDetailsSection {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::RepeatedField<ProductDetailsDescription>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductDetailsSection {
    fn default() -> &'a ProductDetailsSection {
        <ProductDetailsSection as ::protobuf::Message>::default_instance()
    }
}

impl ProductDetailsSection {
    pub fn new() -> ProductDetailsSection {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ProductDetailsDescription description = 3;


    pub fn get_description(&self) -> &[ProductDetailsDescription] {
        &self.description
    }
}

impl ::protobuf::Message for ProductDetailsSection {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.description {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.description {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetailsSection {
        ProductDetailsSection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ProductDetailsSection| { &m.title },
                |m: &mut ProductDetailsSection| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProductDetailsDescription>>(
                "description",
                |m: &ProductDetailsSection| { &m.description },
                |m: &mut ProductDetailsSection| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductDetailsSection>(
                "ProductDetailsSection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetailsSection {
        static instance: ::protobuf::rt::LazyV2<ProductDetailsSection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductDetailsSection::new)
    }
}

impl ::protobuf::Clear for ProductDetailsSection {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetailsSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailsSection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ProductDetailsDescription {
    // message fields
    pub image: ::protobuf::SingularPtrField<Image>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProductDetailsDescription {
    fn default() -> &'a ProductDetailsDescription {
        <ProductDetailsDescription as ::protobuf::Message>::default_instance()
    }
}

impl ProductDetailsDescription {
    pub fn new() -> ProductDetailsDescription {
        ::std::default::Default::default()
    }

    // optional .Image image = 1;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional string description = 2;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ProductDetailsDescription {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProductDetailsDescription {
        ProductDetailsDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &ProductDetailsDescription| { &m.image },
                |m: &mut ProductDetailsDescription| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ProductDetailsDescription| { &m.description },
                |m: &mut ProductDetailsDescription| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProductDetailsDescription>(
                "ProductDetailsDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProductDetailsDescription {
        static instance: ::protobuf::rt::LazyV2<ProductDetailsDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProductDetailsDescription::new)
    }
}

impl ::protobuf::Clear for ProductDetailsDescription {
    fn clear(&mut self) {
        self.image.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProductDetailsDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailsDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EncryptedSubscriberInfo {
    // message fields
    pub data: ::protobuf::SingularField<::std::string::String>,
    pub encryptedKey: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub initVector: ::protobuf::SingularField<::std::string::String>,
    pub googleKeyVersion: ::std::option::Option<i32>,
    pub carrierKeyVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptedSubscriberInfo {
    fn default() -> &'a EncryptedSubscriberInfo {
        <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance()
    }
}

impl EncryptedSubscriberInfo {
    pub fn new() -> EncryptedSubscriberInfo {
        ::std::default::Default::default()
    }

    // optional string data = 1;


    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string encryptedKey = 2;


    pub fn get_encryptedKey(&self) -> &str {
        match self.encryptedKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 3;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string initVector = 4;


    pub fn get_initVector(&self) -> &str {
        match self.initVector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 googleKeyVersion = 5;


    pub fn get_googleKeyVersion(&self) -> i32 {
        self.googleKeyVersion.unwrap_or(0)
    }

    // optional int32 carrierKeyVersion = 6;


    pub fn get_carrierKeyVersion(&self) -> i32 {
        self.carrierKeyVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for EncryptedSubscriberInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptedKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initVector)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.googleKeyVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.carrierKeyVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.initVector.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.googleKeyVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.carrierKeyVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.initVector.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.googleKeyVersion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.carrierKeyVersion {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedSubscriberInfo {
        EncryptedSubscriberInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &EncryptedSubscriberInfo| { &m.data },
                |m: &mut EncryptedSubscriberInfo| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryptedKey",
                |m: &EncryptedSubscriberInfo| { &m.encryptedKey },
                |m: &mut EncryptedSubscriberInfo| { &mut m.encryptedKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &EncryptedSubscriberInfo| { &m.signature },
                |m: &mut EncryptedSubscriberInfo| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initVector",
                |m: &EncryptedSubscriberInfo| { &m.initVector },
                |m: &mut EncryptedSubscriberInfo| { &mut m.initVector },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "googleKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.googleKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.googleKeyVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "carrierKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.carrierKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.carrierKeyVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptedSubscriberInfo>(
                "EncryptedSubscriberInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptedSubscriberInfo {
        static instance: ::protobuf::rt::LazyV2<EncryptedSubscriberInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptedSubscriberInfo::new)
    }
}

impl ::protobuf::Clear for EncryptedSubscriberInfo {
    fn clear(&mut self) {
        self.data.clear();
        self.encryptedKey.clear();
        self.signature.clear();
        self.initVector.clear();
        self.googleKeyVersion = ::std::option::Option::None;
        self.carrierKeyVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedSubscriberInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedSubscriberInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Availability {
    // message fields
    pub restriction: ::std::option::Option<i32>,
    pub offerType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    // perdeviceavailabilityrestriction: <group>
    pub availableIfOwned: ::std::option::Option<bool>,
    pub install: ::protobuf::RepeatedField<Install>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    pub ownershipInfo: ::protobuf::SingularPtrField<OwnershipInfo>,
    pub availabilityProblem: ::protobuf::RepeatedField<AvailabilityProblem>,
    pub hidden: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability {
    fn default() -> &'a Availability {
        <Availability as ::protobuf::Message>::default_instance()
    }
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    // optional int32 restriction = 5;


    pub fn get_restriction(&self) -> i32 {
        self.restriction.unwrap_or(0)
    }

    // optional int32 offerType = 6;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional .Rule rule = 7;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // optional bool availableIfOwned = 13;


    pub fn get_availableIfOwned(&self) -> bool {
        self.availableIfOwned.unwrap_or(false)
    }

    // repeated .Install install = 14;


    pub fn get_install(&self) -> &[Install] {
        &self.install
    }

    // optional .FilterEvaluationInfo filterInfo = 16;


    pub fn get_filterInfo(&self) -> &FilterEvaluationInfo {
        self.filterInfo.as_ref().unwrap_or_else(|| <FilterEvaluationInfo as ::protobuf::Message>::default_instance())
    }

    // optional .OwnershipInfo ownershipInfo = 17;


    pub fn get_ownershipInfo(&self) -> &OwnershipInfo {
        self.ownershipInfo.as_ref().unwrap_or_else(|| <OwnershipInfo as ::protobuf::Message>::default_instance())
    }

    // repeated .AvailabilityProblem availabilityProblem = 18;


    pub fn get_availabilityProblem(&self) -> &[AvailabilityProblem] {
        &self.availabilityProblem
    }

    // optional bool hidden = 21;


    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
}

impl ::protobuf::Message for Availability {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.install {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownershipInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availabilityProblem {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restriction = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.availableIfOwned = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.install)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filterInfo)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ownershipInfo)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.availabilityProblem)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.restriction {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.availableIfOwned {
            my_size += 2;
        }
        for value in &self.install {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ownershipInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.availabilityProblem {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hidden {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.restriction {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.availableIfOwned {
            os.write_bool(13, v)?;
        }
        for v in &self.install {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.filterInfo.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ownershipInfo.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.availabilityProblem {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hidden {
            os.write_bool(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "restriction",
                |m: &Availability| { &m.restriction },
                |m: &mut Availability| { &mut m.restriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &Availability| { &m.offerType },
                |m: &mut Availability| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &Availability| { &m.rule },
                |m: &mut Availability| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "availableIfOwned",
                |m: &Availability| { &m.availableIfOwned },
                |m: &mut Availability| { &mut m.availableIfOwned },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Install>>(
                "install",
                |m: &Availability| { &m.install },
                |m: &mut Availability| { &mut m.install },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>>(
                "filterInfo",
                |m: &Availability| { &m.filterInfo },
                |m: &mut Availability| { &mut m.filterInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OwnershipInfo>>(
                "ownershipInfo",
                |m: &Availability| { &m.ownershipInfo },
                |m: &mut Availability| { &mut m.ownershipInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AvailabilityProblem>>(
                "availabilityProblem",
                |m: &Availability| { &m.availabilityProblem },
                |m: &mut Availability| { &mut m.availabilityProblem },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hidden",
                |m: &Availability| { &m.hidden },
                |m: &mut Availability| { &mut m.hidden },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Availability>(
                "Availability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability {
        static instance: ::protobuf::rt::LazyV2<Availability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Availability::new)
    }
}

impl ::protobuf::Clear for Availability {
    fn clear(&mut self) {
        self.restriction = ::std::option::Option::None;
        self.offerType = ::std::option::Option::None;
        self.rule.clear();
        self.availableIfOwned = ::std::option::Option::None;
        self.install.clear();
        self.filterInfo.clear();
        self.ownershipInfo.clear();
        self.availabilityProblem.clear();
        self.hidden = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Availability_PerDeviceAvailabilityRestriction {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub deviceRestriction: ::std::option::Option<i32>,
    pub channelId: ::std::option::Option<i64>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability_PerDeviceAvailabilityRestriction {
    fn default() -> &'a Availability_PerDeviceAvailabilityRestriction {
        <Availability_PerDeviceAvailabilityRestriction as ::protobuf::Message>::default_instance()
    }
}

impl Availability_PerDeviceAvailabilityRestriction {
    pub fn new() -> Availability_PerDeviceAvailabilityRestriction {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 10;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 deviceRestriction = 11;


    pub fn get_deviceRestriction(&self) -> i32 {
        self.deviceRestriction.unwrap_or(0)
    }

    // optional int64 channelId = 12;


    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }

    // optional .FilterEvaluationInfo filterInfo = 15;


    pub fn get_filterInfo(&self) -> &FilterEvaluationInfo {
        self.filterInfo.as_ref().unwrap_or_else(|| <FilterEvaluationInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Availability_PerDeviceAvailabilityRestriction {
    fn is_initialized(&self) -> bool {
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceRestriction = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filterInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.deviceRestriction {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.deviceRestriction {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.channelId {
            os.write_int64(12, v)?;
        }
        if let Some(ref v) = self.filterInfo.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability_PerDeviceAvailabilityRestriction {
        Availability_PerDeviceAvailabilityRestriction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.androidId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceRestriction",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.deviceRestriction },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.deviceRestriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "channelId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.channelId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.channelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>>(
                "filterInfo",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.filterInfo },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.filterInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Availability_PerDeviceAvailabilityRestriction>(
                "Availability.PerDeviceAvailabilityRestriction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability_PerDeviceAvailabilityRestriction {
        static instance: ::protobuf::rt::LazyV2<Availability_PerDeviceAvailabilityRestriction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Availability_PerDeviceAvailabilityRestriction::new)
    }
}

impl ::protobuf::Clear for Availability_PerDeviceAvailabilityRestriction {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.deviceRestriction = ::std::option::Option::None;
        self.channelId = ::std::option::Option::None;
        self.filterInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability_PerDeviceAvailabilityRestriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability_PerDeviceAvailabilityRestriction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AvailabilityProblem {
    // message fields
    pub problemType: ::std::option::Option<i32>,
    pub missingValue: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AvailabilityProblem {
    fn default() -> &'a AvailabilityProblem {
        <AvailabilityProblem as ::protobuf::Message>::default_instance()
    }
}

impl AvailabilityProblem {
    pub fn new() -> AvailabilityProblem {
        ::std::default::Default::default()
    }

    // optional int32 problemType = 1;


    pub fn get_problemType(&self) -> i32 {
        self.problemType.unwrap_or(0)
    }

    // repeated string missingValue = 2;


    pub fn get_missingValue(&self) -> &[::std::string::String] {
        &self.missingValue
    }
}

impl ::protobuf::Message for AvailabilityProblem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.problemType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.missingValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.problemType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.missingValue {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.problemType {
            os.write_int32(1, v)?;
        }
        for v in &self.missingValue {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvailabilityProblem {
        AvailabilityProblem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "problemType",
                |m: &AvailabilityProblem| { &m.problemType },
                |m: &mut AvailabilityProblem| { &mut m.problemType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "missingValue",
                |m: &AvailabilityProblem| { &m.missingValue },
                |m: &mut AvailabilityProblem| { &mut m.missingValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AvailabilityProblem>(
                "AvailabilityProblem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvailabilityProblem {
        static instance: ::protobuf::rt::LazyV2<AvailabilityProblem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AvailabilityProblem::new)
    }
}

impl ::protobuf::Clear for AvailabilityProblem {
    fn clear(&mut self) {
        self.problemType = ::std::option::Option::None;
        self.missingValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvailabilityProblem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailabilityProblem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FilterEvaluationInfo {
    // message fields
    pub ruleEvaluation: ::protobuf::RepeatedField<RuleEvaluation>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterEvaluationInfo {
    fn default() -> &'a FilterEvaluationInfo {
        <FilterEvaluationInfo as ::protobuf::Message>::default_instance()
    }
}

impl FilterEvaluationInfo {
    pub fn new() -> FilterEvaluationInfo {
        ::std::default::Default::default()
    }

    // repeated .RuleEvaluation ruleEvaluation = 1;


    pub fn get_ruleEvaluation(&self) -> &[RuleEvaluation] {
        &self.ruleEvaluation
    }
}

impl ::protobuf::Message for FilterEvaluationInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.ruleEvaluation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ruleEvaluation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ruleEvaluation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ruleEvaluation {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterEvaluationInfo {
        FilterEvaluationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuleEvaluation>>(
                "ruleEvaluation",
                |m: &FilterEvaluationInfo| { &m.ruleEvaluation },
                |m: &mut FilterEvaluationInfo| { &mut m.ruleEvaluation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterEvaluationInfo>(
                "FilterEvaluationInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterEvaluationInfo {
        static instance: ::protobuf::rt::LazyV2<FilterEvaluationInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterEvaluationInfo::new)
    }
}

impl ::protobuf::Clear for FilterEvaluationInfo {
    fn clear(&mut self) {
        self.ruleEvaluation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterEvaluationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterEvaluationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Rule {
    // message fields
    pub negate: ::std::option::Option<bool>,
    pub operator: ::std::option::Option<i32>,
    pub key: ::std::option::Option<i32>,
    pub stringArg: ::protobuf::RepeatedField<::std::string::String>,
    pub longArg: ::std::vec::Vec<i64>,
    pub doubleArg: ::std::vec::Vec<f64>,
    pub subrule: ::protobuf::RepeatedField<Rule>,
    pub responseCode: ::std::option::Option<i32>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub stringArgHash: ::std::vec::Vec<u64>,
    pub constArg: ::std::vec::Vec<i32>,
    pub availabilityProblemType: ::std::option::Option<i32>,
    pub includeMissingValues: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rule {
    fn default() -> &'a Rule {
        <Rule as ::protobuf::Message>::default_instance()
    }
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    // optional bool negate = 1;


    pub fn get_negate(&self) -> bool {
        self.negate.unwrap_or(false)
    }

    // optional int32 operator = 2;


    pub fn get_operator(&self) -> i32 {
        self.operator.unwrap_or(0)
    }

    // optional int32 key = 3;


    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // repeated string stringArg = 4;


    pub fn get_stringArg(&self) -> &[::std::string::String] {
        &self.stringArg
    }

    // repeated int64 longArg = 5;


    pub fn get_longArg(&self) -> &[i64] {
        &self.longArg
    }

    // repeated double doubleArg = 6;


    pub fn get_doubleArg(&self) -> &[f64] {
        &self.doubleArg
    }

    // repeated .Rule subrule = 7;


    pub fn get_subrule(&self) -> &[Rule] {
        &self.subrule
    }

    // optional int32 responseCode = 8;


    pub fn get_responseCode(&self) -> i32 {
        self.responseCode.unwrap_or(0)
    }

    // optional string comment = 9;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated fixed64 stringArgHash = 10;


    pub fn get_stringArgHash(&self) -> &[u64] {
        &self.stringArgHash
    }

    // repeated int32 constArg = 11;


    pub fn get_constArg(&self) -> &[i32] {
        &self.constArg
    }

    // optional int32 availabilityProblemType = 12;


    pub fn get_availabilityProblemType(&self) -> i32 {
        self.availabilityProblemType.unwrap_or(0)
    }

    // optional bool includeMissingValues = 13;


    pub fn get_includeMissingValues(&self) -> bool {
        self.includeMissingValues.unwrap_or(false)
    }
}

impl ::protobuf::Message for Rule {
    fn is_initialized(&self) -> bool {
        for v in &self.subrule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.operator = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.stringArg)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.longArg)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.doubleArg)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subrule)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.responseCode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.stringArgHash)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.constArg)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.availabilityProblemType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeMissingValues = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.negate {
            my_size += 2;
        }
        if let Some(v) = self.operator {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stringArg {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.longArg {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.doubleArg.len() as u32;
        for value in &self.subrule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.responseCode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += 9 * self.stringArgHash.len() as u32;
        for value in &self.constArg {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.availabilityProblemType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.includeMissingValues {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.negate {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.operator {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.key {
            os.write_int32(3, v)?;
        }
        for v in &self.stringArg {
            os.write_string(4, &v)?;
        };
        for v in &self.longArg {
            os.write_int64(5, *v)?;
        };
        for v in &self.doubleArg {
            os.write_double(6, *v)?;
        };
        for v in &self.subrule {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.responseCode {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.stringArgHash {
            os.write_fixed64(10, *v)?;
        };
        for v in &self.constArg {
            os.write_int32(11, *v)?;
        };
        if let Some(v) = self.availabilityProblemType {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.includeMissingValues {
            os.write_bool(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "negate",
                |m: &Rule| { &m.negate },
                |m: &mut Rule| { &mut m.negate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "operator",
                |m: &Rule| { &m.operator },
                |m: &mut Rule| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key",
                |m: &Rule| { &m.key },
                |m: &mut Rule| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stringArg",
                |m: &Rule| { &m.stringArg },
                |m: &mut Rule| { &mut m.stringArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "longArg",
                |m: &Rule| { &m.longArg },
                |m: &mut Rule| { &mut m.longArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "doubleArg",
                |m: &Rule| { &m.doubleArg },
                |m: &mut Rule| { &mut m.doubleArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "subrule",
                |m: &Rule| { &m.subrule },
                |m: &mut Rule| { &mut m.subrule },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "responseCode",
                |m: &Rule| { &m.responseCode },
                |m: &mut Rule| { &mut m.responseCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &Rule| { &m.comment },
                |m: &mut Rule| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "stringArgHash",
                |m: &Rule| { &m.stringArgHash },
                |m: &mut Rule| { &mut m.stringArgHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "constArg",
                |m: &Rule| { &m.constArg },
                |m: &mut Rule| { &mut m.constArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "availabilityProblemType",
                |m: &Rule| { &m.availabilityProblemType },
                |m: &mut Rule| { &mut m.availabilityProblemType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "includeMissingValues",
                |m: &Rule| { &m.includeMissingValues },
                |m: &mut Rule| { &mut m.includeMissingValues },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rule>(
                "Rule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rule {
        static instance: ::protobuf::rt::LazyV2<Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rule::new)
    }
}

impl ::protobuf::Clear for Rule {
    fn clear(&mut self) {
        self.negate = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.stringArg.clear();
        self.longArg.clear();
        self.doubleArg.clear();
        self.subrule.clear();
        self.responseCode = ::std::option::Option::None;
        self.comment.clear();
        self.stringArgHash.clear();
        self.constArg.clear();
        self.availabilityProblemType = ::std::option::Option::None;
        self.includeMissingValues = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuleEvaluation {
    // message fields
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub actualStringValue: ::protobuf::RepeatedField<::std::string::String>,
    pub actualLongValue: ::std::vec::Vec<i64>,
    pub actualBoolValue: ::std::vec::Vec<bool>,
    pub actualDoubleValue: ::std::vec::Vec<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuleEvaluation {
    fn default() -> &'a RuleEvaluation {
        <RuleEvaluation as ::protobuf::Message>::default_instance()
    }
}

impl RuleEvaluation {
    pub fn new() -> RuleEvaluation {
        ::std::default::Default::default()
    }

    // optional .Rule rule = 1;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // repeated string actualStringValue = 2;


    pub fn get_actualStringValue(&self) -> &[::std::string::String] {
        &self.actualStringValue
    }

    // repeated int64 actualLongValue = 3;


    pub fn get_actualLongValue(&self) -> &[i64] {
        &self.actualLongValue
    }

    // repeated bool actualBoolValue = 4;


    pub fn get_actualBoolValue(&self) -> &[bool] {
        &self.actualBoolValue
    }

    // repeated double actualDoubleValue = 5;


    pub fn get_actualDoubleValue(&self) -> &[f64] {
        &self.actualDoubleValue
    }
}

impl ::protobuf::Message for RuleEvaluation {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actualStringValue)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.actualLongValue)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.actualBoolValue)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.actualDoubleValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.actualStringValue {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.actualLongValue {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 2 * self.actualBoolValue.len() as u32;
        my_size += 9 * self.actualDoubleValue.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.actualStringValue {
            os.write_string(2, &v)?;
        };
        for v in &self.actualLongValue {
            os.write_int64(3, *v)?;
        };
        for v in &self.actualBoolValue {
            os.write_bool(4, *v)?;
        };
        for v in &self.actualDoubleValue {
            os.write_double(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuleEvaluation {
        RuleEvaluation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &RuleEvaluation| { &m.rule },
                |m: &mut RuleEvaluation| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actualStringValue",
                |m: &RuleEvaluation| { &m.actualStringValue },
                |m: &mut RuleEvaluation| { &mut m.actualStringValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "actualLongValue",
                |m: &RuleEvaluation| { &m.actualLongValue },
                |m: &mut RuleEvaluation| { &mut m.actualLongValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "actualBoolValue",
                |m: &RuleEvaluation| { &m.actualBoolValue },
                |m: &mut RuleEvaluation| { &mut m.actualBoolValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "actualDoubleValue",
                |m: &RuleEvaluation| { &m.actualDoubleValue },
                |m: &mut RuleEvaluation| { &mut m.actualDoubleValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuleEvaluation>(
                "RuleEvaluation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuleEvaluation {
        static instance: ::protobuf::rt::LazyV2<RuleEvaluation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuleEvaluation::new)
    }
}

impl ::protobuf::Clear for RuleEvaluation {
    fn clear(&mut self) {
        self.rule.clear();
        self.actualStringValue.clear();
        self.actualLongValue.clear();
        self.actualBoolValue.clear();
        self.actualDoubleValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuleEvaluation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleEvaluation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GroupLicenseInfo {
    // message fields
    pub licensedOfferType: ::std::option::Option<i32>,
    pub gaiaGroupId: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupLicenseInfo {
    fn default() -> &'a GroupLicenseInfo {
        <GroupLicenseInfo as ::protobuf::Message>::default_instance()
    }
}

impl GroupLicenseInfo {
    pub fn new() -> GroupLicenseInfo {
        ::std::default::Default::default()
    }

    // optional int32 licensedOfferType = 1;


    pub fn get_licensedOfferType(&self) -> i32 {
        self.licensedOfferType.unwrap_or(0)
    }

    // optional fixed64 gaiaGroupId = 2;


    pub fn get_gaiaGroupId(&self) -> u64 {
        self.gaiaGroupId.unwrap_or(0)
    }
}

impl ::protobuf::Message for GroupLicenseInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.licensedOfferType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gaiaGroupId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.licensedOfferType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gaiaGroupId {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.licensedOfferType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gaiaGroupId {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupLicenseInfo {
        GroupLicenseInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "licensedOfferType",
                |m: &GroupLicenseInfo| { &m.licensedOfferType },
                |m: &mut GroupLicenseInfo| { &mut m.licensedOfferType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gaiaGroupId",
                |m: &GroupLicenseInfo| { &m.gaiaGroupId },
                |m: &mut GroupLicenseInfo| { &mut m.gaiaGroupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupLicenseInfo>(
                "GroupLicenseInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupLicenseInfo {
        static instance: ::protobuf::rt::LazyV2<GroupLicenseInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupLicenseInfo::new)
    }
}

impl ::protobuf::Clear for GroupLicenseInfo {
    fn clear(&mut self) {
        self.licensedOfferType = ::std::option::Option::None;
        self.gaiaGroupId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupLicenseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupLicenseInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LicensedDocumentInfo {
    // message fields
    pub gaiaGroupId: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LicensedDocumentInfo {
    fn default() -> &'a LicensedDocumentInfo {
        <LicensedDocumentInfo as ::protobuf::Message>::default_instance()
    }
}

impl LicensedDocumentInfo {
    pub fn new() -> LicensedDocumentInfo {
        ::std::default::Default::default()
    }

    // repeated fixed64 gaiaGroupId = 1;


    pub fn get_gaiaGroupId(&self) -> &[u64] {
        &self.gaiaGroupId
    }
}

impl ::protobuf::Message for LicensedDocumentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.gaiaGroupId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.gaiaGroupId.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gaiaGroupId {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LicensedDocumentInfo {
        LicensedDocumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gaiaGroupId",
                |m: &LicensedDocumentInfo| { &m.gaiaGroupId },
                |m: &mut LicensedDocumentInfo| { &mut m.gaiaGroupId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LicensedDocumentInfo>(
                "LicensedDocumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LicensedDocumentInfo {
        static instance: ::protobuf::rt::LazyV2<LicensedDocumentInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LicensedDocumentInfo::new)
    }
}

impl ::protobuf::Clear for LicensedDocumentInfo {
    fn clear(&mut self) {
        self.gaiaGroupId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LicensedDocumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LicensedDocumentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryAppDetails {
    // message fields
    pub certificateHash: ::protobuf::SingularField<::std::string::String>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryAppDetails {
    fn default() -> &'a LibraryAppDetails {
        <LibraryAppDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibraryAppDetails {
    pub fn new() -> LibraryAppDetails {
        ::std::default::Default::default()
    }

    // optional string certificateHash = 2;


    pub fn get_certificateHash(&self) -> &str {
        match self.certificateHash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 refundTimeoutTimestampMsec = 3;


    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 4;


    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificateHash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificateHash.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryAppDetails {
        LibraryAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &LibraryAppDetails| { &m.certificateHash },
                |m: &mut LibraryAppDetails| { &mut m.certificateHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutTimestampMsec",
                |m: &LibraryAppDetails| { &m.refundTimeoutTimestampMsec },
                |m: &mut LibraryAppDetails| { &mut m.refundTimeoutTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postDeliveryRefundWindowMsec",
                |m: &LibraryAppDetails| { &m.postDeliveryRefundWindowMsec },
                |m: &mut LibraryAppDetails| { &mut m.postDeliveryRefundWindowMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryAppDetails>(
                "LibraryAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryAppDetails {
        static instance: ::protobuf::rt::LazyV2<LibraryAppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryAppDetails {
    fn clear(&mut self) {
        self.certificateHash.clear();
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryAppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryInAppDetails {
    // message fields
    pub signedPurchaseData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryInAppDetails {
    fn default() -> &'a LibraryInAppDetails {
        <LibraryInAppDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibraryInAppDetails {
    pub fn new() -> LibraryInAppDetails {
        ::std::default::Default::default()
    }

    // optional string signedPurchaseData = 1;


    pub fn get_signedPurchaseData(&self) -> &str {
        match self.signedPurchaseData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 2;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryInAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedPurchaseData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryInAppDetails {
        LibraryInAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedPurchaseData",
                |m: &LibraryInAppDetails| { &m.signedPurchaseData },
                |m: &mut LibraryInAppDetails| { &mut m.signedPurchaseData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &LibraryInAppDetails| { &m.signature },
                |m: &mut LibraryInAppDetails| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryInAppDetails>(
                "LibraryInAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryInAppDetails {
        static instance: ::protobuf::rt::LazyV2<LibraryInAppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryInAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryInAppDetails {
    fn clear(&mut self) {
        self.signedPurchaseData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryInAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryInAppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryMutation {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub offerType: ::std::option::Option<i32>,
    pub documentHash: ::std::option::Option<i64>,
    pub deleted: ::std::option::Option<bool>,
    pub appDetails: ::protobuf::SingularPtrField<LibraryAppDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<LibrarySubscriptionDetails>,
    pub inAppDetails: ::protobuf::SingularPtrField<LibraryInAppDetails>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryMutation {
    fn default() -> &'a LibraryMutation {
        <LibraryMutation as ::protobuf::Message>::default_instance()
    }
}

impl LibraryMutation {
    pub fn new() -> LibraryMutation {
        ::std::default::Default::default()
    }

    // optional .Docid docid = 1;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional int32 offerType = 2;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int64 documentHash = 3;


    pub fn get_documentHash(&self) -> i64 {
        self.documentHash.unwrap_or(0)
    }

    // optional bool deleted = 4;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    // optional .LibraryAppDetails appDetails = 5;


    pub fn get_appDetails(&self) -> &LibraryAppDetails {
        self.appDetails.as_ref().unwrap_or_else(|| <LibraryAppDetails as ::protobuf::Message>::default_instance())
    }

    // optional .LibrarySubscriptionDetails subscriptionDetails = 6;


    pub fn get_subscriptionDetails(&self) -> &LibrarySubscriptionDetails {
        self.subscriptionDetails.as_ref().unwrap_or_else(|| <LibrarySubscriptionDetails as ::protobuf::Message>::default_instance())
    }

    // optional .LibraryInAppDetails inAppDetails = 7;


    pub fn get_inAppDetails(&self) -> &LibraryInAppDetails {
        self.inAppDetails.as_ref().unwrap_or_else(|| <LibraryInAppDetails as ::protobuf::Message>::default_instance())
    }

    // optional int64 validUntilTimestampMsec = 8;


    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryMutation {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.documentHash = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppDetails)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.documentHash {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(ref v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.documentHash {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.appDetails.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppDetails.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryMutation {
        LibraryMutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &LibraryMutation| { &m.docid },
                |m: &mut LibraryMutation| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &LibraryMutation| { &m.offerType },
                |m: &mut LibraryMutation| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "documentHash",
                |m: &LibraryMutation| { &m.documentHash },
                |m: &mut LibraryMutation| { &mut m.documentHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &LibraryMutation| { &m.deleted },
                |m: &mut LibraryMutation| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryAppDetails>>(
                "appDetails",
                |m: &LibraryMutation| { &m.appDetails },
                |m: &mut LibraryMutation| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibrarySubscriptionDetails>>(
                "subscriptionDetails",
                |m: &LibraryMutation| { &m.subscriptionDetails },
                |m: &mut LibraryMutation| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryInAppDetails>>(
                "inAppDetails",
                |m: &LibraryMutation| { &m.inAppDetails },
                |m: &mut LibraryMutation| { &mut m.inAppDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "validUntilTimestampMsec",
                |m: &LibraryMutation| { &m.validUntilTimestampMsec },
                |m: &mut LibraryMutation| { &mut m.validUntilTimestampMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryMutation>(
                "LibraryMutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryMutation {
        static instance: ::protobuf::rt::LazyV2<LibraryMutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryMutation::new)
    }
}

impl ::protobuf::Clear for LibraryMutation {
    fn clear(&mut self) {
        self.docid.clear();
        self.offerType = ::std::option::Option::None;
        self.documentHash = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.appDetails.clear();
        self.subscriptionDetails.clear();
        self.inAppDetails.clear();
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryMutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibrarySubscriptionDetails {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub deprecatedValidUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub trialUntilTimestampMsec: ::std::option::Option<i64>,
    pub signedPurchaseData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibrarySubscriptionDetails {
    fn default() -> &'a LibrarySubscriptionDetails {
        <LibrarySubscriptionDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibrarySubscriptionDetails {
    pub fn new() -> LibrarySubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;


    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 deprecatedValidUntilTimestampMsec = 2;


    pub fn get_deprecatedValidUntilTimestampMsec(&self) -> i64 {
        self.deprecatedValidUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;


    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 trialUntilTimestampMsec = 4;


    pub fn get_trialUntilTimestampMsec(&self) -> i64 {
        self.trialUntilTimestampMsec.unwrap_or(0)
    }

    // optional string signedPurchaseData = 5;


    pub fn get_signedPurchaseData(&self) -> &str {
        match self.signedPurchaseData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 6;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibrarySubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deprecatedValidUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.trialUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedPurchaseData)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deprecatedValidUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.deprecatedValidUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibrarySubscriptionDetails {
        LibrarySubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initiationTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.initiationTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.initiationTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "deprecatedValidUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.deprecatedValidUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.deprecatedValidUntilTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoRenewing",
                |m: &LibrarySubscriptionDetails| { &m.autoRenewing },
                |m: &mut LibrarySubscriptionDetails| { &mut m.autoRenewing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "trialUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.trialUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.trialUntilTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedPurchaseData",
                |m: &LibrarySubscriptionDetails| { &m.signedPurchaseData },
                |m: &mut LibrarySubscriptionDetails| { &mut m.signedPurchaseData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &LibrarySubscriptionDetails| { &m.signature },
                |m: &mut LibrarySubscriptionDetails| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibrarySubscriptionDetails>(
                "LibrarySubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibrarySubscriptionDetails {
        static instance: ::protobuf::rt::LazyV2<LibrarySubscriptionDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibrarySubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for LibrarySubscriptionDetails {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.deprecatedValidUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.trialUntilTimestampMsec = ::std::option::Option::None;
        self.signedPurchaseData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibrarySubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibrarySubscriptionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryUpdate {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub mutation: ::protobuf::RepeatedField<LibraryMutation>,
    pub hasMore: ::std::option::Option<bool>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryUpdate {
    fn default() -> &'a LibraryUpdate {
        <LibraryUpdate as ::protobuf::Message>::default_instance()
    }
}

impl LibraryUpdate {
    pub fn new() -> LibraryUpdate {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional int32 corpus = 2;


    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 3;


    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .LibraryMutation mutation = 4;


    pub fn get_mutation(&self) -> &[LibraryMutation] {
        &self.mutation
    }

    // optional bool hasMore = 5;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    // optional string libraryId = 6;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mutation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.mutation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.corpus {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.mutation {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryUpdate {
        LibraryUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &LibraryUpdate| { &m.status },
                |m: &mut LibraryUpdate| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "corpus",
                |m: &LibraryUpdate| { &m.corpus },
                |m: &mut LibraryUpdate| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverToken",
                |m: &LibraryUpdate| { &m.serverToken },
                |m: &mut LibraryUpdate| { &mut m.serverToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryMutation>>(
                "mutation",
                |m: &LibraryUpdate| { &m.mutation },
                |m: &mut LibraryUpdate| { &mut m.mutation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &LibraryUpdate| { &m.hasMore },
                |m: &mut LibraryUpdate| { &mut m.hasMore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &LibraryUpdate| { &m.libraryId },
                |m: &mut LibraryUpdate| { &mut m.libraryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryUpdate>(
                "LibraryUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryUpdate {
        static instance: ::protobuf::rt::LazyV2<LibraryUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryUpdate::new)
    }
}

impl ::protobuf::Clear for LibraryUpdate {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.mutation.clear();
        self.hasMore = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientLibraryState {
    // message fields
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub hashCodeSum: ::std::option::Option<i64>,
    pub librarySize: ::std::option::Option<i32>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientLibraryState {
    fn default() -> &'a ClientLibraryState {
        <ClientLibraryState as ::protobuf::Message>::default_instance()
    }
}

impl ClientLibraryState {
    pub fn new() -> ClientLibraryState {
        ::std::default::Default::default()
    }

    // optional int32 corpus = 1;


    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 2;


    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int64 hashCodeSum = 3;


    pub fn get_hashCodeSum(&self) -> i64 {
        self.hashCodeSum.unwrap_or(0)
    }

    // optional int32 librarySize = 4;


    pub fn get_librarySize(&self) -> i32 {
        self.librarySize.unwrap_or(0)
    }

    // optional string libraryId = 5;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientLibraryState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.hashCodeSum = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.librarySize = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.hashCodeSum {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.librarySize {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.corpus {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.hashCodeSum {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.librarySize {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientLibraryState {
        ClientLibraryState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "corpus",
                |m: &ClientLibraryState| { &m.corpus },
                |m: &mut ClientLibraryState| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverToken",
                |m: &ClientLibraryState| { &m.serverToken },
                |m: &mut ClientLibraryState| { &mut m.serverToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "hashCodeSum",
                |m: &ClientLibraryState| { &m.hashCodeSum },
                |m: &mut ClientLibraryState| { &mut m.hashCodeSum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "librarySize",
                |m: &ClientLibraryState| { &m.librarySize },
                |m: &mut ClientLibraryState| { &mut m.librarySize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &ClientLibraryState| { &m.libraryId },
                |m: &mut ClientLibraryState| { &mut m.libraryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientLibraryState>(
                "ClientLibraryState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientLibraryState {
        static instance: ::protobuf::rt::LazyV2<ClientLibraryState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientLibraryState::new)
    }
}

impl ::protobuf::Clear for ClientLibraryState {
    fn clear(&mut self) {
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.hashCodeSum = ::std::option::Option::None;
        self.librarySize = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientLibraryState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientLibraryState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryReplicationRequest {
    // message fields
    pub libraryState: ::protobuf::RepeatedField<ClientLibraryState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryReplicationRequest {
    fn default() -> &'a LibraryReplicationRequest {
        <LibraryReplicationRequest as ::protobuf::Message>::default_instance()
    }
}

impl LibraryReplicationRequest {
    pub fn new() -> LibraryReplicationRequest {
        ::std::default::Default::default()
    }

    // repeated .ClientLibraryState libraryState = 1;


    pub fn get_libraryState(&self) -> &[ClientLibraryState] {
        &self.libraryState
    }
}

impl ::protobuf::Message for LibraryReplicationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.libraryState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.libraryState {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.libraryState {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryReplicationRequest {
        LibraryReplicationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientLibraryState>>(
                "libraryState",
                |m: &LibraryReplicationRequest| { &m.libraryState },
                |m: &mut LibraryReplicationRequest| { &mut m.libraryState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryReplicationRequest>(
                "LibraryReplicationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryReplicationRequest {
        static instance: ::protobuf::rt::LazyV2<LibraryReplicationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryReplicationRequest::new)
    }
}

impl ::protobuf::Clear for LibraryReplicationRequest {
    fn clear(&mut self) {
        self.libraryState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryReplicationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryReplicationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryReplicationResponse {
    // message fields
    pub update: ::protobuf::RepeatedField<LibraryUpdate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryReplicationResponse {
    fn default() -> &'a LibraryReplicationResponse {
        <LibraryReplicationResponse as ::protobuf::Message>::default_instance()
    }
}

impl LibraryReplicationResponse {
    pub fn new() -> LibraryReplicationResponse {
        ::std::default::Default::default()
    }

    // repeated .LibraryUpdate update = 1;


    pub fn get_update(&self) -> &[LibraryUpdate] {
        &self.update
    }
}

impl ::protobuf::Message for LibraryReplicationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.update {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryReplicationResponse {
        LibraryReplicationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "update",
                |m: &LibraryReplicationResponse| { &m.update },
                |m: &mut LibraryReplicationResponse| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryReplicationResponse>(
                "LibraryReplicationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryReplicationResponse {
        static instance: ::protobuf::rt::LazyV2<LibraryReplicationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryReplicationResponse::new)
    }
}

impl ::protobuf::Clear for LibraryReplicationResponse {
    fn clear(&mut self) {
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryReplicationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryReplicationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClickLogEvent {
    // message fields
    pub eventTime: ::std::option::Option<i64>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub listId: ::protobuf::SingularField<::std::string::String>,
    pub referrerUrl: ::protobuf::SingularField<::std::string::String>,
    pub referrerListId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClickLogEvent {
    fn default() -> &'a ClickLogEvent {
        <ClickLogEvent as ::protobuf::Message>::default_instance()
    }
}

impl ClickLogEvent {
    pub fn new() -> ClickLogEvent {
        ::std::default::Default::default()
    }

    // optional int64 eventTime = 1;


    pub fn get_eventTime(&self) -> i64 {
        self.eventTime.unwrap_or(0)
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string listId = 3;


    pub fn get_listId(&self) -> &str {
        match self.listId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string referrerUrl = 4;


    pub fn get_referrerUrl(&self) -> &str {
        match self.referrerUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string referrerListId = 5;


    pub fn get_referrerListId(&self) -> &str {
        match self.referrerListId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClickLogEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.eventTime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.listId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerListId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.listId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.referrerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.referrerListId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventTime {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.listId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.referrerUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.referrerListId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClickLogEvent {
        ClickLogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "eventTime",
                |m: &ClickLogEvent| { &m.eventTime },
                |m: &mut ClickLogEvent| { &mut m.eventTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ClickLogEvent| { &m.url },
                |m: &mut ClickLogEvent| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "listId",
                |m: &ClickLogEvent| { &m.listId },
                |m: &mut ClickLogEvent| { &mut m.listId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referrerUrl",
                |m: &ClickLogEvent| { &m.referrerUrl },
                |m: &mut ClickLogEvent| { &mut m.referrerUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referrerListId",
                |m: &ClickLogEvent| { &m.referrerListId },
                |m: &mut ClickLogEvent| { &mut m.referrerListId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClickLogEvent>(
                "ClickLogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClickLogEvent {
        static instance: ::protobuf::rt::LazyV2<ClickLogEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClickLogEvent::new)
    }
}

impl ::protobuf::Clear for ClickLogEvent {
    fn clear(&mut self) {
        self.eventTime = ::std::option::Option::None;
        self.url.clear();
        self.listId.clear();
        self.referrerUrl.clear();
        self.referrerListId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClickLogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClickLogEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModifyLibraryRequest {
    // message fields
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    pub forAddDocid: ::protobuf::RepeatedField<::std::string::String>,
    pub forRemovalDocid: ::protobuf::RepeatedField<::std::string::String>,
    pub forArchiveDocid: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyLibraryRequest {
    fn default() -> &'a ModifyLibraryRequest {
        <ModifyLibraryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyLibraryRequest {
    pub fn new() -> ModifyLibraryRequest {
        ::std::default::Default::default()
    }

    // optional string libraryId = 1;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string forAddDocid = 2;


    pub fn get_forAddDocid(&self) -> &[::std::string::String] {
        &self.forAddDocid
    }

    // repeated string forRemovalDocid = 3;


    pub fn get_forRemovalDocid(&self) -> &[::std::string::String] {
        &self.forRemovalDocid
    }

    // repeated string forArchiveDocid = 4;


    pub fn get_forArchiveDocid(&self) -> &[::std::string::String] {
        &self.forArchiveDocid
    }
}

impl ::protobuf::Message for ModifyLibraryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forAddDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forRemovalDocid)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.forArchiveDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.forAddDocid {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.forRemovalDocid {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.forArchiveDocid {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.forAddDocid {
            os.write_string(2, &v)?;
        };
        for v in &self.forRemovalDocid {
            os.write_string(3, &v)?;
        };
        for v in &self.forArchiveDocid {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyLibraryRequest {
        ModifyLibraryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &ModifyLibraryRequest| { &m.libraryId },
                |m: &mut ModifyLibraryRequest| { &mut m.libraryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forAddDocid",
                |m: &ModifyLibraryRequest| { &m.forAddDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forAddDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forRemovalDocid",
                |m: &ModifyLibraryRequest| { &m.forRemovalDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forRemovalDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forArchiveDocid",
                |m: &ModifyLibraryRequest| { &m.forArchiveDocid },
                |m: &mut ModifyLibraryRequest| { &mut m.forArchiveDocid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyLibraryRequest>(
                "ModifyLibraryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyLibraryRequest {
        static instance: ::protobuf::rt::LazyV2<ModifyLibraryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyLibraryRequest::new)
    }
}

impl ::protobuf::Clear for ModifyLibraryRequest {
    fn clear(&mut self) {
        self.libraryId.clear();
        self.forAddDocid.clear();
        self.forRemovalDocid.clear();
        self.forArchiveDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyLibraryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyLibraryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModifyLibraryResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyLibraryResponse {
    fn default() -> &'a ModifyLibraryResponse {
        <ModifyLibraryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ModifyLibraryResponse {
    pub fn new() -> ModifyLibraryResponse {
        ::std::default::Default::default()
    }

    // optional .LibraryUpdate libraryUpdate = 1;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ModifyLibraryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyLibraryResponse {
        ModifyLibraryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &ModifyLibraryResponse| { &m.libraryUpdate },
                |m: &mut ModifyLibraryResponse| { &mut m.libraryUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyLibraryResponse>(
                "ModifyLibraryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyLibraryResponse {
        static instance: ::protobuf::rt::LazyV2<ModifyLibraryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyLibraryResponse::new)
    }
}

impl ::protobuf::Clear for ModifyLibraryResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyLibraryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyLibraryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppNotificationData {
    // message fields
    pub versionCode: ::std::option::Option<i32>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppNotificationData {
    fn default() -> &'a AndroidAppNotificationData {
        <AndroidAppNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppNotificationData {
    pub fn new() -> AndroidAppNotificationData {
        ::std::default::Default::default()
    }

    // optional int32 versionCode = 1;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetId = 2;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.versionCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppNotificationData {
        AndroidAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AndroidAppNotificationData| { &m.versionCode },
                |m: &mut AndroidAppNotificationData| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &AndroidAppNotificationData| { &m.assetId },
                |m: &mut AndroidAppNotificationData| { &mut m.assetId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppNotificationData>(
                "AndroidAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppNotificationData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppNotificationData::new)
    }
}

impl ::protobuf::Clear for AndroidAppNotificationData {
    fn clear(&mut self) {
        self.versionCode = ::std::option::Option::None;
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppNotificationData {
    // message fields
    pub checkoutOrderId: ::protobuf::SingularField<::std::string::String>,
    pub inAppNotificationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppNotificationData {
    fn default() -> &'a InAppNotificationData {
        <InAppNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl InAppNotificationData {
    pub fn new() -> InAppNotificationData {
        ::std::default::Default::default()
    }

    // optional string checkoutOrderId = 1;


    pub fn get_checkoutOrderId(&self) -> &str {
        match self.checkoutOrderId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string inAppNotificationId = 2;


    pub fn get_inAppNotificationId(&self) -> &str {
        match self.inAppNotificationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutOrderId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inAppNotificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checkoutOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.inAppNotificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checkoutOrderId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.inAppNotificationId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppNotificationData {
        InAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutOrderId",
                |m: &InAppNotificationData| { &m.checkoutOrderId },
                |m: &mut InAppNotificationData| { &mut m.checkoutOrderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inAppNotificationId",
                |m: &InAppNotificationData| { &m.inAppNotificationId },
                |m: &mut InAppNotificationData| { &mut m.inAppNotificationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppNotificationData>(
                "InAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppNotificationData {
        static instance: ::protobuf::rt::LazyV2<InAppNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppNotificationData::new)
    }
}

impl ::protobuf::Clear for InAppNotificationData {
    fn clear(&mut self) {
        self.checkoutOrderId.clear();
        self.inAppNotificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryDirtyData {
    // message fields
    pub backend: ::std::option::Option<i32>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryDirtyData {
    fn default() -> &'a LibraryDirtyData {
        <LibraryDirtyData as ::protobuf::Message>::default_instance()
    }
}

impl LibraryDirtyData {
    pub fn new() -> LibraryDirtyData {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string libraryId = 2;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryDirtyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryDirtyData {
        LibraryDirtyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &LibraryDirtyData| { &m.backend },
                |m: &mut LibraryDirtyData| { &mut m.backend },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &LibraryDirtyData| { &m.libraryId },
                |m: &mut LibraryDirtyData| { &mut m.libraryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryDirtyData>(
                "LibraryDirtyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryDirtyData {
        static instance: ::protobuf::rt::LazyV2<LibraryDirtyData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryDirtyData::new)
    }
}

impl ::protobuf::Clear for LibraryDirtyData {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryDirtyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryDirtyData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Notification {
    // message fields
    pub notificationType: ::std::option::Option<i32>,
    pub timestamp: ::std::option::Option<i64>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub docTitle: ::protobuf::SingularField<::std::string::String>,
    pub userEmail: ::protobuf::SingularField<::std::string::String>,
    pub appData: ::protobuf::SingularPtrField<AndroidAppNotificationData>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    pub purchaseRemovalData: ::protobuf::SingularPtrField<PurchaseRemovalData>,
    pub userNotificationData: ::protobuf::SingularPtrField<UserNotificationData>,
    pub inAppNotificationData: ::protobuf::SingularPtrField<InAppNotificationData>,
    pub purchaseDeclinedData: ::protobuf::SingularPtrField<PurchaseDeclinedData>,
    pub notificationId: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub libraryDirtyData: ::protobuf::SingularPtrField<LibraryDirtyData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Notification {
    fn default() -> &'a Notification {
        <Notification as ::protobuf::Message>::default_instance()
    }
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    // optional int32 notificationType = 1;


    pub fn get_notificationType(&self) -> i32 {
        self.notificationType.unwrap_or(0)
    }

    // optional int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional .Docid docid = 4;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional string docTitle = 5;


    pub fn get_docTitle(&self) -> &str {
        match self.docTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userEmail = 6;


    pub fn get_userEmail(&self) -> &str {
        match self.userEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AndroidAppNotificationData appData = 7;


    pub fn get_appData(&self) -> &AndroidAppNotificationData {
        self.appData.as_ref().unwrap_or_else(|| <AndroidAppNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 8;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseRemovalData purchaseRemovalData = 9;


    pub fn get_purchaseRemovalData(&self) -> &PurchaseRemovalData {
        self.purchaseRemovalData.as_ref().unwrap_or_else(|| <PurchaseRemovalData as ::protobuf::Message>::default_instance())
    }

    // optional .UserNotificationData userNotificationData = 10;


    pub fn get_userNotificationData(&self) -> &UserNotificationData {
        self.userNotificationData.as_ref().unwrap_or_else(|| <UserNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .InAppNotificationData inAppNotificationData = 11;


    pub fn get_inAppNotificationData(&self) -> &InAppNotificationData {
        self.inAppNotificationData.as_ref().unwrap_or_else(|| <InAppNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseDeclinedData purchaseDeclinedData = 12;


    pub fn get_purchaseDeclinedData(&self) -> &PurchaseDeclinedData {
        self.purchaseDeclinedData.as_ref().unwrap_or_else(|| <PurchaseDeclinedData as ::protobuf::Message>::default_instance())
    }

    // optional string notificationId = 13;


    pub fn get_notificationId(&self) -> &str {
        match self.notificationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .LibraryUpdate libraryUpdate = 14;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }

    // optional .LibraryDirtyData libraryDirtyData = 15;


    pub fn get_libraryDirtyData(&self) -> &LibraryDirtyData {
        self.libraryDirtyData.as_ref().unwrap_or_else(|| <LibraryDirtyData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseRemovalData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseDeclinedData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryDirtyData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.notificationType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docTitle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userEmail)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appData)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseRemovalData)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userNotificationData)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppNotificationData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseDeclinedData)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationId)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryDirtyData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notificationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.userEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.appData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseRemovalData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseDeclinedData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.notificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.libraryDirtyData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notificationType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docTitle.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.userEmail.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.appData.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseRemovalData.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userNotificationData.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppNotificationData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseDeclinedData.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.notificationId.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.libraryDirtyData.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "notificationType",
                |m: &Notification| { &m.notificationType },
                |m: &mut Notification| { &mut m.notificationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Notification| { &m.timestamp },
                |m: &mut Notification| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &Notification| { &m.docid },
                |m: &mut Notification| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docTitle",
                |m: &Notification| { &m.docTitle },
                |m: &mut Notification| { &mut m.docTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userEmail",
                |m: &Notification| { &m.userEmail },
                |m: &mut Notification| { &mut m.userEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppNotificationData>>(
                "appData",
                |m: &Notification| { &m.appData },
                |m: &mut Notification| { &mut m.appData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &Notification| { &m.appDeliveryData },
                |m: &mut Notification| { &mut m.appDeliveryData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseRemovalData>>(
                "purchaseRemovalData",
                |m: &Notification| { &m.purchaseRemovalData },
                |m: &mut Notification| { &mut m.purchaseRemovalData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserNotificationData>>(
                "userNotificationData",
                |m: &Notification| { &m.userNotificationData },
                |m: &mut Notification| { &mut m.userNotificationData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppNotificationData>>(
                "inAppNotificationData",
                |m: &Notification| { &m.inAppNotificationData },
                |m: &mut Notification| { &mut m.inAppNotificationData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseDeclinedData>>(
                "purchaseDeclinedData",
                |m: &Notification| { &m.purchaseDeclinedData },
                |m: &mut Notification| { &mut m.purchaseDeclinedData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &Notification| { &m.notificationId },
                |m: &mut Notification| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &Notification| { &m.libraryUpdate },
                |m: &mut Notification| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryDirtyData>>(
                "libraryDirtyData",
                |m: &Notification| { &m.libraryDirtyData },
                |m: &mut Notification| { &mut m.libraryDirtyData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Notification>(
                "Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Notification {
        static instance: ::protobuf::rt::LazyV2<Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Notification::new)
    }
}

impl ::protobuf::Clear for Notification {
    fn clear(&mut self) {
        self.notificationType = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.docid.clear();
        self.docTitle.clear();
        self.userEmail.clear();
        self.appData.clear();
        self.appDeliveryData.clear();
        self.purchaseRemovalData.clear();
        self.userNotificationData.clear();
        self.inAppNotificationData.clear();
        self.purchaseDeclinedData.clear();
        self.notificationId.clear();
        self.libraryUpdate.clear();
        self.libraryDirtyData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseDeclinedData {
    // message fields
    pub reason: ::std::option::Option<i32>,
    pub showNotification: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseDeclinedData {
    fn default() -> &'a PurchaseDeclinedData {
        <PurchaseDeclinedData as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseDeclinedData {
    pub fn new() -> PurchaseDeclinedData {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    // optional bool showNotification = 2;


    pub fn get_showNotification(&self) -> bool {
        self.showNotification.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseDeclinedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.showNotification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.showNotification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.showNotification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseDeclinedData {
        PurchaseDeclinedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reason",
                |m: &PurchaseDeclinedData| { &m.reason },
                |m: &mut PurchaseDeclinedData| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "showNotification",
                |m: &PurchaseDeclinedData| { &m.showNotification },
                |m: &mut PurchaseDeclinedData| { &mut m.showNotification },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseDeclinedData>(
                "PurchaseDeclinedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseDeclinedData {
        static instance: ::protobuf::rt::LazyV2<PurchaseDeclinedData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseDeclinedData::new)
    }
}

impl ::protobuf::Clear for PurchaseDeclinedData {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.showNotification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseDeclinedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseDeclinedData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseRemovalData {
    // message fields
    pub malicious: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseRemovalData {
    fn default() -> &'a PurchaseRemovalData {
        <PurchaseRemovalData as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseRemovalData {
    pub fn new() -> PurchaseRemovalData {
        ::std::default::Default::default()
    }

    // optional bool malicious = 1;


    pub fn get_malicious(&self) -> bool {
        self.malicious.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseRemovalData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.malicious = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.malicious {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.malicious {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseRemovalData {
        PurchaseRemovalData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "malicious",
                |m: &PurchaseRemovalData| { &m.malicious },
                |m: &mut PurchaseRemovalData| { &mut m.malicious },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseRemovalData>(
                "PurchaseRemovalData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseRemovalData {
        static instance: ::protobuf::rt::LazyV2<PurchaseRemovalData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseRemovalData::new)
    }
}

impl ::protobuf::Clear for PurchaseRemovalData {
    fn clear(&mut self) {
        self.malicious = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseRemovalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseRemovalData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserNotificationData {
    // message fields
    pub notificationTitle: ::protobuf::SingularField<::std::string::String>,
    pub notificationText: ::protobuf::SingularField<::std::string::String>,
    pub tickerText: ::protobuf::SingularField<::std::string::String>,
    pub dialogTitle: ::protobuf::SingularField<::std::string::String>,
    pub dialogText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserNotificationData {
    fn default() -> &'a UserNotificationData {
        <UserNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl UserNotificationData {
    pub fn new() -> UserNotificationData {
        ::std::default::Default::default()
    }

    // optional string notificationTitle = 1;


    pub fn get_notificationTitle(&self) -> &str {
        match self.notificationTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string notificationText = 2;


    pub fn get_notificationText(&self) -> &str {
        match self.notificationText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tickerText = 3;


    pub fn get_tickerText(&self) -> &str {
        match self.tickerText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dialogTitle = 4;


    pub fn get_dialogTitle(&self) -> &str {
        match self.dialogTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dialogText = 5;


    pub fn get_dialogText(&self) -> &str {
        match self.dialogText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UserNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationText)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tickerText)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogTitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.notificationTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.notificationText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.tickerText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.dialogTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.dialogText.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.notificationTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.notificationText.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.tickerText.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.dialogTitle.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.dialogText.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserNotificationData {
        UserNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationTitle",
                |m: &UserNotificationData| { &m.notificationTitle },
                |m: &mut UserNotificationData| { &mut m.notificationTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationText",
                |m: &UserNotificationData| { &m.notificationText },
                |m: &mut UserNotificationData| { &mut m.notificationText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tickerText",
                |m: &UserNotificationData| { &m.tickerText },
                |m: &mut UserNotificationData| { &mut m.tickerText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dialogTitle",
                |m: &UserNotificationData| { &m.dialogTitle },
                |m: &mut UserNotificationData| { &mut m.dialogTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dialogText",
                |m: &UserNotificationData| { &m.dialogText },
                |m: &mut UserNotificationData| { &mut m.dialogText },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserNotificationData>(
                "UserNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserNotificationData {
        static instance: ::protobuf::rt::LazyV2<UserNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserNotificationData::new)
    }
}

impl ::protobuf::Clear for UserNotificationData {
    fn clear(&mut self) {
        self.notificationTitle.clear();
        self.notificationText.clear();
        self.tickerText.clear();
        self.dialogTitle.clear();
        self.dialogText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OwnershipInfo {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    pub developerPurchaseInfo: ::protobuf::SingularPtrField<SignedData>,
    pub preordered: ::std::option::Option<bool>,
    pub hidden: ::std::option::Option<bool>,
    pub rentalTerms: ::protobuf::SingularPtrField<RentalTerms>,
    pub groupLicenseInfo: ::protobuf::SingularPtrField<GroupLicenseInfo>,
    pub licensedDocumentInfo: ::protobuf::SingularPtrField<LicensedDocumentInfo>,
    pub quantity: ::std::option::Option<i32>,
    pub libraryExpirationTimestampMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OwnershipInfo {
    fn default() -> &'a OwnershipInfo {
        <OwnershipInfo as ::protobuf::Message>::default_instance()
    }
}

impl OwnershipInfo {
    pub fn new() -> OwnershipInfo {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;


    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 validUntilTimestampMsec = 2;


    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;


    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 refundTimeoutTimestampMsec = 4;


    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 5;


    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }

    // optional .SignedData developerPurchaseInfo = 6;


    pub fn get_developerPurchaseInfo(&self) -> &SignedData {
        self.developerPurchaseInfo.as_ref().unwrap_or_else(|| <SignedData as ::protobuf::Message>::default_instance())
    }

    // optional bool preordered = 7;


    pub fn get_preordered(&self) -> bool {
        self.preordered.unwrap_or(false)
    }

    // optional bool hidden = 8;


    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    // optional .RentalTerms rentalTerms = 9;


    pub fn get_rentalTerms(&self) -> &RentalTerms {
        self.rentalTerms.as_ref().unwrap_or_else(|| <RentalTerms as ::protobuf::Message>::default_instance())
    }

    // optional .GroupLicenseInfo groupLicenseInfo = 10;


    pub fn get_groupLicenseInfo(&self) -> &GroupLicenseInfo {
        self.groupLicenseInfo.as_ref().unwrap_or_else(|| <GroupLicenseInfo as ::protobuf::Message>::default_instance())
    }

    // optional .LicensedDocumentInfo licensedDocumentInfo = 11;


    pub fn get_licensedDocumentInfo(&self) -> &LicensedDocumentInfo {
        self.licensedDocumentInfo.as_ref().unwrap_or_else(|| <LicensedDocumentInfo as ::protobuf::Message>::default_instance())
    }

    // optional int32 quantity = 12;


    pub fn get_quantity(&self) -> i32 {
        self.quantity.unwrap_or(0)
    }

    // optional int64 libraryExpirationTimestampMsec = 14;


    pub fn get_libraryExpirationTimestampMsec(&self) -> i64 {
        self.libraryExpirationTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for OwnershipInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.developerPurchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groupLicenseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.licensedDocumentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.developerPurchaseInfo)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preordered = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rentalTerms)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groupLicenseInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.licensedDocumentInfo)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.libraryExpirationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.developerPurchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.preordered {
            my_size += 2;
        }
        if let Some(v) = self.hidden {
            my_size += 2;
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.groupLicenseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.licensedDocumentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.libraryExpirationTimestampMsec {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(5, v)?;
        }
        if let Some(ref v) = self.developerPurchaseInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.preordered {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.groupLicenseInfo.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.licensedDocumentInfo.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.quantity {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.libraryExpirationTimestampMsec {
            os.write_int64(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OwnershipInfo {
        OwnershipInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initiationTimestampMsec",
                |m: &OwnershipInfo| { &m.initiationTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.initiationTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "validUntilTimestampMsec",
                |m: &OwnershipInfo| { &m.validUntilTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.validUntilTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoRenewing",
                |m: &OwnershipInfo| { &m.autoRenewing },
                |m: &mut OwnershipInfo| { &mut m.autoRenewing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutTimestampMsec",
                |m: &OwnershipInfo| { &m.refundTimeoutTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.refundTimeoutTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postDeliveryRefundWindowMsec",
                |m: &OwnershipInfo| { &m.postDeliveryRefundWindowMsec },
                |m: &mut OwnershipInfo| { &mut m.postDeliveryRefundWindowMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedData>>(
                "developerPurchaseInfo",
                |m: &OwnershipInfo| { &m.developerPurchaseInfo },
                |m: &mut OwnershipInfo| { &mut m.developerPurchaseInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "preordered",
                |m: &OwnershipInfo| { &m.preordered },
                |m: &mut OwnershipInfo| { &mut m.preordered },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hidden",
                |m: &OwnershipInfo| { &m.hidden },
                |m: &mut OwnershipInfo| { &mut m.hidden },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RentalTerms>>(
                "rentalTerms",
                |m: &OwnershipInfo| { &m.rentalTerms },
                |m: &mut OwnershipInfo| { &mut m.rentalTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupLicenseInfo>>(
                "groupLicenseInfo",
                |m: &OwnershipInfo| { &m.groupLicenseInfo },
                |m: &mut OwnershipInfo| { &mut m.groupLicenseInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LicensedDocumentInfo>>(
                "licensedDocumentInfo",
                |m: &OwnershipInfo| { &m.licensedDocumentInfo },
                |m: &mut OwnershipInfo| { &mut m.licensedDocumentInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "quantity",
                |m: &OwnershipInfo| { &m.quantity },
                |m: &mut OwnershipInfo| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "libraryExpirationTimestampMsec",
                |m: &OwnershipInfo| { &m.libraryExpirationTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.libraryExpirationTimestampMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OwnershipInfo>(
                "OwnershipInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OwnershipInfo {
        static instance: ::protobuf::rt::LazyV2<OwnershipInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OwnershipInfo::new)
    }
}

impl ::protobuf::Clear for OwnershipInfo {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.developerPurchaseInfo.clear();
        self.preordered = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rentalTerms.clear();
        self.groupLicenseInfo.clear();
        self.licensedDocumentInfo.clear();
        self.quantity = ::std::option::Option::None;
        self.libraryExpirationTimestampMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OwnershipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnershipInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppData {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub oldVersion: ::std::option::Option<i32>,
    pub systemApp: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppData {
    fn default() -> &'a AppData {
        <AppData as ::protobuf::Message>::default_instance()
    }
}

impl AppData {
    pub fn new() -> AppData {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional int32 oldVersion = 2;


    pub fn get_oldVersion(&self) -> i32 {
        self.oldVersion.unwrap_or(0)
    }

    // optional bool systemApp = 3;


    pub fn get_systemApp(&self) -> bool {
        self.systemApp.unwrap_or(false)
    }
}

impl ::protobuf::Message for AppData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.oldVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.systemApp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.oldVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.systemApp {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.oldVersion {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.systemApp {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppData {
        AppData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &AppData| { &m.version },
                |m: &mut AppData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "oldVersion",
                |m: &AppData| { &m.oldVersion },
                |m: &mut AppData| { &mut m.oldVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "systemApp",
                |m: &AppData| { &m.systemApp },
                |m: &mut AppData| { &mut m.systemApp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppData>(
                "AppData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppData {
        static instance: ::protobuf::rt::LazyV2<AppData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppData::new)
    }
}

impl ::protobuf::Clear for AppData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.oldVersion = ::std::option::Option::None;
        self.systemApp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreBackgroundActionEvent {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub document: ::protobuf::SingularField<::std::string::String>,
    pub reason: ::protobuf::SingularField<::std::string::String>,
    pub errorCode: ::std::option::Option<i32>,
    pub exceptionType: ::protobuf::SingularField<::std::string::String>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub offerType: ::std::option::Option<i32>,
    pub fromSetting: ::std::option::Option<i32>,
    pub toSetting: ::std::option::Option<i32>,
    pub sessionInfo: ::protobuf::SingularPtrField<PlayStoreSessionData>,
    pub appData: ::protobuf::SingularPtrField<AppData>,
    pub serverLatencyMs: ::std::option::Option<i64>,
    pub clientLatencyMs: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreBackgroundActionEvent {
    fn default() -> &'a PlayStoreBackgroundActionEvent {
        <PlayStoreBackgroundActionEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreBackgroundActionEvent {
    pub fn new() -> PlayStoreBackgroundActionEvent {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string document = 2;


    pub fn get_document(&self) -> &str {
        match self.document.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 errorCode = 4;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode.unwrap_or(0)
    }

    // optional string exceptionType = 5;


    pub fn get_exceptionType(&self) -> &str {
        match self.exceptionType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes serverLogsCookie = 6;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 offerType = 7;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int32 fromSetting = 8;


    pub fn get_fromSetting(&self) -> i32 {
        self.fromSetting.unwrap_or(0)
    }

    // optional int32 toSetting = 9;


    pub fn get_toSetting(&self) -> i32 {
        self.toSetting.unwrap_or(0)
    }

    // optional .PlayStoreSessionData sessionInfo = 10;


    pub fn get_sessionInfo(&self) -> &PlayStoreSessionData {
        self.sessionInfo.as_ref().unwrap_or_else(|| <PlayStoreSessionData as ::protobuf::Message>::default_instance())
    }

    // optional .AppData appData = 11;


    pub fn get_appData(&self) -> &AppData {
        self.appData.as_ref().unwrap_or_else(|| <AppData as ::protobuf::Message>::default_instance())
    }

    // optional int64 serverLatencyMs = 12;


    pub fn get_serverLatencyMs(&self) -> i64 {
        self.serverLatencyMs.unwrap_or(0)
    }

    // optional int64 clientLatencyMs = 13;


    pub fn get_clientLatencyMs(&self) -> i64 {
        self.clientLatencyMs.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreBackgroundActionEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.sessionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.document)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.exceptionType)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fromSetting = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.toSetting = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sessionInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appData)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.serverLatencyMs = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.clientLatencyMs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.document.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exceptionType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fromSetting {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.toSetting {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sessionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.serverLatencyMs {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.clientLatencyMs {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.document.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.errorCode {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.exceptionType.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.fromSetting {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.toSetting {
            os.write_int32(9, v)?;
        }
        if let Some(ref v) = self.sessionInfo.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.serverLatencyMs {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.clientLatencyMs {
            os.write_int64(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreBackgroundActionEvent {
        PlayStoreBackgroundActionEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &PlayStoreBackgroundActionEvent| { &m.field_type },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "document",
                |m: &PlayStoreBackgroundActionEvent| { &m.document },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.document },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PlayStoreBackgroundActionEvent| { &m.reason },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &PlayStoreBackgroundActionEvent| { &m.errorCode },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exceptionType",
                |m: &PlayStoreBackgroundActionEvent| { &m.exceptionType },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.exceptionType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &PlayStoreBackgroundActionEvent| { &m.serverLogsCookie },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &PlayStoreBackgroundActionEvent| { &m.offerType },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fromSetting",
                |m: &PlayStoreBackgroundActionEvent| { &m.fromSetting },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.fromSetting },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "toSetting",
                |m: &PlayStoreBackgroundActionEvent| { &m.toSetting },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.toSetting },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreSessionData>>(
                "sessionInfo",
                |m: &PlayStoreBackgroundActionEvent| { &m.sessionInfo },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.sessionInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppData>>(
                "appData",
                |m: &PlayStoreBackgroundActionEvent| { &m.appData },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.appData },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "serverLatencyMs",
                |m: &PlayStoreBackgroundActionEvent| { &m.serverLatencyMs },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.serverLatencyMs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "clientLatencyMs",
                |m: &PlayStoreBackgroundActionEvent| { &m.clientLatencyMs },
                |m: &mut PlayStoreBackgroundActionEvent| { &mut m.clientLatencyMs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreBackgroundActionEvent>(
                "PlayStoreBackgroundActionEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreBackgroundActionEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreBackgroundActionEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreBackgroundActionEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreBackgroundActionEvent {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.document.clear();
        self.reason.clear();
        self.errorCode = ::std::option::Option::None;
        self.exceptionType.clear();
        self.serverLogsCookie.clear();
        self.offerType = ::std::option::Option::None;
        self.fromSetting = ::std::option::Option::None;
        self.toSetting = ::std::option::Option::None;
        self.sessionInfo.clear();
        self.appData.clear();
        self.serverLatencyMs = ::std::option::Option::None;
        self.clientLatencyMs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreBackgroundActionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreBackgroundActionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreClickEvent {
    // message fields
    pub elementPath: ::protobuf::RepeatedField<PlayStoreUiElement>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreClickEvent {
    fn default() -> &'a PlayStoreClickEvent {
        <PlayStoreClickEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreClickEvent {
    pub fn new() -> PlayStoreClickEvent {
        ::std::default::Default::default()
    }

    // repeated .PlayStoreUiElement elementPath = 1;


    pub fn get_elementPath(&self) -> &[PlayStoreUiElement] {
        &self.elementPath
    }
}

impl ::protobuf::Message for PlayStoreClickEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.elementPath {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elementPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elementPath {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elementPath {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreClickEvent {
        PlayStoreClickEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "elementPath",
                |m: &PlayStoreClickEvent| { &m.elementPath },
                |m: &mut PlayStoreClickEvent| { &mut m.elementPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreClickEvent>(
                "PlayStoreClickEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreClickEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreClickEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreClickEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreClickEvent {
    fn clear(&mut self) {
        self.elementPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreClickEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreClickEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreDeepLinkEvent {
    // message fields
    pub externalUrl: ::protobuf::SingularField<::std::string::String>,
    pub resolvedType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreDeepLinkEvent {
    fn default() -> &'a PlayStoreDeepLinkEvent {
        <PlayStoreDeepLinkEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreDeepLinkEvent {
    pub fn new() -> PlayStoreDeepLinkEvent {
        ::std::default::Default::default()
    }

    // optional string externalUrl = 1;


    pub fn get_externalUrl(&self) -> &str {
        match self.externalUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 resolvedType = 2;


    pub fn get_resolvedType(&self) -> i32 {
        self.resolvedType.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreDeepLinkEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resolvedType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.externalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.resolvedType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.externalUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.resolvedType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreDeepLinkEvent {
        PlayStoreDeepLinkEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalUrl",
                |m: &PlayStoreDeepLinkEvent| { &m.externalUrl },
                |m: &mut PlayStoreDeepLinkEvent| { &mut m.externalUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "resolvedType",
                |m: &PlayStoreDeepLinkEvent| { &m.resolvedType },
                |m: &mut PlayStoreDeepLinkEvent| { &mut m.resolvedType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreDeepLinkEvent>(
                "PlayStoreDeepLinkEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreDeepLinkEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreDeepLinkEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreDeepLinkEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreDeepLinkEvent {
    fn clear(&mut self) {
        self.externalUrl.clear();
        self.resolvedType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreDeepLinkEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreDeepLinkEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreImpressionEvent {
    // message fields
    pub tree: ::protobuf::SingularPtrField<PlayStoreUiElement>,
    pub referrerPath: ::protobuf::RepeatedField<PlayStoreUiElement>,
    pub id: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreImpressionEvent {
    fn default() -> &'a PlayStoreImpressionEvent {
        <PlayStoreImpressionEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreImpressionEvent {
    pub fn new() -> PlayStoreImpressionEvent {
        ::std::default::Default::default()
    }

    // optional .PlayStoreUiElement tree = 1;


    pub fn get_tree(&self) -> &PlayStoreUiElement {
        self.tree.as_ref().unwrap_or_else(|| <PlayStoreUiElement as ::protobuf::Message>::default_instance())
    }

    // repeated .PlayStoreUiElement referrerPath = 2;


    pub fn get_referrerPath(&self) -> &[PlayStoreUiElement] {
        &self.referrerPath
    }

    // optional int64 id = 3;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
}

impl ::protobuf::Message for PlayStoreImpressionEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.tree {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.referrerPath {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tree)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.referrerPath)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tree.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.referrerPath {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tree.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.referrerPath {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.id {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreImpressionEvent {
        PlayStoreImpressionEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "tree",
                |m: &PlayStoreImpressionEvent| { &m.tree },
                |m: &mut PlayStoreImpressionEvent| { &mut m.tree },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "referrerPath",
                |m: &PlayStoreImpressionEvent| { &m.referrerPath },
                |m: &mut PlayStoreImpressionEvent| { &mut m.referrerPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &PlayStoreImpressionEvent| { &m.id },
                |m: &mut PlayStoreImpressionEvent| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreImpressionEvent>(
                "PlayStoreImpressionEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreImpressionEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreImpressionEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreImpressionEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreImpressionEvent {
    fn clear(&mut self) {
        self.tree.clear();
        self.referrerPath.clear();
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreImpressionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreImpressionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreLogEvent {
    // message fields
    pub impression: ::protobuf::SingularPtrField<PlayStoreImpressionEvent>,
    pub click: ::protobuf::SingularPtrField<PlayStoreClickEvent>,
    pub backgroundAction: ::protobuf::SingularPtrField<PlayStoreBackgroundActionEvent>,
    pub search: ::protobuf::SingularPtrField<PlayStoreSearchEvent>,
    pub deepLink: ::protobuf::SingularPtrField<PlayStoreDeepLinkEvent>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreLogEvent {
    fn default() -> &'a PlayStoreLogEvent {
        <PlayStoreLogEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreLogEvent {
    pub fn new() -> PlayStoreLogEvent {
        ::std::default::Default::default()
    }

    // optional .PlayStoreImpressionEvent impression = 1;


    pub fn get_impression(&self) -> &PlayStoreImpressionEvent {
        self.impression.as_ref().unwrap_or_else(|| <PlayStoreImpressionEvent as ::protobuf::Message>::default_instance())
    }

    // optional .PlayStoreClickEvent click = 3;


    pub fn get_click(&self) -> &PlayStoreClickEvent {
        self.click.as_ref().unwrap_or_else(|| <PlayStoreClickEvent as ::protobuf::Message>::default_instance())
    }

    // optional .PlayStoreBackgroundActionEvent backgroundAction = 4;


    pub fn get_backgroundAction(&self) -> &PlayStoreBackgroundActionEvent {
        self.backgroundAction.as_ref().unwrap_or_else(|| <PlayStoreBackgroundActionEvent as ::protobuf::Message>::default_instance())
    }

    // optional .PlayStoreSearchEvent search = 5;


    pub fn get_search(&self) -> &PlayStoreSearchEvent {
        self.search.as_ref().unwrap_or_else(|| <PlayStoreSearchEvent as ::protobuf::Message>::default_instance())
    }

    // optional .PlayStoreDeepLinkEvent deepLink = 6;


    pub fn get_deepLink(&self) -> &PlayStoreDeepLinkEvent {
        self.deepLink.as_ref().unwrap_or_else(|| <PlayStoreDeepLinkEvent as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PlayStoreLogEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.impression {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.click {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backgroundAction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.search {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deepLink {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.impression)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.click)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backgroundAction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deepLink)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.impression.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.click.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.backgroundAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.search.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deepLink.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.impression.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.click.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.backgroundAction.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.search.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deepLink.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreLogEvent {
        PlayStoreLogEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreImpressionEvent>>(
                "impression",
                |m: &PlayStoreLogEvent| { &m.impression },
                |m: &mut PlayStoreLogEvent| { &mut m.impression },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreClickEvent>>(
                "click",
                |m: &PlayStoreLogEvent| { &m.click },
                |m: &mut PlayStoreLogEvent| { &mut m.click },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreBackgroundActionEvent>>(
                "backgroundAction",
                |m: &PlayStoreLogEvent| { &m.backgroundAction },
                |m: &mut PlayStoreLogEvent| { &mut m.backgroundAction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreSearchEvent>>(
                "search",
                |m: &PlayStoreLogEvent| { &m.search },
                |m: &mut PlayStoreLogEvent| { &mut m.search },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreDeepLinkEvent>>(
                "deepLink",
                |m: &PlayStoreLogEvent| { &m.deepLink },
                |m: &mut PlayStoreLogEvent| { &mut m.deepLink },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreLogEvent>(
                "PlayStoreLogEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreLogEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreLogEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreLogEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreLogEvent {
    fn clear(&mut self) {
        self.impression.clear();
        self.click.clear();
        self.backgroundAction.clear();
        self.search.clear();
        self.deepLink.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreLogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreLogEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreSearchEvent {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub queryUrl: ::protobuf::SingularField<::std::string::String>,
    pub referrerUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreSearchEvent {
    fn default() -> &'a PlayStoreSearchEvent {
        <PlayStoreSearchEvent as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreSearchEvent {
    pub fn new() -> PlayStoreSearchEvent {
        ::std::default::Default::default()
    }

    // optional string query = 1;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string queryUrl = 2;


    pub fn get_queryUrl(&self) -> &str {
        match self.queryUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string referrerUrl = 3;


    pub fn get_referrerUrl(&self) -> &str {
        match self.referrerUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlayStoreSearchEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.queryUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.referrerUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.queryUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.referrerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.queryUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.referrerUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreSearchEvent {
        PlayStoreSearchEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &PlayStoreSearchEvent| { &m.query },
                |m: &mut PlayStoreSearchEvent| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "queryUrl",
                |m: &PlayStoreSearchEvent| { &m.queryUrl },
                |m: &mut PlayStoreSearchEvent| { &mut m.queryUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referrerUrl",
                |m: &PlayStoreSearchEvent| { &m.referrerUrl },
                |m: &mut PlayStoreSearchEvent| { &mut m.referrerUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreSearchEvent>(
                "PlayStoreSearchEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreSearchEvent {
        static instance: ::protobuf::rt::LazyV2<PlayStoreSearchEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreSearchEvent::new)
    }
}

impl ::protobuf::Clear for PlayStoreSearchEvent {
    fn clear(&mut self) {
        self.query.clear();
        self.queryUrl.clear();
        self.referrerUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreSearchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreSearchEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreSessionData {
    // message fields
    pub globalAutoUpdateEnabled: ::std::option::Option<bool>,
    pub globalAutoUpdateOverWifiOnly: ::std::option::Option<bool>,
    pub autoUpdateCleanupDialogNumTimesShown: ::std::option::Option<i32>,
    pub networkType: ::std::option::Option<i32>,
    pub networkSubType: ::std::option::Option<i32>,
    pub numAccountsOnDevice: ::std::option::Option<i32>,
    pub numInstalledApps: ::std::option::Option<i32>,
    pub numAutoUpdatingInstalledApps: ::std::option::Option<i32>,
    pub numInstalledAppsNotAutoUpdating: ::std::option::Option<i32>,
    pub gaiaPasswordAuthOptedOut: ::std::option::Option<bool>,
    pub contentFilterLevel: ::std::option::Option<i32>,
    pub allowUnknownSources: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreSessionData {
    fn default() -> &'a PlayStoreSessionData {
        <PlayStoreSessionData as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreSessionData {
    pub fn new() -> PlayStoreSessionData {
        ::std::default::Default::default()
    }

    // optional bool globalAutoUpdateEnabled = 1;


    pub fn get_globalAutoUpdateEnabled(&self) -> bool {
        self.globalAutoUpdateEnabled.unwrap_or(false)
    }

    // optional bool globalAutoUpdateOverWifiOnly = 2;


    pub fn get_globalAutoUpdateOverWifiOnly(&self) -> bool {
        self.globalAutoUpdateOverWifiOnly.unwrap_or(false)
    }

    // optional int32 autoUpdateCleanupDialogNumTimesShown = 3;


    pub fn get_autoUpdateCleanupDialogNumTimesShown(&self) -> i32 {
        self.autoUpdateCleanupDialogNumTimesShown.unwrap_or(0)
    }

    // optional int32 networkType = 4;


    pub fn get_networkType(&self) -> i32 {
        self.networkType.unwrap_or(0)
    }

    // optional int32 networkSubType = 5;


    pub fn get_networkSubType(&self) -> i32 {
        self.networkSubType.unwrap_or(0)
    }

    // optional int32 numAccountsOnDevice = 6;


    pub fn get_numAccountsOnDevice(&self) -> i32 {
        self.numAccountsOnDevice.unwrap_or(0)
    }

    // optional int32 numInstalledApps = 7;


    pub fn get_numInstalledApps(&self) -> i32 {
        self.numInstalledApps.unwrap_or(0)
    }

    // optional int32 numAutoUpdatingInstalledApps = 8;


    pub fn get_numAutoUpdatingInstalledApps(&self) -> i32 {
        self.numAutoUpdatingInstalledApps.unwrap_or(0)
    }

    // optional int32 numInstalledAppsNotAutoUpdating = 9;


    pub fn get_numInstalledAppsNotAutoUpdating(&self) -> i32 {
        self.numInstalledAppsNotAutoUpdating.unwrap_or(0)
    }

    // optional bool gaiaPasswordAuthOptedOut = 10;


    pub fn get_gaiaPasswordAuthOptedOut(&self) -> bool {
        self.gaiaPasswordAuthOptedOut.unwrap_or(false)
    }

    // optional int32 contentFilterLevel = 11;


    pub fn get_contentFilterLevel(&self) -> i32 {
        self.contentFilterLevel.unwrap_or(0)
    }

    // optional bool allowUnknownSources = 12;


    pub fn get_allowUnknownSources(&self) -> bool {
        self.allowUnknownSources.unwrap_or(false)
    }
}

impl ::protobuf::Message for PlayStoreSessionData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.globalAutoUpdateEnabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.globalAutoUpdateOverWifiOnly = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.autoUpdateCleanupDialogNumTimesShown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.networkType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.networkSubType = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numAccountsOnDevice = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numInstalledApps = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numAutoUpdatingInstalledApps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numInstalledAppsNotAutoUpdating = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gaiaPasswordAuthOptedOut = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentFilterLevel = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowUnknownSources = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.globalAutoUpdateEnabled {
            my_size += 2;
        }
        if let Some(v) = self.globalAutoUpdateOverWifiOnly {
            my_size += 2;
        }
        if let Some(v) = self.autoUpdateCleanupDialogNumTimesShown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.networkType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.networkSubType {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numAccountsOnDevice {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numInstalledApps {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numAutoUpdatingInstalledApps {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numInstalledAppsNotAutoUpdating {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gaiaPasswordAuthOptedOut {
            my_size += 2;
        }
        if let Some(v) = self.contentFilterLevel {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allowUnknownSources {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.globalAutoUpdateEnabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.globalAutoUpdateOverWifiOnly {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.autoUpdateCleanupDialogNumTimesShown {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.networkType {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.networkSubType {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.numAccountsOnDevice {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.numInstalledApps {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.numAutoUpdatingInstalledApps {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.numInstalledAppsNotAutoUpdating {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.gaiaPasswordAuthOptedOut {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.contentFilterLevel {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.allowUnknownSources {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreSessionData {
        PlayStoreSessionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "globalAutoUpdateEnabled",
                |m: &PlayStoreSessionData| { &m.globalAutoUpdateEnabled },
                |m: &mut PlayStoreSessionData| { &mut m.globalAutoUpdateEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "globalAutoUpdateOverWifiOnly",
                |m: &PlayStoreSessionData| { &m.globalAutoUpdateOverWifiOnly },
                |m: &mut PlayStoreSessionData| { &mut m.globalAutoUpdateOverWifiOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "autoUpdateCleanupDialogNumTimesShown",
                |m: &PlayStoreSessionData| { &m.autoUpdateCleanupDialogNumTimesShown },
                |m: &mut PlayStoreSessionData| { &mut m.autoUpdateCleanupDialogNumTimesShown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "networkType",
                |m: &PlayStoreSessionData| { &m.networkType },
                |m: &mut PlayStoreSessionData| { &mut m.networkType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "networkSubType",
                |m: &PlayStoreSessionData| { &m.networkSubType },
                |m: &mut PlayStoreSessionData| { &mut m.networkSubType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numAccountsOnDevice",
                |m: &PlayStoreSessionData| { &m.numAccountsOnDevice },
                |m: &mut PlayStoreSessionData| { &mut m.numAccountsOnDevice },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numInstalledApps",
                |m: &PlayStoreSessionData| { &m.numInstalledApps },
                |m: &mut PlayStoreSessionData| { &mut m.numInstalledApps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numAutoUpdatingInstalledApps",
                |m: &PlayStoreSessionData| { &m.numAutoUpdatingInstalledApps },
                |m: &mut PlayStoreSessionData| { &mut m.numAutoUpdatingInstalledApps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numInstalledAppsNotAutoUpdating",
                |m: &PlayStoreSessionData| { &m.numInstalledAppsNotAutoUpdating },
                |m: &mut PlayStoreSessionData| { &mut m.numInstalledAppsNotAutoUpdating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "gaiaPasswordAuthOptedOut",
                |m: &PlayStoreSessionData| { &m.gaiaPasswordAuthOptedOut },
                |m: &mut PlayStoreSessionData| { &mut m.gaiaPasswordAuthOptedOut },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "contentFilterLevel",
                |m: &PlayStoreSessionData| { &m.contentFilterLevel },
                |m: &mut PlayStoreSessionData| { &mut m.contentFilterLevel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowUnknownSources",
                |m: &PlayStoreSessionData| { &m.allowUnknownSources },
                |m: &mut PlayStoreSessionData| { &mut m.allowUnknownSources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreSessionData>(
                "PlayStoreSessionData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreSessionData {
        static instance: ::protobuf::rt::LazyV2<PlayStoreSessionData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreSessionData::new)
    }
}

impl ::protobuf::Clear for PlayStoreSessionData {
    fn clear(&mut self) {
        self.globalAutoUpdateEnabled = ::std::option::Option::None;
        self.globalAutoUpdateOverWifiOnly = ::std::option::Option::None;
        self.autoUpdateCleanupDialogNumTimesShown = ::std::option::Option::None;
        self.networkType = ::std::option::Option::None;
        self.networkSubType = ::std::option::Option::None;
        self.numAccountsOnDevice = ::std::option::Option::None;
        self.numInstalledApps = ::std::option::Option::None;
        self.numAutoUpdatingInstalledApps = ::std::option::Option::None;
        self.numInstalledAppsNotAutoUpdating = ::std::option::Option::None;
        self.gaiaPasswordAuthOptedOut = ::std::option::Option::None;
        self.contentFilterLevel = ::std::option::Option::None;
        self.allowUnknownSources = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreSessionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreSessionData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreUiElement {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub clientLogsCookie: ::protobuf::SingularPtrField<PlayStoreUiElementInfo>,
    pub child: ::protobuf::RepeatedField<PlayStoreUiElement>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreUiElement {
    fn default() -> &'a PlayStoreUiElement {
        <PlayStoreUiElement as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreUiElement {
    pub fn new() -> PlayStoreUiElement {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional bytes serverLogsCookie = 2;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .PlayStoreUiElementInfo clientLogsCookie = 3;


    pub fn get_clientLogsCookie(&self) -> &PlayStoreUiElementInfo {
        self.clientLogsCookie.as_ref().unwrap_or_else(|| <PlayStoreUiElementInfo as ::protobuf::Message>::default_instance())
    }

    // repeated .PlayStoreUiElement child = 4;


    pub fn get_child(&self) -> &[PlayStoreUiElement] {
        &self.child
    }
}

impl ::protobuf::Message for PlayStoreUiElement {
    fn is_initialized(&self) -> bool {
        for v in &self.clientLogsCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clientLogsCookie)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.clientLogsCookie.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.clientLogsCookie.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.child {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElement {
        PlayStoreUiElement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &PlayStoreUiElement| { &m.field_type },
                |m: &mut PlayStoreUiElement| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &PlayStoreUiElement| { &m.serverLogsCookie },
                |m: &mut PlayStoreUiElement| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElementInfo>>(
                "clientLogsCookie",
                |m: &PlayStoreUiElement| { &m.clientLogsCookie },
                |m: &mut PlayStoreUiElement| { &mut m.clientLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElement>>(
                "child",
                |m: &PlayStoreUiElement| { &m.child },
                |m: &mut PlayStoreUiElement| { &mut m.child },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreUiElement>(
                "PlayStoreUiElement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElement {
        static instance: ::protobuf::rt::LazyV2<PlayStoreUiElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreUiElement::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElement {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.serverLogsCookie.clear();
        self.clientLogsCookie.clear();
        self.child.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreUiElementInfo {
    // message fields
    pub instrumentInfo: ::protobuf::SingularPtrField<PlayStoreUiElementInfo_InstrumentInfo>,
    pub serialDocid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreUiElementInfo {
    fn default() -> &'a PlayStoreUiElementInfo {
        <PlayStoreUiElementInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreUiElementInfo {
    pub fn new() -> PlayStoreUiElementInfo {
        ::std::default::Default::default()
    }

    // optional .PlayStoreUiElementInfo.InstrumentInfo instrumentInfo = 1;


    pub fn get_instrumentInfo(&self) -> &PlayStoreUiElementInfo_InstrumentInfo {
        self.instrumentInfo.as_ref().unwrap_or_else(|| <PlayStoreUiElementInfo_InstrumentInfo as ::protobuf::Message>::default_instance())
    }

    // optional string serialDocid = 2;


    pub fn get_serialDocid(&self) -> &str {
        match self.serialDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlayStoreUiElementInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.instrumentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrumentInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serialDocid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serialDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serialDocid.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElementInfo {
        PlayStoreUiElementInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlayStoreUiElementInfo_InstrumentInfo>>(
                "instrumentInfo",
                |m: &PlayStoreUiElementInfo| { &m.instrumentInfo },
                |m: &mut PlayStoreUiElementInfo| { &mut m.instrumentInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serialDocid",
                |m: &PlayStoreUiElementInfo| { &m.serialDocid },
                |m: &mut PlayStoreUiElementInfo| { &mut m.serialDocid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreUiElementInfo>(
                "PlayStoreUiElementInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElementInfo {
        static instance: ::protobuf::rt::LazyV2<PlayStoreUiElementInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreUiElementInfo::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElementInfo {
    fn clear(&mut self) {
        self.instrumentInfo.clear();
        self.serialDocid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElementInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlayStoreUiElementInfo_InstrumentInfo {
    // message fields
    pub instrumentFamily: ::std::option::Option<i32>,
    pub isDefault: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlayStoreUiElementInfo_InstrumentInfo {
    fn default() -> &'a PlayStoreUiElementInfo_InstrumentInfo {
        <PlayStoreUiElementInfo_InstrumentInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayStoreUiElementInfo_InstrumentInfo {
    pub fn new() -> PlayStoreUiElementInfo_InstrumentInfo {
        ::std::default::Default::default()
    }

    // optional int32 instrumentFamily = 1;


    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional bool isDefault = 2;


    pub fn get_isDefault(&self) -> bool {
        self.isDefault.unwrap_or(false)
    }
}

impl ::protobuf::Message for PlayStoreUiElementInfo_InstrumentInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isDefault = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isDefault {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.instrumentFamily {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.isDefault {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlayStoreUiElementInfo_InstrumentInfo {
        PlayStoreUiElementInfo_InstrumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instrumentFamily",
                |m: &PlayStoreUiElementInfo_InstrumentInfo| { &m.instrumentFamily },
                |m: &mut PlayStoreUiElementInfo_InstrumentInfo| { &mut m.instrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isDefault",
                |m: &PlayStoreUiElementInfo_InstrumentInfo| { &m.isDefault },
                |m: &mut PlayStoreUiElementInfo_InstrumentInfo| { &mut m.isDefault },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlayStoreUiElementInfo_InstrumentInfo>(
                "PlayStoreUiElementInfo.InstrumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlayStoreUiElementInfo_InstrumentInfo {
        static instance: ::protobuf::rt::LazyV2<PlayStoreUiElementInfo_InstrumentInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlayStoreUiElementInfo_InstrumentInfo::new)
    }
}

impl ::protobuf::Clear for PlayStoreUiElementInfo_InstrumentInfo {
    fn clear(&mut self) {
        self.instrumentFamily = ::std::option::Option::None;
        self.isDefault = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlayStoreUiElementInfo_InstrumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayStoreUiElementInfo_InstrumentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusProfile {
    // message fields
    pub displayName: ::protobuf::SingularField<::std::string::String>,
    pub profileImageUrl: ::protobuf::SingularField<::std::string::String>,
    pub profileImage: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusProfile {
    fn default() -> &'a PlusProfile {
        <PlusProfile as ::protobuf::Message>::default_instance()
    }
}

impl PlusProfile {
    pub fn new() -> PlusProfile {
        ::std::default::Default::default()
    }

    // optional string displayName = 2;


    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string profileImageUrl = 4;


    pub fn get_profileImageUrl(&self) -> &str {
        match self.profileImageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image profileImage = 5;


    pub fn get_profileImage(&self) -> &Image {
        self.profileImage.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PlusProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.profileImage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profileImageUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profileImage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.profileImageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.profileImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.displayName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.profileImageUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.profileImage.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusProfile {
        PlusProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayName",
                |m: &PlusProfile| { &m.displayName },
                |m: &mut PlusProfile| { &mut m.displayName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "profileImageUrl",
                |m: &PlusProfile| { &m.profileImageUrl },
                |m: &mut PlusProfile| { &mut m.profileImageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "profileImage",
                |m: &PlusProfile| { &m.profileImage },
                |m: &mut PlusProfile| { &mut m.profileImage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusProfile>(
                "PlusProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusProfile {
        static instance: ::protobuf::rt::LazyV2<PlusProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusProfile::new)
    }
}

impl ::protobuf::Clear for PlusProfile {
    fn clear(&mut self) {
        self.displayName.clear();
        self.profileImageUrl.clear();
        self.profileImage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusOneResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusOneResponse {
    fn default() -> &'a PlusOneResponse {
        <PlusOneResponse as ::protobuf::Message>::default_instance()
    }
}

impl PlusOneResponse {
    pub fn new() -> PlusOneResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PlusOneResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusOneResponse {
        PlusOneResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusOneResponse>(
                "PlusOneResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusOneResponse {
        static instance: ::protobuf::rt::LazyV2<PlusOneResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusOneResponse::new)
    }
}

impl ::protobuf::Clear for PlusOneResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusOneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusOneResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusProfileResponse {
    // message fields
    pub plusProfile: ::protobuf::SingularPtrField<PlusProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusProfileResponse {
    fn default() -> &'a PlusProfileResponse {
        <PlusProfileResponse as ::protobuf::Message>::default_instance()
    }
}

impl PlusProfileResponse {
    pub fn new() -> PlusProfileResponse {
        ::std::default::Default::default()
    }

    // optional .PlusProfile plusProfile = 1;


    pub fn get_plusProfile(&self) -> &PlusProfile {
        self.plusProfile.as_ref().unwrap_or_else(|| <PlusProfile as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PlusProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.plusProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.plusProfile.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusProfileResponse {
        PlusProfileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "plusProfile",
                |m: &PlusProfileResponse| { &m.plusProfile },
                |m: &mut PlusProfileResponse| { &mut m.plusProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusProfileResponse>(
                "PlusProfileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusProfileResponse {
        static instance: ::protobuf::rt::LazyV2<PlusProfileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusProfileResponse::new)
    }
}

impl ::protobuf::Clear for PlusProfileResponse {
    fn clear(&mut self) {
        self.plusProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusProfileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientCart {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub formattedPrice: ::protobuf::SingularField<::std::string::String>,
    pub purchaseContextToken: ::protobuf::SingularField<::std::string::String>,
    pub instrument: ::protobuf::SingularPtrField<Instrument>,
    pub extendedDetailHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub footerHtml: ::protobuf::SingularField<::std::string::String>,
    pub addInstrumentPromptHtml: ::protobuf::SingularField<::std::string::String>,
    pub buttonText: ::protobuf::SingularField<::std::string::String>,
    pub completePurchaseChallenge: ::protobuf::SingularPtrField<Challenge>,
    pub priceByline: ::protobuf::SingularField<::std::string::String>,
    pub detailHtml: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientCart {
    fn default() -> &'a ClientCart {
        <ClientCart as ::protobuf::Message>::default_instance()
    }
}

impl ClientCart {
    pub fn new() -> ClientCart {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedPrice = 2;


    pub fn get_formattedPrice(&self) -> &str {
        match self.formattedPrice.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseContextToken = 3;


    pub fn get_purchaseContextToken(&self) -> &str {
        match self.purchaseContextToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Instrument instrument = 4;


    pub fn get_instrument(&self) -> &Instrument {
        self.instrument.as_ref().unwrap_or_else(|| <Instrument as ::protobuf::Message>::default_instance())
    }

    // repeated string extendedDetailHtml = 5;


    pub fn get_extendedDetailHtml(&self) -> &[::std::string::String] {
        &self.extendedDetailHtml
    }

    // optional string footerHtml = 6;


    pub fn get_footerHtml(&self) -> &str {
        match self.footerHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addInstrumentPromptHtml = 7;


    pub fn get_addInstrumentPromptHtml(&self) -> &str {
        match self.addInstrumentPromptHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string buttonText = 8;


    pub fn get_buttonText(&self) -> &str {
        match self.buttonText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Challenge completePurchaseChallenge = 9;


    pub fn get_completePurchaseChallenge(&self) -> &Challenge {
        self.completePurchaseChallenge.as_ref().unwrap_or_else(|| <Challenge as ::protobuf::Message>::default_instance())
    }

    // optional string priceByline = 10;


    pub fn get_priceByline(&self) -> &str {
        match self.priceByline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string detailHtml = 11;


    pub fn get_detailHtml(&self) -> &[::std::string::String] {
        &self.detailHtml
    }
}

impl ::protobuf::Message for ClientCart {
    fn is_initialized(&self) -> bool {
        for v in &self.instrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.completePurchaseChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedPrice)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseContextToken)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrument)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extendedDetailHtml)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentPromptHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buttonText)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.completePurchaseChallenge)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceByline)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.detailHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.formattedPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.purchaseContextToken.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.instrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extendedDetailHtml {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.footerHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.addInstrumentPromptHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.buttonText.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.completePurchaseChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.priceByline.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.detailHtml {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.formattedPrice.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.purchaseContextToken.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.instrument.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extendedDetailHtml {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.footerHtml.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.addInstrumentPromptHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.buttonText.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.completePurchaseChallenge.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.priceByline.as_ref() {
            os.write_string(10, &v)?;
        }
        for v in &self.detailHtml {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientCart {
        ClientCart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ClientCart| { &m.title },
                |m: &mut ClientCart| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedPrice",
                |m: &ClientCart| { &m.formattedPrice },
                |m: &mut ClientCart| { &mut m.formattedPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseContextToken",
                |m: &ClientCart| { &m.purchaseContextToken },
                |m: &mut ClientCart| { &mut m.purchaseContextToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "instrument",
                |m: &ClientCart| { &m.instrument },
                |m: &mut ClientCart| { &mut m.instrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extendedDetailHtml",
                |m: &ClientCart| { &m.extendedDetailHtml },
                |m: &mut ClientCart| { &mut m.extendedDetailHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &ClientCart| { &m.footerHtml },
                |m: &mut ClientCart| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addInstrumentPromptHtml",
                |m: &ClientCart| { &m.addInstrumentPromptHtml },
                |m: &mut ClientCart| { &mut m.addInstrumentPromptHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "buttonText",
                |m: &ClientCart| { &m.buttonText },
                |m: &mut ClientCart| { &mut m.buttonText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>>(
                "completePurchaseChallenge",
                |m: &ClientCart| { &m.completePurchaseChallenge },
                |m: &mut ClientCart| { &mut m.completePurchaseChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "priceByline",
                |m: &ClientCart| { &m.priceByline },
                |m: &mut ClientCart| { &mut m.priceByline },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailHtml",
                |m: &ClientCart| { &m.detailHtml },
                |m: &mut ClientCart| { &mut m.detailHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientCart>(
                "ClientCart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientCart {
        static instance: ::protobuf::rt::LazyV2<ClientCart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientCart::new)
    }
}

impl ::protobuf::Clear for ClientCart {
    fn clear(&mut self) {
        self.title.clear();
        self.formattedPrice.clear();
        self.purchaseContextToken.clear();
        self.instrument.clear();
        self.extendedDetailHtml.clear();
        self.footerHtml.clear();
        self.addInstrumentPromptHtml.clear();
        self.buttonText.clear();
        self.completePurchaseChallenge.clear();
        self.priceByline.clear();
        self.detailHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientCart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientCart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CommitPurchaseResponse {
    // message fields
    pub purchaseStatus: ::protobuf::SingularPtrField<PurchaseStatus>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub libraryUpdate: ::protobuf::RepeatedField<LibraryUpdate>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitPurchaseResponse {
    fn default() -> &'a CommitPurchaseResponse {
        <CommitPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitPurchaseResponse {
    pub fn new() -> CommitPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional .PurchaseStatus purchaseStatus = 1;


    pub fn get_purchaseStatus(&self) -> &PurchaseStatus {
        self.purchaseStatus.as_ref().unwrap_or_else(|| <PurchaseStatus as ::protobuf::Message>::default_instance())
    }

    // optional .Challenge challenge = 2;


    pub fn get_challenge(&self) -> &Challenge {
        self.challenge.as_ref().unwrap_or_else(|| <Challenge as ::protobuf::Message>::default_instance())
    }

    // repeated .LibraryUpdate libraryUpdate = 3;


    pub fn get_libraryUpdate(&self) -> &[LibraryUpdate] {
        &self.libraryUpdate
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 4;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }

    // optional bytes serverLogsCookie = 5;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CommitPurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.purchaseStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.libraryUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.purchaseStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.libraryUpdate {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitPurchaseResponse {
        CommitPurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatus>>(
                "purchaseStatus",
                |m: &CommitPurchaseResponse| { &m.purchaseStatus },
                |m: &mut CommitPurchaseResponse| { &mut m.purchaseStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>>(
                "challenge",
                |m: &CommitPurchaseResponse| { &m.challenge },
                |m: &mut CommitPurchaseResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &CommitPurchaseResponse| { &m.libraryUpdate },
                |m: &mut CommitPurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &CommitPurchaseResponse| { &m.appDeliveryData },
                |m: &mut CommitPurchaseResponse| { &mut m.appDeliveryData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &CommitPurchaseResponse| { &m.serverLogsCookie },
                |m: &mut CommitPurchaseResponse| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitPurchaseResponse>(
                "CommitPurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitPurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<CommitPurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitPurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CommitPurchaseResponse {
    fn clear(&mut self) {
        self.purchaseStatus.clear();
        self.challenge.clear();
        self.libraryUpdate.clear();
        self.appDeliveryData.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitPurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PreparePurchaseResponse {
    // message fields
    pub purchaseStatus: ::protobuf::SingularPtrField<PurchaseStatus>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub cart: ::protobuf::SingularPtrField<ClientCart>,
    pub libraryUpdate: ::protobuf::RepeatedField<LibraryUpdate>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreparePurchaseResponse {
    fn default() -> &'a PreparePurchaseResponse {
        <PreparePurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreparePurchaseResponse {
    pub fn new() -> PreparePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional .PurchaseStatus purchaseStatus = 1;


    pub fn get_purchaseStatus(&self) -> &PurchaseStatus {
        self.purchaseStatus.as_ref().unwrap_or_else(|| <PurchaseStatus as ::protobuf::Message>::default_instance())
    }

    // optional .Challenge challenge = 2;


    pub fn get_challenge(&self) -> &Challenge {
        self.challenge.as_ref().unwrap_or_else(|| <Challenge as ::protobuf::Message>::default_instance())
    }

    // optional .ClientCart cart = 3;


    pub fn get_cart(&self) -> &ClientCart {
        self.cart.as_ref().unwrap_or_else(|| <ClientCart as ::protobuf::Message>::default_instance())
    }

    // repeated .LibraryUpdate libraryUpdate = 4;


    pub fn get_libraryUpdate(&self) -> &[LibraryUpdate] {
        &self.libraryUpdate
    }

    // optional bytes serverLogsCookie = 5;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for PreparePurchaseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cart)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.purchaseStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.libraryUpdate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.purchaseStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cart.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.libraryUpdate {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreparePurchaseResponse {
        PreparePurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatus>>(
                "purchaseStatus",
                |m: &PreparePurchaseResponse| { &m.purchaseStatus },
                |m: &mut PreparePurchaseResponse| { &mut m.purchaseStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>>(
                "challenge",
                |m: &PreparePurchaseResponse| { &m.challenge },
                |m: &mut PreparePurchaseResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientCart>>(
                "cart",
                |m: &PreparePurchaseResponse| { &m.cart },
                |m: &mut PreparePurchaseResponse| { &mut m.cart },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &PreparePurchaseResponse| { &m.libraryUpdate },
                |m: &mut PreparePurchaseResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &PreparePurchaseResponse| { &m.serverLogsCookie },
                |m: &mut PreparePurchaseResponse| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreparePurchaseResponse>(
                "PreparePurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreparePurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<PreparePurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreparePurchaseResponse::new)
    }
}

impl ::protobuf::Clear for PreparePurchaseResponse {
    fn clear(&mut self) {
        self.purchaseStatus.clear();
        self.challenge.clear();
        self.cart.clear();
        self.libraryUpdate.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreparePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreparePurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseStatus {
    // message fields
    pub statusCode: ::std::option::Option<i32>,
    pub errorMessageHtml: ::protobuf::SingularField<::std::string::String>,
    pub permissionError: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseStatus {
    fn default() -> &'a PurchaseStatus {
        <PurchaseStatus as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseStatus {
    pub fn new() -> PurchaseStatus {
        ::std::default::Default::default()
    }

    // optional int32 statusCode = 1;


    pub fn get_statusCode(&self) -> i32 {
        self.statusCode.unwrap_or(0)
    }

    // optional string errorMessageHtml = 2;


    pub fn get_errorMessageHtml(&self) -> &str {
        match self.errorMessageHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 permissionError = 3;


    pub fn get_permissionError(&self) -> i32 {
        self.permissionError.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.statusCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessageHtml)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.permissionError = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.statusCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.errorMessageHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.permissionError {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.statusCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.errorMessageHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.permissionError {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseStatus {
        PurchaseStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "statusCode",
                |m: &PurchaseStatus| { &m.statusCode },
                |m: &mut PurchaseStatus| { &mut m.statusCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessageHtml",
                |m: &PurchaseStatus| { &m.errorMessageHtml },
                |m: &mut PurchaseStatus| { &mut m.errorMessageHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "permissionError",
                |m: &PurchaseStatus| { &m.permissionError },
                |m: &mut PurchaseStatus| { &mut m.permissionError },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseStatus>(
                "PurchaseStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseStatus {
        static instance: ::protobuf::rt::LazyV2<PurchaseStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseStatus::new)
    }
}

impl ::protobuf::Clear for PurchaseStatus {
    fn clear(&mut self) {
        self.statusCode = ::std::option::Option::None;
        self.errorMessageHtml.clear();
        self.permissionError = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateSuggestedContentResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateSuggestedContentResponse {
    fn default() -> &'a RateSuggestedContentResponse {
        <RateSuggestedContentResponse as ::protobuf::Message>::default_instance()
    }
}

impl RateSuggestedContentResponse {
    pub fn new() -> RateSuggestedContentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateSuggestedContentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateSuggestedContentResponse {
        RateSuggestedContentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateSuggestedContentResponse>(
                "RateSuggestedContentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateSuggestedContentResponse {
        static instance: ::protobuf::rt::LazyV2<RateSuggestedContentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateSuggestedContentResponse::new)
    }
}

impl ::protobuf::Clear for RateSuggestedContentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateSuggestedContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateSuggestedContentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AggregateRating {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub starRating: ::std::option::Option<f32>,
    pub ratingsCount: ::std::option::Option<u64>,
    pub oneStarRatings: ::std::option::Option<u64>,
    pub twoStarRatings: ::std::option::Option<u64>,
    pub threeStarRatings: ::std::option::Option<u64>,
    pub fourStarRatings: ::std::option::Option<u64>,
    pub fiveStarRatings: ::std::option::Option<u64>,
    pub thumbsUpCount: ::std::option::Option<u64>,
    pub thumbsDownCount: ::std::option::Option<u64>,
    pub commentCount: ::std::option::Option<u64>,
    pub bayesianMeanRating: ::std::option::Option<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AggregateRating {
    fn default() -> &'a AggregateRating {
        <AggregateRating as ::protobuf::Message>::default_instance()
    }
}

impl AggregateRating {
    pub fn new() -> AggregateRating {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional float starRating = 2;


    pub fn get_starRating(&self) -> f32 {
        self.starRating.unwrap_or(0.)
    }

    // optional uint64 ratingsCount = 3;


    pub fn get_ratingsCount(&self) -> u64 {
        self.ratingsCount.unwrap_or(0)
    }

    // optional uint64 oneStarRatings = 4;


    pub fn get_oneStarRatings(&self) -> u64 {
        self.oneStarRatings.unwrap_or(0)
    }

    // optional uint64 twoStarRatings = 5;


    pub fn get_twoStarRatings(&self) -> u64 {
        self.twoStarRatings.unwrap_or(0)
    }

    // optional uint64 threeStarRatings = 6;


    pub fn get_threeStarRatings(&self) -> u64 {
        self.threeStarRatings.unwrap_or(0)
    }

    // optional uint64 fourStarRatings = 7;


    pub fn get_fourStarRatings(&self) -> u64 {
        self.fourStarRatings.unwrap_or(0)
    }

    // optional uint64 fiveStarRatings = 8;


    pub fn get_fiveStarRatings(&self) -> u64 {
        self.fiveStarRatings.unwrap_or(0)
    }

    // optional uint64 thumbsUpCount = 9;


    pub fn get_thumbsUpCount(&self) -> u64 {
        self.thumbsUpCount.unwrap_or(0)
    }

    // optional uint64 thumbsDownCount = 10;


    pub fn get_thumbsDownCount(&self) -> u64 {
        self.thumbsDownCount.unwrap_or(0)
    }

    // optional uint64 commentCount = 11;


    pub fn get_commentCount(&self) -> u64 {
        self.commentCount.unwrap_or(0)
    }

    // optional double bayesianMeanRating = 12;


    pub fn get_bayesianMeanRating(&self) -> f64 {
        self.bayesianMeanRating.unwrap_or(0.)
    }
}

impl ::protobuf::Message for AggregateRating {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ratingsCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.oneStarRatings = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.twoStarRatings = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.threeStarRatings = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fourStarRatings = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fiveStarRatings = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsUpCount = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsDownCount = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commentCount = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bayesianMeanRating = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += 5;
        }
        if let Some(v) = self.ratingsCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.oneStarRatings {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twoStarRatings {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threeStarRatings {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fourStarRatings {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fiveStarRatings {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsUpCount {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsDownCount {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commentCount {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bayesianMeanRating {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.ratingsCount {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.oneStarRatings {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.twoStarRatings {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.threeStarRatings {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.fourStarRatings {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.fiveStarRatings {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.thumbsUpCount {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.thumbsDownCount {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.commentCount {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.bayesianMeanRating {
            os.write_double(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregateRating {
        AggregateRating::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &AggregateRating| { &m.field_type },
                |m: &mut AggregateRating| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "starRating",
                |m: &AggregateRating| { &m.starRating },
                |m: &mut AggregateRating| { &mut m.starRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ratingsCount",
                |m: &AggregateRating| { &m.ratingsCount },
                |m: &mut AggregateRating| { &mut m.ratingsCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "oneStarRatings",
                |m: &AggregateRating| { &m.oneStarRatings },
                |m: &mut AggregateRating| { &mut m.oneStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "twoStarRatings",
                |m: &AggregateRating| { &m.twoStarRatings },
                |m: &mut AggregateRating| { &mut m.twoStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "threeStarRatings",
                |m: &AggregateRating| { &m.threeStarRatings },
                |m: &mut AggregateRating| { &mut m.threeStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fourStarRatings",
                |m: &AggregateRating| { &m.fourStarRatings },
                |m: &mut AggregateRating| { &mut m.fourStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fiveStarRatings",
                |m: &AggregateRating| { &m.fiveStarRatings },
                |m: &mut AggregateRating| { &mut m.fiveStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "thumbsUpCount",
                |m: &AggregateRating| { &m.thumbsUpCount },
                |m: &mut AggregateRating| { &mut m.thumbsUpCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "thumbsDownCount",
                |m: &AggregateRating| { &m.thumbsDownCount },
                |m: &mut AggregateRating| { &mut m.thumbsDownCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "commentCount",
                |m: &AggregateRating| { &m.commentCount },
                |m: &mut AggregateRating| { &mut m.commentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bayesianMeanRating",
                |m: &AggregateRating| { &m.bayesianMeanRating },
                |m: &mut AggregateRating| { &mut m.bayesianMeanRating },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AggregateRating>(
                "AggregateRating",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AggregateRating {
        static instance: ::protobuf::rt::LazyV2<AggregateRating> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AggregateRating::new)
    }
}

impl ::protobuf::Clear for AggregateRating {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.ratingsCount = ::std::option::Option::None;
        self.oneStarRatings = ::std::option::Option::None;
        self.twoStarRatings = ::std::option::Option::None;
        self.threeStarRatings = ::std::option::Option::None;
        self.fourStarRatings = ::std::option::Option::None;
        self.fiveStarRatings = ::std::option::Option::None;
        self.thumbsUpCount = ::std::option::Option::None;
        self.thumbsDownCount = ::std::option::Option::None;
        self.commentCount = ::std::option::Option::None;
        self.bayesianMeanRating = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AggregateRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregateRating {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DirectPurchase {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseDocid: ::protobuf::SingularField<::std::string::String>,
    pub parentDocid: ::protobuf::SingularField<::std::string::String>,
    pub offerType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectPurchase {
    fn default() -> &'a DirectPurchase {
        <DirectPurchase as ::protobuf::Message>::default_instance()
    }
}

impl DirectPurchase {
    pub fn new() -> DirectPurchase {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseDocid = 2;


    pub fn get_purchaseDocid(&self) -> &str {
        match self.purchaseDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string parentDocid = 3;


    pub fn get_parentDocid(&self) -> &str {
        match self.parentDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 offerType = 4;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }
}

impl ::protobuf::Message for DirectPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDocid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.purchaseDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.parentDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.purchaseDocid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.parentDocid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectPurchase {
        DirectPurchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &DirectPurchase| { &m.detailsUrl },
                |m: &mut DirectPurchase| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseDocid",
                |m: &DirectPurchase| { &m.purchaseDocid },
                |m: &mut DirectPurchase| { &mut m.purchaseDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDocid",
                |m: &DirectPurchase| { &m.parentDocid },
                |m: &mut DirectPurchase| { &mut m.parentDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &DirectPurchase| { &m.offerType },
                |m: &mut DirectPurchase| { &mut m.offerType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectPurchase>(
                "DirectPurchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectPurchase {
        static instance: ::protobuf::rt::LazyV2<DirectPurchase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectPurchase::new)
    }
}

impl ::protobuf::Clear for DirectPurchase {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.purchaseDocid.clear();
        self.parentDocid.clear();
        self.offerType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectPurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedeemGiftCard {
    // message fields
    pub prefillCode: ::protobuf::SingularField<::std::string::String>,
    pub partnerPayload: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedeemGiftCard {
    fn default() -> &'a RedeemGiftCard {
        <RedeemGiftCard as ::protobuf::Message>::default_instance()
    }
}

impl RedeemGiftCard {
    pub fn new() -> RedeemGiftCard {
        ::std::default::Default::default()
    }

    // optional string prefillCode = 1;


    pub fn get_prefillCode(&self) -> &str {
        match self.prefillCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string partnerPayload = 2;


    pub fn get_partnerPayload(&self) -> &str {
        match self.partnerPayload.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RedeemGiftCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefillCode)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partnerPayload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prefillCode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.partnerPayload.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prefillCode.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.partnerPayload.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemGiftCard {
        RedeemGiftCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefillCode",
                |m: &RedeemGiftCard| { &m.prefillCode },
                |m: &mut RedeemGiftCard| { &mut m.prefillCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "partnerPayload",
                |m: &RedeemGiftCard| { &m.partnerPayload },
                |m: &mut RedeemGiftCard| { &mut m.partnerPayload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedeemGiftCard>(
                "RedeemGiftCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemGiftCard {
        static instance: ::protobuf::rt::LazyV2<RedeemGiftCard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedeemGiftCard::new)
    }
}

impl ::protobuf::Clear for RedeemGiftCard {
    fn clear(&mut self) {
        self.prefillCode.clear();
        self.partnerPayload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemGiftCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemGiftCard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResolvedLink {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub searchUrl: ::protobuf::SingularField<::std::string::String>,
    pub directPurchase: ::protobuf::SingularPtrField<DirectPurchase>,
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub redeemGiftCard: ::protobuf::SingularPtrField<RedeemGiftCard>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub wishlistUrl: ::protobuf::SingularField<::std::string::String>,
    pub backend: ::std::option::Option<i32>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolvedLink {
    fn default() -> &'a ResolvedLink {
        <ResolvedLink as ::protobuf::Message>::default_instance()
    }
}

impl ResolvedLink {
    pub fn new() -> ResolvedLink {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string browseUrl = 2;


    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string searchUrl = 3;


    pub fn get_searchUrl(&self) -> &str {
        match self.searchUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DirectPurchase directPurchase = 4;


    pub fn get_directPurchase(&self) -> &DirectPurchase {
        self.directPurchase.as_ref().unwrap_or_else(|| <DirectPurchase as ::protobuf::Message>::default_instance())
    }

    // optional string homeUrl = 5;


    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .RedeemGiftCard redeemGiftCard = 6;


    pub fn get_redeemGiftCard(&self) -> &RedeemGiftCard {
        self.redeemGiftCard.as_ref().unwrap_or_else(|| <RedeemGiftCard as ::protobuf::Message>::default_instance())
    }

    // optional bytes serverLogsCookie = 7;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .Docid docid = 8;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional string wishlistUrl = 9;


    pub fn get_wishlistUrl(&self) -> &str {
        match self.wishlistUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 backend = 10;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string query = 11;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ResolvedLink {
    fn is_initialized(&self) -> bool {
        for v in &self.directPurchase {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemGiftCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.directPurchase)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeemGiftCard)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.wishlistUrl)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.searchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.directPurchase.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.redeemGiftCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.wishlistUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.browseUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.searchUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.directPurchase.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.redeemGiftCard.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.wishlistUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.backend {
            os.write_int32(10, v)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolvedLink {
        ResolvedLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &ResolvedLink| { &m.detailsUrl },
                |m: &mut ResolvedLink| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "browseUrl",
                |m: &ResolvedLink| { &m.browseUrl },
                |m: &mut ResolvedLink| { &mut m.browseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searchUrl",
                |m: &ResolvedLink| { &m.searchUrl },
                |m: &mut ResolvedLink| { &mut m.searchUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirectPurchase>>(
                "directPurchase",
                |m: &ResolvedLink| { &m.directPurchase },
                |m: &mut ResolvedLink| { &mut m.directPurchase },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "homeUrl",
                |m: &ResolvedLink| { &m.homeUrl },
                |m: &mut ResolvedLink| { &mut m.homeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemGiftCard>>(
                "redeemGiftCard",
                |m: &ResolvedLink| { &m.redeemGiftCard },
                |m: &mut ResolvedLink| { &mut m.redeemGiftCard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &ResolvedLink| { &m.serverLogsCookie },
                |m: &mut ResolvedLink| { &mut m.serverLogsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &ResolvedLink| { &m.docid },
                |m: &mut ResolvedLink| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wishlistUrl",
                |m: &ResolvedLink| { &m.wishlistUrl },
                |m: &mut ResolvedLink| { &mut m.wishlistUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &ResolvedLink| { &m.backend },
                |m: &mut ResolvedLink| { &mut m.backend },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &ResolvedLink| { &m.query },
                |m: &mut ResolvedLink| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResolvedLink>(
                "ResolvedLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResolvedLink {
        static instance: ::protobuf::rt::LazyV2<ResolvedLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResolvedLink::new)
    }
}

impl ::protobuf::Clear for ResolvedLink {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.browseUrl.clear();
        self.searchUrl.clear();
        self.directPurchase.clear();
        self.homeUrl.clear();
        self.redeemGiftCard.clear();
        self.serverLogsCookie.clear();
        self.docid.clear();
        self.wishlistUrl.clear();
        self.backend = ::std::option::Option::None;
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResolvedLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Payload {
    // message fields
    pub listResponse: ::protobuf::SingularPtrField<ListResponse>,
    pub detailsResponse: ::protobuf::SingularPtrField<DetailsResponse>,
    pub reviewResponse: ::protobuf::SingularPtrField<ReviewResponse>,
    pub buyResponse: ::protobuf::SingularPtrField<BuyResponse>,
    pub searchResponse: ::protobuf::SingularPtrField<SearchResponse>,
    pub tocResponse: ::protobuf::SingularPtrField<TocResponse>,
    pub browseResponse: ::protobuf::SingularPtrField<BrowseResponse>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub updateInstrumentResponse: ::protobuf::SingularPtrField<UpdateInstrumentResponse>,
    pub logResponse: ::protobuf::SingularPtrField<LogResponse>,
    pub checkInstrumentResponse: ::protobuf::SingularPtrField<CheckInstrumentResponse>,
    pub plusOneResponse: ::protobuf::SingularPtrField<PlusOneResponse>,
    pub flagContentResponse: ::protobuf::SingularPtrField<FlagContentResponse>,
    pub ackNotificationResponse: ::protobuf::SingularPtrField<AckNotificationResponse>,
    pub initiateAssociationResponse: ::protobuf::SingularPtrField<InitiateAssociationResponse>,
    pub verifyAssociationResponse: ::protobuf::SingularPtrField<VerifyAssociationResponse>,
    pub libraryReplicationResponse: ::protobuf::SingularPtrField<LibraryReplicationResponse>,
    pub revokeResponse: ::protobuf::SingularPtrField<RevokeResponse>,
    pub bulkDetailsResponse: ::protobuf::SingularPtrField<BulkDetailsResponse>,
    pub resolveLinkResponse: ::protobuf::SingularPtrField<ResolvedLink>,
    pub deliveryResponse: ::protobuf::SingularPtrField<DeliveryResponse>,
    pub acceptTosResponse: ::protobuf::SingularPtrField<AcceptTosResponse>,
    pub rateSuggestedContentResponse: ::protobuf::SingularPtrField<RateSuggestedContentResponse>,
    pub checkPromoOfferResponse: ::protobuf::SingularPtrField<CheckPromoOfferResponse>,
    pub instrumentSetupInfoResponse: ::protobuf::SingularPtrField<InstrumentSetupInfoResponse>,
    pub redeemGiftCardResponse: ::protobuf::SingularPtrField<RedeemGiftCardResponse>,
    pub modifyLibraryResponse: ::protobuf::SingularPtrField<ModifyLibraryResponse>,
    pub uploadDeviceConfigResponse: ::protobuf::SingularPtrField<UploadDeviceConfigResponse>,
    pub plusProfileResponse: ::protobuf::SingularPtrField<PlusProfileResponse>,
    pub consumePurchaseResponse: ::protobuf::SingularPtrField<ConsumePurchaseResponse>,
    pub billingProfileResponse: ::protobuf::SingularPtrField<BillingProfileResponse>,
    pub preparePurchaseResponse: ::protobuf::SingularPtrField<PreparePurchaseResponse>,
    pub commitPurchaseResponse: ::protobuf::SingularPtrField<CommitPurchaseResponse>,
    pub debugSettingsResponse: ::protobuf::SingularPtrField<DebugSettingsResponse>,
    pub checkIabPromoResponse: ::protobuf::SingularPtrField<CheckIabPromoResponse>,
    pub userActivitySettingsResponse: ::protobuf::SingularPtrField<UserActivitySettingsResponse>,
    pub recordUserActivityResponse: ::protobuf::SingularPtrField<RecordUserActivityResponse>,
    pub redeemCodeResponse: ::protobuf::SingularPtrField<RedeemCodeResponse>,
    pub selfUpdateResponse: ::protobuf::SingularPtrField<SelfUpdateResponse>,
    pub searchSuggestResponse: ::protobuf::SingularPtrField<searchSuggestResponse>,
    pub getInitialInstrumentFlowStateResponse: ::protobuf::SingularPtrField<GetInitialInstrumentFlowStateResponse>,
    pub createInstrumentResponse: ::protobuf::SingularPtrField<CreateInstrumentResponse>,
    pub challengeResponse: ::protobuf::SingularPtrField<ChallengeResponse>,
    pub backupDeviceChoicesResponse: ::protobuf::SingularPtrField<BackDeviceChoicesResponse>,
    pub backupDocumentChoicesResponse: ::protobuf::SingularPtrField<BackupDocumentChoicesResponse>,
    pub earlyUpdateResponse: ::protobuf::SingularPtrField<EarlyUpdateResponse>,
    pub preloadsResponse: ::protobuf::SingularPtrField<PreloadsResponse>,
    pub myAccountsResponse: ::protobuf::SingularPtrField<MyAccountsResponse>,
    pub contentFilterResponse: ::protobuf::SingularPtrField<ContentFilterResponse>,
    pub experimentsResponse: ::protobuf::SingularPtrField<ExperimentsResponse>,
    pub surveyResponse: ::protobuf::SingularPtrField<SurveyResponse>,
    pub pingResponse: ::protobuf::SingularPtrField<PingResponse>,
    pub updateUserSettingResponse: ::protobuf::SingularPtrField<UpdateUserSettingResponse>,
    pub getUserSettingsREsponse: ::protobuf::SingularPtrField<GetUserSettingsResponse>,
    pub getSharingSettingsResponse: ::protobuf::SingularPtrField<GetSharingSettingsResponse>,
    pub updateSharingSettingsResponse: ::protobuf::SingularPtrField<UpdateSharingSettingsResponse>,
    pub reviewSnippetsResponse: ::protobuf::SingularPtrField<ReviewSnippetsResponse>,
    pub documentSharingStateResponse: ::protobuf::SingularPtrField<DocumentSharingStateResponse>,
    pub moduleDeliveryResponse: ::protobuf::SingularPtrField<ModuleDeliveryResponse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    // optional .ListResponse listResponse = 1;


    pub fn get_listResponse(&self) -> &ListResponse {
        self.listResponse.as_ref().unwrap_or_else(|| <ListResponse as ::protobuf::Message>::default_instance())
    }

    // optional .DetailsResponse detailsResponse = 2;


    pub fn get_detailsResponse(&self) -> &DetailsResponse {
        self.detailsResponse.as_ref().unwrap_or_else(|| <DetailsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ReviewResponse reviewResponse = 3;


    pub fn get_reviewResponse(&self) -> &ReviewResponse {
        self.reviewResponse.as_ref().unwrap_or_else(|| <ReviewResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BuyResponse buyResponse = 4;


    pub fn get_buyResponse(&self) -> &BuyResponse {
        self.buyResponse.as_ref().unwrap_or_else(|| <BuyResponse as ::protobuf::Message>::default_instance())
    }

    // optional .SearchResponse searchResponse = 5;


    pub fn get_searchResponse(&self) -> &SearchResponse {
        self.searchResponse.as_ref().unwrap_or_else(|| <SearchResponse as ::protobuf::Message>::default_instance())
    }

    // optional .TocResponse tocResponse = 6;


    pub fn get_tocResponse(&self) -> &TocResponse {
        self.tocResponse.as_ref().unwrap_or_else(|| <TocResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BrowseResponse browseResponse = 7;


    pub fn get_browseResponse(&self) -> &BrowseResponse {
        self.browseResponse.as_ref().unwrap_or_else(|| <BrowseResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseStatusResponse purchaseStatusResponse = 8;


    pub fn get_purchaseStatusResponse(&self) -> &PurchaseStatusResponse {
        self.purchaseStatusResponse.as_ref().unwrap_or_else(|| <PurchaseStatusResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UpdateInstrumentResponse updateInstrumentResponse = 9;


    pub fn get_updateInstrumentResponse(&self) -> &UpdateInstrumentResponse {
        self.updateInstrumentResponse.as_ref().unwrap_or_else(|| <UpdateInstrumentResponse as ::protobuf::Message>::default_instance())
    }

    // optional .LogResponse logResponse = 10;


    pub fn get_logResponse(&self) -> &LogResponse {
        self.logResponse.as_ref().unwrap_or_else(|| <LogResponse as ::protobuf::Message>::default_instance())
    }

    // optional .CheckInstrumentResponse checkInstrumentResponse = 11;


    pub fn get_checkInstrumentResponse(&self) -> &CheckInstrumentResponse {
        self.checkInstrumentResponse.as_ref().unwrap_or_else(|| <CheckInstrumentResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PlusOneResponse plusOneResponse = 12;


    pub fn get_plusOneResponse(&self) -> &PlusOneResponse {
        self.plusOneResponse.as_ref().unwrap_or_else(|| <PlusOneResponse as ::protobuf::Message>::default_instance())
    }

    // optional .FlagContentResponse flagContentResponse = 13;


    pub fn get_flagContentResponse(&self) -> &FlagContentResponse {
        self.flagContentResponse.as_ref().unwrap_or_else(|| <FlagContentResponse as ::protobuf::Message>::default_instance())
    }

    // optional .AckNotificationResponse ackNotificationResponse = 14;


    pub fn get_ackNotificationResponse(&self) -> &AckNotificationResponse {
        self.ackNotificationResponse.as_ref().unwrap_or_else(|| <AckNotificationResponse as ::protobuf::Message>::default_instance())
    }

    // optional .InitiateAssociationResponse initiateAssociationResponse = 15;


    pub fn get_initiateAssociationResponse(&self) -> &InitiateAssociationResponse {
        self.initiateAssociationResponse.as_ref().unwrap_or_else(|| <InitiateAssociationResponse as ::protobuf::Message>::default_instance())
    }

    // optional .VerifyAssociationResponse verifyAssociationResponse = 16;


    pub fn get_verifyAssociationResponse(&self) -> &VerifyAssociationResponse {
        self.verifyAssociationResponse.as_ref().unwrap_or_else(|| <VerifyAssociationResponse as ::protobuf::Message>::default_instance())
    }

    // optional .LibraryReplicationResponse libraryReplicationResponse = 17;


    pub fn get_libraryReplicationResponse(&self) -> &LibraryReplicationResponse {
        self.libraryReplicationResponse.as_ref().unwrap_or_else(|| <LibraryReplicationResponse as ::protobuf::Message>::default_instance())
    }

    // optional .RevokeResponse revokeResponse = 18;


    pub fn get_revokeResponse(&self) -> &RevokeResponse {
        self.revokeResponse.as_ref().unwrap_or_else(|| <RevokeResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BulkDetailsResponse bulkDetailsResponse = 19;


    pub fn get_bulkDetailsResponse(&self) -> &BulkDetailsResponse {
        self.bulkDetailsResponse.as_ref().unwrap_or_else(|| <BulkDetailsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ResolvedLink resolveLinkResponse = 20;


    pub fn get_resolveLinkResponse(&self) -> &ResolvedLink {
        self.resolveLinkResponse.as_ref().unwrap_or_else(|| <ResolvedLink as ::protobuf::Message>::default_instance())
    }

    // optional .DeliveryResponse deliveryResponse = 21;


    pub fn get_deliveryResponse(&self) -> &DeliveryResponse {
        self.deliveryResponse.as_ref().unwrap_or_else(|| <DeliveryResponse as ::protobuf::Message>::default_instance())
    }

    // optional .AcceptTosResponse acceptTosResponse = 22;


    pub fn get_acceptTosResponse(&self) -> &AcceptTosResponse {
        self.acceptTosResponse.as_ref().unwrap_or_else(|| <AcceptTosResponse as ::protobuf::Message>::default_instance())
    }

    // optional .RateSuggestedContentResponse rateSuggestedContentResponse = 23;


    pub fn get_rateSuggestedContentResponse(&self) -> &RateSuggestedContentResponse {
        self.rateSuggestedContentResponse.as_ref().unwrap_or_else(|| <RateSuggestedContentResponse as ::protobuf::Message>::default_instance())
    }

    // optional .CheckPromoOfferResponse checkPromoOfferResponse = 24;


    pub fn get_checkPromoOfferResponse(&self) -> &CheckPromoOfferResponse {
        self.checkPromoOfferResponse.as_ref().unwrap_or_else(|| <CheckPromoOfferResponse as ::protobuf::Message>::default_instance())
    }

    // optional .InstrumentSetupInfoResponse instrumentSetupInfoResponse = 25;


    pub fn get_instrumentSetupInfoResponse(&self) -> &InstrumentSetupInfoResponse {
        self.instrumentSetupInfoResponse.as_ref().unwrap_or_else(|| <InstrumentSetupInfoResponse as ::protobuf::Message>::default_instance())
    }

    // optional .RedeemGiftCardResponse redeemGiftCardResponse = 26;


    pub fn get_redeemGiftCardResponse(&self) -> &RedeemGiftCardResponse {
        self.redeemGiftCardResponse.as_ref().unwrap_or_else(|| <RedeemGiftCardResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ModifyLibraryResponse modifyLibraryResponse = 27;


    pub fn get_modifyLibraryResponse(&self) -> &ModifyLibraryResponse {
        self.modifyLibraryResponse.as_ref().unwrap_or_else(|| <ModifyLibraryResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UploadDeviceConfigResponse uploadDeviceConfigResponse = 28;


    pub fn get_uploadDeviceConfigResponse(&self) -> &UploadDeviceConfigResponse {
        self.uploadDeviceConfigResponse.as_ref().unwrap_or_else(|| <UploadDeviceConfigResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PlusProfileResponse plusProfileResponse = 29;


    pub fn get_plusProfileResponse(&self) -> &PlusProfileResponse {
        self.plusProfileResponse.as_ref().unwrap_or_else(|| <PlusProfileResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ConsumePurchaseResponse consumePurchaseResponse = 30;


    pub fn get_consumePurchaseResponse(&self) -> &ConsumePurchaseResponse {
        self.consumePurchaseResponse.as_ref().unwrap_or_else(|| <ConsumePurchaseResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BillingProfileResponse billingProfileResponse = 31;


    pub fn get_billingProfileResponse(&self) -> &BillingProfileResponse {
        self.billingProfileResponse.as_ref().unwrap_or_else(|| <BillingProfileResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PreparePurchaseResponse preparePurchaseResponse = 32;


    pub fn get_preparePurchaseResponse(&self) -> &PreparePurchaseResponse {
        self.preparePurchaseResponse.as_ref().unwrap_or_else(|| <PreparePurchaseResponse as ::protobuf::Message>::default_instance())
    }

    // optional .CommitPurchaseResponse commitPurchaseResponse = 33;


    pub fn get_commitPurchaseResponse(&self) -> &CommitPurchaseResponse {
        self.commitPurchaseResponse.as_ref().unwrap_or_else(|| <CommitPurchaseResponse as ::protobuf::Message>::default_instance())
    }

    // optional .DebugSettingsResponse debugSettingsResponse = 34;


    pub fn get_debugSettingsResponse(&self) -> &DebugSettingsResponse {
        self.debugSettingsResponse.as_ref().unwrap_or_else(|| <DebugSettingsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .CheckIabPromoResponse checkIabPromoResponse = 35;


    pub fn get_checkIabPromoResponse(&self) -> &CheckIabPromoResponse {
        self.checkIabPromoResponse.as_ref().unwrap_or_else(|| <CheckIabPromoResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UserActivitySettingsResponse userActivitySettingsResponse = 36;


    pub fn get_userActivitySettingsResponse(&self) -> &UserActivitySettingsResponse {
        self.userActivitySettingsResponse.as_ref().unwrap_or_else(|| <UserActivitySettingsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .RecordUserActivityResponse recordUserActivityResponse = 37;


    pub fn get_recordUserActivityResponse(&self) -> &RecordUserActivityResponse {
        self.recordUserActivityResponse.as_ref().unwrap_or_else(|| <RecordUserActivityResponse as ::protobuf::Message>::default_instance())
    }

    // optional .RedeemCodeResponse redeemCodeResponse = 38;


    pub fn get_redeemCodeResponse(&self) -> &RedeemCodeResponse {
        self.redeemCodeResponse.as_ref().unwrap_or_else(|| <RedeemCodeResponse as ::protobuf::Message>::default_instance())
    }

    // optional .SelfUpdateResponse selfUpdateResponse = 39;


    pub fn get_selfUpdateResponse(&self) -> &SelfUpdateResponse {
        self.selfUpdateResponse.as_ref().unwrap_or_else(|| <SelfUpdateResponse as ::protobuf::Message>::default_instance())
    }

    // optional .searchSuggestResponse searchSuggestResponse = 40;


    pub fn get_searchSuggestResponse(&self) -> &searchSuggestResponse {
        self.searchSuggestResponse.as_ref().unwrap_or_else(|| <searchSuggestResponse as ::protobuf::Message>::default_instance())
    }

    // optional .GetInitialInstrumentFlowStateResponse getInitialInstrumentFlowStateResponse = 41;


    pub fn get_getInitialInstrumentFlowStateResponse(&self) -> &GetInitialInstrumentFlowStateResponse {
        self.getInitialInstrumentFlowStateResponse.as_ref().unwrap_or_else(|| <GetInitialInstrumentFlowStateResponse as ::protobuf::Message>::default_instance())
    }

    // optional .CreateInstrumentResponse createInstrumentResponse = 42;


    pub fn get_createInstrumentResponse(&self) -> &CreateInstrumentResponse {
        self.createInstrumentResponse.as_ref().unwrap_or_else(|| <CreateInstrumentResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ChallengeResponse challengeResponse = 43;


    pub fn get_challengeResponse(&self) -> &ChallengeResponse {
        self.challengeResponse.as_ref().unwrap_or_else(|| <ChallengeResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BackDeviceChoicesResponse backupDeviceChoicesResponse = 44;


    pub fn get_backupDeviceChoicesResponse(&self) -> &BackDeviceChoicesResponse {
        self.backupDeviceChoicesResponse.as_ref().unwrap_or_else(|| <BackDeviceChoicesResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BackupDocumentChoicesResponse backupDocumentChoicesResponse = 45;


    pub fn get_backupDocumentChoicesResponse(&self) -> &BackupDocumentChoicesResponse {
        self.backupDocumentChoicesResponse.as_ref().unwrap_or_else(|| <BackupDocumentChoicesResponse as ::protobuf::Message>::default_instance())
    }

    // optional .EarlyUpdateResponse earlyUpdateResponse = 46;


    pub fn get_earlyUpdateResponse(&self) -> &EarlyUpdateResponse {
        self.earlyUpdateResponse.as_ref().unwrap_or_else(|| <EarlyUpdateResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PreloadsResponse preloadsResponse = 47;


    pub fn get_preloadsResponse(&self) -> &PreloadsResponse {
        self.preloadsResponse.as_ref().unwrap_or_else(|| <PreloadsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .MyAccountsResponse myAccountsResponse = 48;


    pub fn get_myAccountsResponse(&self) -> &MyAccountsResponse {
        self.myAccountsResponse.as_ref().unwrap_or_else(|| <MyAccountsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ContentFilterResponse contentFilterResponse = 49;


    pub fn get_contentFilterResponse(&self) -> &ContentFilterResponse {
        self.contentFilterResponse.as_ref().unwrap_or_else(|| <ContentFilterResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ExperimentsResponse experimentsResponse = 50;


    pub fn get_experimentsResponse(&self) -> &ExperimentsResponse {
        self.experimentsResponse.as_ref().unwrap_or_else(|| <ExperimentsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .SurveyResponse surveyResponse = 51;


    pub fn get_surveyResponse(&self) -> &SurveyResponse {
        self.surveyResponse.as_ref().unwrap_or_else(|| <SurveyResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PingResponse pingResponse = 52;


    pub fn get_pingResponse(&self) -> &PingResponse {
        self.pingResponse.as_ref().unwrap_or_else(|| <PingResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UpdateUserSettingResponse updateUserSettingResponse = 53;


    pub fn get_updateUserSettingResponse(&self) -> &UpdateUserSettingResponse {
        self.updateUserSettingResponse.as_ref().unwrap_or_else(|| <UpdateUserSettingResponse as ::protobuf::Message>::default_instance())
    }

    // optional .GetUserSettingsResponse getUserSettingsREsponse = 54;


    pub fn get_getUserSettingsREsponse(&self) -> &GetUserSettingsResponse {
        self.getUserSettingsREsponse.as_ref().unwrap_or_else(|| <GetUserSettingsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .GetSharingSettingsResponse getSharingSettingsResponse = 56;


    pub fn get_getSharingSettingsResponse(&self) -> &GetSharingSettingsResponse {
        self.getSharingSettingsResponse.as_ref().unwrap_or_else(|| <GetSharingSettingsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UpdateSharingSettingsResponse updateSharingSettingsResponse = 57;


    pub fn get_updateSharingSettingsResponse(&self) -> &UpdateSharingSettingsResponse {
        self.updateSharingSettingsResponse.as_ref().unwrap_or_else(|| <UpdateSharingSettingsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ReviewSnippetsResponse reviewSnippetsResponse = 58;


    pub fn get_reviewSnippetsResponse(&self) -> &ReviewSnippetsResponse {
        self.reviewSnippetsResponse.as_ref().unwrap_or_else(|| <ReviewSnippetsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .DocumentSharingStateResponse documentSharingStateResponse = 59;


    pub fn get_documentSharingStateResponse(&self) -> &DocumentSharingStateResponse {
        self.documentSharingStateResponse.as_ref().unwrap_or_else(|| <DocumentSharingStateResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ModuleDeliveryResponse moduleDeliveryResponse = 70;


    pub fn get_moduleDeliveryResponse(&self) -> &ModuleDeliveryResponse {
        self.moduleDeliveryResponse.as_ref().unwrap_or_else(|| <ModuleDeliveryResponse as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Payload {
    fn is_initialized(&self) -> bool {
        for v in &self.listResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reviewResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buyResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tocResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.browseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flagContentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initiateAssociationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.verifyAssociationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryReplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revokeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bulkDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resolveLinkResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deliveryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptTosResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateSuggestedContentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkPromoOfferResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.instrumentSetupInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemGiftCardResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyLibraryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uploadDeviceConfigResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusProfileResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumePurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingProfileResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparePurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commitPurchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debugSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkIabPromoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userActivitySettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recordUserActivityResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeemCodeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfUpdateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchSuggestResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInitialInstrumentFlowStateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.createInstrumentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challengeResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backupDeviceChoicesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.backupDocumentChoicesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.earlyUpdateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preloadsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.myAccountsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentFilterResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experimentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.surveyResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pingResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateUserSettingResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getUserSettingsREsponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSharingSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updateSharingSettingsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reviewSnippetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.documentSharingStateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.moduleDeliveryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.listResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.detailsResponse)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reviewResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buyResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.searchResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tocResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.browseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updateInstrumentResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkInstrumentResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusOneResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flagContentResponse)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackNotificationResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initiateAssociationResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verifyAssociationResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryReplicationResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revokeResponse)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bulkDetailsResponse)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resolveLinkResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deliveryResponse)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acceptTosResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rateSuggestedContentResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkPromoOfferResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.instrumentSetupInfoResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeemGiftCardResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyLibraryResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uploadDeviceConfigResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusProfileResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumePurchaseResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingProfileResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparePurchaseResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commitPurchaseResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debugSettingsResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkIabPromoResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userActivitySettingsResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recordUserActivityResponse)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeemCodeResponse)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selfUpdateResponse)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.searchSuggestResponse)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getInitialInstrumentFlowStateResponse)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.createInstrumentResponse)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challengeResponse)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backupDeviceChoicesResponse)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backupDocumentChoicesResponse)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.earlyUpdateResponse)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preloadsResponse)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.myAccountsResponse)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contentFilterResponse)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experimentsResponse)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.surveyResponse)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pingResponse)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updateUserSettingResponse)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getUserSettingsREsponse)?;
                },
                56 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSharingSettingsResponse)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updateSharingSettingsResponse)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reviewSnippetsResponse)?;
                },
                59 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.documentSharingStateResponse)?;
                },
                70 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.moduleDeliveryResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.listResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reviewResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buyResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.searchResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tocResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.browseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updateInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.logResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plusOneResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flagContentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackNotificationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initiateAssociationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.verifyAssociationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.libraryReplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.revokeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bulkDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resolveLinkResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deliveryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acceptTosResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rateSuggestedContentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkPromoOfferResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instrumentSetupInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.redeemGiftCardResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyLibraryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uploadDeviceConfigResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plusProfileResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumePurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingProfileResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparePurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commitPurchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.debugSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkIabPromoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userActivitySettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recordUserActivityResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.redeemCodeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selfUpdateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.searchSuggestResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getInitialInstrumentFlowStateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.createInstrumentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.challengeResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.backupDeviceChoicesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.backupDocumentChoicesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.earlyUpdateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preloadsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.myAccountsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contentFilterResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.experimentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.surveyResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pingResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updateUserSettingResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getUserSettingsREsponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSharingSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updateSharingSettingsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reviewSnippetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.documentSharingStateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.moduleDeliveryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.listResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detailsResponse.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reviewResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buyResponse.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.searchResponse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tocResponse.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.browseResponse.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updateInstrumentResponse.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.logResponse.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkInstrumentResponse.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plusOneResponse.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flagContentResponse.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackNotificationResponse.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initiateAssociationResponse.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.verifyAssociationResponse.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.libraryReplicationResponse.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.revokeResponse.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bulkDetailsResponse.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resolveLinkResponse.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deliveryResponse.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acceptTosResponse.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rateSuggestedContentResponse.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkPromoOfferResponse.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instrumentSetupInfoResponse.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.redeemGiftCardResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyLibraryResponse.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uploadDeviceConfigResponse.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plusProfileResponse.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumePurchaseResponse.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingProfileResponse.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparePurchaseResponse.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commitPurchaseResponse.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.debugSettingsResponse.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkIabPromoResponse.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userActivitySettingsResponse.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recordUserActivityResponse.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.redeemCodeResponse.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selfUpdateResponse.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.searchSuggestResponse.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getInitialInstrumentFlowStateResponse.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.createInstrumentResponse.as_ref() {
            os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.challengeResponse.as_ref() {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.backupDeviceChoicesResponse.as_ref() {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.backupDocumentChoicesResponse.as_ref() {
            os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.earlyUpdateResponse.as_ref() {
            os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preloadsResponse.as_ref() {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.myAccountsResponse.as_ref() {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contentFilterResponse.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.experimentsResponse.as_ref() {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.surveyResponse.as_ref() {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pingResponse.as_ref() {
            os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updateUserSettingResponse.as_ref() {
            os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getUserSettingsREsponse.as_ref() {
            os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSharingSettingsResponse.as_ref() {
            os.write_tag(56, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updateSharingSettingsResponse.as_ref() {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reviewSnippetsResponse.as_ref() {
            os.write_tag(58, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.documentSharingStateResponse.as_ref() {
            os.write_tag(59, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.moduleDeliveryResponse.as_ref() {
            os.write_tag(70, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListResponse>>(
                "listResponse",
                |m: &Payload| { &m.listResponse },
                |m: &mut Payload| { &mut m.listResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailsResponse>>(
                "detailsResponse",
                |m: &Payload| { &m.detailsResponse },
                |m: &mut Payload| { &mut m.detailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewResponse>>(
                "reviewResponse",
                |m: &Payload| { &m.reviewResponse },
                |m: &mut Payload| { &mut m.reviewResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuyResponse>>(
                "buyResponse",
                |m: &Payload| { &m.buyResponse },
                |m: &mut Payload| { &mut m.buyResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchResponse>>(
                "searchResponse",
                |m: &Payload| { &m.searchResponse },
                |m: &mut Payload| { &mut m.searchResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TocResponse>>(
                "tocResponse",
                |m: &Payload| { &m.tocResponse },
                |m: &mut Payload| { &mut m.tocResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseResponse>>(
                "browseResponse",
                |m: &Payload| { &m.browseResponse },
                |m: &mut Payload| { &mut m.browseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>>(
                "purchaseStatusResponse",
                |m: &Payload| { &m.purchaseStatusResponse },
                |m: &mut Payload| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateInstrumentResponse>>(
                "updateInstrumentResponse",
                |m: &Payload| { &m.updateInstrumentResponse },
                |m: &mut Payload| { &mut m.updateInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogResponse>>(
                "logResponse",
                |m: &Payload| { &m.logResponse },
                |m: &mut Payload| { &mut m.logResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckInstrumentResponse>>(
                "checkInstrumentResponse",
                |m: &Payload| { &m.checkInstrumentResponse },
                |m: &mut Payload| { &mut m.checkInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneResponse>>(
                "plusOneResponse",
                |m: &Payload| { &m.plusOneResponse },
                |m: &mut Payload| { &mut m.plusOneResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlagContentResponse>>(
                "flagContentResponse",
                |m: &Payload| { &m.flagContentResponse },
                |m: &mut Payload| { &mut m.flagContentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationResponse>>(
                "ackNotificationResponse",
                |m: &Payload| { &m.ackNotificationResponse },
                |m: &mut Payload| { &mut m.ackNotificationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InitiateAssociationResponse>>(
                "initiateAssociationResponse",
                |m: &Payload| { &m.initiateAssociationResponse },
                |m: &mut Payload| { &mut m.initiateAssociationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerifyAssociationResponse>>(
                "verifyAssociationResponse",
                |m: &Payload| { &m.verifyAssociationResponse },
                |m: &mut Payload| { &mut m.verifyAssociationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryReplicationResponse>>(
                "libraryReplicationResponse",
                |m: &Payload| { &m.libraryReplicationResponse },
                |m: &mut Payload| { &mut m.libraryReplicationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RevokeResponse>>(
                "revokeResponse",
                |m: &Payload| { &m.revokeResponse },
                |m: &mut Payload| { &mut m.revokeResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsResponse>>(
                "bulkDetailsResponse",
                |m: &Payload| { &m.bulkDetailsResponse },
                |m: &mut Payload| { &mut m.bulkDetailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResolvedLink>>(
                "resolveLinkResponse",
                |m: &Payload| { &m.resolveLinkResponse },
                |m: &mut Payload| { &mut m.resolveLinkResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeliveryResponse>>(
                "deliveryResponse",
                |m: &Payload| { &m.deliveryResponse },
                |m: &mut Payload| { &mut m.deliveryResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AcceptTosResponse>>(
                "acceptTosResponse",
                |m: &Payload| { &m.acceptTosResponse },
                |m: &mut Payload| { &mut m.acceptTosResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateSuggestedContentResponse>>(
                "rateSuggestedContentResponse",
                |m: &Payload| { &m.rateSuggestedContentResponse },
                |m: &mut Payload| { &mut m.rateSuggestedContentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckPromoOfferResponse>>(
                "checkPromoOfferResponse",
                |m: &Payload| { &m.checkPromoOfferResponse },
                |m: &mut Payload| { &mut m.checkPromoOfferResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstrumentSetupInfoResponse>>(
                "instrumentSetupInfoResponse",
                |m: &Payload| { &m.instrumentSetupInfoResponse },
                |m: &mut Payload| { &mut m.instrumentSetupInfoResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemGiftCardResponse>>(
                "redeemGiftCardResponse",
                |m: &Payload| { &m.redeemGiftCardResponse },
                |m: &mut Payload| { &mut m.redeemGiftCardResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyLibraryResponse>>(
                "modifyLibraryResponse",
                |m: &Payload| { &m.modifyLibraryResponse },
                |m: &mut Payload| { &mut m.modifyLibraryResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UploadDeviceConfigResponse>>(
                "uploadDeviceConfigResponse",
                |m: &Payload| { &m.uploadDeviceConfigResponse },
                |m: &mut Payload| { &mut m.uploadDeviceConfigResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfileResponse>>(
                "plusProfileResponse",
                |m: &Payload| { &m.plusProfileResponse },
                |m: &mut Payload| { &mut m.plusProfileResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumePurchaseResponse>>(
                "consumePurchaseResponse",
                |m: &Payload| { &m.consumePurchaseResponse },
                |m: &mut Payload| { &mut m.consumePurchaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingProfileResponse>>(
                "billingProfileResponse",
                |m: &Payload| { &m.billingProfileResponse },
                |m: &mut Payload| { &mut m.billingProfileResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreparePurchaseResponse>>(
                "preparePurchaseResponse",
                |m: &Payload| { &m.preparePurchaseResponse },
                |m: &mut Payload| { &mut m.preparePurchaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommitPurchaseResponse>>(
                "commitPurchaseResponse",
                |m: &Payload| { &m.commitPurchaseResponse },
                |m: &mut Payload| { &mut m.commitPurchaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugSettingsResponse>>(
                "debugSettingsResponse",
                |m: &Payload| { &m.debugSettingsResponse },
                |m: &mut Payload| { &mut m.debugSettingsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckIabPromoResponse>>(
                "checkIabPromoResponse",
                |m: &Payload| { &m.checkIabPromoResponse },
                |m: &mut Payload| { &mut m.checkIabPromoResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserActivitySettingsResponse>>(
                "userActivitySettingsResponse",
                |m: &Payload| { &m.userActivitySettingsResponse },
                |m: &mut Payload| { &mut m.userActivitySettingsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecordUserActivityResponse>>(
                "recordUserActivityResponse",
                |m: &Payload| { &m.recordUserActivityResponse },
                |m: &mut Payload| { &mut m.recordUserActivityResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedeemCodeResponse>>(
                "redeemCodeResponse",
                |m: &Payload| { &m.redeemCodeResponse },
                |m: &mut Payload| { &mut m.redeemCodeResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfUpdateResponse>>(
                "selfUpdateResponse",
                |m: &Payload| { &m.selfUpdateResponse },
                |m: &mut Payload| { &mut m.selfUpdateResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<searchSuggestResponse>>(
                "searchSuggestResponse",
                |m: &Payload| { &m.searchSuggestResponse },
                |m: &mut Payload| { &mut m.searchSuggestResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetInitialInstrumentFlowStateResponse>>(
                "getInitialInstrumentFlowStateResponse",
                |m: &Payload| { &m.getInitialInstrumentFlowStateResponse },
                |m: &mut Payload| { &mut m.getInitialInstrumentFlowStateResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateInstrumentResponse>>(
                "createInstrumentResponse",
                |m: &Payload| { &m.createInstrumentResponse },
                |m: &mut Payload| { &mut m.createInstrumentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChallengeResponse>>(
                "challengeResponse",
                |m: &Payload| { &m.challengeResponse },
                |m: &mut Payload| { &mut m.challengeResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BackDeviceChoicesResponse>>(
                "backupDeviceChoicesResponse",
                |m: &Payload| { &m.backupDeviceChoicesResponse },
                |m: &mut Payload| { &mut m.backupDeviceChoicesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BackupDocumentChoicesResponse>>(
                "backupDocumentChoicesResponse",
                |m: &Payload| { &m.backupDocumentChoicesResponse },
                |m: &mut Payload| { &mut m.backupDocumentChoicesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EarlyUpdateResponse>>(
                "earlyUpdateResponse",
                |m: &Payload| { &m.earlyUpdateResponse },
                |m: &mut Payload| { &mut m.earlyUpdateResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreloadsResponse>>(
                "preloadsResponse",
                |m: &Payload| { &m.preloadsResponse },
                |m: &mut Payload| { &mut m.preloadsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MyAccountsResponse>>(
                "myAccountsResponse",
                |m: &Payload| { &m.myAccountsResponse },
                |m: &mut Payload| { &mut m.myAccountsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentFilterResponse>>(
                "contentFilterResponse",
                |m: &Payload| { &m.contentFilterResponse },
                |m: &mut Payload| { &mut m.contentFilterResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExperimentsResponse>>(
                "experimentsResponse",
                |m: &Payload| { &m.experimentsResponse },
                |m: &mut Payload| { &mut m.experimentsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SurveyResponse>>(
                "surveyResponse",
                |m: &Payload| { &m.surveyResponse },
                |m: &mut Payload| { &mut m.surveyResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PingResponse>>(
                "pingResponse",
                |m: &Payload| { &m.pingResponse },
                |m: &mut Payload| { &mut m.pingResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateUserSettingResponse>>(
                "updateUserSettingResponse",
                |m: &Payload| { &m.updateUserSettingResponse },
                |m: &mut Payload| { &mut m.updateUserSettingResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetUserSettingsResponse>>(
                "getUserSettingsREsponse",
                |m: &Payload| { &m.getUserSettingsREsponse },
                |m: &mut Payload| { &mut m.getUserSettingsREsponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSharingSettingsResponse>>(
                "getSharingSettingsResponse",
                |m: &Payload| { &m.getSharingSettingsResponse },
                |m: &mut Payload| { &mut m.getSharingSettingsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateSharingSettingsResponse>>(
                "updateSharingSettingsResponse",
                |m: &Payload| { &m.updateSharingSettingsResponse },
                |m: &mut Payload| { &mut m.updateSharingSettingsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewSnippetsResponse>>(
                "reviewSnippetsResponse",
                |m: &Payload| { &m.reviewSnippetsResponse },
                |m: &mut Payload| { &mut m.reviewSnippetsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentSharingStateResponse>>(
                "documentSharingStateResponse",
                |m: &Payload| { &m.documentSharingStateResponse },
                |m: &mut Payload| { &mut m.documentSharingStateResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleDeliveryResponse>>(
                "moduleDeliveryResponse",
                |m: &Payload| { &m.moduleDeliveryResponse },
                |m: &mut Payload| { &mut m.moduleDeliveryResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload>(
                "Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload {
        static instance: ::protobuf::rt::LazyV2<Payload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload::new)
    }
}

impl ::protobuf::Clear for Payload {
    fn clear(&mut self) {
        self.listResponse.clear();
        self.detailsResponse.clear();
        self.reviewResponse.clear();
        self.buyResponse.clear();
        self.searchResponse.clear();
        self.tocResponse.clear();
        self.browseResponse.clear();
        self.purchaseStatusResponse.clear();
        self.updateInstrumentResponse.clear();
        self.logResponse.clear();
        self.checkInstrumentResponse.clear();
        self.plusOneResponse.clear();
        self.flagContentResponse.clear();
        self.ackNotificationResponse.clear();
        self.initiateAssociationResponse.clear();
        self.verifyAssociationResponse.clear();
        self.libraryReplicationResponse.clear();
        self.revokeResponse.clear();
        self.bulkDetailsResponse.clear();
        self.resolveLinkResponse.clear();
        self.deliveryResponse.clear();
        self.acceptTosResponse.clear();
        self.rateSuggestedContentResponse.clear();
        self.checkPromoOfferResponse.clear();
        self.instrumentSetupInfoResponse.clear();
        self.redeemGiftCardResponse.clear();
        self.modifyLibraryResponse.clear();
        self.uploadDeviceConfigResponse.clear();
        self.plusProfileResponse.clear();
        self.consumePurchaseResponse.clear();
        self.billingProfileResponse.clear();
        self.preparePurchaseResponse.clear();
        self.commitPurchaseResponse.clear();
        self.debugSettingsResponse.clear();
        self.checkIabPromoResponse.clear();
        self.userActivitySettingsResponse.clear();
        self.recordUserActivityResponse.clear();
        self.redeemCodeResponse.clear();
        self.selfUpdateResponse.clear();
        self.searchSuggestResponse.clear();
        self.getInitialInstrumentFlowStateResponse.clear();
        self.createInstrumentResponse.clear();
        self.challengeResponse.clear();
        self.backupDeviceChoicesResponse.clear();
        self.backupDocumentChoicesResponse.clear();
        self.earlyUpdateResponse.clear();
        self.preloadsResponse.clear();
        self.myAccountsResponse.clear();
        self.contentFilterResponse.clear();
        self.experimentsResponse.clear();
        self.surveyResponse.clear();
        self.pingResponse.clear();
        self.updateUserSettingResponse.clear();
        self.getUserSettingsREsponse.clear();
        self.getSharingSettingsResponse.clear();
        self.updateSharingSettingsResponse.clear();
        self.reviewSnippetsResponse.clear();
        self.documentSharingStateResponse.clear();
        self.moduleDeliveryResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckIabPromoResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckIabPromoResponse {
    fn default() -> &'a CheckIabPromoResponse {
        <CheckIabPromoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckIabPromoResponse {
    pub fn new() -> CheckIabPromoResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckIabPromoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckIabPromoResponse {
        CheckIabPromoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckIabPromoResponse>(
                "CheckIabPromoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckIabPromoResponse {
        static instance: ::protobuf::rt::LazyV2<CheckIabPromoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckIabPromoResponse::new)
    }
}

impl ::protobuf::Clear for CheckIabPromoResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckIabPromoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckIabPromoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserActivitySettingsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserActivitySettingsResponse {
    fn default() -> &'a UserActivitySettingsResponse {
        <UserActivitySettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserActivitySettingsResponse {
    pub fn new() -> UserActivitySettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UserActivitySettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserActivitySettingsResponse {
        UserActivitySettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserActivitySettingsResponse>(
                "UserActivitySettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserActivitySettingsResponse {
        static instance: ::protobuf::rt::LazyV2<UserActivitySettingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserActivitySettingsResponse::new)
    }
}

impl ::protobuf::Clear for UserActivitySettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserActivitySettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserActivitySettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RecordUserActivityResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecordUserActivityResponse {
    fn default() -> &'a RecordUserActivityResponse {
        <RecordUserActivityResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecordUserActivityResponse {
    pub fn new() -> RecordUserActivityResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecordUserActivityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecordUserActivityResponse {
        RecordUserActivityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecordUserActivityResponse>(
                "RecordUserActivityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecordUserActivityResponse {
        static instance: ::protobuf::rt::LazyV2<RecordUserActivityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecordUserActivityResponse::new)
    }
}

impl ::protobuf::Clear for RecordUserActivityResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecordUserActivityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecordUserActivityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedeemCodeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedeemCodeResponse {
    fn default() -> &'a RedeemCodeResponse {
        <RedeemCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RedeemCodeResponse {
    pub fn new() -> RedeemCodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RedeemCodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedeemCodeResponse {
        RedeemCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedeemCodeResponse>(
                "RedeemCodeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedeemCodeResponse {
        static instance: ::protobuf::rt::LazyV2<RedeemCodeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedeemCodeResponse::new)
    }
}

impl ::protobuf::Clear for RedeemCodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedeemCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedeemCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SelfUpdateResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfUpdateResponse {
    fn default() -> &'a SelfUpdateResponse {
        <SelfUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelfUpdateResponse {
    pub fn new() -> SelfUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SelfUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfUpdateResponse {
        SelfUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfUpdateResponse>(
                "SelfUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<SelfUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelfUpdateResponse::new)
    }
}

impl ::protobuf::Clear for SelfUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct searchSuggestResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a searchSuggestResponse {
    fn default() -> &'a searchSuggestResponse {
        <searchSuggestResponse as ::protobuf::Message>::default_instance()
    }
}

impl searchSuggestResponse {
    pub fn new() -> searchSuggestResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for searchSuggestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> searchSuggestResponse {
        searchSuggestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<searchSuggestResponse>(
                "searchSuggestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static searchSuggestResponse {
        static instance: ::protobuf::rt::LazyV2<searchSuggestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(searchSuggestResponse::new)
    }
}

impl ::protobuf::Clear for searchSuggestResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for searchSuggestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for searchSuggestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetInitialInstrumentFlowStateResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInitialInstrumentFlowStateResponse {
    fn default() -> &'a GetInitialInstrumentFlowStateResponse {
        <GetInitialInstrumentFlowStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInitialInstrumentFlowStateResponse {
    pub fn new() -> GetInitialInstrumentFlowStateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInitialInstrumentFlowStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInitialInstrumentFlowStateResponse {
        GetInitialInstrumentFlowStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetInitialInstrumentFlowStateResponse>(
                "GetInitialInstrumentFlowStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetInitialInstrumentFlowStateResponse {
        static instance: ::protobuf::rt::LazyV2<GetInitialInstrumentFlowStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetInitialInstrumentFlowStateResponse::new)
    }
}

impl ::protobuf::Clear for GetInitialInstrumentFlowStateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInitialInstrumentFlowStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInitialInstrumentFlowStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CreateInstrumentResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateInstrumentResponse {
    fn default() -> &'a CreateInstrumentResponse {
        <CreateInstrumentResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateInstrumentResponse {
    pub fn new() -> CreateInstrumentResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateInstrumentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateInstrumentResponse {
        CreateInstrumentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateInstrumentResponse>(
                "CreateInstrumentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateInstrumentResponse {
        static instance: ::protobuf::rt::LazyV2<CreateInstrumentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateInstrumentResponse::new)
    }
}

impl ::protobuf::Clear for CreateInstrumentResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateInstrumentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateInstrumentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ChallengeResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChallengeResponse {
    fn default() -> &'a ChallengeResponse {
        <ChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChallengeResponse {
    pub fn new() -> ChallengeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChallengeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChallengeResponse {
        ChallengeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChallengeResponse>(
                "ChallengeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChallengeResponse {
        static instance: ::protobuf::rt::LazyV2<ChallengeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChallengeResponse::new)
    }
}

impl ::protobuf::Clear for ChallengeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChallengeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BackDeviceChoicesResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackDeviceChoicesResponse {
    fn default() -> &'a BackDeviceChoicesResponse {
        <BackDeviceChoicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BackDeviceChoicesResponse {
    pub fn new() -> BackDeviceChoicesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackDeviceChoicesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackDeviceChoicesResponse {
        BackDeviceChoicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackDeviceChoicesResponse>(
                "BackDeviceChoicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackDeviceChoicesResponse {
        static instance: ::protobuf::rt::LazyV2<BackDeviceChoicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackDeviceChoicesResponse::new)
    }
}

impl ::protobuf::Clear for BackDeviceChoicesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackDeviceChoicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackDeviceChoicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BackupDocumentChoicesResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupDocumentChoicesResponse {
    fn default() -> &'a BackupDocumentChoicesResponse {
        <BackupDocumentChoicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BackupDocumentChoicesResponse {
    pub fn new() -> BackupDocumentChoicesResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BackupDocumentChoicesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupDocumentChoicesResponse {
        BackupDocumentChoicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupDocumentChoicesResponse>(
                "BackupDocumentChoicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupDocumentChoicesResponse {
        static instance: ::protobuf::rt::LazyV2<BackupDocumentChoicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupDocumentChoicesResponse::new)
    }
}

impl ::protobuf::Clear for BackupDocumentChoicesResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupDocumentChoicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupDocumentChoicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EarlyUpdateResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EarlyUpdateResponse {
    fn default() -> &'a EarlyUpdateResponse {
        <EarlyUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl EarlyUpdateResponse {
    pub fn new() -> EarlyUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EarlyUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EarlyUpdateResponse {
        EarlyUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EarlyUpdateResponse>(
                "EarlyUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EarlyUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<EarlyUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EarlyUpdateResponse::new)
    }
}

impl ::protobuf::Clear for EarlyUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EarlyUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EarlyUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PreloadsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreloadsResponse {
    fn default() -> &'a PreloadsResponse {
        <PreloadsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreloadsResponse {
    pub fn new() -> PreloadsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreloadsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreloadsResponse {
        PreloadsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreloadsResponse>(
                "PreloadsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreloadsResponse {
        static instance: ::protobuf::rt::LazyV2<PreloadsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreloadsResponse::new)
    }
}

impl ::protobuf::Clear for PreloadsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreloadsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreloadsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MyAccountsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MyAccountsResponse {
    fn default() -> &'a MyAccountsResponse {
        <MyAccountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MyAccountsResponse {
    pub fn new() -> MyAccountsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MyAccountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MyAccountsResponse {
        MyAccountsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MyAccountsResponse>(
                "MyAccountsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MyAccountsResponse {
        static instance: ::protobuf::rt::LazyV2<MyAccountsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MyAccountsResponse::new)
    }
}

impl ::protobuf::Clear for MyAccountsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MyAccountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MyAccountsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContentFilterResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentFilterResponse {
    fn default() -> &'a ContentFilterResponse {
        <ContentFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContentFilterResponse {
    pub fn new() -> ContentFilterResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ContentFilterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentFilterResponse {
        ContentFilterResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentFilterResponse>(
                "ContentFilterResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentFilterResponse {
        static instance: ::protobuf::rt::LazyV2<ContentFilterResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentFilterResponse::new)
    }
}

impl ::protobuf::Clear for ContentFilterResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentFilterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExperimentsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExperimentsResponse {
    fn default() -> &'a ExperimentsResponse {
        <ExperimentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExperimentsResponse {
    pub fn new() -> ExperimentsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExperimentsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExperimentsResponse {
        ExperimentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExperimentsResponse>(
                "ExperimentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExperimentsResponse {
        static instance: ::protobuf::rt::LazyV2<ExperimentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExperimentsResponse::new)
    }
}

impl ::protobuf::Clear for ExperimentsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExperimentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExperimentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SurveyResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SurveyResponse {
    fn default() -> &'a SurveyResponse {
        <SurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SurveyResponse {
    pub fn new() -> SurveyResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SurveyResponse {
        SurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SurveyResponse>(
                "SurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SurveyResponse {
        static instance: ::protobuf::rt::LazyV2<SurveyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SurveyResponse::new)
    }
}

impl ::protobuf::Clear for SurveyResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SurveyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PingResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PingResponse>(
                "PingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingResponse {
        static instance: ::protobuf::rt::LazyV2<PingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PingResponse::new)
    }
}

impl ::protobuf::Clear for PingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateUserSettingResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateUserSettingResponse {
    fn default() -> &'a UpdateUserSettingResponse {
        <UpdateUserSettingResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateUserSettingResponse {
    pub fn new() -> UpdateUserSettingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateUserSettingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateUserSettingResponse {
        UpdateUserSettingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateUserSettingResponse>(
                "UpdateUserSettingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateUserSettingResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateUserSettingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateUserSettingResponse::new)
    }
}

impl ::protobuf::Clear for UpdateUserSettingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateUserSettingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateUserSettingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetUserSettingsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetUserSettingsResponse {
    fn default() -> &'a GetUserSettingsResponse {
        <GetUserSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetUserSettingsResponse {
    pub fn new() -> GetUserSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetUserSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUserSettingsResponse {
        GetUserSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetUserSettingsResponse>(
                "GetUserSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetUserSettingsResponse {
        static instance: ::protobuf::rt::LazyV2<GetUserSettingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetUserSettingsResponse::new)
    }
}

impl ::protobuf::Clear for GetUserSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUserSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserSettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetSharingSettingsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSharingSettingsResponse {
    fn default() -> &'a GetSharingSettingsResponse {
        <GetSharingSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSharingSettingsResponse {
    pub fn new() -> GetSharingSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSharingSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSharingSettingsResponse {
        GetSharingSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSharingSettingsResponse>(
                "GetSharingSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSharingSettingsResponse {
        static instance: ::protobuf::rt::LazyV2<GetSharingSettingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSharingSettingsResponse::new)
    }
}

impl ::protobuf::Clear for GetSharingSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSharingSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSharingSettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UpdateSharingSettingsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSharingSettingsResponse {
    fn default() -> &'a UpdateSharingSettingsResponse {
        <UpdateSharingSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSharingSettingsResponse {
    pub fn new() -> UpdateSharingSettingsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateSharingSettingsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSharingSettingsResponse {
        UpdateSharingSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSharingSettingsResponse>(
                "UpdateSharingSettingsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSharingSettingsResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateSharingSettingsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSharingSettingsResponse::new)
    }
}

impl ::protobuf::Clear for UpdateSharingSettingsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSharingSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSharingSettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReviewSnippetsResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReviewSnippetsResponse {
    fn default() -> &'a ReviewSnippetsResponse {
        <ReviewSnippetsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReviewSnippetsResponse {
    pub fn new() -> ReviewSnippetsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReviewSnippetsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewSnippetsResponse {
        ReviewSnippetsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReviewSnippetsResponse>(
                "ReviewSnippetsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewSnippetsResponse {
        static instance: ::protobuf::rt::LazyV2<ReviewSnippetsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReviewSnippetsResponse::new)
    }
}

impl ::protobuf::Clear for ReviewSnippetsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewSnippetsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewSnippetsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocumentSharingStateResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentSharingStateResponse {
    fn default() -> &'a DocumentSharingStateResponse {
        <DocumentSharingStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl DocumentSharingStateResponse {
    pub fn new() -> DocumentSharingStateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DocumentSharingStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentSharingStateResponse {
        DocumentSharingStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentSharingStateResponse>(
                "DocumentSharingStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentSharingStateResponse {
        static instance: ::protobuf::rt::LazyV2<DocumentSharingStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentSharingStateResponse::new)
    }
}

impl ::protobuf::Clear for DocumentSharingStateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentSharingStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentSharingStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModuleDeliveryResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModuleDeliveryResponse {
    fn default() -> &'a ModuleDeliveryResponse {
        <ModuleDeliveryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ModuleDeliveryResponse {
    pub fn new() -> ModuleDeliveryResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModuleDeliveryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleDeliveryResponse {
        ModuleDeliveryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModuleDeliveryResponse>(
                "ModuleDeliveryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModuleDeliveryResponse {
        static instance: ::protobuf::rt::LazyV2<ModuleDeliveryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModuleDeliveryResponse::new)
    }
}

impl ::protobuf::Clear for ModuleDeliveryResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModuleDeliveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleDeliveryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PreFetch {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub etag: ::protobuf::SingularField<::std::string::String>,
    pub ttl: ::std::option::Option<i64>,
    pub softTtl: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreFetch {
    fn default() -> &'a PreFetch {
        <PreFetch as ::protobuf::Message>::default_instance()
    }
}

impl PreFetch {
    pub fn new() -> PreFetch {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes response = 2;


    pub fn get_response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string etag = 3;


    pub fn get_etag(&self) -> &str {
        match self.etag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 ttl = 4;


    pub fn get_ttl(&self) -> i64 {
        self.ttl.unwrap_or(0)
    }

    // optional int64 softTtl = 5;


    pub fn get_softTtl(&self) -> i64 {
        self.softTtl.unwrap_or(0)
    }
}

impl ::protobuf::Message for PreFetch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.response)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.etag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ttl = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.softTtl = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.etag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ttl {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.softTtl {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.etag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ttl {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.softTtl {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreFetch {
        PreFetch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &PreFetch| { &m.url },
                |m: &mut PreFetch| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "response",
                |m: &PreFetch| { &m.response },
                |m: &mut PreFetch| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &PreFetch| { &m.etag },
                |m: &mut PreFetch| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ttl",
                |m: &PreFetch| { &m.ttl },
                |m: &mut PreFetch| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "softTtl",
                |m: &PreFetch| { &m.softTtl },
                |m: &mut PreFetch| { &mut m.softTtl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreFetch>(
                "PreFetch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreFetch {
        static instance: ::protobuf::rt::LazyV2<PreFetch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreFetch::new)
    }
}

impl ::protobuf::Clear for PreFetch {
    fn clear(&mut self) {
        self.url.clear();
        self.response.clear();
        self.etag.clear();
        self.ttl = ::std::option::Option::None;
        self.softTtl = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreFetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreFetch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponseWrapper {
    // message fields
    pub payload: ::protobuf::SingularPtrField<Payload>,
    pub commands: ::protobuf::SingularPtrField<ServerCommands>,
    pub preFetch: ::protobuf::RepeatedField<PreFetch>,
    pub notification: ::protobuf::RepeatedField<Notification>,
    pub serverMetadata: ::protobuf::SingularPtrField<ServerMetadata>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseWrapper {
    fn default() -> &'a ResponseWrapper {
        <ResponseWrapper as ::protobuf::Message>::default_instance()
    }
}

impl ResponseWrapper {
    pub fn new() -> ResponseWrapper {
        ::std::default::Default::default()
    }

    // optional .Payload payload = 1;


    pub fn get_payload(&self) -> &Payload {
        self.payload.as_ref().unwrap_or_else(|| <Payload as ::protobuf::Message>::default_instance())
    }

    // optional .ServerCommands commands = 2;


    pub fn get_commands(&self) -> &ServerCommands {
        self.commands.as_ref().unwrap_or_else(|| <ServerCommands as ::protobuf::Message>::default_instance())
    }

    // repeated .PreFetch preFetch = 3;


    pub fn get_preFetch(&self) -> &[PreFetch] {
        &self.preFetch
    }

    // repeated .Notification notification = 4;


    pub fn get_notification(&self) -> &[Notification] {
        &self.notification
    }

    // optional .ServerMetadata serverMetadata = 5;


    pub fn get_serverMetadata(&self) -> &ServerMetadata {
        self.serverMetadata.as_ref().unwrap_or_else(|| <ServerMetadata as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ResponseWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commands {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preFetch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commands)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preFetch)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notification)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverMetadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commands.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.preFetch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.serverMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commands.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.preFetch {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notification {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.serverMetadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseWrapper {
        ResponseWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload>>(
                "payload",
                |m: &ResponseWrapper| { &m.payload },
                |m: &mut ResponseWrapper| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerCommands>>(
                "commands",
                |m: &ResponseWrapper| { &m.commands },
                |m: &mut ResponseWrapper| { &mut m.commands },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreFetch>>(
                "preFetch",
                |m: &ResponseWrapper| { &m.preFetch },
                |m: &mut ResponseWrapper| { &mut m.preFetch },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Notification>>(
                "notification",
                |m: &ResponseWrapper| { &m.notification },
                |m: &mut ResponseWrapper| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMetadata>>(
                "serverMetadata",
                |m: &ResponseWrapper| { &m.serverMetadata },
                |m: &mut ResponseWrapper| { &mut m.serverMetadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseWrapper>(
                "ResponseWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseWrapper {
        static instance: ::protobuf::rt::LazyV2<ResponseWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseWrapper::new)
    }
}

impl ::protobuf::Clear for ResponseWrapper {
    fn clear(&mut self) {
        self.payload.clear();
        self.commands.clear();
        self.preFetch.clear();
        self.notification.clear();
        self.serverMetadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerCommands {
    // message fields
    pub clearCache: ::std::option::Option<bool>,
    pub displayErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub logErrorStacktrace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerCommands {
    fn default() -> &'a ServerCommands {
        <ServerCommands as ::protobuf::Message>::default_instance()
    }
}

impl ServerCommands {
    pub fn new() -> ServerCommands {
        ::std::default::Default::default()
    }

    // optional bool clearCache = 1;


    pub fn get_clearCache(&self) -> bool {
        self.clearCache.unwrap_or(false)
    }

    // optional string displayErrorMessage = 2;


    pub fn get_displayErrorMessage(&self) -> &str {
        match self.displayErrorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string logErrorStacktrace = 3;


    pub fn get_logErrorStacktrace(&self) -> &str {
        match self.logErrorStacktrace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ServerCommands {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clearCache = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayErrorMessage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logErrorStacktrace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clearCache {
            my_size += 2;
        }
        if let Some(ref v) = self.displayErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.logErrorStacktrace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clearCache {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.displayErrorMessage.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.logErrorStacktrace.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerCommands {
        ServerCommands::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clearCache",
                |m: &ServerCommands| { &m.clearCache },
                |m: &mut ServerCommands| { &mut m.clearCache },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayErrorMessage",
                |m: &ServerCommands| { &m.displayErrorMessage },
                |m: &mut ServerCommands| { &mut m.displayErrorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logErrorStacktrace",
                |m: &ServerCommands| { &m.logErrorStacktrace },
                |m: &mut ServerCommands| { &mut m.logErrorStacktrace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerCommands>(
                "ServerCommands",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerCommands {
        static instance: ::protobuf::rt::LazyV2<ServerCommands> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerCommands::new)
    }
}

impl ::protobuf::Clear for ServerCommands {
    fn clear(&mut self) {
        self.clearCache = ::std::option::Option::None;
        self.displayErrorMessage.clear();
        self.logErrorStacktrace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerCommands {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerCommands {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerMetadata {
    // message fields
    pub latencyMillis: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerMetadata {
    fn default() -> &'a ServerMetadata {
        <ServerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ServerMetadata {
    pub fn new() -> ServerMetadata {
        ::std::default::Default::default()
    }

    // optional int64 latencyMillis = 1;


    pub fn get_latencyMillis(&self) -> i64 {
        self.latencyMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for ServerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latencyMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latencyMillis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latencyMillis {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMetadata {
        ServerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latencyMillis",
                |m: &ServerMetadata| { &m.latencyMillis },
                |m: &mut ServerMetadata| { &mut m.latencyMillis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerMetadata>(
                "ServerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerMetadata {
        static instance: ::protobuf::rt::LazyV2<ServerMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerMetadata::new)
    }
}

impl ::protobuf::Clear for ServerMetadata {
    fn clear(&mut self) {
        self.latencyMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetReviewsResponse {
    // message fields
    pub review: ::protobuf::RepeatedField<Review>,
    pub matchingCount: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetReviewsResponse {
    fn default() -> &'a GetReviewsResponse {
        <GetReviewsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetReviewsResponse {
    pub fn new() -> GetReviewsResponse {
        ::std::default::Default::default()
    }

    // repeated .Review review = 1;


    pub fn get_review(&self) -> &[Review] {
        &self.review
    }

    // optional int64 matchingCount = 2;


    pub fn get_matchingCount(&self) -> i64 {
        self.matchingCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetReviewsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.review)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.matchingCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.review {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.matchingCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.review {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.matchingCount {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReviewsResponse {
        GetReviewsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &GetReviewsResponse| { &m.review },
                |m: &mut GetReviewsResponse| { &mut m.review },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "matchingCount",
                |m: &GetReviewsResponse| { &m.matchingCount },
                |m: &mut GetReviewsResponse| { &mut m.matchingCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetReviewsResponse>(
                "GetReviewsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetReviewsResponse {
        static instance: ::protobuf::rt::LazyV2<GetReviewsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetReviewsResponse::new)
    }
}

impl ::protobuf::Clear for GetReviewsResponse {
    fn clear(&mut self) {
        self.review.clear();
        self.matchingCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReviewsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReviewsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Review {
    // message fields
    pub authorName: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularField<::std::string::String>,
    pub documentVersion: ::protobuf::SingularField<::std::string::String>,
    pub timestampMsec: ::std::option::Option<i64>,
    pub starRating: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub commentId: ::protobuf::SingularField<::std::string::String>,
    pub deviceName: ::protobuf::SingularField<::std::string::String>,
    pub replyText: ::protobuf::SingularField<::std::string::String>,
    pub replyTimestampMsec: ::std::option::Option<i64>,
    pub plusProfile: ::protobuf::SingularPtrField<PlusProfile>,
    pub author: ::protobuf::SingularPtrField<DocV2>,
    pub sentiment: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Review {
    fn default() -> &'a Review {
        <Review as ::protobuf::Message>::default_instance()
    }
}

impl Review {
    pub fn new() -> Review {
        ::std::default::Default::default()
    }

    // optional string authorName = 1;


    pub fn get_authorName(&self) -> &str {
        match self.authorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string source = 3;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string documentVersion = 4;


    pub fn get_documentVersion(&self) -> &str {
        match self.documentVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 timestampMsec = 5;


    pub fn get_timestampMsec(&self) -> i64 {
        self.timestampMsec.unwrap_or(0)
    }

    // optional int32 starRating = 6;


    pub fn get_starRating(&self) -> i32 {
        self.starRating.unwrap_or(0)
    }

    // optional string title = 7;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string comment = 8;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string commentId = 9;


    pub fn get_commentId(&self) -> &str {
        match self.commentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deviceName = 19;


    pub fn get_deviceName(&self) -> &str {
        match self.deviceName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string replyText = 29;


    pub fn get_replyText(&self) -> &str {
        match self.replyText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 replyTimestampMsec = 30;


    pub fn get_replyTimestampMsec(&self) -> i64 {
        self.replyTimestampMsec.unwrap_or(0)
    }

    // optional .PlusProfile plusProfile = 31;


    pub fn get_plusProfile(&self) -> &PlusProfile {
        self.plusProfile.as_ref().unwrap_or_else(|| <PlusProfile as ::protobuf::Message>::default_instance())
    }

    // optional .DocV2 author = 33;


    pub fn get_author(&self) -> &DocV2 {
        self.author.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }

    // optional .Image sentiment = 34;


    pub fn get_sentiment(&self) -> &Image {
        self.sentiment.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Review {
    fn is_initialized(&self) -> bool {
        for v in &self.plusProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.documentVersion)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestampMsec = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.commentId)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceName)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replyText)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replyTimestampMsec = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusProfile)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.author)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sentiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authorName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.documentVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestampMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.commentId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.deviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.replyText.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.replyTimestampMsec {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.plusProfile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.author.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authorName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.documentVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.timestampMsec {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.commentId.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.deviceName.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.replyText.as_ref() {
            os.write_string(29, &v)?;
        }
        if let Some(v) = self.replyTimestampMsec {
            os.write_int64(30, v)?;
        }
        if let Some(ref v) = self.plusProfile.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.author.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Review {
        Review::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorName",
                |m: &Review| { &m.authorName },
                |m: &mut Review| { &mut m.authorName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Review| { &m.url },
                |m: &mut Review| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &Review| { &m.source },
                |m: &mut Review| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "documentVersion",
                |m: &Review| { &m.documentVersion },
                |m: &mut Review| { &mut m.documentVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestampMsec",
                |m: &Review| { &m.timestampMsec },
                |m: &mut Review| { &mut m.timestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "starRating",
                |m: &Review| { &m.starRating },
                |m: &mut Review| { &mut m.starRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Review| { &m.title },
                |m: &mut Review| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &Review| { &m.comment },
                |m: &mut Review| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "commentId",
                |m: &Review| { &m.commentId },
                |m: &mut Review| { &mut m.commentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceName",
                |m: &Review| { &m.deviceName },
                |m: &mut Review| { &mut m.deviceName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "replyText",
                |m: &Review| { &m.replyText },
                |m: &mut Review| { &mut m.replyText },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replyTimestampMsec",
                |m: &Review| { &m.replyTimestampMsec },
                |m: &mut Review| { &mut m.replyTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusProfile>>(
                "plusProfile",
                |m: &Review| { &m.plusProfile },
                |m: &mut Review| { &mut m.plusProfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "author",
                |m: &Review| { &m.author },
                |m: &mut Review| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "sentiment",
                |m: &Review| { &m.sentiment },
                |m: &mut Review| { &mut m.sentiment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Review>(
                "Review",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Review {
        static instance: ::protobuf::rt::LazyV2<Review> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Review::new)
    }
}

impl ::protobuf::Clear for Review {
    fn clear(&mut self) {
        self.authorName.clear();
        self.url.clear();
        self.source.clear();
        self.documentVersion.clear();
        self.timestampMsec = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.title.clear();
        self.comment.clear();
        self.commentId.clear();
        self.deviceName.clear();
        self.replyText.clear();
        self.replyTimestampMsec = ::std::option::Option::None;
        self.plusProfile.clear();
        self.author.clear();
        self.sentiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Review {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Review {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReviewResponse {
    // message fields
    pub getResponse: ::protobuf::SingularPtrField<GetReviewsResponse>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub updatedReview: ::protobuf::SingularPtrField<Review>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReviewResponse {
    fn default() -> &'a ReviewResponse {
        <ReviewResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReviewResponse {
    pub fn new() -> ReviewResponse {
        ::std::default::Default::default()
    }

    // optional .GetReviewsResponse getResponse = 1;


    pub fn get_getResponse(&self) -> &GetReviewsResponse {
        self.getResponse.as_ref().unwrap_or_else(|| <GetReviewsResponse as ::protobuf::Message>::default_instance())
    }

    // optional string nextPageUrl = 2;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Review updatedReview = 3;


    pub fn get_updatedReview(&self) -> &Review {
        self.updatedReview.as_ref().unwrap_or_else(|| <Review as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ReviewResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.getResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updatedReview {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updatedReview)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.getResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.updatedReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.getResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.updatedReview.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewResponse {
        ReviewResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetReviewsResponse>>(
                "getResponse",
                |m: &ReviewResponse| { &m.getResponse },
                |m: &mut ReviewResponse| { &mut m.getResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &ReviewResponse| { &m.nextPageUrl },
                |m: &mut ReviewResponse| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "updatedReview",
                |m: &ReviewResponse| { &m.updatedReview },
                |m: &mut ReviewResponse| { &mut m.updatedReview },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReviewResponse>(
                "ReviewResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewResponse {
        static instance: ::protobuf::rt::LazyV2<ReviewResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReviewResponse::new)
    }
}

impl ::protobuf::Clear for ReviewResponse {
    fn clear(&mut self) {
        self.getResponse.clear();
        self.nextPageUrl.clear();
        self.updatedReview.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RevokeResponse {
    // message fields
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RevokeResponse {
    fn default() -> &'a RevokeResponse {
        <RevokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RevokeResponse {
    pub fn new() -> RevokeResponse {
        ::std::default::Default::default()
    }

    // optional .LibraryUpdate libraryUpdate = 1;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RevokeResponse {
        RevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &RevokeResponse| { &m.libraryUpdate },
                |m: &mut RevokeResponse| { &mut m.libraryUpdate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RevokeResponse>(
                "RevokeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RevokeResponse {
        static instance: ::protobuf::rt::LazyV2<RevokeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RevokeResponse::new)
    }
}

impl ::protobuf::Clear for RevokeResponse {
    fn clear(&mut self) {
        self.libraryUpdate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RevokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedSearch {
    // message fields
    pub searchUrl: ::protobuf::SingularField<::std::string::String>,
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub backendId: ::std::option::Option<i32>,
    pub docType: ::std::option::Option<i32>,
    pub current: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedSearch {
    fn default() -> &'a RelatedSearch {
        <RelatedSearch as ::protobuf::Message>::default_instance()
    }
}

impl RelatedSearch {
    pub fn new() -> RelatedSearch {
        ::std::default::Default::default()
    }

    // optional string searchUrl = 1;


    pub fn get_searchUrl(&self) -> &str {
        match self.searchUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string header = 2;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 backendId = 3;


    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional int32 docType = 4;


    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional bool current = 5;


    pub fn get_current(&self) -> bool {
        self.current.unwrap_or(false)
    }
}

impl ::protobuf::Message for RelatedSearch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.searchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.searchUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.current {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedSearch {
        RelatedSearch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searchUrl",
                |m: &RelatedSearch| { &m.searchUrl },
                |m: &mut RelatedSearch| { &mut m.searchUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &RelatedSearch| { &m.header },
                |m: &mut RelatedSearch| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backendId",
                |m: &RelatedSearch| { &m.backendId },
                |m: &mut RelatedSearch| { &mut m.backendId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "docType",
                |m: &RelatedSearch| { &m.docType },
                |m: &mut RelatedSearch| { &mut m.docType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "current",
                |m: &RelatedSearch| { &m.current },
                |m: &mut RelatedSearch| { &mut m.current },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedSearch>(
                "RelatedSearch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedSearch {
        static instance: ::protobuf::rt::LazyV2<RelatedSearch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedSearch::new)
    }
}

impl ::protobuf::Clear for RelatedSearch {
    fn clear(&mut self) {
        self.searchUrl.clear();
        self.header.clear();
        self.backendId = ::std::option::Option::None;
        self.docType = ::std::option::Option::None;
        self.current = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedSearch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedSearch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchResponse {
    // message fields
    pub originalQuery: ::protobuf::SingularField<::std::string::String>,
    pub suggestedQuery: ::protobuf::SingularField<::std::string::String>,
    pub aggregateQuery: ::std::option::Option<bool>,
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    pub relatedSearch: ::protobuf::RepeatedField<RelatedSearch>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchResponse {
    fn default() -> &'a SearchResponse {
        <SearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchResponse {
    pub fn new() -> SearchResponse {
        ::std::default::Default::default()
    }

    // optional string originalQuery = 1;


    pub fn get_originalQuery(&self) -> &str {
        match self.originalQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string suggestedQuery = 2;


    pub fn get_suggestedQuery(&self) -> &str {
        match self.suggestedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool aggregateQuery = 3;


    pub fn get_aggregateQuery(&self) -> bool {
        self.aggregateQuery.unwrap_or(false)
    }

    // repeated .Bucket bucket = 4;


    pub fn get_bucket(&self) -> &[Bucket] {
        &self.bucket
    }

    // repeated .DocV2 doc = 5;


    pub fn get_doc(&self) -> &[DocV2] {
        &self.doc
    }

    // repeated .RelatedSearch relatedSearch = 6;


    pub fn get_relatedSearch(&self) -> &[RelatedSearch] {
        &self.relatedSearch
    }

    // optional bytes serverLogsCookie = 7;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for SearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedSearch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalQuery)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suggestedQuery)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aggregateQuery = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bucket)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.doc)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relatedSearch)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.originalQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.aggregateQuery {
            my_size += 2;
        }
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relatedSearch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.originalQuery.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.aggregateQuery {
            os.write_bool(3, v)?;
        }
        for v in &self.bucket {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.doc {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relatedSearch {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchResponse {
        SearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originalQuery",
                |m: &SearchResponse| { &m.originalQuery },
                |m: &mut SearchResponse| { &mut m.originalQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suggestedQuery",
                |m: &SearchResponse| { &m.suggestedQuery },
                |m: &mut SearchResponse| { &mut m.suggestedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "aggregateQuery",
                |m: &SearchResponse| { &m.aggregateQuery },
                |m: &mut SearchResponse| { &mut m.aggregateQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &SearchResponse| { &m.bucket },
                |m: &mut SearchResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &SearchResponse| { &m.doc },
                |m: &mut SearchResponse| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedSearch>>(
                "relatedSearch",
                |m: &SearchResponse| { &m.relatedSearch },
                |m: &mut SearchResponse| { &mut m.relatedSearch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &SearchResponse| { &m.serverLogsCookie },
                |m: &mut SearchResponse| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchResponse>(
                "SearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchResponse {
        static instance: ::protobuf::rt::LazyV2<SearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchResponse::new)
    }
}

impl ::protobuf::Clear for SearchResponse {
    fn clear(&mut self) {
        self.originalQuery.clear();
        self.suggestedQuery.clear();
        self.aggregateQuery = ::std::option::Option::None;
        self.bucket.clear();
        self.doc.clear();
        self.relatedSearch.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingConfig {
    // message fields
    pub carrierBillingConfig: ::protobuf::SingularPtrField<CarrierBillingConfig>,
    pub maxIabApiVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingConfig {
    fn default() -> &'a BillingConfig {
        <BillingConfig as ::protobuf::Message>::default_instance()
    }
}

impl BillingConfig {
    pub fn new() -> BillingConfig {
        ::std::default::Default::default()
    }

    // optional .CarrierBillingConfig carrierBillingConfig = 1;


    pub fn get_carrierBillingConfig(&self) -> &CarrierBillingConfig {
        self.carrierBillingConfig.as_ref().unwrap_or_else(|| <CarrierBillingConfig as ::protobuf::Message>::default_instance())
    }

    // optional int32 maxIabApiVersion = 2;


    pub fn get_maxIabApiVersion(&self) -> i32 {
        self.maxIabApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for BillingConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierBillingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingConfig)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxIabApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.carrierBillingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.maxIabApiVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.carrierBillingConfig.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.maxIabApiVersion {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingConfig {
        BillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingConfig>>(
                "carrierBillingConfig",
                |m: &BillingConfig| { &m.carrierBillingConfig },
                |m: &mut BillingConfig| { &mut m.carrierBillingConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxIabApiVersion",
                |m: &BillingConfig| { &m.maxIabApiVersion },
                |m: &mut BillingConfig| { &mut m.maxIabApiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingConfig>(
                "BillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingConfig {
        static instance: ::protobuf::rt::LazyV2<BillingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingConfig::new)
    }
}

impl ::protobuf::Clear for BillingConfig {
    fn clear(&mut self) {
        self.carrierBillingConfig.clear();
        self.maxIabApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingConfig {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub apiVersion: ::std::option::Option<i32>,
    pub provisioningUrl: ::protobuf::SingularField<::std::string::String>,
    pub credentialsUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosRequired: ::std::option::Option<bool>,
    pub perTransactionCredentialsRequired: ::std::option::Option<bool>,
    pub sendSubscriberIdWithCarrierBillingRequests: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingConfig {
    fn default() -> &'a CarrierBillingConfig {
        <CarrierBillingConfig as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingConfig {
    pub fn new() -> CarrierBillingConfig {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 apiVersion = 3;


    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string provisioningUrl = 4;


    pub fn get_provisioningUrl(&self) -> &str {
        match self.provisioningUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string credentialsUrl = 5;


    pub fn get_credentialsUrl(&self) -> &str {
        match self.credentialsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool tosRequired = 6;


    pub fn get_tosRequired(&self) -> bool {
        self.tosRequired.unwrap_or(false)
    }

    // optional bool perTransactionCredentialsRequired = 7;


    pub fn get_perTransactionCredentialsRequired(&self) -> bool {
        self.perTransactionCredentialsRequired.unwrap_or(false)
    }

    // optional bool sendSubscriberIdWithCarrierBillingRequests = 8;


    pub fn get_sendSubscriberIdWithCarrierBillingRequests(&self) -> bool {
        self.sendSubscriberIdWithCarrierBillingRequests.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierBillingConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.provisioningUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credentialsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosRequired = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perTransactionCredentialsRequired = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.provisioningUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.credentialsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tosRequired {
            my_size += 2;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            my_size += 2;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.provisioningUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.credentialsUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.tosRequired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingConfig {
        CarrierBillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CarrierBillingConfig| { &m.id },
                |m: &mut CarrierBillingConfig| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CarrierBillingConfig| { &m.name },
                |m: &mut CarrierBillingConfig| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "apiVersion",
                |m: &CarrierBillingConfig| { &m.apiVersion },
                |m: &mut CarrierBillingConfig| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "provisioningUrl",
                |m: &CarrierBillingConfig| { &m.provisioningUrl },
                |m: &mut CarrierBillingConfig| { &mut m.provisioningUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credentialsUrl",
                |m: &CarrierBillingConfig| { &m.credentialsUrl },
                |m: &mut CarrierBillingConfig| { &mut m.credentialsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tosRequired",
                |m: &CarrierBillingConfig| { &m.tosRequired },
                |m: &mut CarrierBillingConfig| { &mut m.tosRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "perTransactionCredentialsRequired",
                |m: &CarrierBillingConfig| { &m.perTransactionCredentialsRequired },
                |m: &mut CarrierBillingConfig| { &mut m.perTransactionCredentialsRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sendSubscriberIdWithCarrierBillingRequests",
                |m: &CarrierBillingConfig| { &m.sendSubscriberIdWithCarrierBillingRequests },
                |m: &mut CarrierBillingConfig| { &mut m.sendSubscriberIdWithCarrierBillingRequests },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingConfig>(
                "CarrierBillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingConfig {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingConfig::new)
    }
}

impl ::protobuf::Clear for CarrierBillingConfig {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.apiVersion = ::std::option::Option::None;
        self.provisioningUrl.clear();
        self.credentialsUrl.clear();
        self.tosRequired = ::std::option::Option::None;
        self.perTransactionCredentialsRequired = ::std::option::Option::None;
        self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CorpusMetadata {
    // message fields
    pub backend: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub landingUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryName: ::protobuf::SingularField<::std::string::String>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorpusMetadata {
    fn default() -> &'a CorpusMetadata {
        <CorpusMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CorpusMetadata {
    pub fn new() -> CorpusMetadata {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string landingUrl = 3;


    pub fn get_landingUrl(&self) -> &str {
        match self.landingUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string libraryName = 4;


    pub fn get_libraryName(&self) -> &str {
        match self.libraryName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string recsWidgetUrl = 6;


    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CorpusMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.landingUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.landingUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.libraryName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.landingUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.libraryName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorpusMetadata {
        CorpusMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &CorpusMetadata| { &m.backend },
                |m: &mut CorpusMetadata| { &mut m.backend },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CorpusMetadata| { &m.name },
                |m: &mut CorpusMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "landingUrl",
                |m: &CorpusMetadata| { &m.landingUrl },
                |m: &mut CorpusMetadata| { &mut m.landingUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryName",
                |m: &CorpusMetadata| { &m.libraryName },
                |m: &mut CorpusMetadata| { &mut m.libraryName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recsWidgetUrl",
                |m: &CorpusMetadata| { &m.recsWidgetUrl },
                |m: &mut CorpusMetadata| { &mut m.recsWidgetUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorpusMetadata>(
                "CorpusMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorpusMetadata {
        static instance: ::protobuf::rt::LazyV2<CorpusMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorpusMetadata::new)
    }
}

impl ::protobuf::Clear for CorpusMetadata {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.name.clear();
        self.landingUrl.clear();
        self.libraryName.clear();
        self.recsWidgetUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorpusMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorpusMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Experiments {
    // message fields
    pub experimentId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Experiments {
    fn default() -> &'a Experiments {
        <Experiments as ::protobuf::Message>::default_instance()
    }
}

impl Experiments {
    pub fn new() -> Experiments {
        ::std::default::Default::default()
    }

    // repeated string experimentId = 1;


    pub fn get_experimentId(&self) -> &[::std::string::String] {
        &self.experimentId
    }
}

impl ::protobuf::Message for Experiments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.experimentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.experimentId {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.experimentId {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Experiments {
        Experiments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experimentId",
                |m: &Experiments| { &m.experimentId },
                |m: &mut Experiments| { &mut m.experimentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Experiments>(
                "Experiments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Experiments {
        static instance: ::protobuf::rt::LazyV2<Experiments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Experiments::new)
    }
}

impl ::protobuf::Clear for Experiments {
    fn clear(&mut self) {
        self.experimentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Experiments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experiments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SelfUpdateConfig {
    // message fields
    pub latestClientVersionCode: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfUpdateConfig {
    fn default() -> &'a SelfUpdateConfig {
        <SelfUpdateConfig as ::protobuf::Message>::default_instance()
    }
}

impl SelfUpdateConfig {
    pub fn new() -> SelfUpdateConfig {
        ::std::default::Default::default()
    }

    // optional int32 latestClientVersionCode = 1;


    pub fn get_latestClientVersionCode(&self) -> i32 {
        self.latestClientVersionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for SelfUpdateConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latestClientVersionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latestClientVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latestClientVersionCode {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfUpdateConfig {
        SelfUpdateConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "latestClientVersionCode",
                |m: &SelfUpdateConfig| { &m.latestClientVersionCode },
                |m: &mut SelfUpdateConfig| { &mut m.latestClientVersionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfUpdateConfig>(
                "SelfUpdateConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfUpdateConfig {
        static instance: ::protobuf::rt::LazyV2<SelfUpdateConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelfUpdateConfig::new)
    }
}

impl ::protobuf::Clear for SelfUpdateConfig {
    fn clear(&mut self) {
        self.latestClientVersionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfUpdateConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfUpdateConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TocResponse {
    // message fields
    pub corpus: ::protobuf::RepeatedField<CorpusMetadata>,
    pub tosVersionDeprecated: ::std::option::Option<i32>,
    pub tosContent: ::protobuf::SingularField<::std::string::String>,
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub experiments: ::protobuf::SingularPtrField<Experiments>,
    pub tosCheckboxTextMarketingEmails: ::protobuf::SingularField<::std::string::String>,
    pub tosToken: ::protobuf::SingularField<::std::string::String>,
    pub userSettings: ::protobuf::SingularPtrField<UserSettings>,
    pub iconOverrideUrl: ::protobuf::SingularField<::std::string::String>,
    pub selfUpdateConfig: ::protobuf::SingularPtrField<SelfUpdateConfig>,
    pub requiresUploadDeviceConfig: ::std::option::Option<bool>,
    pub billingConfig: ::protobuf::SingularPtrField<BillingConfig>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TocResponse {
    fn default() -> &'a TocResponse {
        <TocResponse as ::protobuf::Message>::default_instance()
    }
}

impl TocResponse {
    pub fn new() -> TocResponse {
        ::std::default::Default::default()
    }

    // repeated .CorpusMetadata corpus = 1;


    pub fn get_corpus(&self) -> &[CorpusMetadata] {
        &self.corpus
    }

    // optional int32 tosVersionDeprecated = 2;


    pub fn get_tosVersionDeprecated(&self) -> i32 {
        self.tosVersionDeprecated.unwrap_or(0)
    }

    // optional string tosContent = 3;


    pub fn get_tosContent(&self) -> &str {
        match self.tosContent.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string homeUrl = 4;


    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Experiments experiments = 5;


    pub fn get_experiments(&self) -> &Experiments {
        self.experiments.as_ref().unwrap_or_else(|| <Experiments as ::protobuf::Message>::default_instance())
    }

    // optional string tosCheckboxTextMarketingEmails = 6;


    pub fn get_tosCheckboxTextMarketingEmails(&self) -> &str {
        match self.tosCheckboxTextMarketingEmails.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tosToken = 7;


    pub fn get_tosToken(&self) -> &str {
        match self.tosToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .UserSettings userSettings = 8;


    pub fn get_userSettings(&self) -> &UserSettings {
        self.userSettings.as_ref().unwrap_or_else(|| <UserSettings as ::protobuf::Message>::default_instance())
    }

    // optional string iconOverrideUrl = 9;


    pub fn get_iconOverrideUrl(&self) -> &str {
        match self.iconOverrideUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SelfUpdateConfig selfUpdateConfig = 10;


    pub fn get_selfUpdateConfig(&self) -> &SelfUpdateConfig {
        self.selfUpdateConfig.as_ref().unwrap_or_else(|| <SelfUpdateConfig as ::protobuf::Message>::default_instance())
    }

    // optional bool requiresUploadDeviceConfig = 11;


    pub fn get_requiresUploadDeviceConfig(&self) -> bool {
        self.requiresUploadDeviceConfig.unwrap_or(false)
    }

    // optional .BillingConfig billingConfig = 12;


    pub fn get_billingConfig(&self) -> &BillingConfig {
        self.billingConfig.as_ref().unwrap_or_else(|| <BillingConfig as ::protobuf::Message>::default_instance())
    }

    // optional string recsWidgetUrl = 13;


    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TocResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.corpus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experiments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userSettings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfUpdateConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.corpus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tosVersionDeprecated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosContent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experiments)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosCheckboxTextMarketingEmails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosToken)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userSettings)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconOverrideUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selfUpdateConfig)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requiresUploadDeviceConfig = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingConfig)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.corpus {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tosVersionDeprecated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tosContent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.experiments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.tosToken.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.userSettings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iconOverrideUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.selfUpdateConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            my_size += 2;
        }
        if let Some(ref v) = self.billingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.corpus {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tosVersionDeprecated {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.tosContent.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.experiments.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.tosToken.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.userSettings.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iconOverrideUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.selfUpdateConfig.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.billingConfig.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TocResponse {
        TocResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorpusMetadata>>(
                "corpus",
                |m: &TocResponse| { &m.corpus },
                |m: &mut TocResponse| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tosVersionDeprecated",
                |m: &TocResponse| { &m.tosVersionDeprecated },
                |m: &mut TocResponse| { &mut m.tosVersionDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosContent",
                |m: &TocResponse| { &m.tosContent },
                |m: &mut TocResponse| { &mut m.tosContent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "homeUrl",
                |m: &TocResponse| { &m.homeUrl },
                |m: &mut TocResponse| { &mut m.homeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Experiments>>(
                "experiments",
                |m: &TocResponse| { &m.experiments },
                |m: &mut TocResponse| { &mut m.experiments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosCheckboxTextMarketingEmails",
                |m: &TocResponse| { &m.tosCheckboxTextMarketingEmails },
                |m: &mut TocResponse| { &mut m.tosCheckboxTextMarketingEmails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosToken",
                |m: &TocResponse| { &m.tosToken },
                |m: &mut TocResponse| { &mut m.tosToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserSettings>>(
                "userSettings",
                |m: &TocResponse| { &m.userSettings },
                |m: &mut TocResponse| { &mut m.userSettings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iconOverrideUrl",
                |m: &TocResponse| { &m.iconOverrideUrl },
                |m: &mut TocResponse| { &mut m.iconOverrideUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfUpdateConfig>>(
                "selfUpdateConfig",
                |m: &TocResponse| { &m.selfUpdateConfig },
                |m: &mut TocResponse| { &mut m.selfUpdateConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requiresUploadDeviceConfig",
                |m: &TocResponse| { &m.requiresUploadDeviceConfig },
                |m: &mut TocResponse| { &mut m.requiresUploadDeviceConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingConfig>>(
                "billingConfig",
                |m: &TocResponse| { &m.billingConfig },
                |m: &mut TocResponse| { &mut m.billingConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recsWidgetUrl",
                |m: &TocResponse| { &m.recsWidgetUrl },
                |m: &mut TocResponse| { &mut m.recsWidgetUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TocResponse>(
                "TocResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TocResponse {
        static instance: ::protobuf::rt::LazyV2<TocResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TocResponse::new)
    }
}

impl ::protobuf::Clear for TocResponse {
    fn clear(&mut self) {
        self.corpus.clear();
        self.tosVersionDeprecated = ::std::option::Option::None;
        self.tosContent.clear();
        self.homeUrl.clear();
        self.experiments.clear();
        self.tosCheckboxTextMarketingEmails.clear();
        self.tosToken.clear();
        self.userSettings.clear();
        self.iconOverrideUrl.clear();
        self.selfUpdateConfig.clear();
        self.requiresUploadDeviceConfig = ::std::option::Option::None;
        self.billingConfig.clear();
        self.recsWidgetUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TocResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TocResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserSettings {
    // message fields
    pub tosCheckboxMarketingEmailsOptedIn: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSettings {
    fn default() -> &'a UserSettings {
        <UserSettings as ::protobuf::Message>::default_instance()
    }
}

impl UserSettings {
    pub fn new() -> UserSettings {
        ::std::default::Default::default()
    }

    // optional bool tosCheckboxMarketingEmailsOptedIn = 1;


    pub fn get_tosCheckboxMarketingEmailsOptedIn(&self) -> bool {
        self.tosCheckboxMarketingEmailsOptedIn.unwrap_or(false)
    }
}

impl ::protobuf::Message for UserSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosCheckboxMarketingEmailsOptedIn = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tosCheckboxMarketingEmailsOptedIn {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tosCheckboxMarketingEmailsOptedIn {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSettings {
        UserSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tosCheckboxMarketingEmailsOptedIn",
                |m: &UserSettings| { &m.tosCheckboxMarketingEmailsOptedIn },
                |m: &mut UserSettings| { &mut m.tosCheckboxMarketingEmailsOptedIn },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSettings>(
                "UserSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSettings {
        static instance: ::protobuf::rt::LazyV2<UserSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserSettings::new)
    }
}

impl ::protobuf::Clear for UserSettings {
    fn clear(&mut self) {
        self.tosCheckboxMarketingEmailsOptedIn = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AcceptTosResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptTosResponse {
    fn default() -> &'a AcceptTosResponse {
        <AcceptTosResponse as ::protobuf::Message>::default_instance()
    }
}

impl AcceptTosResponse {
    pub fn new() -> AcceptTosResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AcceptTosResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptTosResponse {
        AcceptTosResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptTosResponse>(
                "AcceptTosResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptTosResponse {
        static instance: ::protobuf::rt::LazyV2<AcceptTosResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptTosResponse::new)
    }
}

impl ::protobuf::Clear for AcceptTosResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptTosResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptTosResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UploadDeviceConfigRequest {
    // message fields
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub manufacturer: ::protobuf::SingularField<::std::string::String>,
    pub gcmRegistrationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadDeviceConfigRequest {
    fn default() -> &'a UploadDeviceConfigRequest {
        <UploadDeviceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadDeviceConfigRequest {
    pub fn new() -> UploadDeviceConfigRequest {
        ::std::default::Default::default()
    }

    // optional .DeviceConfigurationProto deviceConfiguration = 1;


    pub fn get_deviceConfiguration(&self) -> &DeviceConfigurationProto {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfigurationProto as ::protobuf::Message>::default_instance())
    }

    // optional string manufacturer = 2;


    pub fn get_manufacturer(&self) -> &str {
        match self.manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gcmRegistrationId = 3;


    pub fn get_gcmRegistrationId(&self) -> &str {
        match self.gcmRegistrationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceConfiguration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gcmRegistrationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.gcmRegistrationId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.gcmRegistrationId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigRequest {
        UploadDeviceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>>(
                "deviceConfiguration",
                |m: &UploadDeviceConfigRequest| { &m.deviceConfiguration },
                |m: &mut UploadDeviceConfigRequest| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer",
                |m: &UploadDeviceConfigRequest| { &m.manufacturer },
                |m: &mut UploadDeviceConfigRequest| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gcmRegistrationId",
                |m: &UploadDeviceConfigRequest| { &m.gcmRegistrationId },
                |m: &mut UploadDeviceConfigRequest| { &mut m.gcmRegistrationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadDeviceConfigRequest>(
                "UploadDeviceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<UploadDeviceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadDeviceConfigRequest::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigRequest {
    fn clear(&mut self) {
        self.deviceConfiguration.clear();
        self.manufacturer.clear();
        self.gcmRegistrationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UploadDeviceConfigResponse {
    // message fields
    pub uploadDeviceConfigToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadDeviceConfigResponse {
    fn default() -> &'a UploadDeviceConfigResponse {
        <UploadDeviceConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadDeviceConfigResponse {
    pub fn new() -> UploadDeviceConfigResponse {
        ::std::default::Default::default()
    }

    // optional string uploadDeviceConfigToken = 1;


    pub fn get_uploadDeviceConfigToken(&self) -> &str {
        match self.uploadDeviceConfigToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDeviceConfigToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uploadDeviceConfigToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uploadDeviceConfigToken.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigResponse {
        UploadDeviceConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uploadDeviceConfigToken",
                |m: &UploadDeviceConfigResponse| { &m.uploadDeviceConfigToken },
                |m: &mut UploadDeviceConfigResponse| { &mut m.uploadDeviceConfigToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadDeviceConfigResponse>(
                "UploadDeviceConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigResponse {
        static instance: ::protobuf::rt::LazyV2<UploadDeviceConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadDeviceConfigResponse::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigResponse {
    fn clear(&mut self) {
        self.uploadDeviceConfigToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AckNotificationsRequestProto {
    // message fields
    pub notificationId: ::protobuf::RepeatedField<::std::string::String>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nackNotificationId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckNotificationsRequestProto {
    fn default() -> &'a AckNotificationsRequestProto {
        <AckNotificationsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AckNotificationsRequestProto {
    pub fn new() -> AckNotificationsRequestProto {
        ::std::default::Default::default()
    }

    // repeated string notificationId = 1;


    pub fn get_notificationId(&self) -> &[::std::string::String] {
        &self.notificationId
    }

    // optional .SignatureHashProto signatureHash = 2;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }

    // repeated string nackNotificationId = 3;


    pub fn get_nackNotificationId(&self) -> &[::std::string::String] {
        &self.nackNotificationId
    }
}

impl ::protobuf::Message for AckNotificationsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notificationId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nackNotificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notificationId {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nackNotificationId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notificationId {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nackNotificationId {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationsRequestProto {
        AckNotificationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &AckNotificationsRequestProto| { &m.notificationId },
                |m: &mut AckNotificationsRequestProto| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &AckNotificationsRequestProto| { &m.signatureHash },
                |m: &mut AckNotificationsRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nackNotificationId",
                |m: &AckNotificationsRequestProto| { &m.nackNotificationId },
                |m: &mut AckNotificationsRequestProto| { &mut m.nackNotificationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AckNotificationsRequestProto>(
                "AckNotificationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationsRequestProto {
        static instance: ::protobuf::rt::LazyV2<AckNotificationsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AckNotificationsRequestProto::new)
    }
}

impl ::protobuf::Clear for AckNotificationsRequestProto {
    fn clear(&mut self) {
        self.notificationId.clear();
        self.signatureHash.clear();
        self.nackNotificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AckNotificationsResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckNotificationsResponseProto {
    fn default() -> &'a AckNotificationsResponseProto {
        <AckNotificationsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AckNotificationsResponseProto {
    pub fn new() -> AckNotificationsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AckNotificationsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckNotificationsResponseProto {
        AckNotificationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AckNotificationsResponseProto>(
                "AckNotificationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AckNotificationsResponseProto {
        static instance: ::protobuf::rt::LazyV2<AckNotificationsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AckNotificationsResponseProto::new)
    }
}

impl ::protobuf::Clear for AckNotificationsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckNotificationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckNotificationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddressProto {
    // message fields
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::protobuf::SingularField<::std::string::String>,
    pub phone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressProto {
    fn default() -> &'a AddressProto {
        <AddressProto as ::protobuf::Message>::default_instance()
    }
}

impl AddressProto {
    pub fn new() -> AddressProto {
        ::std::default::Default::default()
    }

    // optional string address1 = 1;


    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string address2 = 2;


    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city = 3;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state = 4;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCode = 5;


    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string country = 6;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 7;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string type = 8;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string phone = 9;


    pub fn get_phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AddressProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address1.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address2.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.phone.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressProto {
        AddressProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address1",
                |m: &AddressProto| { &m.address1 },
                |m: &mut AddressProto| { &mut m.address1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address2",
                |m: &AddressProto| { &m.address2 },
                |m: &mut AddressProto| { &mut m.address2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &AddressProto| { &m.city },
                |m: &mut AddressProto| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &AddressProto| { &m.state },
                |m: &mut AddressProto| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCode",
                |m: &AddressProto| { &m.postalCode },
                |m: &mut AddressProto| { &mut m.postalCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &AddressProto| { &m.country },
                |m: &mut AddressProto| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AddressProto| { &m.name },
                |m: &mut AddressProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &AddressProto| { &m.field_type },
                |m: &mut AddressProto| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phone",
                |m: &AddressProto| { &m.phone },
                |m: &mut AddressProto| { &mut m.phone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressProto>(
                "AddressProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressProto {
        static instance: ::protobuf::rt::LazyV2<AddressProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressProto::new)
    }
}

impl ::protobuf::Clear for AddressProto {
    fn clear(&mut self) {
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.country.clear();
        self.name.clear();
        self.field_type.clear();
        self.phone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppDataProto {
    // message fields
    pub key: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDataProto {
    fn default() -> &'a AppDataProto {
        <AppDataProto as ::protobuf::Message>::default_instance()
    }
}

impl AppDataProto {
    pub fn new() -> AppDataProto {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppDataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDataProto {
        AppDataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &AppDataProto| { &m.key },
                |m: &mut AppDataProto| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &AppDataProto| { &m.value },
                |m: &mut AppDataProto| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDataProto>(
                "AppDataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDataProto {
        static instance: ::protobuf::rt::LazyV2<AppDataProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDataProto::new)
    }
}

impl ::protobuf::Clear for AppDataProto {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDataProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppSuggestionProto {
    // message fields
    pub assetInfo: ::protobuf::SingularPtrField<ExternalAssetProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppSuggestionProto {
    fn default() -> &'a AppSuggestionProto {
        <AppSuggestionProto as ::protobuf::Message>::default_instance()
    }
}

impl AppSuggestionProto {
    pub fn new() -> AppSuggestionProto {
        ::std::default::Default::default()
    }

    // optional .ExternalAssetProto assetInfo = 1;


    pub fn get_assetInfo(&self) -> &ExternalAssetProto {
        self.assetInfo.as_ref().unwrap_or_else(|| <ExternalAssetProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AppSuggestionProto {
    fn is_initialized(&self) -> bool {
        for v in &self.assetInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assetInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppSuggestionProto {
        AppSuggestionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "assetInfo",
                |m: &AppSuggestionProto| { &m.assetInfo },
                |m: &mut AppSuggestionProto| { &mut m.assetInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppSuggestionProto>(
                "AppSuggestionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppSuggestionProto {
        static instance: ::protobuf::rt::LazyV2<AppSuggestionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppSuggestionProto::new)
    }
}

impl ::protobuf::Clear for AppSuggestionProto {
    fn clear(&mut self) {
        self.assetInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppSuggestionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppSuggestionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AssetIdentifierProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIdentifierProto {
    fn default() -> &'a AssetIdentifierProto {
        <AssetIdentifierProto as ::protobuf::Message>::default_instance()
    }
}

impl AssetIdentifierProto {
    pub fn new() -> AssetIdentifierProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AssetIdentifierProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIdentifierProto {
        AssetIdentifierProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &AssetIdentifierProto| { &m.packageName },
                |m: &mut AssetIdentifierProto| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AssetIdentifierProto| { &m.versionCode },
                |m: &mut AssetIdentifierProto| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &AssetIdentifierProto| { &m.assetId },
                |m: &mut AssetIdentifierProto| { &mut m.assetId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetIdentifierProto>(
                "AssetIdentifierProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetIdentifierProto {
        static instance: ::protobuf::rt::LazyV2<AssetIdentifierProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetIdentifierProto::new)
    }
}

impl ::protobuf::Clear for AssetIdentifierProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIdentifierProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIdentifierProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AssetsRequestProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub categoryId: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::RepeatedField<::std::string::String>,
    pub retrieveVendingHistory: ::std::option::Option<bool>,
    pub retrieveExtendedInfo: ::std::option::Option<bool>,
    pub sortOrder: ::std::option::Option<i32>,
    pub startIndex: ::std::option::Option<i64>,
    pub numEntries: ::std::option::Option<i64>,
    pub viewFilter: ::std::option::Option<i32>,
    pub rankingType: ::protobuf::SingularField<::std::string::String>,
    pub retrieveCarrierChannel: ::std::option::Option<bool>,
    pub pendingDownloadAssetId: ::protobuf::RepeatedField<::std::string::String>,
    pub reconstructVendingHistory: ::std::option::Option<bool>,
    pub unfilteredResults: ::std::option::Option<bool>,
    pub badgeId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetsRequestProto {
    fn default() -> &'a AssetsRequestProto {
        <AssetsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AssetsRequestProto {
    pub fn new() -> AssetsRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 1;


    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string query = 2;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string categoryId = 3;


    pub fn get_categoryId(&self) -> &str {
        match self.categoryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string assetId = 4;


    pub fn get_assetId(&self) -> &[::std::string::String] {
        &self.assetId
    }

    // optional bool retrieveVendingHistory = 5;


    pub fn get_retrieveVendingHistory(&self) -> bool {
        self.retrieveVendingHistory.unwrap_or(false)
    }

    // optional bool retrieveExtendedInfo = 6;


    pub fn get_retrieveExtendedInfo(&self) -> bool {
        self.retrieveExtendedInfo.unwrap_or(false)
    }

    // optional int32 sortOrder = 7;


    pub fn get_sortOrder(&self) -> i32 {
        self.sortOrder.unwrap_or(0)
    }

    // optional int64 startIndex = 8;


    pub fn get_startIndex(&self) -> i64 {
        self.startIndex.unwrap_or(0)
    }

    // optional int64 numEntries = 9;


    pub fn get_numEntries(&self) -> i64 {
        self.numEntries.unwrap_or(0)
    }

    // optional int32 viewFilter = 10;


    pub fn get_viewFilter(&self) -> i32 {
        self.viewFilter.unwrap_or(0)
    }

    // optional string rankingType = 11;


    pub fn get_rankingType(&self) -> &str {
        match self.rankingType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool retrieveCarrierChannel = 12;


    pub fn get_retrieveCarrierChannel(&self) -> bool {
        self.retrieveCarrierChannel.unwrap_or(false)
    }

    // repeated string pendingDownloadAssetId = 13;


    pub fn get_pendingDownloadAssetId(&self) -> &[::std::string::String] {
        &self.pendingDownloadAssetId
    }

    // optional bool reconstructVendingHistory = 14;


    pub fn get_reconstructVendingHistory(&self) -> bool {
        self.reconstructVendingHistory.unwrap_or(false)
    }

    // optional bool unfilteredResults = 15;


    pub fn get_unfilteredResults(&self) -> bool {
        self.unfilteredResults.unwrap_or(false)
    }

    // repeated string badgeId = 16;


    pub fn get_badgeId(&self) -> &[::std::string::String] {
        &self.badgeId
    }
}

impl ::protobuf::Message for AssetsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryId)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.assetId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveVendingHistory = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveExtendedInfo = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sortOrder = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startIndex = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numEntries = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.viewFilter = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rankingType)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveCarrierChannel = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pendingDownloadAssetId)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reconstructVendingHistory = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unfilteredResults = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.badgeId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.categoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.assetId {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.retrieveVendingHistory {
            my_size += 2;
        }
        if let Some(v) = self.retrieveExtendedInfo {
            my_size += 2;
        }
        if let Some(v) = self.sortOrder {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startIndex {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numEntries {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.viewFilter {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rankingType.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.retrieveCarrierChannel {
            my_size += 2;
        }
        for value in &self.pendingDownloadAssetId {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.reconstructVendingHistory {
            my_size += 2;
        }
        if let Some(v) = self.unfilteredResults {
            my_size += 2;
        }
        for value in &self.badgeId {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.categoryId.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.assetId {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.retrieveVendingHistory {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.retrieveExtendedInfo {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.sortOrder {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.startIndex {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.numEntries {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.viewFilter {
            os.write_int32(10, v)?;
        }
        if let Some(ref v) = self.rankingType.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.retrieveCarrierChannel {
            os.write_bool(12, v)?;
        }
        for v in &self.pendingDownloadAssetId {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.reconstructVendingHistory {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.unfilteredResults {
            os.write_bool(15, v)?;
        }
        for v in &self.badgeId {
            os.write_string(16, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetsRequestProto {
        AssetsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assetType",
                |m: &AssetsRequestProto| { &m.assetType },
                |m: &mut AssetsRequestProto| { &mut m.assetType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &AssetsRequestProto| { &m.query },
                |m: &mut AssetsRequestProto| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &AssetsRequestProto| { &m.categoryId },
                |m: &mut AssetsRequestProto| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &AssetsRequestProto| { &m.assetId },
                |m: &mut AssetsRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retrieveVendingHistory",
                |m: &AssetsRequestProto| { &m.retrieveVendingHistory },
                |m: &mut AssetsRequestProto| { &mut m.retrieveVendingHistory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retrieveExtendedInfo",
                |m: &AssetsRequestProto| { &m.retrieveExtendedInfo },
                |m: &mut AssetsRequestProto| { &mut m.retrieveExtendedInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sortOrder",
                |m: &AssetsRequestProto| { &m.sortOrder },
                |m: &mut AssetsRequestProto| { &mut m.sortOrder },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startIndex",
                |m: &AssetsRequestProto| { &m.startIndex },
                |m: &mut AssetsRequestProto| { &mut m.startIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numEntries",
                |m: &AssetsRequestProto| { &m.numEntries },
                |m: &mut AssetsRequestProto| { &mut m.numEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "viewFilter",
                |m: &AssetsRequestProto| { &m.viewFilter },
                |m: &mut AssetsRequestProto| { &mut m.viewFilter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rankingType",
                |m: &AssetsRequestProto| { &m.rankingType },
                |m: &mut AssetsRequestProto| { &mut m.rankingType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retrieveCarrierChannel",
                |m: &AssetsRequestProto| { &m.retrieveCarrierChannel },
                |m: &mut AssetsRequestProto| { &mut m.retrieveCarrierChannel },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pendingDownloadAssetId",
                |m: &AssetsRequestProto| { &m.pendingDownloadAssetId },
                |m: &mut AssetsRequestProto| { &mut m.pendingDownloadAssetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reconstructVendingHistory",
                |m: &AssetsRequestProto| { &m.reconstructVendingHistory },
                |m: &mut AssetsRequestProto| { &mut m.reconstructVendingHistory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unfilteredResults",
                |m: &AssetsRequestProto| { &m.unfilteredResults },
                |m: &mut AssetsRequestProto| { &mut m.unfilteredResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "badgeId",
                |m: &AssetsRequestProto| { &m.badgeId },
                |m: &mut AssetsRequestProto| { &mut m.badgeId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetsRequestProto>(
                "AssetsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetsRequestProto {
        static instance: ::protobuf::rt::LazyV2<AssetsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetsRequestProto::new)
    }
}

impl ::protobuf::Clear for AssetsRequestProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.query.clear();
        self.categoryId.clear();
        self.assetId.clear();
        self.retrieveVendingHistory = ::std::option::Option::None;
        self.retrieveExtendedInfo = ::std::option::Option::None;
        self.sortOrder = ::std::option::Option::None;
        self.startIndex = ::std::option::Option::None;
        self.numEntries = ::std::option::Option::None;
        self.viewFilter = ::std::option::Option::None;
        self.rankingType.clear();
        self.retrieveCarrierChannel = ::std::option::Option::None;
        self.pendingDownloadAssetId.clear();
        self.reconstructVendingHistory = ::std::option::Option::None;
        self.unfilteredResults = ::std::option::Option::None;
        self.badgeId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AssetsResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<ExternalAssetProto>,
    pub numTotalEntries: ::std::option::Option<i64>,
    pub correctedQuery: ::protobuf::SingularField<::std::string::String>,
    pub altAsset: ::protobuf::RepeatedField<ExternalAssetProto>,
    pub numCorrectedEntries: ::std::option::Option<i64>,
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub listType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetsResponseProto {
    fn default() -> &'a AssetsResponseProto {
        <AssetsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AssetsResponseProto {
    pub fn new() -> AssetsResponseProto {
        ::std::default::Default::default()
    }

    // repeated .ExternalAssetProto asset = 1;


    pub fn get_asset(&self) -> &[ExternalAssetProto] {
        &self.asset
    }

    // optional int64 numTotalEntries = 2;


    pub fn get_numTotalEntries(&self) -> i64 {
        self.numTotalEntries.unwrap_or(0)
    }

    // optional string correctedQuery = 3;


    pub fn get_correctedQuery(&self) -> &str {
        match self.correctedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ExternalAssetProto altAsset = 4;


    pub fn get_altAsset(&self) -> &[ExternalAssetProto] {
        &self.altAsset
    }

    // optional int64 numCorrectedEntries = 5;


    pub fn get_numCorrectedEntries(&self) -> i64 {
        self.numCorrectedEntries.unwrap_or(0)
    }

    // optional string header = 6;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 listType = 7;


    pub fn get_listType(&self) -> i32 {
        self.listType.unwrap_or(0)
    }
}

impl ::protobuf::Message for AssetsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.altAsset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.asset)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numTotalEntries = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.correctedQuery)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.altAsset)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numCorrectedEntries = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.listType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numTotalEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.correctedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.altAsset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numCorrectedEntries {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numTotalEntries {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.correctedQuery.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.altAsset {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numCorrectedEntries {
            os.write_int64(5, v)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.listType {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetsResponseProto {
        AssetsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "asset",
                |m: &AssetsResponseProto| { &m.asset },
                |m: &mut AssetsResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numTotalEntries",
                |m: &AssetsResponseProto| { &m.numTotalEntries },
                |m: &mut AssetsResponseProto| { &mut m.numTotalEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "correctedQuery",
                |m: &AssetsResponseProto| { &m.correctedQuery },
                |m: &mut AssetsResponseProto| { &mut m.correctedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "altAsset",
                |m: &AssetsResponseProto| { &m.altAsset },
                |m: &mut AssetsResponseProto| { &mut m.altAsset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numCorrectedEntries",
                |m: &AssetsResponseProto| { &m.numCorrectedEntries },
                |m: &mut AssetsResponseProto| { &mut m.numCorrectedEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &AssetsResponseProto| { &m.header },
                |m: &mut AssetsResponseProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "listType",
                |m: &AssetsResponseProto| { &m.listType },
                |m: &mut AssetsResponseProto| { &mut m.listType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetsResponseProto>(
                "AssetsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetsResponseProto {
        static instance: ::protobuf::rt::LazyV2<AssetsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetsResponseProto::new)
    }
}

impl ::protobuf::Clear for AssetsResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.numTotalEntries = ::std::option::Option::None;
        self.correctedQuery.clear();
        self.altAsset.clear();
        self.numCorrectedEntries = ::std::option::Option::None;
        self.header.clear();
        self.listType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingEventRequestProto {
    // message fields
    pub eventType: ::std::option::Option<i32>,
    pub billingParametersId: ::protobuf::SingularField<::std::string::String>,
    pub resultSuccess: ::std::option::Option<bool>,
    pub clientMessage: ::protobuf::SingularField<::std::string::String>,
    pub carrierInstrument: ::protobuf::SingularPtrField<ExternalCarrierBillingInstrumentProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingEventRequestProto {
    fn default() -> &'a BillingEventRequestProto {
        <BillingEventRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl BillingEventRequestProto {
    pub fn new() -> BillingEventRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 eventType = 1;


    pub fn get_eventType(&self) -> i32 {
        self.eventType.unwrap_or(0)
    }

    // optional string billingParametersId = 2;


    pub fn get_billingParametersId(&self) -> &str {
        match self.billingParametersId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool resultSuccess = 3;


    pub fn get_resultSuccess(&self) -> bool {
        self.resultSuccess.unwrap_or(false)
    }

    // optional string clientMessage = 4;


    pub fn get_clientMessage(&self) -> &str {
        match self.clientMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ExternalCarrierBillingInstrumentProto carrierInstrument = 5;


    pub fn get_carrierInstrument(&self) -> &ExternalCarrierBillingInstrumentProto {
        self.carrierInstrument.as_ref().unwrap_or_else(|| <ExternalCarrierBillingInstrumentProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BillingEventRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eventType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingParametersId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resultSuccess = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eventType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.billingParametersId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.resultSuccess {
            my_size += 2;
        }
        if let Some(ref v) = self.clientMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.carrierInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eventType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.billingParametersId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.resultSuccess {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.clientMessage.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.carrierInstrument.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingEventRequestProto {
        BillingEventRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eventType",
                |m: &BillingEventRequestProto| { &m.eventType },
                |m: &mut BillingEventRequestProto| { &mut m.eventType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingParametersId",
                |m: &BillingEventRequestProto| { &m.billingParametersId },
                |m: &mut BillingEventRequestProto| { &mut m.billingParametersId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "resultSuccess",
                |m: &BillingEventRequestProto| { &m.resultSuccess },
                |m: &mut BillingEventRequestProto| { &mut m.resultSuccess },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientMessage",
                |m: &BillingEventRequestProto| { &m.clientMessage },
                |m: &mut BillingEventRequestProto| { &mut m.clientMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCarrierBillingInstrumentProto>>(
                "carrierInstrument",
                |m: &BillingEventRequestProto| { &m.carrierInstrument },
                |m: &mut BillingEventRequestProto| { &mut m.carrierInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingEventRequestProto>(
                "BillingEventRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingEventRequestProto {
        static instance: ::protobuf::rt::LazyV2<BillingEventRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingEventRequestProto::new)
    }
}

impl ::protobuf::Clear for BillingEventRequestProto {
    fn clear(&mut self) {
        self.eventType = ::std::option::Option::None;
        self.billingParametersId.clear();
        self.resultSuccess = ::std::option::Option::None;
        self.clientMessage.clear();
        self.carrierInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingEventRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingEventRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingEventResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingEventResponseProto {
    fn default() -> &'a BillingEventResponseProto {
        <BillingEventResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl BillingEventResponseProto {
    pub fn new() -> BillingEventResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BillingEventResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingEventResponseProto {
        BillingEventResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingEventResponseProto>(
                "BillingEventResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingEventResponseProto {
        static instance: ::protobuf::rt::LazyV2<BillingEventResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingEventResponseProto::new)
    }
}

impl ::protobuf::Clear for BillingEventResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingEventResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingEventResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingParameterProto {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub mncMcc: ::protobuf::RepeatedField<::std::string::String>,
    pub backendUrl: ::protobuf::RepeatedField<::std::string::String>,
    pub iconId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    pub applicationId: ::protobuf::SingularField<::std::string::String>,
    pub tosUrl: ::protobuf::SingularField<::std::string::String>,
    pub instrumentTosRequired: ::std::option::Option<bool>,
    pub apiVersion: ::std::option::Option<i32>,
    pub perTransactionCredentialsRequired: ::std::option::Option<bool>,
    pub sendSubscriberIdWithCarrierBillingRequests: ::std::option::Option<bool>,
    pub deviceAssociationMethod: ::std::option::Option<i32>,
    pub userTokenRequestMessage: ::protobuf::SingularField<::std::string::String>,
    pub userTokenRequestAddress: ::protobuf::SingularField<::std::string::String>,
    pub passphraseRequired: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingParameterProto {
    fn default() -> &'a BillingParameterProto {
        <BillingParameterProto as ::protobuf::Message>::default_instance()
    }
}

impl BillingParameterProto {
    pub fn new() -> BillingParameterProto {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string mncMcc = 3;


    pub fn get_mncMcc(&self) -> &[::std::string::String] {
        &self.mncMcc
    }

    // repeated string backendUrl = 4;


    pub fn get_backendUrl(&self) -> &[::std::string::String] {
        &self.backendUrl
    }

    // optional string iconId = 5;


    pub fn get_iconId(&self) -> &str {
        match self.iconId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 billingInstrumentType = 6;


    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }

    // optional string applicationId = 7;


    pub fn get_applicationId(&self) -> &str {
        match self.applicationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tosUrl = 8;


    pub fn get_tosUrl(&self) -> &str {
        match self.tosUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool instrumentTosRequired = 9;


    pub fn get_instrumentTosRequired(&self) -> bool {
        self.instrumentTosRequired.unwrap_or(false)
    }

    // optional int32 apiVersion = 10;


    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional bool perTransactionCredentialsRequired = 11;


    pub fn get_perTransactionCredentialsRequired(&self) -> bool {
        self.perTransactionCredentialsRequired.unwrap_or(false)
    }

    // optional bool sendSubscriberIdWithCarrierBillingRequests = 12;


    pub fn get_sendSubscriberIdWithCarrierBillingRequests(&self) -> bool {
        self.sendSubscriberIdWithCarrierBillingRequests.unwrap_or(false)
    }

    // optional int32 deviceAssociationMethod = 13;


    pub fn get_deviceAssociationMethod(&self) -> i32 {
        self.deviceAssociationMethod.unwrap_or(0)
    }

    // optional string userTokenRequestMessage = 14;


    pub fn get_userTokenRequestMessage(&self) -> &str {
        match self.userTokenRequestMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userTokenRequestAddress = 15;


    pub fn get_userTokenRequestAddress(&self) -> &str {
        match self.userTokenRequestAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool passphraseRequired = 16;


    pub fn get_passphraseRequired(&self) -> bool {
        self.passphraseRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for BillingParameterProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mncMcc)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.backendUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconId)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.applicationId)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosUrl)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.instrumentTosRequired = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perTransactionCredentialsRequired = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceAssociationMethod = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestMessage)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userTokenRequestAddress)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passphraseRequired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.mncMcc {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.backendUrl {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.iconId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.applicationId.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.tosUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.instrumentTosRequired {
            my_size += 2;
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            my_size += 2;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            my_size += 2;
        }
        if let Some(v) = self.deviceAssociationMethod {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.userTokenRequestMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.userTokenRequestAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.passphraseRequired {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.mncMcc {
            os.write_string(3, &v)?;
        };
        for v in &self.backendUrl {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.iconId.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.applicationId.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.tosUrl.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.instrumentTosRequired {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.deviceAssociationMethod {
            os.write_int32(13, v)?;
        }
        if let Some(ref v) = self.userTokenRequestMessage.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.userTokenRequestAddress.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.passphraseRequired {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingParameterProto {
        BillingParameterProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &BillingParameterProto| { &m.id },
                |m: &mut BillingParameterProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BillingParameterProto| { &m.name },
                |m: &mut BillingParameterProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mncMcc",
                |m: &BillingParameterProto| { &m.mncMcc },
                |m: &mut BillingParameterProto| { &mut m.mncMcc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendUrl",
                |m: &BillingParameterProto| { &m.backendUrl },
                |m: &mut BillingParameterProto| { &mut m.backendUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iconId",
                |m: &BillingParameterProto| { &m.iconId },
                |m: &mut BillingParameterProto| { &mut m.iconId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingInstrumentType",
                |m: &BillingParameterProto| { &m.billingInstrumentType },
                |m: &mut BillingParameterProto| { &mut m.billingInstrumentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationId",
                |m: &BillingParameterProto| { &m.applicationId },
                |m: &mut BillingParameterProto| { &mut m.applicationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosUrl",
                |m: &BillingParameterProto| { &m.tosUrl },
                |m: &mut BillingParameterProto| { &mut m.tosUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "instrumentTosRequired",
                |m: &BillingParameterProto| { &m.instrumentTosRequired },
                |m: &mut BillingParameterProto| { &mut m.instrumentTosRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "apiVersion",
                |m: &BillingParameterProto| { &m.apiVersion },
                |m: &mut BillingParameterProto| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "perTransactionCredentialsRequired",
                |m: &BillingParameterProto| { &m.perTransactionCredentialsRequired },
                |m: &mut BillingParameterProto| { &mut m.perTransactionCredentialsRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sendSubscriberIdWithCarrierBillingRequests",
                |m: &BillingParameterProto| { &m.sendSubscriberIdWithCarrierBillingRequests },
                |m: &mut BillingParameterProto| { &mut m.sendSubscriberIdWithCarrierBillingRequests },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceAssociationMethod",
                |m: &BillingParameterProto| { &m.deviceAssociationMethod },
                |m: &mut BillingParameterProto| { &mut m.deviceAssociationMethod },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userTokenRequestMessage",
                |m: &BillingParameterProto| { &m.userTokenRequestMessage },
                |m: &mut BillingParameterProto| { &mut m.userTokenRequestMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userTokenRequestAddress",
                |m: &BillingParameterProto| { &m.userTokenRequestAddress },
                |m: &mut BillingParameterProto| { &mut m.userTokenRequestAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passphraseRequired",
                |m: &BillingParameterProto| { &m.passphraseRequired },
                |m: &mut BillingParameterProto| { &mut m.passphraseRequired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingParameterProto>(
                "BillingParameterProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingParameterProto {
        static instance: ::protobuf::rt::LazyV2<BillingParameterProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingParameterProto::new)
    }
}

impl ::protobuf::Clear for BillingParameterProto {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.mncMcc.clear();
        self.backendUrl.clear();
        self.iconId.clear();
        self.billingInstrumentType = ::std::option::Option::None;
        self.applicationId.clear();
        self.tosUrl.clear();
        self.instrumentTosRequired = ::std::option::Option::None;
        self.apiVersion = ::std::option::Option::None;
        self.perTransactionCredentialsRequired = ::std::option::Option::None;
        self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::None;
        self.deviceAssociationMethod = ::std::option::Option::None;
        self.userTokenRequestMessage.clear();
        self.userTokenRequestAddress.clear();
        self.passphraseRequired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingParameterProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingParameterProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingCredentialsProto {
    // message fields
    pub credentials: ::protobuf::SingularField<::std::string::String>,
    pub credentialsTimeout: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingCredentialsProto {
    fn default() -> &'a CarrierBillingCredentialsProto {
        <CarrierBillingCredentialsProto as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingCredentialsProto {
    pub fn new() -> CarrierBillingCredentialsProto {
        ::std::default::Default::default()
    }

    // optional string credentials = 1;


    pub fn get_credentials(&self) -> &str {
        match self.credentials.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 credentialsTimeout = 2;


    pub fn get_credentialsTimeout(&self) -> i64 {
        self.credentialsTimeout.unwrap_or(0)
    }
}

impl ::protobuf::Message for CarrierBillingCredentialsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credentials)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.credentialsTimeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.credentials.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.credentialsTimeout {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.credentials.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.credentialsTimeout {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingCredentialsProto {
        CarrierBillingCredentialsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credentials",
                |m: &CarrierBillingCredentialsProto| { &m.credentials },
                |m: &mut CarrierBillingCredentialsProto| { &mut m.credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "credentialsTimeout",
                |m: &CarrierBillingCredentialsProto| { &m.credentialsTimeout },
                |m: &mut CarrierBillingCredentialsProto| { &mut m.credentialsTimeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingCredentialsProto>(
                "CarrierBillingCredentialsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingCredentialsProto {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingCredentialsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingCredentialsProto::new)
    }
}

impl ::protobuf::Clear for CarrierBillingCredentialsProto {
    fn clear(&mut self) {
        self.credentials.clear();
        self.credentialsTimeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingCredentialsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingCredentialsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CategoryProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    pub categoryId: ::protobuf::SingularField<::std::string::String>,
    pub categoryDisplay: ::protobuf::SingularField<::std::string::String>,
    pub categorySubtitle: ::protobuf::SingularField<::std::string::String>,
    pub promotedAssetsNew: ::protobuf::RepeatedField<::std::string::String>,
    pub promotedAssetsHome: ::protobuf::RepeatedField<::std::string::String>,
    pub subCategories: ::protobuf::RepeatedField<CategoryProto>,
    pub promotedAssetsPaid: ::protobuf::RepeatedField<::std::string::String>,
    pub promotedAssetsFree: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CategoryProto {
    fn default() -> &'a CategoryProto {
        <CategoryProto as ::protobuf::Message>::default_instance()
    }
}

impl CategoryProto {
    pub fn new() -> CategoryProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 2;


    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string categoryId = 3;


    pub fn get_categoryId(&self) -> &str {
        match self.categoryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string categoryDisplay = 4;


    pub fn get_categoryDisplay(&self) -> &str {
        match self.categoryDisplay.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string categorySubtitle = 5;


    pub fn get_categorySubtitle(&self) -> &str {
        match self.categorySubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string promotedAssetsNew = 6;


    pub fn get_promotedAssetsNew(&self) -> &[::std::string::String] {
        &self.promotedAssetsNew
    }

    // repeated string promotedAssetsHome = 7;


    pub fn get_promotedAssetsHome(&self) -> &[::std::string::String] {
        &self.promotedAssetsHome
    }

    // repeated .CategoryProto subCategories = 8;


    pub fn get_subCategories(&self) -> &[CategoryProto] {
        &self.subCategories
    }

    // repeated string promotedAssetsPaid = 9;


    pub fn get_promotedAssetsPaid(&self) -> &[::std::string::String] {
        &self.promotedAssetsPaid
    }

    // repeated string promotedAssetsFree = 10;


    pub fn get_promotedAssetsFree(&self) -> &[::std::string::String] {
        &self.promotedAssetsFree
    }
}

impl ::protobuf::Message for CategoryProto {
    fn is_initialized(&self) -> bool {
        for v in &self.subCategories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryDisplay)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categorySubtitle)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsNew)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsHome)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subCategories)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsPaid)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotedAssetsFree)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.categoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.categoryDisplay.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.categorySubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.promotedAssetsNew {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.promotedAssetsHome {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.subCategories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.promotedAssetsPaid {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.promotedAssetsFree {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.categoryId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.categoryDisplay.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.categorySubtitle.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.promotedAssetsNew {
            os.write_string(6, &v)?;
        };
        for v in &self.promotedAssetsHome {
            os.write_string(7, &v)?;
        };
        for v in &self.subCategories {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.promotedAssetsPaid {
            os.write_string(9, &v)?;
        };
        for v in &self.promotedAssetsFree {
            os.write_string(10, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoryProto {
        CategoryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assetType",
                |m: &CategoryProto| { &m.assetType },
                |m: &mut CategoryProto| { &mut m.assetType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &CategoryProto| { &m.categoryId },
                |m: &mut CategoryProto| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryDisplay",
                |m: &CategoryProto| { &m.categoryDisplay },
                |m: &mut CategoryProto| { &mut m.categoryDisplay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categorySubtitle",
                |m: &CategoryProto| { &m.categorySubtitle },
                |m: &mut CategoryProto| { &mut m.categorySubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsNew",
                |m: &CategoryProto| { &m.promotedAssetsNew },
                |m: &mut CategoryProto| { &mut m.promotedAssetsNew },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsHome",
                |m: &CategoryProto| { &m.promotedAssetsHome },
                |m: &mut CategoryProto| { &mut m.promotedAssetsHome },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryProto>>(
                "subCategories",
                |m: &CategoryProto| { &m.subCategories },
                |m: &mut CategoryProto| { &mut m.subCategories },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsPaid",
                |m: &CategoryProto| { &m.promotedAssetsPaid },
                |m: &mut CategoryProto| { &mut m.promotedAssetsPaid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotedAssetsFree",
                |m: &CategoryProto| { &m.promotedAssetsFree },
                |m: &mut CategoryProto| { &mut m.promotedAssetsFree },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CategoryProto>(
                "CategoryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoryProto {
        static instance: ::protobuf::rt::LazyV2<CategoryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CategoryProto::new)
    }
}

impl ::protobuf::Clear for CategoryProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.categoryId.clear();
        self.categoryDisplay.clear();
        self.categorySubtitle.clear();
        self.promotedAssetsNew.clear();
        self.promotedAssetsHome.clear();
        self.subCategories.clear();
        self.promotedAssetsPaid.clear();
        self.promotedAssetsFree.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckForNotificationsRequestProto {
    // message fields
    pub alarmDuration: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckForNotificationsRequestProto {
    fn default() -> &'a CheckForNotificationsRequestProto {
        <CheckForNotificationsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckForNotificationsRequestProto {
    pub fn new() -> CheckForNotificationsRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 alarmDuration = 1;


    pub fn get_alarmDuration(&self) -> i64 {
        self.alarmDuration.unwrap_or(0)
    }
}

impl ::protobuf::Message for CheckForNotificationsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.alarmDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.alarmDuration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.alarmDuration {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckForNotificationsRequestProto {
        CheckForNotificationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "alarmDuration",
                |m: &CheckForNotificationsRequestProto| { &m.alarmDuration },
                |m: &mut CheckForNotificationsRequestProto| { &mut m.alarmDuration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckForNotificationsRequestProto>(
                "CheckForNotificationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckForNotificationsRequestProto {
        static instance: ::protobuf::rt::LazyV2<CheckForNotificationsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckForNotificationsRequestProto::new)
    }
}

impl ::protobuf::Clear for CheckForNotificationsRequestProto {
    fn clear(&mut self) {
        self.alarmDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckForNotificationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckForNotificationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckForNotificationsResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckForNotificationsResponseProto {
    fn default() -> &'a CheckForNotificationsResponseProto {
        <CheckForNotificationsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckForNotificationsResponseProto {
    pub fn new() -> CheckForNotificationsResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckForNotificationsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckForNotificationsResponseProto {
        CheckForNotificationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckForNotificationsResponseProto>(
                "CheckForNotificationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckForNotificationsResponseProto {
        static instance: ::protobuf::rt::LazyV2<CheckForNotificationsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckForNotificationsResponseProto::new)
    }
}

impl ::protobuf::Clear for CheckForNotificationsResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckForNotificationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckForNotificationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckLicenseRequestProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub nonce: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLicenseRequestProto {
    fn default() -> &'a CheckLicenseRequestProto {
        <CheckLicenseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckLicenseRequestProto {
    pub fn new() -> CheckLicenseRequestProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 nonce = 3;


    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }
}

impl ::protobuf::Message for CheckLicenseRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLicenseRequestProto {
        CheckLicenseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &CheckLicenseRequestProto| { &m.packageName },
                |m: &mut CheckLicenseRequestProto| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &CheckLicenseRequestProto| { &m.versionCode },
                |m: &mut CheckLicenseRequestProto| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &CheckLicenseRequestProto| { &m.nonce },
                |m: &mut CheckLicenseRequestProto| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckLicenseRequestProto>(
                "CheckLicenseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckLicenseRequestProto {
        static instance: ::protobuf::rt::LazyV2<CheckLicenseRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckLicenseRequestProto::new)
    }
}

impl ::protobuf::Clear for CheckLicenseRequestProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckLicenseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLicenseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CheckLicenseResponseProto {
    // message fields
    pub responseCode: ::std::option::Option<i32>,
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLicenseResponseProto {
    fn default() -> &'a CheckLicenseResponseProto {
        <CheckLicenseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckLicenseResponseProto {
    pub fn new() -> CheckLicenseResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 responseCode = 1;


    pub fn get_responseCode(&self) -> i32 {
        self.responseCode.unwrap_or(0)
    }

    // optional string signedData = 2;


    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 3;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CheckLicenseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.responseCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.responseCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.responseCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.signedData.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLicenseResponseProto {
        CheckLicenseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "responseCode",
                |m: &CheckLicenseResponseProto| { &m.responseCode },
                |m: &mut CheckLicenseResponseProto| { &mut m.responseCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedData",
                |m: &CheckLicenseResponseProto| { &m.signedData },
                |m: &mut CheckLicenseResponseProto| { &mut m.signedData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &CheckLicenseResponseProto| { &m.signature },
                |m: &mut CheckLicenseResponseProto| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckLicenseResponseProto>(
                "CheckLicenseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckLicenseResponseProto {
        static instance: ::protobuf::rt::LazyV2<CheckLicenseResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckLicenseResponseProto::new)
    }
}

impl ::protobuf::Clear for CheckLicenseResponseProto {
    fn clear(&mut self) {
        self.responseCode = ::std::option::Option::None;
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckLicenseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLicenseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CommentsRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub startIndex: ::std::option::Option<i64>,
    pub numEntries: ::std::option::Option<i64>,
    pub shouldReturnSelfComment: ::std::option::Option<bool>,
    pub assetReferrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommentsRequestProto {
    fn default() -> &'a CommentsRequestProto {
        <CommentsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CommentsRequestProto {
    pub fn new() -> CommentsRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 startIndex = 2;


    pub fn get_startIndex(&self) -> i64 {
        self.startIndex.unwrap_or(0)
    }

    // optional int64 numEntries = 3;


    pub fn get_numEntries(&self) -> i64 {
        self.numEntries.unwrap_or(0)
    }

    // optional bool shouldReturnSelfComment = 4;


    pub fn get_shouldReturnSelfComment(&self) -> bool {
        self.shouldReturnSelfComment.unwrap_or(false)
    }

    // optional string assetReferrer = 5;


    pub fn get_assetReferrer(&self) -> &str {
        match self.assetReferrer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommentsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numEntries = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shouldReturnSelfComment = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetReferrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.startIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numEntries {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shouldReturnSelfComment {
            my_size += 2;
        }
        if let Some(ref v) = self.assetReferrer.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.startIndex {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.numEntries {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.shouldReturnSelfComment {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.assetReferrer.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommentsRequestProto {
        CommentsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &CommentsRequestProto| { &m.assetId },
                |m: &mut CommentsRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startIndex",
                |m: &CommentsRequestProto| { &m.startIndex },
                |m: &mut CommentsRequestProto| { &mut m.startIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numEntries",
                |m: &CommentsRequestProto| { &m.numEntries },
                |m: &mut CommentsRequestProto| { &mut m.numEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shouldReturnSelfComment",
                |m: &CommentsRequestProto| { &m.shouldReturnSelfComment },
                |m: &mut CommentsRequestProto| { &mut m.shouldReturnSelfComment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetReferrer",
                |m: &CommentsRequestProto| { &m.assetReferrer },
                |m: &mut CommentsRequestProto| { &mut m.assetReferrer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommentsRequestProto>(
                "CommentsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommentsRequestProto {
        static instance: ::protobuf::rt::LazyV2<CommentsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommentsRequestProto::new)
    }
}

impl ::protobuf::Clear for CommentsRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.startIndex = ::std::option::Option::None;
        self.numEntries = ::std::option::Option::None;
        self.shouldReturnSelfComment = ::std::option::Option::None;
        self.assetReferrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommentsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CommentsResponseProto {
    // message fields
    pub comment: ::protobuf::RepeatedField<ExternalCommentProto>,
    pub numTotalEntries: ::std::option::Option<i64>,
    pub selfComment: ::protobuf::SingularPtrField<ExternalCommentProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommentsResponseProto {
    fn default() -> &'a CommentsResponseProto {
        <CommentsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CommentsResponseProto {
    pub fn new() -> CommentsResponseProto {
        ::std::default::Default::default()
    }

    // repeated .ExternalCommentProto comment = 1;


    pub fn get_comment(&self) -> &[ExternalCommentProto] {
        &self.comment
    }

    // optional int64 numTotalEntries = 2;


    pub fn get_numTotalEntries(&self) -> i64 {
        self.numTotalEntries.unwrap_or(0)
    }

    // optional .ExternalCommentProto selfComment = 3;


    pub fn get_selfComment(&self) -> &ExternalCommentProto {
        self.selfComment.as_ref().unwrap_or_else(|| <ExternalCommentProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for CommentsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.comment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfComment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.comment)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numTotalEntries = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selfComment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.comment {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numTotalEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.selfComment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.comment {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numTotalEntries {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.selfComment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommentsResponseProto {
        CommentsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>>(
                "comment",
                |m: &CommentsResponseProto| { &m.comment },
                |m: &mut CommentsResponseProto| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numTotalEntries",
                |m: &CommentsResponseProto| { &m.numTotalEntries },
                |m: &mut CommentsResponseProto| { &mut m.numTotalEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>>(
                "selfComment",
                |m: &CommentsResponseProto| { &m.selfComment },
                |m: &mut CommentsResponseProto| { &mut m.selfComment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommentsResponseProto>(
                "CommentsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommentsResponseProto {
        static instance: ::protobuf::rt::LazyV2<CommentsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommentsResponseProto::new)
    }
}

impl ::protobuf::Clear for CommentsResponseProto {
    fn clear(&mut self) {
        self.comment.clear();
        self.numTotalEntries = ::std::option::Option::None;
        self.selfComment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommentsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContentSyncRequestProto {
    // message fields
    pub incremental: ::std::option::Option<bool>,
    // assetinstallstate: <group>
    // systemapp: <group>
    pub sideloadedAppCount: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSyncRequestProto {
    fn default() -> &'a ContentSyncRequestProto {
        <ContentSyncRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ContentSyncRequestProto {
    pub fn new() -> ContentSyncRequestProto {
        ::std::default::Default::default()
    }

    // optional bool incremental = 1;


    pub fn get_incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    // optional int32 sideloadedAppCount = 14;


    pub fn get_sideloadedAppCount(&self) -> i32 {
        self.sideloadedAppCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for ContentSyncRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incremental = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sideloadedAppCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.incremental {
            my_size += 2;
        }
        if let Some(v) = self.sideloadedAppCount {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.incremental {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sideloadedAppCount {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto {
        ContentSyncRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "incremental",
                |m: &ContentSyncRequestProto| { &m.incremental },
                |m: &mut ContentSyncRequestProto| { &mut m.incremental },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sideloadedAppCount",
                |m: &ContentSyncRequestProto| { &m.sideloadedAppCount },
                |m: &mut ContentSyncRequestProto| { &mut m.sideloadedAppCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentSyncRequestProto>(
                "ContentSyncRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto {
        static instance: ::protobuf::rt::LazyV2<ContentSyncRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentSyncRequestProto::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto {
    fn clear(&mut self) {
        self.incremental = ::std::option::Option::None;
        self.sideloadedAppCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContentSyncRequestProto_AssetInstallState {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub assetState: ::std::option::Option<i32>,
    pub installTime: ::std::option::Option<i64>,
    pub uninstallTime: ::std::option::Option<i64>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub assetReferrer: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSyncRequestProto_AssetInstallState {
    fn default() -> &'a ContentSyncRequestProto_AssetInstallState {
        <ContentSyncRequestProto_AssetInstallState as ::protobuf::Message>::default_instance()
    }
}

impl ContentSyncRequestProto_AssetInstallState {
    pub fn new() -> ContentSyncRequestProto_AssetInstallState {
        ::std::default::Default::default()
    }

    // optional string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 assetState = 4;


    pub fn get_assetState(&self) -> i32 {
        self.assetState.unwrap_or(0)
    }

    // optional int64 installTime = 5;


    pub fn get_installTime(&self) -> i64 {
        self.installTime.unwrap_or(0)
    }

    // optional int64 uninstallTime = 6;


    pub fn get_uninstallTime(&self) -> i64 {
        self.uninstallTime.unwrap_or(0)
    }

    // optional string packageName = 7;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 8;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetReferrer = 9;


    pub fn get_assetReferrer(&self) -> &str {
        match self.assetReferrer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContentSyncRequestProto_AssetInstallState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetState = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.installTime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.uninstallTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetReferrer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.assetState {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installTime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uninstallTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.assetReferrer.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.assetState {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.installTime {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.uninstallTime {
            os.write_int64(6, v)?;
        }
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.assetReferrer.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto_AssetInstallState {
        ContentSyncRequestProto_AssetInstallState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetId },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assetState",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetState },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "installTime",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.installTime },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.installTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "uninstallTime",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.uninstallTime },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.uninstallTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.packageName },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.versionCode },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetReferrer",
                |m: &ContentSyncRequestProto_AssetInstallState| { &m.assetReferrer },
                |m: &mut ContentSyncRequestProto_AssetInstallState| { &mut m.assetReferrer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentSyncRequestProto_AssetInstallState>(
                "ContentSyncRequestProto.AssetInstallState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto_AssetInstallState {
        static instance: ::protobuf::rt::LazyV2<ContentSyncRequestProto_AssetInstallState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentSyncRequestProto_AssetInstallState::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto_AssetInstallState {
    fn clear(&mut self) {
        self.assetId.clear();
        self.assetState = ::std::option::Option::None;
        self.installTime = ::std::option::Option::None;
        self.uninstallTime = ::std::option::Option::None;
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.assetReferrer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto_AssetInstallState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto_AssetInstallState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContentSyncRequestProto_SystemApp {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub certificateHash: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSyncRequestProto_SystemApp {
    fn default() -> &'a ContentSyncRequestProto_SystemApp {
        <ContentSyncRequestProto_SystemApp as ::protobuf::Message>::default_instance()
    }
}

impl ContentSyncRequestProto_SystemApp {
    pub fn new() -> ContentSyncRequestProto_SystemApp {
        ::std::default::Default::default()
    }

    // optional string packageName = 11;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 12;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // repeated string certificateHash = 13;


    pub fn get_certificateHash(&self) -> &[::std::string::String] {
        &self.certificateHash
    }
}

impl ::protobuf::Message for ContentSyncRequestProto_SystemApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.certificateHash {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(12, v)?;
        }
        for v in &self.certificateHash {
            os.write_string(13, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncRequestProto_SystemApp {
        ContentSyncRequestProto_SystemApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &ContentSyncRequestProto_SystemApp| { &m.packageName },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &ContentSyncRequestProto_SystemApp| { &m.versionCode },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &ContentSyncRequestProto_SystemApp| { &m.certificateHash },
                |m: &mut ContentSyncRequestProto_SystemApp| { &mut m.certificateHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentSyncRequestProto_SystemApp>(
                "ContentSyncRequestProto.SystemApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncRequestProto_SystemApp {
        static instance: ::protobuf::rt::LazyV2<ContentSyncRequestProto_SystemApp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentSyncRequestProto_SystemApp::new)
    }
}

impl ::protobuf::Clear for ContentSyncRequestProto_SystemApp {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.certificateHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncRequestProto_SystemApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncRequestProto_SystemApp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContentSyncResponseProto {
    // message fields
    pub numUpdatesAvailable: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSyncResponseProto {
    fn default() -> &'a ContentSyncResponseProto {
        <ContentSyncResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ContentSyncResponseProto {
    pub fn new() -> ContentSyncResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 numUpdatesAvailable = 1;


    pub fn get_numUpdatesAvailable(&self) -> i32 {
        self.numUpdatesAvailable.unwrap_or(0)
    }
}

impl ::protobuf::Message for ContentSyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numUpdatesAvailable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.numUpdatesAvailable {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.numUpdatesAvailable {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSyncResponseProto {
        ContentSyncResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numUpdatesAvailable",
                |m: &ContentSyncResponseProto| { &m.numUpdatesAvailable },
                |m: &mut ContentSyncResponseProto| { &mut m.numUpdatesAvailable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentSyncResponseProto>(
                "ContentSyncResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSyncResponseProto {
        static instance: ::protobuf::rt::LazyV2<ContentSyncResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentSyncResponseProto::new)
    }
}

impl ::protobuf::Clear for ContentSyncResponseProto {
    fn clear(&mut self) {
        self.numUpdatesAvailable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataMessageProto {
    // message fields
    pub category: ::protobuf::SingularField<::std::string::String>,
    pub appData: ::protobuf::RepeatedField<AppDataProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataMessageProto {
    fn default() -> &'a DataMessageProto {
        <DataMessageProto as ::protobuf::Message>::default_instance()
    }
}

impl DataMessageProto {
    pub fn new() -> DataMessageProto {
        ::std::default::Default::default()
    }

    // optional string category = 1;


    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .AppDataProto appData = 3;


    pub fn get_appData(&self) -> &[AppDataProto] {
        &self.appData
    }
}

impl ::protobuf::Message for DataMessageProto {
    fn is_initialized(&self) -> bool {
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.appData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.appData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.category.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.appData {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataMessageProto {
        DataMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category",
                |m: &DataMessageProto| { &m.category },
                |m: &mut DataMessageProto| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDataProto>>(
                "appData",
                |m: &DataMessageProto| { &m.appData },
                |m: &mut DataMessageProto| { &mut m.appData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataMessageProto>(
                "DataMessageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataMessageProto {
        static instance: ::protobuf::rt::LazyV2<DataMessageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataMessageProto::new)
    }
}

impl ::protobuf::Clear for DataMessageProto {
    fn clear(&mut self) {
        self.category.clear();
        self.appData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataMessageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DownloadInfoProto {
    // message fields
    pub apkSize: ::std::option::Option<i64>,
    pub additionalFile: ::protobuf::RepeatedField<FileMetadataProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadInfoProto {
    fn default() -> &'a DownloadInfoProto {
        <DownloadInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DownloadInfoProto {
    pub fn new() -> DownloadInfoProto {
        ::std::default::Default::default()
    }

    // optional int64 apkSize = 1;


    pub fn get_apkSize(&self) -> i64 {
        self.apkSize.unwrap_or(0)
    }

    // repeated .FileMetadataProto additionalFile = 2;


    pub fn get_additionalFile(&self) -> &[FileMetadataProto] {
        &self.additionalFile
    }
}

impl ::protobuf::Message for DownloadInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.apkSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additionalFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.apkSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.apkSize {
            os.write_int64(1, v)?;
        }
        for v in &self.additionalFile {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadInfoProto {
        DownloadInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "apkSize",
                |m: &DownloadInfoProto| { &m.apkSize },
                |m: &mut DownloadInfoProto| { &mut m.apkSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadataProto>>(
                "additionalFile",
                |m: &DownloadInfoProto| { &m.additionalFile },
                |m: &mut DownloadInfoProto| { &mut m.additionalFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownloadInfoProto>(
                "DownloadInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownloadInfoProto {
        static instance: ::protobuf::rt::LazyV2<DownloadInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownloadInfoProto::new)
    }
}

impl ::protobuf::Clear for DownloadInfoProto {
    fn clear(&mut self) {
        self.apkSize = ::std::option::Option::None;
        self.additionalFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalAssetProto {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub assetType: ::std::option::Option<i32>,
    pub owner: ::protobuf::SingularField<::std::string::String>,
    pub version: ::protobuf::SingularField<::std::string::String>,
    pub price: ::protobuf::SingularField<::std::string::String>,
    pub averageRating: ::protobuf::SingularField<::std::string::String>,
    pub numRatings: ::std::option::Option<i64>,
    // purchaseinformation: <group>
    // extendedinfo: <group>
    pub ownerId: ::protobuf::SingularField<::std::string::String>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub bundledAsset: ::std::option::Option<bool>,
    pub priceCurrency: ::protobuf::SingularField<::std::string::String>,
    pub priceMicros: ::std::option::Option<i64>,
    pub filterReason: ::protobuf::SingularField<::std::string::String>,
    pub actualSellerPrice: ::protobuf::SingularField<::std::string::String>,
    pub appBadge: ::protobuf::RepeatedField<ExternalBadgeProto>,
    pub ownerBadge: ::protobuf::RepeatedField<ExternalBadgeProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalAssetProto {
    fn default() -> &'a ExternalAssetProto {
        <ExternalAssetProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalAssetProto {
    pub fn new() -> ExternalAssetProto {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 assetType = 3;


    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }

    // optional string owner = 4;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 5;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string price = 6;


    pub fn get_price(&self) -> &str {
        match self.price.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string averageRating = 7;


    pub fn get_averageRating(&self) -> &str {
        match self.averageRating.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 numRatings = 8;


    pub fn get_numRatings(&self) -> i64 {
        self.numRatings.unwrap_or(0)
    }

    // optional string ownerId = 22;


    pub fn get_ownerId(&self) -> &str {
        match self.ownerId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string packageName = 24;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 25;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional bool bundledAsset = 29;


    pub fn get_bundledAsset(&self) -> bool {
        self.bundledAsset.unwrap_or(false)
    }

    // optional string priceCurrency = 32;


    pub fn get_priceCurrency(&self) -> &str {
        match self.priceCurrency.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 priceMicros = 33;


    pub fn get_priceMicros(&self) -> i64 {
        self.priceMicros.unwrap_or(0)
    }

    // optional string filterReason = 35;


    pub fn get_filterReason(&self) -> &str {
        match self.filterReason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string actualSellerPrice = 40;


    pub fn get_actualSellerPrice(&self) -> &str {
        match self.actualSellerPrice.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ExternalBadgeProto appBadge = 47;


    pub fn get_appBadge(&self) -> &[ExternalBadgeProto] {
        &self.appBadge
    }

    // repeated .ExternalBadgeProto ownerBadge = 48;


    pub fn get_ownerBadge(&self) -> &[ExternalBadgeProto] {
        &self.ownerBadge
    }
}

impl ::protobuf::Message for ExternalAssetProto {
    fn is_initialized(&self) -> bool {
        for v in &self.appBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownerBadge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.price)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.averageRating)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numRatings = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerId)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bundledAsset = ::std::option::Option::Some(tmp);
                },
                32 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceCurrency)?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.priceMicros = ::std::option::Option::Some(tmp);
                },
                35 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filterReason)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.actualSellerPrice)?;
                },
                47 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.appBadge)?;
                },
                48 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ownerBadge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.price.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.averageRating.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.numRatings {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ownerId.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bundledAsset {
            my_size += 3;
        }
        if let Some(ref v) = self.priceCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(32, &v);
        }
        if let Some(v) = self.priceMicros {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filterReason.as_ref() {
            my_size += ::protobuf::rt::string_size(35, &v);
        }
        if let Some(ref v) = self.actualSellerPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        for value in &self.appBadge {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ownerBadge {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.assetType {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.price.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.averageRating.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.numRatings {
            os.write_int64(8, v)?;
        }
        if let Some(ref v) = self.ownerId.as_ref() {
            os.write_string(22, &v)?;
        }
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(24, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.bundledAsset {
            os.write_bool(29, v)?;
        }
        if let Some(ref v) = self.priceCurrency.as_ref() {
            os.write_string(32, &v)?;
        }
        if let Some(v) = self.priceMicros {
            os.write_int64(33, v)?;
        }
        if let Some(ref v) = self.filterReason.as_ref() {
            os.write_string(35, &v)?;
        }
        if let Some(ref v) = self.actualSellerPrice.as_ref() {
            os.write_string(40, &v)?;
        }
        for v in &self.appBadge {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ownerBadge {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto {
        ExternalAssetProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ExternalAssetProto| { &m.id },
                |m: &mut ExternalAssetProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ExternalAssetProto| { &m.title },
                |m: &mut ExternalAssetProto| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assetType",
                |m: &ExternalAssetProto| { &m.assetType },
                |m: &mut ExternalAssetProto| { &mut m.assetType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &ExternalAssetProto| { &m.owner },
                |m: &mut ExternalAssetProto| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &ExternalAssetProto| { &m.version },
                |m: &mut ExternalAssetProto| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "price",
                |m: &ExternalAssetProto| { &m.price },
                |m: &mut ExternalAssetProto| { &mut m.price },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "averageRating",
                |m: &ExternalAssetProto| { &m.averageRating },
                |m: &mut ExternalAssetProto| { &mut m.averageRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numRatings",
                |m: &ExternalAssetProto| { &m.numRatings },
                |m: &mut ExternalAssetProto| { &mut m.numRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ownerId",
                |m: &ExternalAssetProto| { &m.ownerId },
                |m: &mut ExternalAssetProto| { &mut m.ownerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &ExternalAssetProto| { &m.packageName },
                |m: &mut ExternalAssetProto| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &ExternalAssetProto| { &m.versionCode },
                |m: &mut ExternalAssetProto| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bundledAsset",
                |m: &ExternalAssetProto| { &m.bundledAsset },
                |m: &mut ExternalAssetProto| { &mut m.bundledAsset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "priceCurrency",
                |m: &ExternalAssetProto| { &m.priceCurrency },
                |m: &mut ExternalAssetProto| { &mut m.priceCurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "priceMicros",
                |m: &ExternalAssetProto| { &m.priceMicros },
                |m: &mut ExternalAssetProto| { &mut m.priceMicros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filterReason",
                |m: &ExternalAssetProto| { &m.filterReason },
                |m: &mut ExternalAssetProto| { &mut m.filterReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actualSellerPrice",
                |m: &ExternalAssetProto| { &m.actualSellerPrice },
                |m: &mut ExternalAssetProto| { &mut m.actualSellerPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeProto>>(
                "appBadge",
                |m: &ExternalAssetProto| { &m.appBadge },
                |m: &mut ExternalAssetProto| { &mut m.appBadge },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeProto>>(
                "ownerBadge",
                |m: &ExternalAssetProto| { &m.ownerBadge },
                |m: &mut ExternalAssetProto| { &mut m.ownerBadge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalAssetProto>(
                "ExternalAssetProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto {
        static instance: ::protobuf::rt::LazyV2<ExternalAssetProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalAssetProto::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto {
    fn clear(&mut self) {
        self.id.clear();
        self.title.clear();
        self.assetType = ::std::option::Option::None;
        self.owner.clear();
        self.version.clear();
        self.price.clear();
        self.averageRating.clear();
        self.numRatings = ::std::option::Option::None;
        self.ownerId.clear();
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.bundledAsset = ::std::option::Option::None;
        self.priceCurrency.clear();
        self.priceMicros = ::std::option::Option::None;
        self.filterReason.clear();
        self.actualSellerPrice.clear();
        self.appBadge.clear();
        self.ownerBadge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalAssetProto_PurchaseInformation {
    // message fields
    pub purchaseTime: ::std::option::Option<i64>,
    pub refundTimeoutTime: ::std::option::Option<i64>,
    pub refundStartPolicy: ::std::option::Option<i32>,
    pub refundWindowDuration: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalAssetProto_PurchaseInformation {
    fn default() -> &'a ExternalAssetProto_PurchaseInformation {
        <ExternalAssetProto_PurchaseInformation as ::protobuf::Message>::default_instance()
    }
}

impl ExternalAssetProto_PurchaseInformation {
    pub fn new() -> ExternalAssetProto_PurchaseInformation {
        ::std::default::Default::default()
    }

    // optional int64 purchaseTime = 10;


    pub fn get_purchaseTime(&self) -> i64 {
        self.purchaseTime.unwrap_or(0)
    }

    // optional int64 refundTimeoutTime = 11;


    pub fn get_refundTimeoutTime(&self) -> i64 {
        self.refundTimeoutTime.unwrap_or(0)
    }

    // optional int32 refundStartPolicy = 45;


    pub fn get_refundStartPolicy(&self) -> i32 {
        self.refundStartPolicy.unwrap_or(0)
    }

    // optional int64 refundWindowDuration = 46;


    pub fn get_refundWindowDuration(&self) -> i64 {
        self.refundWindowDuration.unwrap_or(0)
    }
}

impl ::protobuf::Message for ExternalAssetProto_PurchaseInformation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.purchaseTime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTime = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.refundStartPolicy = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundWindowDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.purchaseTime {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundTimeoutTime {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundStartPolicy {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundWindowDuration {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.purchaseTime {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.refundTimeoutTime {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.refundStartPolicy {
            os.write_int32(45, v)?;
        }
        if let Some(v) = self.refundWindowDuration {
            os.write_int64(46, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto_PurchaseInformation {
        ExternalAssetProto_PurchaseInformation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "purchaseTime",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.purchaseTime },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.purchaseTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutTime",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundTimeoutTime },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundTimeoutTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "refundStartPolicy",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundStartPolicy },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundStartPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundWindowDuration",
                |m: &ExternalAssetProto_PurchaseInformation| { &m.refundWindowDuration },
                |m: &mut ExternalAssetProto_PurchaseInformation| { &mut m.refundWindowDuration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalAssetProto_PurchaseInformation>(
                "ExternalAssetProto.PurchaseInformation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto_PurchaseInformation {
        static instance: ::protobuf::rt::LazyV2<ExternalAssetProto_PurchaseInformation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalAssetProto_PurchaseInformation::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto_PurchaseInformation {
    fn clear(&mut self) {
        self.purchaseTime = ::std::option::Option::None;
        self.refundTimeoutTime = ::std::option::Option::None;
        self.refundStartPolicy = ::std::option::Option::None;
        self.refundWindowDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto_PurchaseInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto_PurchaseInformation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalAssetProto_ExtendedInfo {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub downloadCount: ::std::option::Option<i64>,
    pub applicationPermissionId: ::protobuf::RepeatedField<::std::string::String>,
    pub requiredInstallationSize: ::std::option::Option<i64>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub category: ::protobuf::SingularField<::std::string::String>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub contactEmail: ::protobuf::SingularField<::std::string::String>,
    pub everInstalledByUser: ::std::option::Option<bool>,
    pub downloadCountString: ::protobuf::SingularField<::std::string::String>,
    pub contactPhone: ::protobuf::SingularField<::std::string::String>,
    pub contactWebsite: ::protobuf::SingularField<::std::string::String>,
    pub nextPurchaseRefundable: ::std::option::Option<bool>,
    pub numScreenshots: ::std::option::Option<i32>,
    pub promotionalDescription: ::protobuf::SingularField<::std::string::String>,
    pub serverAssetState: ::std::option::Option<i32>,
    pub contentRatingLevel: ::std::option::Option<i32>,
    pub contentRatingString: ::protobuf::SingularField<::std::string::String>,
    pub recentChanges: ::protobuf::SingularField<::std::string::String>,
    // packagedependency: <group>
    pub videoLink: ::protobuf::SingularField<::std::string::String>,
    pub downloadInfo: ::protobuf::SingularPtrField<DownloadInfoProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalAssetProto_ExtendedInfo {
    fn default() -> &'a ExternalAssetProto_ExtendedInfo {
        <ExternalAssetProto_ExtendedInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExternalAssetProto_ExtendedInfo {
    pub fn new() -> ExternalAssetProto_ExtendedInfo {
        ::std::default::Default::default()
    }

    // optional string description = 13;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 downloadCount = 14;


    pub fn get_downloadCount(&self) -> i64 {
        self.downloadCount.unwrap_or(0)
    }

    // repeated string applicationPermissionId = 15;


    pub fn get_applicationPermissionId(&self) -> &[::std::string::String] {
        &self.applicationPermissionId
    }

    // optional int64 requiredInstallationSize = 16;


    pub fn get_requiredInstallationSize(&self) -> i64 {
        self.requiredInstallationSize.unwrap_or(0)
    }

    // optional string packageName = 17;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string category = 18;


    pub fn get_category(&self) -> &str {
        match self.category.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool forwardLocked = 19;


    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional string contactEmail = 20;


    pub fn get_contactEmail(&self) -> &str {
        match self.contactEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool everInstalledByUser = 21;


    pub fn get_everInstalledByUser(&self) -> bool {
        self.everInstalledByUser.unwrap_or(false)
    }

    // optional string downloadCountString = 23;


    pub fn get_downloadCountString(&self) -> &str {
        match self.downloadCountString.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contactPhone = 26;


    pub fn get_contactPhone(&self) -> &str {
        match self.contactPhone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contactWebsite = 27;


    pub fn get_contactWebsite(&self) -> &str {
        match self.contactWebsite.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool nextPurchaseRefundable = 28;


    pub fn get_nextPurchaseRefundable(&self) -> bool {
        self.nextPurchaseRefundable.unwrap_or(false)
    }

    // optional int32 numScreenshots = 30;


    pub fn get_numScreenshots(&self) -> i32 {
        self.numScreenshots.unwrap_or(0)
    }

    // optional string promotionalDescription = 31;


    pub fn get_promotionalDescription(&self) -> &str {
        match self.promotionalDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 serverAssetState = 34;


    pub fn get_serverAssetState(&self) -> i32 {
        self.serverAssetState.unwrap_or(0)
    }

    // optional int32 contentRatingLevel = 36;


    pub fn get_contentRatingLevel(&self) -> i32 {
        self.contentRatingLevel.unwrap_or(0)
    }

    // optional string contentRatingString = 37;


    pub fn get_contentRatingString(&self) -> &str {
        match self.contentRatingString.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string recentChanges = 38;


    pub fn get_recentChanges(&self) -> &str {
        match self.recentChanges.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string videoLink = 43;


    pub fn get_videoLink(&self) -> &str {
        match self.videoLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DownloadInfoProto downloadInfo = 49;


    pub fn get_downloadInfo(&self) -> &DownloadInfoProto {
        self.downloadInfo.as_ref().unwrap_or_else(|| <DownloadInfoProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ExternalAssetProto_ExtendedInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.downloadInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadCount = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.applicationPermissionId)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requiredInstallationSize = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactEmail)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.everInstalledByUser = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadCountString)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactPhone)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contactWebsite)?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nextPurchaseRefundable = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numScreenshots = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promotionalDescription)?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.serverAssetState = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRatingLevel = ::std::option::Option::Some(tmp);
                },
                37 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentRatingString)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChanges)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.videoLink)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downloadInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.downloadCount {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.applicationPermissionId {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.requiredInstallationSize {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.category.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.forwardLocked {
            my_size += 3;
        }
        if let Some(ref v) = self.contactEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.everInstalledByUser {
            my_size += 3;
        }
        if let Some(ref v) = self.downloadCountString.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(ref v) = self.contactPhone.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(ref v) = self.contactWebsite.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.nextPurchaseRefundable {
            my_size += 3;
        }
        if let Some(v) = self.numScreenshots {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.promotionalDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.serverAssetState {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contentRatingLevel {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.contentRatingString.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(ref v) = self.recentChanges.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(ref v) = self.videoLink.as_ref() {
            my_size += ::protobuf::rt::string_size(43, &v);
        }
        if let Some(ref v) = self.downloadInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.downloadCount {
            os.write_int64(14, v)?;
        }
        for v in &self.applicationPermissionId {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.requiredInstallationSize {
            os.write_int64(16, v)?;
        }
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.category.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.forwardLocked {
            os.write_bool(19, v)?;
        }
        if let Some(ref v) = self.contactEmail.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.everInstalledByUser {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.downloadCountString.as_ref() {
            os.write_string(23, &v)?;
        }
        if let Some(ref v) = self.contactPhone.as_ref() {
            os.write_string(26, &v)?;
        }
        if let Some(ref v) = self.contactWebsite.as_ref() {
            os.write_string(27, &v)?;
        }
        if let Some(v) = self.nextPurchaseRefundable {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.numScreenshots {
            os.write_int32(30, v)?;
        }
        if let Some(ref v) = self.promotionalDescription.as_ref() {
            os.write_string(31, &v)?;
        }
        if let Some(v) = self.serverAssetState {
            os.write_int32(34, v)?;
        }
        if let Some(v) = self.contentRatingLevel {
            os.write_int32(36, v)?;
        }
        if let Some(ref v) = self.contentRatingString.as_ref() {
            os.write_string(37, &v)?;
        }
        if let Some(ref v) = self.recentChanges.as_ref() {
            os.write_string(38, &v)?;
        }
        if let Some(ref v) = self.videoLink.as_ref() {
            os.write_string(43, &v)?;
        }
        if let Some(ref v) = self.downloadInfo.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalAssetProto_ExtendedInfo {
        ExternalAssetProto_ExtendedInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.description },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloadCount",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadCount },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "applicationPermissionId",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.applicationPermissionId },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.applicationPermissionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "requiredInstallationSize",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.requiredInstallationSize },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.requiredInstallationSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.packageName },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.category },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forwardLocked",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.forwardLocked },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.forwardLocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contactEmail",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactEmail },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "everInstalledByUser",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.everInstalledByUser },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.everInstalledByUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadCountString",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadCountString },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadCountString },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contactPhone",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactPhone },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactPhone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contactWebsite",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contactWebsite },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contactWebsite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "nextPurchaseRefundable",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.nextPurchaseRefundable },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.nextPurchaseRefundable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numScreenshots",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.numScreenshots },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.numScreenshots },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotionalDescription",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.promotionalDescription },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.promotionalDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "serverAssetState",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.serverAssetState },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.serverAssetState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "contentRatingLevel",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contentRatingLevel },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contentRatingLevel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentRatingString",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.contentRatingString },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.contentRatingString },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recentChanges",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.recentChanges },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.recentChanges },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "videoLink",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.videoLink },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.videoLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownloadInfoProto>>(
                "downloadInfo",
                |m: &ExternalAssetProto_ExtendedInfo| { &m.downloadInfo },
                |m: &mut ExternalAssetProto_ExtendedInfo| { &mut m.downloadInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalAssetProto_ExtendedInfo>(
                "ExternalAssetProto.ExtendedInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalAssetProto_ExtendedInfo {
        static instance: ::protobuf::rt::LazyV2<ExternalAssetProto_ExtendedInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalAssetProto_ExtendedInfo::new)
    }
}

impl ::protobuf::Clear for ExternalAssetProto_ExtendedInfo {
    fn clear(&mut self) {
        self.description.clear();
        self.downloadCount = ::std::option::Option::None;
        self.applicationPermissionId.clear();
        self.requiredInstallationSize = ::std::option::Option::None;
        self.packageName.clear();
        self.category.clear();
        self.forwardLocked = ::std::option::Option::None;
        self.contactEmail.clear();
        self.everInstalledByUser = ::std::option::Option::None;
        self.downloadCountString.clear();
        self.contactPhone.clear();
        self.contactWebsite.clear();
        self.nextPurchaseRefundable = ::std::option::Option::None;
        self.numScreenshots = ::std::option::Option::None;
        self.promotionalDescription.clear();
        self.serverAssetState = ::std::option::Option::None;
        self.contentRatingLevel = ::std::option::Option::None;
        self.contentRatingString.clear();
        self.recentChanges.clear();
        self.videoLink.clear();
        self.downloadInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalAssetProto_ExtendedInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAssetProto_ExtendedInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalBadgeImageProto {
    // message fields
    pub usage: ::std::option::Option<i32>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalBadgeImageProto {
    fn default() -> &'a ExternalBadgeImageProto {
        <ExternalBadgeImageProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalBadgeImageProto {
    pub fn new() -> ExternalBadgeImageProto {
        ::std::default::Default::default()
    }

    // optional int32 usage = 1;


    pub fn get_usage(&self) -> i32 {
        self.usage.unwrap_or(0)
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalBadgeImageProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.usage = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.usage {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.usage {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalBadgeImageProto {
        ExternalBadgeImageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "usage",
                |m: &ExternalBadgeImageProto| { &m.usage },
                |m: &mut ExternalBadgeImageProto| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ExternalBadgeImageProto| { &m.url },
                |m: &mut ExternalBadgeImageProto| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalBadgeImageProto>(
                "ExternalBadgeImageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalBadgeImageProto {
        static instance: ::protobuf::rt::LazyV2<ExternalBadgeImageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalBadgeImageProto::new)
    }
}

impl ::protobuf::Clear for ExternalBadgeImageProto {
    fn clear(&mut self) {
        self.usage = ::std::option::Option::None;
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalBadgeImageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBadgeImageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalBadgeProto {
    // message fields
    pub localizedTitle: ::protobuf::SingularField<::std::string::String>,
    pub localizedDescription: ::protobuf::SingularField<::std::string::String>,
    pub badgeImage: ::protobuf::RepeatedField<ExternalBadgeImageProto>,
    pub searchId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalBadgeProto {
    fn default() -> &'a ExternalBadgeProto {
        <ExternalBadgeProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalBadgeProto {
    pub fn new() -> ExternalBadgeProto {
        ::std::default::Default::default()
    }

    // optional string localizedTitle = 1;


    pub fn get_localizedTitle(&self) -> &str {
        match self.localizedTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string localizedDescription = 2;


    pub fn get_localizedDescription(&self) -> &str {
        match self.localizedDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ExternalBadgeImageProto badgeImage = 3;


    pub fn get_badgeImage(&self) -> &[ExternalBadgeImageProto] {
        &self.badgeImage
    }

    // optional string searchId = 4;


    pub fn get_searchId(&self) -> &str {
        match self.searchId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalBadgeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.badgeImage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedDescription)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badgeImage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localizedTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.localizedDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.badgeImage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.searchId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localizedTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.localizedDescription.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.badgeImage {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.searchId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalBadgeProto {
        ExternalBadgeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedTitle",
                |m: &ExternalBadgeProto| { &m.localizedTitle },
                |m: &mut ExternalBadgeProto| { &mut m.localizedTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedDescription",
                |m: &ExternalBadgeProto| { &m.localizedDescription },
                |m: &mut ExternalBadgeProto| { &mut m.localizedDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalBadgeImageProto>>(
                "badgeImage",
                |m: &ExternalBadgeProto| { &m.badgeImage },
                |m: &mut ExternalBadgeProto| { &mut m.badgeImage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searchId",
                |m: &ExternalBadgeProto| { &m.searchId },
                |m: &mut ExternalBadgeProto| { &mut m.searchId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalBadgeProto>(
                "ExternalBadgeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalBadgeProto {
        static instance: ::protobuf::rt::LazyV2<ExternalBadgeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalBadgeProto::new)
    }
}

impl ::protobuf::Clear for ExternalBadgeProto {
    fn clear(&mut self) {
        self.localizedTitle.clear();
        self.localizedDescription.clear();
        self.badgeImage.clear();
        self.searchId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalBadgeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBadgeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalCarrierBillingInstrumentProto {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub subscriberIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub accountType: ::protobuf::SingularField<::std::string::String>,
    pub subscriberCurrency: ::protobuf::SingularField<::std::string::String>,
    pub transactionLimit: ::std::option::Option<u64>,
    pub subscriberName: ::protobuf::SingularField<::std::string::String>,
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub country: ::protobuf::SingularField<::std::string::String>,
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalCarrierBillingInstrumentProto {
    fn default() -> &'a ExternalCarrierBillingInstrumentProto {
        <ExternalCarrierBillingInstrumentProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalCarrierBillingInstrumentProto {
    pub fn new() -> ExternalCarrierBillingInstrumentProto {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;


    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subscriberIdentifier = 2;


    pub fn get_subscriberIdentifier(&self) -> &str {
        match self.subscriberIdentifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string accountType = 3;


    pub fn get_accountType(&self) -> &str {
        match self.accountType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subscriberCurrency = 4;


    pub fn get_subscriberCurrency(&self) -> &str {
        match self.subscriberCurrency.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 transactionLimit = 5;


    pub fn get_transactionLimit(&self) -> u64 {
        self.transactionLimit.unwrap_or(0)
    }

    // optional string subscriberName = 6;


    pub fn get_subscriberName(&self) -> &str {
        match self.subscriberName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string address1 = 7;


    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string address2 = 8;


    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city = 9;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state = 10;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCode = 11;


    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string country = 12;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .EncryptedSubscriberInfo encryptedSubscriberInfo = 13;


    pub fn get_encryptedSubscriberInfo(&self) -> &EncryptedSubscriberInfo {
        self.encryptedSubscriberInfo.as_ref().unwrap_or_else(|| <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ExternalCarrierBillingInstrumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberIdentifier)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberCurrency)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.transactionLimit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberName)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.accountType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.subscriberCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.transactionLimit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscriberName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.accountType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.subscriberCurrency.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.transactionLimit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.subscriberName.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.address1.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.address2.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCarrierBillingInstrumentProto {
        ExternalCarrierBillingInstrumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentKey",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.instrumentKey },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.instrumentKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriberIdentifier",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberIdentifier },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberIdentifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountType",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.accountType },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.accountType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriberCurrency",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberCurrency },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberCurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "transactionLimit",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.transactionLimit },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.transactionLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriberName",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.subscriberName },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.subscriberName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address1",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.address1 },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.address1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address2",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.address2 },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.address2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.city },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.state },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCode",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.postalCode },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.postalCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.country },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>>(
                "encryptedSubscriberInfo",
                |m: &ExternalCarrierBillingInstrumentProto| { &m.encryptedSubscriberInfo },
                |m: &mut ExternalCarrierBillingInstrumentProto| { &mut m.encryptedSubscriberInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalCarrierBillingInstrumentProto>(
                "ExternalCarrierBillingInstrumentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCarrierBillingInstrumentProto {
        static instance: ::protobuf::rt::LazyV2<ExternalCarrierBillingInstrumentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalCarrierBillingInstrumentProto::new)
    }
}

impl ::protobuf::Clear for ExternalCarrierBillingInstrumentProto {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.subscriberIdentifier.clear();
        self.accountType.clear();
        self.subscriberCurrency.clear();
        self.transactionLimit = ::std::option::Option::None;
        self.subscriberName.clear();
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.country.clear();
        self.encryptedSubscriberInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCarrierBillingInstrumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCarrierBillingInstrumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalCommentProto {
    // message fields
    pub body: ::protobuf::SingularField<::std::string::String>,
    pub rating: ::std::option::Option<i32>,
    pub creatorName: ::protobuf::SingularField<::std::string::String>,
    pub creationTime: ::std::option::Option<i64>,
    pub creatorId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalCommentProto {
    fn default() -> &'a ExternalCommentProto {
        <ExternalCommentProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalCommentProto {
    pub fn new() -> ExternalCommentProto {
        ::std::default::Default::default()
    }

    // optional string body = 1;


    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 rating = 2;


    pub fn get_rating(&self) -> i32 {
        self.rating.unwrap_or(0)
    }

    // optional string creatorName = 3;


    pub fn get_creatorName(&self) -> &str {
        match self.creatorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 creationTime = 4;


    pub fn get_creationTime(&self) -> i64 {
        self.creationTime.unwrap_or(0)
    }

    // optional string creatorId = 5;


    pub fn get_creatorId(&self) -> &str {
        match self.creatorId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalCommentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rating = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creationTime = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rating {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.creatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.creationTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.creatorId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.rating {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.creatorName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.creationTime {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.creatorId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCommentProto {
        ExternalCommentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &ExternalCommentProto| { &m.body },
                |m: &mut ExternalCommentProto| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rating",
                |m: &ExternalCommentProto| { &m.rating },
                |m: &mut ExternalCommentProto| { &mut m.rating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creatorName",
                |m: &ExternalCommentProto| { &m.creatorName },
                |m: &mut ExternalCommentProto| { &mut m.creatorName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creationTime",
                |m: &ExternalCommentProto| { &m.creationTime },
                |m: &mut ExternalCommentProto| { &mut m.creationTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creatorId",
                |m: &ExternalCommentProto| { &m.creatorId },
                |m: &mut ExternalCommentProto| { &mut m.creatorId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalCommentProto>(
                "ExternalCommentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCommentProto {
        static instance: ::protobuf::rt::LazyV2<ExternalCommentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalCommentProto::new)
    }
}

impl ::protobuf::Clear for ExternalCommentProto {
    fn clear(&mut self) {
        self.body.clear();
        self.rating = ::std::option::Option::None;
        self.creatorName.clear();
        self.creationTime = ::std::option::Option::None;
        self.creatorId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCommentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCommentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalCreditCard {
    // message fields
    pub field_type: ::protobuf::SingularField<::std::string::String>,
    pub lastDigits: ::protobuf::SingularField<::std::string::String>,
    pub expYear: ::std::option::Option<i32>,
    pub expMonth: ::std::option::Option<i32>,
    pub personName: ::protobuf::SingularField<::std::string::String>,
    pub countryCode: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub makeDefault: ::std::option::Option<bool>,
    pub address1: ::protobuf::SingularField<::std::string::String>,
    pub address2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub phone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalCreditCard {
    fn default() -> &'a ExternalCreditCard {
        <ExternalCreditCard as ::protobuf::Message>::default_instance()
    }
}

impl ExternalCreditCard {
    pub fn new() -> ExternalCreditCard {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastDigits = 2;


    pub fn get_lastDigits(&self) -> &str {
        match self.lastDigits.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 expYear = 3;


    pub fn get_expYear(&self) -> i32 {
        self.expYear.unwrap_or(0)
    }

    // optional int32 expMonth = 4;


    pub fn get_expMonth(&self) -> i32 {
        self.expMonth.unwrap_or(0)
    }

    // optional string personName = 5;


    pub fn get_personName(&self) -> &str {
        match self.personName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string countryCode = 6;


    pub fn get_countryCode(&self) -> &str {
        match self.countryCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCode = 7;


    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool makeDefault = 8;


    pub fn get_makeDefault(&self) -> bool {
        self.makeDefault.unwrap_or(false)
    }

    // optional string address1 = 9;


    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string address2 = 10;


    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city = 11;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state = 12;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string phone = 13;


    pub fn get_phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExternalCreditCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastDigits)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expYear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expMonth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.personName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.countryCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.makeDefault = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expYear {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expMonth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.personName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.countryCode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.makeDefault {
            my_size += 2;
        }
        if let Some(ref v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.expYear {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.expMonth {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.personName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.countryCode.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.makeDefault {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.address1.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.address2.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.phone.as_ref() {
            os.write_string(13, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalCreditCard {
        ExternalCreditCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ExternalCreditCard| { &m.field_type },
                |m: &mut ExternalCreditCard| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastDigits",
                |m: &ExternalCreditCard| { &m.lastDigits },
                |m: &mut ExternalCreditCard| { &mut m.lastDigits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expYear",
                |m: &ExternalCreditCard| { &m.expYear },
                |m: &mut ExternalCreditCard| { &mut m.expYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expMonth",
                |m: &ExternalCreditCard| { &m.expMonth },
                |m: &mut ExternalCreditCard| { &mut m.expMonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "personName",
                |m: &ExternalCreditCard| { &m.personName },
                |m: &mut ExternalCreditCard| { &mut m.personName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "countryCode",
                |m: &ExternalCreditCard| { &m.countryCode },
                |m: &mut ExternalCreditCard| { &mut m.countryCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCode",
                |m: &ExternalCreditCard| { &m.postalCode },
                |m: &mut ExternalCreditCard| { &mut m.postalCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "makeDefault",
                |m: &ExternalCreditCard| { &m.makeDefault },
                |m: &mut ExternalCreditCard| { &mut m.makeDefault },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address1",
                |m: &ExternalCreditCard| { &m.address1 },
                |m: &mut ExternalCreditCard| { &mut m.address1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address2",
                |m: &ExternalCreditCard| { &m.address2 },
                |m: &mut ExternalCreditCard| { &mut m.address2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &ExternalCreditCard| { &m.city },
                |m: &mut ExternalCreditCard| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &ExternalCreditCard| { &m.state },
                |m: &mut ExternalCreditCard| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phone",
                |m: &ExternalCreditCard| { &m.phone },
                |m: &mut ExternalCreditCard| { &mut m.phone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalCreditCard>(
                "ExternalCreditCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalCreditCard {
        static instance: ::protobuf::rt::LazyV2<ExternalCreditCard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalCreditCard::new)
    }
}

impl ::protobuf::Clear for ExternalCreditCard {
    fn clear(&mut self) {
        self.field_type.clear();
        self.lastDigits.clear();
        self.expYear = ::std::option::Option::None;
        self.expMonth = ::std::option::Option::None;
        self.personName.clear();
        self.countryCode.clear();
        self.postalCode.clear();
        self.makeDefault = ::std::option::Option::None;
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.state.clear();
        self.phone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalCreditCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalCreditCard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ExternalPaypalInstrumentProto {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    pub paypalAddress: ::protobuf::SingularPtrField<AddressProto>,
    pub multiplePaypalInstrumentsSupported: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExternalPaypalInstrumentProto {
    fn default() -> &'a ExternalPaypalInstrumentProto {
        <ExternalPaypalInstrumentProto as ::protobuf::Message>::default_instance()
    }
}

impl ExternalPaypalInstrumentProto {
    pub fn new() -> ExternalPaypalInstrumentProto {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;


    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string preapprovalKey = 2;


    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string paypalEmail = 3;


    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AddressProto paypalAddress = 4;


    pub fn get_paypalAddress(&self) -> &AddressProto {
        self.paypalAddress.as_ref().unwrap_or_else(|| <AddressProto as ::protobuf::Message>::default_instance())
    }

    // optional bool multiplePaypalInstrumentsSupported = 5;


    pub fn get_multiplePaypalInstrumentsSupported(&self) -> bool {
        self.multiplePaypalInstrumentsSupported.unwrap_or(false)
    }
}

impl ::protobuf::Message for ExternalPaypalInstrumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.paypalAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalAddress)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiplePaypalInstrumentsSupported = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.paypalAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.multiplePaypalInstrumentsSupported {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.paypalAddress.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.multiplePaypalInstrumentsSupported {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExternalPaypalInstrumentProto {
        ExternalPaypalInstrumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentKey",
                |m: &ExternalPaypalInstrumentProto| { &m.instrumentKey },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.instrumentKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preapprovalKey",
                |m: &ExternalPaypalInstrumentProto| { &m.preapprovalKey },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.preapprovalKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paypalEmail",
                |m: &ExternalPaypalInstrumentProto| { &m.paypalEmail },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.paypalEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>>(
                "paypalAddress",
                |m: &ExternalPaypalInstrumentProto| { &m.paypalAddress },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.paypalAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "multiplePaypalInstrumentsSupported",
                |m: &ExternalPaypalInstrumentProto| { &m.multiplePaypalInstrumentsSupported },
                |m: &mut ExternalPaypalInstrumentProto| { &mut m.multiplePaypalInstrumentsSupported },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExternalPaypalInstrumentProto>(
                "ExternalPaypalInstrumentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExternalPaypalInstrumentProto {
        static instance: ::protobuf::rt::LazyV2<ExternalPaypalInstrumentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExternalPaypalInstrumentProto::new)
    }
}

impl ::protobuf::Clear for ExternalPaypalInstrumentProto {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.preapprovalKey.clear();
        self.paypalEmail.clear();
        self.paypalAddress.clear();
        self.multiplePaypalInstrumentsSupported = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExternalPaypalInstrumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalPaypalInstrumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FileMetadataProto {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileMetadataProto {
    fn default() -> &'a FileMetadataProto {
        <FileMetadataProto as ::protobuf::Message>::default_instance()
    }
}

impl FileMetadataProto {
    pub fn new() -> FileMetadataProto {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;


    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string downloadUrl = 4;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FileMetadataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileMetadataProto {
        FileMetadataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fileType",
                |m: &FileMetadataProto| { &m.fileType },
                |m: &mut FileMetadataProto| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &FileMetadataProto| { &m.versionCode },
                |m: &mut FileMetadataProto| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &FileMetadataProto| { &m.size },
                |m: &mut FileMetadataProto| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &FileMetadataProto| { &m.downloadUrl },
                |m: &mut FileMetadataProto| { &mut m.downloadUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileMetadataProto>(
                "FileMetadataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileMetadataProto {
        static instance: ::protobuf::rt::LazyV2<FileMetadataProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileMetadataProto::new)
    }
}

impl ::protobuf::Clear for FileMetadataProto {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.downloadUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileMetadataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileMetadataProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetAddressSnippetRequestProto {
    // message fields
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressSnippetRequestProto {
    fn default() -> &'a GetAddressSnippetRequestProto {
        <GetAddressSnippetRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressSnippetRequestProto {
    pub fn new() -> GetAddressSnippetRequestProto {
        ::std::default::Default::default()
    }

    // optional .EncryptedSubscriberInfo encryptedSubscriberInfo = 1;


    pub fn get_encryptedSubscriberInfo(&self) -> &EncryptedSubscriberInfo {
        self.encryptedSubscriberInfo.as_ref().unwrap_or_else(|| <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for GetAddressSnippetRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressSnippetRequestProto {
        GetAddressSnippetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>>(
                "encryptedSubscriberInfo",
                |m: &GetAddressSnippetRequestProto| { &m.encryptedSubscriberInfo },
                |m: &mut GetAddressSnippetRequestProto| { &mut m.encryptedSubscriberInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressSnippetRequestProto>(
                "GetAddressSnippetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressSnippetRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetAddressSnippetRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressSnippetRequestProto::new)
    }
}

impl ::protobuf::Clear for GetAddressSnippetRequestProto {
    fn clear(&mut self) {
        self.encryptedSubscriberInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressSnippetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressSnippetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetAddressSnippetResponseProto {
    // message fields
    pub addressSnippet: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressSnippetResponseProto {
    fn default() -> &'a GetAddressSnippetResponseProto {
        <GetAddressSnippetResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressSnippetResponseProto {
    pub fn new() -> GetAddressSnippetResponseProto {
        ::std::default::Default::default()
    }

    // optional string addressSnippet = 1;


    pub fn get_addressSnippet(&self) -> &str {
        match self.addressSnippet.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetAddressSnippetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressSnippet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addressSnippet.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addressSnippet.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressSnippetResponseProto {
        GetAddressSnippetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressSnippet",
                |m: &GetAddressSnippetResponseProto| { &m.addressSnippet },
                |m: &mut GetAddressSnippetResponseProto| { &mut m.addressSnippet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressSnippetResponseProto>(
                "GetAddressSnippetResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressSnippetResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetAddressSnippetResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressSnippetResponseProto::new)
    }
}

impl ::protobuf::Clear for GetAddressSnippetResponseProto {
    fn clear(&mut self) {
        self.addressSnippet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressSnippetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressSnippetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetAssetRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub directDownloadKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAssetRequestProto {
    fn default() -> &'a GetAssetRequestProto {
        <GetAssetRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAssetRequestProto {
    pub fn new() -> GetAssetRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string directDownloadKey = 2;


    pub fn get_directDownloadKey(&self) -> &str {
        match self.directDownloadKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetAssetRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directDownloadKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.directDownloadKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.directDownloadKey.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetRequestProto {
        GetAssetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &GetAssetRequestProto| { &m.assetId },
                |m: &mut GetAssetRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "directDownloadKey",
                |m: &GetAssetRequestProto| { &m.directDownloadKey },
                |m: &mut GetAssetRequestProto| { &mut m.directDownloadKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAssetRequestProto>(
                "GetAssetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetAssetRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAssetRequestProto::new)
    }
}

impl ::protobuf::Clear for GetAssetRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.directDownloadKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetAssetResponseProto {
    // message fields
    // installasset: <group>
    pub additionalFile: ::protobuf::RepeatedField<FileMetadataProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAssetResponseProto {
    fn default() -> &'a GetAssetResponseProto {
        <GetAssetResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAssetResponseProto {
    pub fn new() -> GetAssetResponseProto {
        ::std::default::Default::default()
    }

    // repeated .FileMetadataProto additionalFile = 15;


    pub fn get_additionalFile(&self) -> &[FileMetadataProto] {
        &self.additionalFile
    }
}

impl ::protobuf::Message for GetAssetResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additionalFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.additionalFile {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetResponseProto {
        GetAssetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadataProto>>(
                "additionalFile",
                |m: &GetAssetResponseProto| { &m.additionalFile },
                |m: &mut GetAssetResponseProto| { &mut m.additionalFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAssetResponseProto>(
                "GetAssetResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetAssetResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAssetResponseProto::new)
    }
}

impl ::protobuf::Clear for GetAssetResponseProto {
    fn clear(&mut self) {
        self.additionalFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetAssetResponseProto_InstallAsset {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub assetName: ::protobuf::SingularField<::std::string::String>,
    pub assetType: ::protobuf::SingularField<::std::string::String>,
    pub assetPackage: ::protobuf::SingularField<::std::string::String>,
    pub blobUrl: ::protobuf::SingularField<::std::string::String>,
    pub assetSignature: ::protobuf::SingularField<::std::string::String>,
    pub assetSize: ::std::option::Option<i64>,
    pub refundTimeoutMillis: ::std::option::Option<i64>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub secured: ::std::option::Option<bool>,
    pub versionCode: ::std::option::Option<i32>,
    pub downloadAuthCookieName: ::protobuf::SingularField<::std::string::String>,
    pub downloadAuthCookieValue: ::protobuf::SingularField<::std::string::String>,
    pub postInstallRefundWindowMillis: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAssetResponseProto_InstallAsset {
    fn default() -> &'a GetAssetResponseProto_InstallAsset {
        <GetAssetResponseProto_InstallAsset as ::protobuf::Message>::default_instance()
    }
}

impl GetAssetResponseProto_InstallAsset {
    pub fn new() -> GetAssetResponseProto_InstallAsset {
        ::std::default::Default::default()
    }

    // optional string assetId = 2;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetName = 3;


    pub fn get_assetName(&self) -> &str {
        match self.assetName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetType = 4;


    pub fn get_assetType(&self) -> &str {
        match self.assetType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetPackage = 5;


    pub fn get_assetPackage(&self) -> &str {
        match self.assetPackage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string blobUrl = 6;


    pub fn get_blobUrl(&self) -> &str {
        match self.blobUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetSignature = 7;


    pub fn get_assetSignature(&self) -> &str {
        match self.assetSignature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 assetSize = 8;


    pub fn get_assetSize(&self) -> i64 {
        self.assetSize.unwrap_or(0)
    }

    // optional int64 refundTimeoutMillis = 9;


    pub fn get_refundTimeoutMillis(&self) -> i64 {
        self.refundTimeoutMillis.unwrap_or(0)
    }

    // optional bool forwardLocked = 10;


    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional bool secured = 11;


    pub fn get_secured(&self) -> bool {
        self.secured.unwrap_or(false)
    }

    // optional int32 versionCode = 12;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string downloadAuthCookieName = 13;


    pub fn get_downloadAuthCookieName(&self) -> &str {
        match self.downloadAuthCookieName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadAuthCookieValue = 14;


    pub fn get_downloadAuthCookieValue(&self) -> &str {
        match self.downloadAuthCookieValue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 postInstallRefundWindowMillis = 16;


    pub fn get_postInstallRefundWindowMillis(&self) -> i64 {
        self.postInstallRefundWindowMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetAssetResponseProto_InstallAsset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetType)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetPackage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blobUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetSignature)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.assetSize = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutMillis = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secured = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadAuthCookieName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadAuthCookieValue)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postInstallRefundWindowMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.assetName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.assetType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.assetPackage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.blobUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.assetSignature.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.assetSize {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refundTimeoutMillis {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forwardLocked {
            my_size += 2;
        }
        if let Some(v) = self.secured {
            my_size += 2;
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadAuthCookieName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.downloadAuthCookieValue.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.assetName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.assetType.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.assetPackage.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.blobUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.assetSignature.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.assetSize {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.refundTimeoutMillis {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.forwardLocked {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.secured {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(12, v)?;
        }
        if let Some(ref v) = self.downloadAuthCookieName.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.downloadAuthCookieValue.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            os.write_int64(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssetResponseProto_InstallAsset {
        GetAssetResponseProto_InstallAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetId },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetName",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetName },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetType",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetType },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetPackage",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetPackage },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetPackage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blobUrl",
                |m: &GetAssetResponseProto_InstallAsset| { &m.blobUrl },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.blobUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetSignature",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetSignature },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "assetSize",
                |m: &GetAssetResponseProto_InstallAsset| { &m.assetSize },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.assetSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutMillis",
                |m: &GetAssetResponseProto_InstallAsset| { &m.refundTimeoutMillis },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.refundTimeoutMillis },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forwardLocked",
                |m: &GetAssetResponseProto_InstallAsset| { &m.forwardLocked },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.forwardLocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "secured",
                |m: &GetAssetResponseProto_InstallAsset| { &m.secured },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.secured },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &GetAssetResponseProto_InstallAsset| { &m.versionCode },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadAuthCookieName",
                |m: &GetAssetResponseProto_InstallAsset| { &m.downloadAuthCookieName },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.downloadAuthCookieName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadAuthCookieValue",
                |m: &GetAssetResponseProto_InstallAsset| { &m.downloadAuthCookieValue },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.downloadAuthCookieValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postInstallRefundWindowMillis",
                |m: &GetAssetResponseProto_InstallAsset| { &m.postInstallRefundWindowMillis },
                |m: &mut GetAssetResponseProto_InstallAsset| { &mut m.postInstallRefundWindowMillis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAssetResponseProto_InstallAsset>(
                "GetAssetResponseProto.InstallAsset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAssetResponseProto_InstallAsset {
        static instance: ::protobuf::rt::LazyV2<GetAssetResponseProto_InstallAsset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAssetResponseProto_InstallAsset::new)
    }
}

impl ::protobuf::Clear for GetAssetResponseProto_InstallAsset {
    fn clear(&mut self) {
        self.assetId.clear();
        self.assetName.clear();
        self.assetType.clear();
        self.assetPackage.clear();
        self.blobUrl.clear();
        self.assetSignature.clear();
        self.assetSize = ::std::option::Option::None;
        self.refundTimeoutMillis = ::std::option::Option::None;
        self.forwardLocked = ::std::option::Option::None;
        self.secured = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.downloadAuthCookieName.clear();
        self.downloadAuthCookieValue.clear();
        self.postInstallRefundWindowMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAssetResponseProto_InstallAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssetResponseProto_InstallAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetCarrierInfoRequestProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCarrierInfoRequestProto {
    fn default() -> &'a GetCarrierInfoRequestProto {
        <GetCarrierInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCarrierInfoRequestProto {
    pub fn new() -> GetCarrierInfoRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCarrierInfoRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCarrierInfoRequestProto {
        GetCarrierInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCarrierInfoRequestProto>(
                "GetCarrierInfoRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCarrierInfoRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetCarrierInfoRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCarrierInfoRequestProto::new)
    }
}

impl ::protobuf::Clear for GetCarrierInfoRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCarrierInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCarrierInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetCarrierInfoResponseProto {
    // message fields
    pub carrierChannelEnabled: ::std::option::Option<bool>,
    pub carrierLogoIcon: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub carrierBanner: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub carrierSubtitle: ::protobuf::SingularField<::std::string::String>,
    pub carrierTitle: ::protobuf::SingularField<::std::string::String>,
    pub carrierImageDensity: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCarrierInfoResponseProto {
    fn default() -> &'a GetCarrierInfoResponseProto {
        <GetCarrierInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCarrierInfoResponseProto {
    pub fn new() -> GetCarrierInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional bool carrierChannelEnabled = 1;


    pub fn get_carrierChannelEnabled(&self) -> bool {
        self.carrierChannelEnabled.unwrap_or(false)
    }

    // optional bytes carrierLogoIcon = 2;


    pub fn get_carrierLogoIcon(&self) -> &[u8] {
        match self.carrierLogoIcon.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes carrierBanner = 3;


    pub fn get_carrierBanner(&self) -> &[u8] {
        match self.carrierBanner.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string carrierSubtitle = 4;


    pub fn get_carrierSubtitle(&self) -> &str {
        match self.carrierSubtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string carrierTitle = 5;


    pub fn get_carrierTitle(&self) -> &str {
        match self.carrierTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 carrierImageDensity = 6;


    pub fn get_carrierImageDensity(&self) -> i32 {
        self.carrierImageDensity.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetCarrierInfoResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.carrierChannelEnabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.carrierLogoIcon)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.carrierBanner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierSubtitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrierTitle)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.carrierImageDensity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.carrierChannelEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.carrierLogoIcon.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.carrierBanner.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.carrierSubtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.carrierTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.carrierImageDensity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.carrierChannelEnabled {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.carrierLogoIcon.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.carrierBanner.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.carrierSubtitle.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.carrierTitle.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.carrierImageDensity {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCarrierInfoResponseProto {
        GetCarrierInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "carrierChannelEnabled",
                |m: &GetCarrierInfoResponseProto| { &m.carrierChannelEnabled },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierChannelEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "carrierLogoIcon",
                |m: &GetCarrierInfoResponseProto| { &m.carrierLogoIcon },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierLogoIcon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "carrierBanner",
                |m: &GetCarrierInfoResponseProto| { &m.carrierBanner },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierBanner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "carrierSubtitle",
                |m: &GetCarrierInfoResponseProto| { &m.carrierSubtitle },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierSubtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "carrierTitle",
                |m: &GetCarrierInfoResponseProto| { &m.carrierTitle },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "carrierImageDensity",
                |m: &GetCarrierInfoResponseProto| { &m.carrierImageDensity },
                |m: &mut GetCarrierInfoResponseProto| { &mut m.carrierImageDensity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCarrierInfoResponseProto>(
                "GetCarrierInfoResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCarrierInfoResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetCarrierInfoResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCarrierInfoResponseProto::new)
    }
}

impl ::protobuf::Clear for GetCarrierInfoResponseProto {
    fn clear(&mut self) {
        self.carrierChannelEnabled = ::std::option::Option::None;
        self.carrierLogoIcon.clear();
        self.carrierBanner.clear();
        self.carrierSubtitle.clear();
        self.carrierTitle.clear();
        self.carrierImageDensity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCarrierInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCarrierInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetCategoriesRequestProto {
    // message fields
    pub prefetchPromoData: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCategoriesRequestProto {
    fn default() -> &'a GetCategoriesRequestProto {
        <GetCategoriesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCategoriesRequestProto {
    pub fn new() -> GetCategoriesRequestProto {
        ::std::default::Default::default()
    }

    // optional bool prefetchPromoData = 1;


    pub fn get_prefetchPromoData(&self) -> bool {
        self.prefetchPromoData.unwrap_or(false)
    }
}

impl ::protobuf::Message for GetCategoriesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefetchPromoData = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prefetchPromoData {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prefetchPromoData {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCategoriesRequestProto {
        GetCategoriesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prefetchPromoData",
                |m: &GetCategoriesRequestProto| { &m.prefetchPromoData },
                |m: &mut GetCategoriesRequestProto| { &mut m.prefetchPromoData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCategoriesRequestProto>(
                "GetCategoriesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCategoriesRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetCategoriesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCategoriesRequestProto::new)
    }
}

impl ::protobuf::Clear for GetCategoriesRequestProto {
    fn clear(&mut self) {
        self.prefetchPromoData = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCategoriesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCategoriesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetCategoriesResponseProto {
    // message fields
    pub categories: ::protobuf::RepeatedField<CategoryProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCategoriesResponseProto {
    fn default() -> &'a GetCategoriesResponseProto {
        <GetCategoriesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCategoriesResponseProto {
    pub fn new() -> GetCategoriesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .CategoryProto categories = 1;


    pub fn get_categories(&self) -> &[CategoryProto] {
        &self.categories
    }
}

impl ::protobuf::Message for GetCategoriesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.categories {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCategoriesResponseProto {
        GetCategoriesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryProto>>(
                "categories",
                |m: &GetCategoriesResponseProto| { &m.categories },
                |m: &mut GetCategoriesResponseProto| { &mut m.categories },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCategoriesResponseProto>(
                "GetCategoriesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCategoriesResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetCategoriesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCategoriesResponseProto::new)
    }
}

impl ::protobuf::Clear for GetCategoriesResponseProto {
    fn clear(&mut self) {
        self.categories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCategoriesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCategoriesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetImageRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub imageUsage: ::std::option::Option<i32>,
    pub imageId: ::protobuf::SingularField<::std::string::String>,
    pub screenPropertyWidth: ::std::option::Option<i32>,
    pub screenPropertyHeight: ::std::option::Option<i32>,
    pub screenPropertyDensity: ::std::option::Option<i32>,
    pub productType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetImageRequestProto {
    fn default() -> &'a GetImageRequestProto {
        <GetImageRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetImageRequestProto {
    pub fn new() -> GetImageRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 imageUsage = 3;


    pub fn get_imageUsage(&self) -> i32 {
        self.imageUsage.unwrap_or(0)
    }

    // optional string imageId = 4;


    pub fn get_imageId(&self) -> &str {
        match self.imageId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 screenPropertyWidth = 5;


    pub fn get_screenPropertyWidth(&self) -> i32 {
        self.screenPropertyWidth.unwrap_or(0)
    }

    // optional int32 screenPropertyHeight = 6;


    pub fn get_screenPropertyHeight(&self) -> i32 {
        self.screenPropertyHeight.unwrap_or(0)
    }

    // optional int32 screenPropertyDensity = 7;


    pub fn get_screenPropertyDensity(&self) -> i32 {
        self.screenPropertyDensity.unwrap_or(0)
    }

    // optional int32 productType = 8;


    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetImageRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageUsage = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyWidth = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyHeight = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenPropertyDensity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.imageUsage {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.imageId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.screenPropertyWidth {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenPropertyHeight {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenPropertyDensity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.imageUsage {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.imageId.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.screenPropertyWidth {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.screenPropertyHeight {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.screenPropertyDensity {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetImageRequestProto {
        GetImageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &GetImageRequestProto| { &m.assetId },
                |m: &mut GetImageRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "imageUsage",
                |m: &GetImageRequestProto| { &m.imageUsage },
                |m: &mut GetImageRequestProto| { &mut m.imageUsage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imageId",
                |m: &GetImageRequestProto| { &m.imageId },
                |m: &mut GetImageRequestProto| { &mut m.imageId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenPropertyWidth",
                |m: &GetImageRequestProto| { &m.screenPropertyWidth },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyWidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenPropertyHeight",
                |m: &GetImageRequestProto| { &m.screenPropertyHeight },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyHeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenPropertyDensity",
                |m: &GetImageRequestProto| { &m.screenPropertyDensity },
                |m: &mut GetImageRequestProto| { &mut m.screenPropertyDensity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "productType",
                |m: &GetImageRequestProto| { &m.productType },
                |m: &mut GetImageRequestProto| { &mut m.productType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetImageRequestProto>(
                "GetImageRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetImageRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetImageRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetImageRequestProto::new)
    }
}

impl ::protobuf::Clear for GetImageRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.imageUsage = ::std::option::Option::None;
        self.imageId.clear();
        self.screenPropertyWidth = ::std::option::Option::None;
        self.screenPropertyHeight = ::std::option::Option::None;
        self.screenPropertyDensity = ::std::option::Option::None;
        self.productType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetImageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetImageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetImageResponseProto {
    // message fields
    pub imageData: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub imageDensity: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetImageResponseProto {
    fn default() -> &'a GetImageResponseProto {
        <GetImageResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetImageResponseProto {
    pub fn new() -> GetImageResponseProto {
        ::std::default::Default::default()
    }

    // optional bytes imageData = 1;


    pub fn get_imageData(&self) -> &[u8] {
        match self.imageData.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 imageDensity = 2;


    pub fn get_imageDensity(&self) -> i32 {
        self.imageDensity.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetImageResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.imageData)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageDensity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.imageData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.imageDensity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.imageData.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.imageDensity {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetImageResponseProto {
        GetImageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "imageData",
                |m: &GetImageResponseProto| { &m.imageData },
                |m: &mut GetImageResponseProto| { &mut m.imageData },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "imageDensity",
                |m: &GetImageResponseProto| { &m.imageDensity },
                |m: &mut GetImageResponseProto| { &mut m.imageDensity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetImageResponseProto>(
                "GetImageResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetImageResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetImageResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetImageResponseProto::new)
    }
}

impl ::protobuf::Clear for GetImageResponseProto {
    fn clear(&mut self) {
        self.imageData.clear();
        self.imageDensity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetImageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetImageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetMarketMetadataRequestProto {
    // message fields
    pub lastRequestTime: ::std::option::Option<i64>,
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub deviceRoaming: ::std::option::Option<bool>,
    pub marketSignatureHash: ::protobuf::RepeatedField<::std::string::String>,
    pub contentRating: ::std::option::Option<i32>,
    pub deviceModelName: ::protobuf::SingularField<::std::string::String>,
    pub deviceManufacturerName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMarketMetadataRequestProto {
    fn default() -> &'a GetMarketMetadataRequestProto {
        <GetMarketMetadataRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetMarketMetadataRequestProto {
    pub fn new() -> GetMarketMetadataRequestProto {
        ::std::default::Default::default()
    }

    // optional int64 lastRequestTime = 1;


    pub fn get_lastRequestTime(&self) -> i64 {
        self.lastRequestTime.unwrap_or(0)
    }

    // optional .DeviceConfigurationProto deviceConfiguration = 2;


    pub fn get_deviceConfiguration(&self) -> &DeviceConfigurationProto {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfigurationProto as ::protobuf::Message>::default_instance())
    }

    // optional bool deviceRoaming = 3;


    pub fn get_deviceRoaming(&self) -> bool {
        self.deviceRoaming.unwrap_or(false)
    }

    // repeated string marketSignatureHash = 4;


    pub fn get_marketSignatureHash(&self) -> &[::std::string::String] {
        &self.marketSignatureHash
    }

    // optional int32 contentRating = 5;


    pub fn get_contentRating(&self) -> i32 {
        self.contentRating.unwrap_or(0)
    }

    // optional string deviceModelName = 6;


    pub fn get_deviceModelName(&self) -> &str {
        match self.deviceModelName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deviceManufacturerName = 7;


    pub fn get_deviceManufacturerName(&self) -> &str {
        match self.deviceManufacturerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetMarketMetadataRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastRequestTime = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceConfiguration)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deviceRoaming = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.marketSignatureHash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRating = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceModelName)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceManufacturerName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastRequestTime {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deviceRoaming {
            my_size += 2;
        }
        for value in &self.marketSignatureHash {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.contentRating {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.deviceModelName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.deviceManufacturerName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastRequestTime {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deviceRoaming {
            os.write_bool(3, v)?;
        }
        for v in &self.marketSignatureHash {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.contentRating {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.deviceModelName.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.deviceManufacturerName.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMarketMetadataRequestProto {
        GetMarketMetadataRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastRequestTime",
                |m: &GetMarketMetadataRequestProto| { &m.lastRequestTime },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.lastRequestTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>>(
                "deviceConfiguration",
                |m: &GetMarketMetadataRequestProto| { &m.deviceConfiguration },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deviceRoaming",
                |m: &GetMarketMetadataRequestProto| { &m.deviceRoaming },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceRoaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "marketSignatureHash",
                |m: &GetMarketMetadataRequestProto| { &m.marketSignatureHash },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.marketSignatureHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "contentRating",
                |m: &GetMarketMetadataRequestProto| { &m.contentRating },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.contentRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceModelName",
                |m: &GetMarketMetadataRequestProto| { &m.deviceModelName },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceModelName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceManufacturerName",
                |m: &GetMarketMetadataRequestProto| { &m.deviceManufacturerName },
                |m: &mut GetMarketMetadataRequestProto| { &mut m.deviceManufacturerName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMarketMetadataRequestProto>(
                "GetMarketMetadataRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMarketMetadataRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetMarketMetadataRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMarketMetadataRequestProto::new)
    }
}

impl ::protobuf::Clear for GetMarketMetadataRequestProto {
    fn clear(&mut self) {
        self.lastRequestTime = ::std::option::Option::None;
        self.deviceConfiguration.clear();
        self.deviceRoaming = ::std::option::Option::None;
        self.marketSignatureHash.clear();
        self.contentRating = ::std::option::Option::None;
        self.deviceModelName.clear();
        self.deviceManufacturerName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMarketMetadataRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMarketMetadataRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetMarketMetadataResponseProto {
    // message fields
    pub latestClientVersionCode: ::std::option::Option<i32>,
    pub latestClientUrl: ::protobuf::SingularField<::std::string::String>,
    pub paidAppsEnabled: ::std::option::Option<bool>,
    pub billingParameter: ::protobuf::RepeatedField<BillingParameterProto>,
    pub commentPostEnabled: ::std::option::Option<bool>,
    pub billingEventsEnabled: ::std::option::Option<bool>,
    pub warningMessage: ::protobuf::SingularField<::std::string::String>,
    pub inAppBillingEnabled: ::std::option::Option<bool>,
    pub inAppBillingMaxApiVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMarketMetadataResponseProto {
    fn default() -> &'a GetMarketMetadataResponseProto {
        <GetMarketMetadataResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetMarketMetadataResponseProto {
    pub fn new() -> GetMarketMetadataResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 latestClientVersionCode = 1;


    pub fn get_latestClientVersionCode(&self) -> i32 {
        self.latestClientVersionCode.unwrap_or(0)
    }

    // optional string latestClientUrl = 2;


    pub fn get_latestClientUrl(&self) -> &str {
        match self.latestClientUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool paidAppsEnabled = 3;


    pub fn get_paidAppsEnabled(&self) -> bool {
        self.paidAppsEnabled.unwrap_or(false)
    }

    // repeated .BillingParameterProto billingParameter = 4;


    pub fn get_billingParameter(&self) -> &[BillingParameterProto] {
        &self.billingParameter
    }

    // optional bool commentPostEnabled = 5;


    pub fn get_commentPostEnabled(&self) -> bool {
        self.commentPostEnabled.unwrap_or(false)
    }

    // optional bool billingEventsEnabled = 6;


    pub fn get_billingEventsEnabled(&self) -> bool {
        self.billingEventsEnabled.unwrap_or(false)
    }

    // optional string warningMessage = 7;


    pub fn get_warningMessage(&self) -> &str {
        match self.warningMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool inAppBillingEnabled = 8;


    pub fn get_inAppBillingEnabled(&self) -> bool {
        self.inAppBillingEnabled.unwrap_or(false)
    }

    // optional int32 inAppBillingMaxApiVersion = 9;


    pub fn get_inAppBillingMaxApiVersion(&self) -> i32 {
        self.inAppBillingMaxApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetMarketMetadataResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.billingParameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latestClientVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.latestClientUrl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.paidAppsEnabled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.billingParameter)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.commentPostEnabled = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.billingEventsEnabled = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.warningMessage)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inAppBillingEnabled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inAppBillingMaxApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latestClientVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.latestClientUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.paidAppsEnabled {
            my_size += 2;
        }
        for value in &self.billingParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.commentPostEnabled {
            my_size += 2;
        }
        if let Some(v) = self.billingEventsEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.inAppBillingEnabled {
            my_size += 2;
        }
        if let Some(v) = self.inAppBillingMaxApiVersion {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latestClientVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.latestClientUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.paidAppsEnabled {
            os.write_bool(3, v)?;
        }
        for v in &self.billingParameter {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.commentPostEnabled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.billingEventsEnabled {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.inAppBillingEnabled {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.inAppBillingMaxApiVersion {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMarketMetadataResponseProto {
        GetMarketMetadataResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "latestClientVersionCode",
                |m: &GetMarketMetadataResponseProto| { &m.latestClientVersionCode },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.latestClientVersionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "latestClientUrl",
                |m: &GetMarketMetadataResponseProto| { &m.latestClientUrl },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.latestClientUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "paidAppsEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.paidAppsEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.paidAppsEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingParameterProto>>(
                "billingParameter",
                |m: &GetMarketMetadataResponseProto| { &m.billingParameter },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.billingParameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "commentPostEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.commentPostEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.commentPostEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "billingEventsEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.billingEventsEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.billingEventsEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "warningMessage",
                |m: &GetMarketMetadataResponseProto| { &m.warningMessage },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.warningMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inAppBillingEnabled",
                |m: &GetMarketMetadataResponseProto| { &m.inAppBillingEnabled },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.inAppBillingEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "inAppBillingMaxApiVersion",
                |m: &GetMarketMetadataResponseProto| { &m.inAppBillingMaxApiVersion },
                |m: &mut GetMarketMetadataResponseProto| { &mut m.inAppBillingMaxApiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetMarketMetadataResponseProto>(
                "GetMarketMetadataResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetMarketMetadataResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetMarketMetadataResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetMarketMetadataResponseProto::new)
    }
}

impl ::protobuf::Clear for GetMarketMetadataResponseProto {
    fn clear(&mut self) {
        self.latestClientVersionCode = ::std::option::Option::None;
        self.latestClientUrl.clear();
        self.paidAppsEnabled = ::std::option::Option::None;
        self.billingParameter.clear();
        self.commentPostEnabled = ::std::option::Option::None;
        self.billingEventsEnabled = ::std::option::Option::None;
        self.warningMessage.clear();
        self.inAppBillingEnabled = ::std::option::Option::None;
        self.inAppBillingMaxApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMarketMetadataResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMarketMetadataResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetSubCategoriesRequestProto {
    // message fields
    pub assetType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSubCategoriesRequestProto {
    fn default() -> &'a GetSubCategoriesRequestProto {
        <GetSubCategoriesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSubCategoriesRequestProto {
    pub fn new() -> GetSubCategoriesRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 assetType = 1;


    pub fn get_assetType(&self) -> i32 {
        self.assetType.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetSubCategoriesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.assetType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.assetType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.assetType {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesRequestProto {
        GetSubCategoriesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "assetType",
                |m: &GetSubCategoriesRequestProto| { &m.assetType },
                |m: &mut GetSubCategoriesRequestProto| { &mut m.assetType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSubCategoriesRequestProto>(
                "GetSubCategoriesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetSubCategoriesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSubCategoriesRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesRequestProto {
    fn clear(&mut self) {
        self.assetType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetSubCategoriesResponseProto {
    // message fields
    // subcategory: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSubCategoriesResponseProto {
    fn default() -> &'a GetSubCategoriesResponseProto {
        <GetSubCategoriesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSubCategoriesResponseProto {
    pub fn new() -> GetSubCategoriesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSubCategoriesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesResponseProto {
        GetSubCategoriesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSubCategoriesResponseProto>(
                "GetSubCategoriesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetSubCategoriesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSubCategoriesResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetSubCategoriesResponseProto_SubCategory {
    // message fields
    pub subCategoryDisplay: ::protobuf::SingularField<::std::string::String>,
    pub subCategoryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSubCategoriesResponseProto_SubCategory {
    fn default() -> &'a GetSubCategoriesResponseProto_SubCategory {
        <GetSubCategoriesResponseProto_SubCategory as ::protobuf::Message>::default_instance()
    }
}

impl GetSubCategoriesResponseProto_SubCategory {
    pub fn new() -> GetSubCategoriesResponseProto_SubCategory {
        ::std::default::Default::default()
    }

    // optional string subCategoryDisplay = 2;


    pub fn get_subCategoryDisplay(&self) -> &str {
        match self.subCategoryDisplay.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subCategoryId = 3;


    pub fn get_subCategoryId(&self) -> &str {
        match self.subCategoryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for GetSubCategoriesResponseProto_SubCategory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subCategoryDisplay)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subCategoryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subCategoryDisplay.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.subCategoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subCategoryDisplay.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.subCategoryId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubCategoriesResponseProto_SubCategory {
        GetSubCategoriesResponseProto_SubCategory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subCategoryDisplay",
                |m: &GetSubCategoriesResponseProto_SubCategory| { &m.subCategoryDisplay },
                |m: &mut GetSubCategoriesResponseProto_SubCategory| { &mut m.subCategoryDisplay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subCategoryId",
                |m: &GetSubCategoriesResponseProto_SubCategory| { &m.subCategoryId },
                |m: &mut GetSubCategoriesResponseProto_SubCategory| { &mut m.subCategoryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSubCategoriesResponseProto_SubCategory>(
                "GetSubCategoriesResponseProto.SubCategory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSubCategoriesResponseProto_SubCategory {
        static instance: ::protobuf::rt::LazyV2<GetSubCategoriesResponseProto_SubCategory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSubCategoriesResponseProto_SubCategory::new)
    }
}

impl ::protobuf::Clear for GetSubCategoriesResponseProto_SubCategory {
    fn clear(&mut self) {
        self.subCategoryDisplay.clear();
        self.subCategoryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubCategoriesResponseProto_SubCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubCategoriesResponseProto_SubCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppPurchaseInformationRequestProto {
    // message fields
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nonce: ::std::option::Option<i64>,
    pub notificationId: ::protobuf::RepeatedField<::std::string::String>,
    pub signatureAlgorithm: ::protobuf::SingularField<::std::string::String>,
    pub billingApiVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppPurchaseInformationRequestProto {
    fn default() -> &'a InAppPurchaseInformationRequestProto {
        <InAppPurchaseInformationRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl InAppPurchaseInformationRequestProto {
    pub fn new() -> InAppPurchaseInformationRequestProto {
        ::std::default::Default::default()
    }

    // optional .SignatureHashProto signatureHash = 1;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }

    // optional int64 nonce = 2;


    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }

    // repeated string notificationId = 3;


    pub fn get_notificationId(&self) -> &[::std::string::String] {
        &self.notificationId
    }

    // optional string signatureAlgorithm = 4;


    pub fn get_signatureAlgorithm(&self) -> &str {
        match self.signatureAlgorithm.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 billingApiVersion = 5;


    pub fn get_billingApiVersion(&self) -> i32 {
        self.billingApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InAppPurchaseInformationRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.notificationId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signatureAlgorithm)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.notificationId {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.signatureAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.billingApiVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(2, v)?;
        }
        for v in &self.notificationId {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.signatureAlgorithm.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.billingApiVersion {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppPurchaseInformationRequestProto {
        InAppPurchaseInformationRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &InAppPurchaseInformationRequestProto| { &m.signatureHash },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &InAppPurchaseInformationRequestProto| { &m.nonce },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &InAppPurchaseInformationRequestProto| { &m.notificationId },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signatureAlgorithm",
                |m: &InAppPurchaseInformationRequestProto| { &m.signatureAlgorithm },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.signatureAlgorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingApiVersion",
                |m: &InAppPurchaseInformationRequestProto| { &m.billingApiVersion },
                |m: &mut InAppPurchaseInformationRequestProto| { &mut m.billingApiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppPurchaseInformationRequestProto>(
                "InAppPurchaseInformationRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppPurchaseInformationRequestProto {
        static instance: ::protobuf::rt::LazyV2<InAppPurchaseInformationRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppPurchaseInformationRequestProto::new)
    }
}

impl ::protobuf::Clear for InAppPurchaseInformationRequestProto {
    fn clear(&mut self) {
        self.signatureHash.clear();
        self.nonce = ::std::option::Option::None;
        self.notificationId.clear();
        self.signatureAlgorithm.clear();
        self.billingApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppPurchaseInformationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppPurchaseInformationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppPurchaseInformationResponseProto {
    // message fields
    pub signedResponse: ::protobuf::SingularPtrField<SignedDataProto>,
    pub statusBarNotification: ::protobuf::RepeatedField<StatusBarNotificationProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppPurchaseInformationResponseProto {
    fn default() -> &'a InAppPurchaseInformationResponseProto {
        <InAppPurchaseInformationResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl InAppPurchaseInformationResponseProto {
    pub fn new() -> InAppPurchaseInformationResponseProto {
        ::std::default::Default::default()
    }

    // optional .SignedDataProto signedResponse = 1;


    pub fn get_signedResponse(&self) -> &SignedDataProto {
        self.signedResponse.as_ref().unwrap_or_else(|| <SignedDataProto as ::protobuf::Message>::default_instance())
    }

    // repeated .StatusBarNotificationProto statusBarNotification = 2;


    pub fn get_statusBarNotification(&self) -> &[StatusBarNotificationProto] {
        &self.statusBarNotification
    }

    // optional .PurchaseResultProto purchaseResult = 3;


    pub fn get_purchaseResult(&self) -> &PurchaseResultProto {
        self.purchaseResult.as_ref().unwrap_or_else(|| <PurchaseResultProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for InAppPurchaseInformationResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signedResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusBarNotification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signedResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statusBarNotification)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statusBarNotification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statusBarNotification {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.purchaseResult.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppPurchaseInformationResponseProto {
        InAppPurchaseInformationResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedDataProto>>(
                "signedResponse",
                |m: &InAppPurchaseInformationResponseProto| { &m.signedResponse },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.signedResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusBarNotificationProto>>(
                "statusBarNotification",
                |m: &InAppPurchaseInformationResponseProto| { &m.statusBarNotification },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.statusBarNotification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>>(
                "purchaseResult",
                |m: &InAppPurchaseInformationResponseProto| { &m.purchaseResult },
                |m: &mut InAppPurchaseInformationResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppPurchaseInformationResponseProto>(
                "InAppPurchaseInformationResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppPurchaseInformationResponseProto {
        static instance: ::protobuf::rt::LazyV2<InAppPurchaseInformationResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppPurchaseInformationResponseProto::new)
    }
}

impl ::protobuf::Clear for InAppPurchaseInformationResponseProto {
    fn clear(&mut self) {
        self.signedResponse.clear();
        self.statusBarNotification.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppPurchaseInformationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppPurchaseInformationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppRestoreTransactionsRequestProto {
    // message fields
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub nonce: ::std::option::Option<i64>,
    pub signatureAlgorithm: ::protobuf::SingularField<::std::string::String>,
    pub billingApiVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppRestoreTransactionsRequestProto {
    fn default() -> &'a InAppRestoreTransactionsRequestProto {
        <InAppRestoreTransactionsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl InAppRestoreTransactionsRequestProto {
    pub fn new() -> InAppRestoreTransactionsRequestProto {
        ::std::default::Default::default()
    }

    // optional .SignatureHashProto signatureHash = 1;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }

    // optional int64 nonce = 2;


    pub fn get_nonce(&self) -> i64 {
        self.nonce.unwrap_or(0)
    }

    // optional string signatureAlgorithm = 3;


    pub fn get_signatureAlgorithm(&self) -> &str {
        match self.signatureAlgorithm.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 billingApiVersion = 4;


    pub fn get_billingApiVersion(&self) -> i32 {
        self.billingApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for InAppRestoreTransactionsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nonce = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signatureAlgorithm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonce {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signatureAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.billingApiVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nonce {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.signatureAlgorithm.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.billingApiVersion {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppRestoreTransactionsRequestProto {
        InAppRestoreTransactionsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &InAppRestoreTransactionsRequestProto| { &m.signatureHash },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nonce",
                |m: &InAppRestoreTransactionsRequestProto| { &m.nonce },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signatureAlgorithm",
                |m: &InAppRestoreTransactionsRequestProto| { &m.signatureAlgorithm },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.signatureAlgorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingApiVersion",
                |m: &InAppRestoreTransactionsRequestProto| { &m.billingApiVersion },
                |m: &mut InAppRestoreTransactionsRequestProto| { &mut m.billingApiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppRestoreTransactionsRequestProto>(
                "InAppRestoreTransactionsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppRestoreTransactionsRequestProto {
        static instance: ::protobuf::rt::LazyV2<InAppRestoreTransactionsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppRestoreTransactionsRequestProto::new)
    }
}

impl ::protobuf::Clear for InAppRestoreTransactionsRequestProto {
    fn clear(&mut self) {
        self.signatureHash.clear();
        self.nonce = ::std::option::Option::None;
        self.signatureAlgorithm.clear();
        self.billingApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppRestoreTransactionsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppRestoreTransactionsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppRestoreTransactionsResponseProto {
    // message fields
    pub signedResponse: ::protobuf::SingularPtrField<SignedDataProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppRestoreTransactionsResponseProto {
    fn default() -> &'a InAppRestoreTransactionsResponseProto {
        <InAppRestoreTransactionsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl InAppRestoreTransactionsResponseProto {
    pub fn new() -> InAppRestoreTransactionsResponseProto {
        ::std::default::Default::default()
    }

    // optional .SignedDataProto signedResponse = 1;


    pub fn get_signedResponse(&self) -> &SignedDataProto {
        self.signedResponse.as_ref().unwrap_or_else(|| <SignedDataProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseResultProto purchaseResult = 2;


    pub fn get_purchaseResult(&self) -> &PurchaseResultProto {
        self.purchaseResult.as_ref().unwrap_or_else(|| <PurchaseResultProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for InAppRestoreTransactionsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signedResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signedResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppRestoreTransactionsResponseProto {
        InAppRestoreTransactionsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignedDataProto>>(
                "signedResponse",
                |m: &InAppRestoreTransactionsResponseProto| { &m.signedResponse },
                |m: &mut InAppRestoreTransactionsResponseProto| { &mut m.signedResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>>(
                "purchaseResult",
                |m: &InAppRestoreTransactionsResponseProto| { &m.purchaseResult },
                |m: &mut InAppRestoreTransactionsResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppRestoreTransactionsResponseProto>(
                "InAppRestoreTransactionsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppRestoreTransactionsResponseProto {
        static instance: ::protobuf::rt::LazyV2<InAppRestoreTransactionsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppRestoreTransactionsResponseProto::new)
    }
}

impl ::protobuf::Clear for InAppRestoreTransactionsResponseProto {
    fn clear(&mut self) {
        self.signedResponse.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppRestoreTransactionsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppRestoreTransactionsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModifyCommentRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub comment: ::protobuf::SingularPtrField<ExternalCommentProto>,
    pub deleteComment: ::std::option::Option<bool>,
    pub flagAsset: ::std::option::Option<bool>,
    pub flagType: ::std::option::Option<i32>,
    pub flagMessage: ::protobuf::SingularField<::std::string::String>,
    pub nonFlagFlow: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCommentRequestProto {
    fn default() -> &'a ModifyCommentRequestProto {
        <ModifyCommentRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCommentRequestProto {
    pub fn new() -> ModifyCommentRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ExternalCommentProto comment = 2;


    pub fn get_comment(&self) -> &ExternalCommentProto {
        self.comment.as_ref().unwrap_or_else(|| <ExternalCommentProto as ::protobuf::Message>::default_instance())
    }

    // optional bool deleteComment = 3;


    pub fn get_deleteComment(&self) -> bool {
        self.deleteComment.unwrap_or(false)
    }

    // optional bool flagAsset = 4;


    pub fn get_flagAsset(&self) -> bool {
        self.flagAsset.unwrap_or(false)
    }

    // optional int32 flagType = 5;


    pub fn get_flagType(&self) -> i32 {
        self.flagType.unwrap_or(0)
    }

    // optional string flagMessage = 6;


    pub fn get_flagMessage(&self) -> &str {
        match self.flagMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool nonFlagFlow = 7;


    pub fn get_nonFlagFlow(&self) -> bool {
        self.nonFlagFlow.unwrap_or(false)
    }
}

impl ::protobuf::Message for ModifyCommentRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.comment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleteComment = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flagAsset = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flagType = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.flagMessage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nonFlagFlow = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deleteComment {
            my_size += 2;
        }
        if let Some(v) = self.flagAsset {
            my_size += 2;
        }
        if let Some(v) = self.flagType {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.flagMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.nonFlagFlow {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deleteComment {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.flagAsset {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.flagType {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.flagMessage.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.nonFlagFlow {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCommentRequestProto {
        ModifyCommentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &ModifyCommentRequestProto| { &m.assetId },
                |m: &mut ModifyCommentRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCommentProto>>(
                "comment",
                |m: &ModifyCommentRequestProto| { &m.comment },
                |m: &mut ModifyCommentRequestProto| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleteComment",
                |m: &ModifyCommentRequestProto| { &m.deleteComment },
                |m: &mut ModifyCommentRequestProto| { &mut m.deleteComment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flagAsset",
                |m: &ModifyCommentRequestProto| { &m.flagAsset },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagAsset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flagType",
                |m: &ModifyCommentRequestProto| { &m.flagType },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flagMessage",
                |m: &ModifyCommentRequestProto| { &m.flagMessage },
                |m: &mut ModifyCommentRequestProto| { &mut m.flagMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "nonFlagFlow",
                |m: &ModifyCommentRequestProto| { &m.nonFlagFlow },
                |m: &mut ModifyCommentRequestProto| { &mut m.nonFlagFlow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCommentRequestProto>(
                "ModifyCommentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCommentRequestProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCommentRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCommentRequestProto::new)
    }
}

impl ::protobuf::Clear for ModifyCommentRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.comment.clear();
        self.deleteComment = ::std::option::Option::None;
        self.flagAsset = ::std::option::Option::None;
        self.flagType = ::std::option::Option::None;
        self.flagMessage.clear();
        self.nonFlagFlow = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCommentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCommentRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModifyCommentResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCommentResponseProto {
    fn default() -> &'a ModifyCommentResponseProto {
        <ModifyCommentResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCommentResponseProto {
    pub fn new() -> ModifyCommentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCommentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCommentResponseProto {
        ModifyCommentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCommentResponseProto>(
                "ModifyCommentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCommentResponseProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCommentResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCommentResponseProto::new)
    }
}

impl ::protobuf::Clear for ModifyCommentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCommentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCommentResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalCountryInfoProto {
    // message fields
    pub birthDateRequired: ::std::option::Option<bool>,
    pub tosText: ::protobuf::SingularField<::std::string::String>,
    pub billingAgreementText: ::protobuf::SingularField<::std::string::String>,
    pub preTosText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalCountryInfoProto {
    fn default() -> &'a PaypalCountryInfoProto {
        <PaypalCountryInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalCountryInfoProto {
    pub fn new() -> PaypalCountryInfoProto {
        ::std::default::Default::default()
    }

    // optional bool birthDateRequired = 1;


    pub fn get_birthDateRequired(&self) -> bool {
        self.birthDateRequired.unwrap_or(false)
    }

    // optional string tosText = 2;


    pub fn get_tosText(&self) -> &str {
        match self.tosText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string billingAgreementText = 3;


    pub fn get_billingAgreementText(&self) -> &str {
        match self.billingAgreementText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string preTosText = 4;


    pub fn get_preTosText(&self) -> &str {
        match self.preTosText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCountryInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.birthDateRequired = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosText)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingAgreementText)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preTosText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.birthDateRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.tosText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.billingAgreementText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.preTosText.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.birthDateRequired {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.tosText.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.billingAgreementText.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.preTosText.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCountryInfoProto {
        PaypalCountryInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "birthDateRequired",
                |m: &PaypalCountryInfoProto| { &m.birthDateRequired },
                |m: &mut PaypalCountryInfoProto| { &mut m.birthDateRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosText",
                |m: &PaypalCountryInfoProto| { &m.tosText },
                |m: &mut PaypalCountryInfoProto| { &mut m.tosText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingAgreementText",
                |m: &PaypalCountryInfoProto| { &m.billingAgreementText },
                |m: &mut PaypalCountryInfoProto| { &mut m.billingAgreementText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preTosText",
                |m: &PaypalCountryInfoProto| { &m.preTosText },
                |m: &mut PaypalCountryInfoProto| { &mut m.preTosText },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalCountryInfoProto>(
                "PaypalCountryInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCountryInfoProto {
        static instance: ::protobuf::rt::LazyV2<PaypalCountryInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalCountryInfoProto::new)
    }
}

impl ::protobuf::Clear for PaypalCountryInfoProto {
    fn clear(&mut self) {
        self.birthDateRequired = ::std::option::Option::None;
        self.tosText.clear();
        self.billingAgreementText.clear();
        self.preTosText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCountryInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCountryInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalCreateAccountRequestProto {
    // message fields
    pub firstName: ::protobuf::SingularField<::std::string::String>,
    pub lastName: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    pub birthDate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalCreateAccountRequestProto {
    fn default() -> &'a PaypalCreateAccountRequestProto {
        <PaypalCreateAccountRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalCreateAccountRequestProto {
    pub fn new() -> PaypalCreateAccountRequestProto {
        ::std::default::Default::default()
    }

    // optional string firstName = 1;


    pub fn get_firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastName = 2;


    pub fn get_lastName(&self) -> &str {
        match self.lastName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AddressProto address = 3;


    pub fn get_address(&self) -> &AddressProto {
        self.address.as_ref().unwrap_or_else(|| <AddressProto as ::protobuf::Message>::default_instance())
    }

    // optional string birthDate = 4;


    pub fn get_birthDate(&self) -> &str {
        match self.birthDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCreateAccountRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.birthDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.lastName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.birthDate.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.firstName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.lastName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.birthDate.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCreateAccountRequestProto {
        PaypalCreateAccountRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &PaypalCreateAccountRequestProto| { &m.firstName },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &PaypalCreateAccountRequestProto| { &m.lastName },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>>(
                "address",
                |m: &PaypalCreateAccountRequestProto| { &m.address },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "birthDate",
                |m: &PaypalCreateAccountRequestProto| { &m.birthDate },
                |m: &mut PaypalCreateAccountRequestProto| { &mut m.birthDate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalCreateAccountRequestProto>(
                "PaypalCreateAccountRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCreateAccountRequestProto {
        static instance: ::protobuf::rt::LazyV2<PaypalCreateAccountRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalCreateAccountRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalCreateAccountRequestProto {
    fn clear(&mut self) {
        self.firstName.clear();
        self.lastName.clear();
        self.address.clear();
        self.birthDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCreateAccountRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCreateAccountRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalCreateAccountResponseProto {
    // message fields
    pub createAccountKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalCreateAccountResponseProto {
    fn default() -> &'a PaypalCreateAccountResponseProto {
        <PaypalCreateAccountResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalCreateAccountResponseProto {
    pub fn new() -> PaypalCreateAccountResponseProto {
        ::std::default::Default::default()
    }

    // optional string createAccountKey = 1;


    pub fn get_createAccountKey(&self) -> &str {
        match self.createAccountKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCreateAccountResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.createAccountKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.createAccountKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.createAccountKey.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCreateAccountResponseProto {
        PaypalCreateAccountResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "createAccountKey",
                |m: &PaypalCreateAccountResponseProto| { &m.createAccountKey },
                |m: &mut PaypalCreateAccountResponseProto| { &mut m.createAccountKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalCreateAccountResponseProto>(
                "PaypalCreateAccountResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCreateAccountResponseProto {
        static instance: ::protobuf::rt::LazyV2<PaypalCreateAccountResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalCreateAccountResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalCreateAccountResponseProto {
    fn clear(&mut self) {
        self.createAccountKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCreateAccountResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCreateAccountResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalCredentialsProto {
    // message fields
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalCredentialsProto {
    fn default() -> &'a PaypalCredentialsProto {
        <PaypalCredentialsProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalCredentialsProto {
    pub fn new() -> PaypalCredentialsProto {
        ::std::default::Default::default()
    }

    // optional string preapprovalKey = 1;


    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string paypalEmail = 2;


    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalCredentialsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalCredentialsProto {
        PaypalCredentialsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preapprovalKey",
                |m: &PaypalCredentialsProto| { &m.preapprovalKey },
                |m: &mut PaypalCredentialsProto| { &mut m.preapprovalKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paypalEmail",
                |m: &PaypalCredentialsProto| { &m.paypalEmail },
                |m: &mut PaypalCredentialsProto| { &mut m.paypalEmail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalCredentialsProto>(
                "PaypalCredentialsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalCredentialsProto {
        static instance: ::protobuf::rt::LazyV2<PaypalCredentialsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalCredentialsProto::new)
    }
}

impl ::protobuf::Clear for PaypalCredentialsProto {
    fn clear(&mut self) {
        self.preapprovalKey.clear();
        self.paypalEmail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalCredentialsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalCredentialsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalMassageAddressRequestProto {
    // message fields
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalMassageAddressRequestProto {
    fn default() -> &'a PaypalMassageAddressRequestProto {
        <PaypalMassageAddressRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalMassageAddressRequestProto {
    pub fn new() -> PaypalMassageAddressRequestProto {
        ::std::default::Default::default()
    }

    // optional .AddressProto address = 1;


    pub fn get_address(&self) -> &AddressProto {
        self.address.as_ref().unwrap_or_else(|| <AddressProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PaypalMassageAddressRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalMassageAddressRequestProto {
        PaypalMassageAddressRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>>(
                "address",
                |m: &PaypalMassageAddressRequestProto| { &m.address },
                |m: &mut PaypalMassageAddressRequestProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalMassageAddressRequestProto>(
                "PaypalMassageAddressRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalMassageAddressRequestProto {
        static instance: ::protobuf::rt::LazyV2<PaypalMassageAddressRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalMassageAddressRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalMassageAddressRequestProto {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalMassageAddressRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalMassageAddressRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalMassageAddressResponseProto {
    // message fields
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalMassageAddressResponseProto {
    fn default() -> &'a PaypalMassageAddressResponseProto {
        <PaypalMassageAddressResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalMassageAddressResponseProto {
    pub fn new() -> PaypalMassageAddressResponseProto {
        ::std::default::Default::default()
    }

    // optional .AddressProto address = 1;


    pub fn get_address(&self) -> &AddressProto {
        self.address.as_ref().unwrap_or_else(|| <AddressProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PaypalMassageAddressResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalMassageAddressResponseProto {
        PaypalMassageAddressResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>>(
                "address",
                |m: &PaypalMassageAddressResponseProto| { &m.address },
                |m: &mut PaypalMassageAddressResponseProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalMassageAddressResponseProto>(
                "PaypalMassageAddressResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalMassageAddressResponseProto {
        static instance: ::protobuf::rt::LazyV2<PaypalMassageAddressResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalMassageAddressResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalMassageAddressResponseProto {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalMassageAddressResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalMassageAddressResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalCredentialsRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalCredentialsRequestProto {
    fn default() -> &'a PaypalPreapprovalCredentialsRequestProto {
        <PaypalPreapprovalCredentialsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalCredentialsRequestProto {
    pub fn new() -> PaypalPreapprovalCredentialsRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;


    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string billingInstrumentId = 2;


    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalCredentialsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalCredentialsRequestProto {
        PaypalPreapprovalCredentialsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaAuthToken",
                |m: &PaypalPreapprovalCredentialsRequestProto| { &m.gaiaAuthToken },
                |m: &mut PaypalPreapprovalCredentialsRequestProto| { &mut m.gaiaAuthToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingInstrumentId",
                |m: &PaypalPreapprovalCredentialsRequestProto| { &m.billingInstrumentId },
                |m: &mut PaypalPreapprovalCredentialsRequestProto| { &mut m.billingInstrumentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalCredentialsRequestProto>(
                "PaypalPreapprovalCredentialsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalCredentialsRequestProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalCredentialsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalCredentialsRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalCredentialsRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.billingInstrumentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalCredentialsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalCredentialsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalCredentialsResponseProto {
    // message fields
    pub resultCode: ::std::option::Option<i32>,
    pub paypalAccountKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalCredentialsResponseProto {
    fn default() -> &'a PaypalPreapprovalCredentialsResponseProto {
        <PaypalPreapprovalCredentialsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalCredentialsResponseProto {
    pub fn new() -> PaypalPreapprovalCredentialsResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 resultCode = 1;


    pub fn get_resultCode(&self) -> i32 {
        self.resultCode.unwrap_or(0)
    }

    // optional string paypalAccountKey = 2;


    pub fn get_paypalAccountKey(&self) -> &str {
        match self.paypalAccountKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string paypalEmail = 3;


    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalCredentialsResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalAccountKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.paypalAccountKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resultCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.paypalAccountKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.paypalEmail.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalCredentialsResponseProto {
        PaypalPreapprovalCredentialsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "resultCode",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.resultCode },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.resultCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paypalAccountKey",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.paypalAccountKey },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.paypalAccountKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paypalEmail",
                |m: &PaypalPreapprovalCredentialsResponseProto| { &m.paypalEmail },
                |m: &mut PaypalPreapprovalCredentialsResponseProto| { &mut m.paypalEmail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalCredentialsResponseProto>(
                "PaypalPreapprovalCredentialsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalCredentialsResponseProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalCredentialsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalCredentialsResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalCredentialsResponseProto {
    fn clear(&mut self) {
        self.resultCode = ::std::option::Option::None;
        self.paypalAccountKey.clear();
        self.paypalEmail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalCredentialsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalCredentialsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalDetailsRequestProto {
    // message fields
    pub getAddress: ::std::option::Option<bool>,
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalDetailsRequestProto {
    fn default() -> &'a PaypalPreapprovalDetailsRequestProto {
        <PaypalPreapprovalDetailsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalDetailsRequestProto {
    pub fn new() -> PaypalPreapprovalDetailsRequestProto {
        ::std::default::Default::default()
    }

    // optional bool getAddress = 1;


    pub fn get_getAddress(&self) -> bool {
        self.getAddress.unwrap_or(false)
    }

    // optional string preapprovalKey = 2;


    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalDetailsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.getAddress = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.getAddress {
            my_size += 2;
        }
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.getAddress {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalDetailsRequestProto {
        PaypalPreapprovalDetailsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "getAddress",
                |m: &PaypalPreapprovalDetailsRequestProto| { &m.getAddress },
                |m: &mut PaypalPreapprovalDetailsRequestProto| { &mut m.getAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preapprovalKey",
                |m: &PaypalPreapprovalDetailsRequestProto| { &m.preapprovalKey },
                |m: &mut PaypalPreapprovalDetailsRequestProto| { &mut m.preapprovalKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalDetailsRequestProto>(
                "PaypalPreapprovalDetailsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalDetailsRequestProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalDetailsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalDetailsRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalDetailsRequestProto {
    fn clear(&mut self) {
        self.getAddress = ::std::option::Option::None;
        self.preapprovalKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalDetailsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalDetailsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalDetailsResponseProto {
    // message fields
    pub paypalEmail: ::protobuf::SingularField<::std::string::String>,
    pub address: ::protobuf::SingularPtrField<AddressProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalDetailsResponseProto {
    fn default() -> &'a PaypalPreapprovalDetailsResponseProto {
        <PaypalPreapprovalDetailsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalDetailsResponseProto {
    pub fn new() -> PaypalPreapprovalDetailsResponseProto {
        ::std::default::Default::default()
    }

    // optional string paypalEmail = 1;


    pub fn get_paypalEmail(&self) -> &str {
        match self.paypalEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AddressProto address = 2;


    pub fn get_address(&self) -> &AddressProto {
        self.address.as_ref().unwrap_or_else(|| <AddressProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PaypalPreapprovalDetailsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.paypalEmail)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paypalEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paypalEmail.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalDetailsResponseProto {
        PaypalPreapprovalDetailsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paypalEmail",
                |m: &PaypalPreapprovalDetailsResponseProto| { &m.paypalEmail },
                |m: &mut PaypalPreapprovalDetailsResponseProto| { &mut m.paypalEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressProto>>(
                "address",
                |m: &PaypalPreapprovalDetailsResponseProto| { &m.address },
                |m: &mut PaypalPreapprovalDetailsResponseProto| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalDetailsResponseProto>(
                "PaypalPreapprovalDetailsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalDetailsResponseProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalDetailsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalDetailsResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalDetailsResponseProto {
    fn clear(&mut self) {
        self.paypalEmail.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalDetailsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalDetailsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalRequestProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalRequestProto {
    fn default() -> &'a PaypalPreapprovalRequestProto {
        <PaypalPreapprovalRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalRequestProto {
    pub fn new() -> PaypalPreapprovalRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PaypalPreapprovalRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalRequestProto {
        PaypalPreapprovalRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalRequestProto>(
                "PaypalPreapprovalRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalRequestProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalRequestProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PaypalPreapprovalResponseProto {
    // message fields
    pub preapprovalKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaypalPreapprovalResponseProto {
    fn default() -> &'a PaypalPreapprovalResponseProto {
        <PaypalPreapprovalResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PaypalPreapprovalResponseProto {
    pub fn new() -> PaypalPreapprovalResponseProto {
        ::std::default::Default::default()
    }

    // optional string preapprovalKey = 1;


    pub fn get_preapprovalKey(&self) -> &str {
        match self.preapprovalKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PaypalPreapprovalResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preapprovalKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preapprovalKey.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaypalPreapprovalResponseProto {
        PaypalPreapprovalResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preapprovalKey",
                |m: &PaypalPreapprovalResponseProto| { &m.preapprovalKey },
                |m: &mut PaypalPreapprovalResponseProto| { &mut m.preapprovalKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaypalPreapprovalResponseProto>(
                "PaypalPreapprovalResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaypalPreapprovalResponseProto {
        static instance: ::protobuf::rt::LazyV2<PaypalPreapprovalResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaypalPreapprovalResponseProto::new)
    }
}

impl ::protobuf::Clear for PaypalPreapprovalResponseProto {
    fn clear(&mut self) {
        self.preapprovalKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaypalPreapprovalResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaypalPreapprovalResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PendingNotificationsProto {
    // message fields
    pub notification: ::protobuf::RepeatedField<DataMessageProto>,
    pub nextCheckMillis: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingNotificationsProto {
    fn default() -> &'a PendingNotificationsProto {
        <PendingNotificationsProto as ::protobuf::Message>::default_instance()
    }
}

impl PendingNotificationsProto {
    pub fn new() -> PendingNotificationsProto {
        ::std::default::Default::default()
    }

    // repeated .DataMessageProto notification = 1;


    pub fn get_notification(&self) -> &[DataMessageProto] {
        &self.notification
    }

    // optional int64 nextCheckMillis = 2;


    pub fn get_nextCheckMillis(&self) -> i64 {
        self.nextCheckMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for PendingNotificationsProto {
    fn is_initialized(&self) -> bool {
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notification)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nextCheckMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.nextCheckMillis {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notification {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.nextCheckMillis {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingNotificationsProto {
        PendingNotificationsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataMessageProto>>(
                "notification",
                |m: &PendingNotificationsProto| { &m.notification },
                |m: &mut PendingNotificationsProto| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nextCheckMillis",
                |m: &PendingNotificationsProto| { &m.nextCheckMillis },
                |m: &mut PendingNotificationsProto| { &mut m.nextCheckMillis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PendingNotificationsProto>(
                "PendingNotificationsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PendingNotificationsProto {
        static instance: ::protobuf::rt::LazyV2<PendingNotificationsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PendingNotificationsProto::new)
    }
}

impl ::protobuf::Clear for PendingNotificationsProto {
    fn clear(&mut self) {
        self.notification.clear();
        self.nextCheckMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingNotificationsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingNotificationsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PrefetchedBundleProto {
    // message fields
    pub request: ::protobuf::SingularPtrField<SingleRequestProto>,
    pub response: ::protobuf::SingularPtrField<SingleResponseProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrefetchedBundleProto {
    fn default() -> &'a PrefetchedBundleProto {
        <PrefetchedBundleProto as ::protobuf::Message>::default_instance()
    }
}

impl PrefetchedBundleProto {
    pub fn new() -> PrefetchedBundleProto {
        ::std::default::Default::default()
    }

    // optional .SingleRequestProto request = 1;


    pub fn get_request(&self) -> &SingleRequestProto {
        self.request.as_ref().unwrap_or_else(|| <SingleRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .SingleResponseProto response = 2;


    pub fn get_response(&self) -> &SingleResponseProto {
        self.response.as_ref().unwrap_or_else(|| <SingleResponseProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PrefetchedBundleProto {
    fn is_initialized(&self) -> bool {
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrefetchedBundleProto {
        PrefetchedBundleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SingleRequestProto>>(
                "request",
                |m: &PrefetchedBundleProto| { &m.request },
                |m: &mut PrefetchedBundleProto| { &mut m.request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SingleResponseProto>>(
                "response",
                |m: &PrefetchedBundleProto| { &m.response },
                |m: &mut PrefetchedBundleProto| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrefetchedBundleProto>(
                "PrefetchedBundleProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrefetchedBundleProto {
        static instance: ::protobuf::rt::LazyV2<PrefetchedBundleProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrefetchedBundleProto::new)
    }
}

impl ::protobuf::Clear for PrefetchedBundleProto {
    fn clear(&mut self) {
        self.request.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrefetchedBundleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefetchedBundleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseCartInfoProto {
    // message fields
    pub itemPrice: ::protobuf::SingularField<::std::string::String>,
    pub taxInclusive: ::protobuf::SingularField<::std::string::String>,
    pub taxExclusive: ::protobuf::SingularField<::std::string::String>,
    pub total: ::protobuf::SingularField<::std::string::String>,
    pub taxMessage: ::protobuf::SingularField<::std::string::String>,
    pub footerMessage: ::protobuf::SingularField<::std::string::String>,
    pub priceCurrency: ::protobuf::SingularField<::std::string::String>,
    pub priceMicros: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseCartInfoProto {
    fn default() -> &'a PurchaseCartInfoProto {
        <PurchaseCartInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseCartInfoProto {
    pub fn new() -> PurchaseCartInfoProto {
        ::std::default::Default::default()
    }

    // optional string itemPrice = 1;


    pub fn get_itemPrice(&self) -> &str {
        match self.itemPrice.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string taxInclusive = 2;


    pub fn get_taxInclusive(&self) -> &str {
        match self.taxInclusive.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string taxExclusive = 3;


    pub fn get_taxExclusive(&self) -> &str {
        match self.taxExclusive.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string total = 4;


    pub fn get_total(&self) -> &str {
        match self.total.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string taxMessage = 5;


    pub fn get_taxMessage(&self) -> &str {
        match self.taxMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string footerMessage = 6;


    pub fn get_footerMessage(&self) -> &str {
        match self.footerMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string priceCurrency = 7;


    pub fn get_priceCurrency(&self) -> &str {
        match self.priceCurrency.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 priceMicros = 8;


    pub fn get_priceMicros(&self) -> i64 {
        self.priceMicros.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseCartInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemPrice)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxInclusive)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxExclusive)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.total)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.taxMessage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerMessage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priceCurrency)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.priceMicros = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.itemPrice.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.taxInclusive.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.taxExclusive.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.total.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.taxMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.footerMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.priceCurrency.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.priceMicros {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.itemPrice.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.taxInclusive.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.taxExclusive.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.total.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.taxMessage.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.footerMessage.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.priceCurrency.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.priceMicros {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseCartInfoProto {
        PurchaseCartInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "itemPrice",
                |m: &PurchaseCartInfoProto| { &m.itemPrice },
                |m: &mut PurchaseCartInfoProto| { &mut m.itemPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "taxInclusive",
                |m: &PurchaseCartInfoProto| { &m.taxInclusive },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxInclusive },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "taxExclusive",
                |m: &PurchaseCartInfoProto| { &m.taxExclusive },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxExclusive },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "total",
                |m: &PurchaseCartInfoProto| { &m.total },
                |m: &mut PurchaseCartInfoProto| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "taxMessage",
                |m: &PurchaseCartInfoProto| { &m.taxMessage },
                |m: &mut PurchaseCartInfoProto| { &mut m.taxMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerMessage",
                |m: &PurchaseCartInfoProto| { &m.footerMessage },
                |m: &mut PurchaseCartInfoProto| { &mut m.footerMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "priceCurrency",
                |m: &PurchaseCartInfoProto| { &m.priceCurrency },
                |m: &mut PurchaseCartInfoProto| { &mut m.priceCurrency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "priceMicros",
                |m: &PurchaseCartInfoProto| { &m.priceMicros },
                |m: &mut PurchaseCartInfoProto| { &mut m.priceMicros },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseCartInfoProto>(
                "PurchaseCartInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseCartInfoProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseCartInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseCartInfoProto::new)
    }
}

impl ::protobuf::Clear for PurchaseCartInfoProto {
    fn clear(&mut self) {
        self.itemPrice.clear();
        self.taxInclusive.clear();
        self.taxExclusive.clear();
        self.total.clear();
        self.taxMessage.clear();
        self.footerMessage.clear();
        self.priceCurrency.clear();
        self.priceMicros = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseCartInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseCartInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseInfoProto {
    // message fields
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    pub cartInfo: ::protobuf::SingularPtrField<PurchaseCartInfoProto>,
    // billinginstruments: <group>
    pub errorInputFields: ::std::vec::Vec<i32>,
    pub refundPolicy: ::protobuf::SingularField<::std::string::String>,
    pub userCanAddGdd: ::std::option::Option<bool>,
    pub eligibleInstrumentTypes: ::std::vec::Vec<i32>,
    pub orderId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseInfoProto {
    fn default() -> &'a PurchaseInfoProto {
        <PurchaseInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseInfoProto {
    pub fn new() -> PurchaseInfoProto {
        ::std::default::Default::default()
    }

    // optional string transactionId = 1;


    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .PurchaseCartInfoProto cartInfo = 2;


    pub fn get_cartInfo(&self) -> &PurchaseCartInfoProto {
        self.cartInfo.as_ref().unwrap_or_else(|| <PurchaseCartInfoProto as ::protobuf::Message>::default_instance())
    }

    // repeated int32 errorInputFields = 9;


    pub fn get_errorInputFields(&self) -> &[i32] {
        &self.errorInputFields
    }

    // optional string refundPolicy = 10;


    pub fn get_refundPolicy(&self) -> &str {
        match self.refundPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool userCanAddGdd = 12;


    pub fn get_userCanAddGdd(&self) -> bool {
        self.userCanAddGdd.unwrap_or(false)
    }

    // repeated int32 eligibleInstrumentTypes = 13;


    pub fn get_eligibleInstrumentTypes(&self) -> &[i32] {
        &self.eligibleInstrumentTypes
    }

    // optional string orderId = 15;


    pub fn get_orderId(&self) -> &str {
        match self.orderId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.cartInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cartInfo)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.errorInputFields)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.refundPolicy)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userCanAddGdd = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.eligibleInstrumentTypes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.orderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.cartInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorInputFields {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.refundPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.userCanAddGdd {
            my_size += 2;
        }
        for value in &self.eligibleInstrumentTypes {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.orderId.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transactionId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.cartInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errorInputFields {
            os.write_int32(9, *v)?;
        };
        if let Some(ref v) = self.refundPolicy.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.userCanAddGdd {
            os.write_bool(12, v)?;
        }
        for v in &self.eligibleInstrumentTypes {
            os.write_int32(13, *v)?;
        };
        if let Some(ref v) = self.orderId.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseInfoProto {
        PurchaseInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transactionId",
                |m: &PurchaseInfoProto| { &m.transactionId },
                |m: &mut PurchaseInfoProto| { &mut m.transactionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseCartInfoProto>>(
                "cartInfo",
                |m: &PurchaseInfoProto| { &m.cartInfo },
                |m: &mut PurchaseInfoProto| { &mut m.cartInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorInputFields",
                |m: &PurchaseInfoProto| { &m.errorInputFields },
                |m: &mut PurchaseInfoProto| { &mut m.errorInputFields },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "refundPolicy",
                |m: &PurchaseInfoProto| { &m.refundPolicy },
                |m: &mut PurchaseInfoProto| { &mut m.refundPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "userCanAddGdd",
                |m: &PurchaseInfoProto| { &m.userCanAddGdd },
                |m: &mut PurchaseInfoProto| { &mut m.userCanAddGdd },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eligibleInstrumentTypes",
                |m: &PurchaseInfoProto| { &m.eligibleInstrumentTypes },
                |m: &mut PurchaseInfoProto| { &mut m.eligibleInstrumentTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "orderId",
                |m: &PurchaseInfoProto| { &m.orderId },
                |m: &mut PurchaseInfoProto| { &mut m.orderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseInfoProto>(
                "PurchaseInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseInfoProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseInfoProto::new)
    }
}

impl ::protobuf::Clear for PurchaseInfoProto {
    fn clear(&mut self) {
        self.transactionId.clear();
        self.cartInfo.clear();
        self.errorInputFields.clear();
        self.refundPolicy.clear();
        self.userCanAddGdd = ::std::option::Option::None;
        self.eligibleInstrumentTypes.clear();
        self.orderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseInfoProto_BillingInstruments {
    // message fields
    // billinginstrument: <group>
    pub defaultBillingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseInfoProto_BillingInstruments {
    fn default() -> &'a PurchaseInfoProto_BillingInstruments {
        <PurchaseInfoProto_BillingInstruments as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseInfoProto_BillingInstruments {
    pub fn new() -> PurchaseInfoProto_BillingInstruments {
        ::std::default::Default::default()
    }

    // optional string defaultBillingInstrumentId = 8;


    pub fn get_defaultBillingInstrumentId(&self) -> &str {
        match self.defaultBillingInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseInfoProto_BillingInstruments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.defaultBillingInstrumentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.defaultBillingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.defaultBillingInstrumentId.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseInfoProto_BillingInstruments {
        PurchaseInfoProto_BillingInstruments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "defaultBillingInstrumentId",
                |m: &PurchaseInfoProto_BillingInstruments| { &m.defaultBillingInstrumentId },
                |m: &mut PurchaseInfoProto_BillingInstruments| { &mut m.defaultBillingInstrumentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseInfoProto_BillingInstruments>(
                "PurchaseInfoProto.BillingInstruments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseInfoProto_BillingInstruments {
        static instance: ::protobuf::rt::LazyV2<PurchaseInfoProto_BillingInstruments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseInfoProto_BillingInstruments::new)
    }
}

impl ::protobuf::Clear for PurchaseInfoProto_BillingInstruments {
    fn clear(&mut self) {
        self.defaultBillingInstrumentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseInfoProto_BillingInstruments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseInfoProto_BillingInstruments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseMetadataRequestProto {
    // message fields
    pub deprecatedRetrieveBillingCountries: ::std::option::Option<bool>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseMetadataRequestProto {
    fn default() -> &'a PurchaseMetadataRequestProto {
        <PurchaseMetadataRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseMetadataRequestProto {
    pub fn new() -> PurchaseMetadataRequestProto {
        ::std::default::Default::default()
    }

    // optional bool deprecatedRetrieveBillingCountries = 1;


    pub fn get_deprecatedRetrieveBillingCountries(&self) -> bool {
        self.deprecatedRetrieveBillingCountries.unwrap_or(false)
    }

    // optional int32 billingInstrumentType = 2;


    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }
}

impl ::protobuf::Message for PurchaseMetadataRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deprecatedRetrieveBillingCountries = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedRetrieveBillingCountries {
            my_size += 2;
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedRetrieveBillingCountries {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataRequestProto {
        PurchaseMetadataRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deprecatedRetrieveBillingCountries",
                |m: &PurchaseMetadataRequestProto| { &m.deprecatedRetrieveBillingCountries },
                |m: &mut PurchaseMetadataRequestProto| { &mut m.deprecatedRetrieveBillingCountries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingInstrumentType",
                |m: &PurchaseMetadataRequestProto| { &m.billingInstrumentType },
                |m: &mut PurchaseMetadataRequestProto| { &mut m.billingInstrumentType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseMetadataRequestProto>(
                "PurchaseMetadataRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataRequestProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseMetadataRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseMetadataRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataRequestProto {
    fn clear(&mut self) {
        self.deprecatedRetrieveBillingCountries = ::std::option::Option::None;
        self.billingInstrumentType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseMetadataResponseProto {
    // message fields
    // countries: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseMetadataResponseProto {
    fn default() -> &'a PurchaseMetadataResponseProto {
        <PurchaseMetadataResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseMetadataResponseProto {
    pub fn new() -> PurchaseMetadataResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto {
        PurchaseMetadataResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseMetadataResponseProto>(
                "PurchaseMetadataResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseMetadataResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseMetadataResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseMetadataResponseProto_Countries {
    // message fields
    // country: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseMetadataResponseProto_Countries {
    fn default() -> &'a PurchaseMetadataResponseProto_Countries {
        <PurchaseMetadataResponseProto_Countries as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseMetadataResponseProto_Countries {
    pub fn new() -> PurchaseMetadataResponseProto_Countries {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PurchaseMetadataResponseProto_Countries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseMetadataResponseProto_Countries {
        PurchaseMetadataResponseProto_Countries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseMetadataResponseProto_Countries>(
                "PurchaseMetadataResponseProto.Countries",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseMetadataResponseProto_Countries {
        static instance: ::protobuf::rt::LazyV2<PurchaseMetadataResponseProto_Countries> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseMetadataResponseProto_Countries::new)
    }
}

impl ::protobuf::Clear for PurchaseMetadataResponseProto_Countries {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseMetadataResponseProto_Countries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseMetadataResponseProto_Countries {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseOrderRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub tosAccepted: ::std::option::Option<bool>,
    pub carrierBillingCredentials: ::protobuf::SingularPtrField<CarrierBillingCredentialsProto>,
    pub existingOrderId: ::protobuf::SingularField<::std::string::String>,
    pub billingInstrumentType: ::std::option::Option<i32>,
    pub billingParametersId: ::protobuf::SingularField<::std::string::String>,
    pub paypalCredentials: ::protobuf::SingularPtrField<PaypalCredentialsProto>,
    pub riskHeaderInfo: ::protobuf::SingularPtrField<RiskHeaderInfoProto>,
    pub productType: ::std::option::Option<i32>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    pub developerPayload: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseOrderRequestProto {
    fn default() -> &'a PurchaseOrderRequestProto {
        <PurchaseOrderRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseOrderRequestProto {
    pub fn new() -> PurchaseOrderRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;


    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetId = 2;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string transactionId = 3;


    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string billingInstrumentId = 4;


    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool tosAccepted = 5;


    pub fn get_tosAccepted(&self) -> bool {
        self.tosAccepted.unwrap_or(false)
    }

    // optional .CarrierBillingCredentialsProto carrierBillingCredentials = 6;


    pub fn get_carrierBillingCredentials(&self) -> &CarrierBillingCredentialsProto {
        self.carrierBillingCredentials.as_ref().unwrap_or_else(|| <CarrierBillingCredentialsProto as ::protobuf::Message>::default_instance())
    }

    // optional string existingOrderId = 7;


    pub fn get_existingOrderId(&self) -> &str {
        match self.existingOrderId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 billingInstrumentType = 8;


    pub fn get_billingInstrumentType(&self) -> i32 {
        self.billingInstrumentType.unwrap_or(0)
    }

    // optional string billingParametersId = 9;


    pub fn get_billingParametersId(&self) -> &str {
        match self.billingParametersId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .PaypalCredentialsProto paypalCredentials = 10;


    pub fn get_paypalCredentials(&self) -> &PaypalCredentialsProto {
        self.paypalCredentials.as_ref().unwrap_or_else(|| <PaypalCredentialsProto as ::protobuf::Message>::default_instance())
    }

    // optional .RiskHeaderInfoProto riskHeaderInfo = 11;


    pub fn get_riskHeaderInfo(&self) -> &RiskHeaderInfoProto {
        self.riskHeaderInfo.as_ref().unwrap_or_else(|| <RiskHeaderInfoProto as ::protobuf::Message>::default_instance())
    }

    // optional int32 productType = 12;


    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }

    // optional .SignatureHashProto signatureHash = 13;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }

    // optional string developerPayload = 14;


    pub fn get_developerPayload(&self) -> &str {
        match self.developerPayload.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseOrderRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierBillingCredentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCredentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.riskHeaderInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosAccepted = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingCredentials)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.existingOrderId)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingInstrumentType = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingParametersId)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalCredentials)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.riskHeaderInfo)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerPayload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tosAccepted {
            my_size += 2;
        }
        if let Some(ref v) = self.carrierBillingCredentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.existingOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.billingInstrumentType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.billingParametersId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.paypalCredentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.riskHeaderInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.developerPayload.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.transactionId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.tosAccepted {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.carrierBillingCredentials.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.existingOrderId.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.billingInstrumentType {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.billingParametersId.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.paypalCredentials.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.riskHeaderInfo.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(12, v)?;
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.developerPayload.as_ref() {
            os.write_string(14, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseOrderRequestProto {
        PurchaseOrderRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaAuthToken",
                |m: &PurchaseOrderRequestProto| { &m.gaiaAuthToken },
                |m: &mut PurchaseOrderRequestProto| { &mut m.gaiaAuthToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &PurchaseOrderRequestProto| { &m.assetId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transactionId",
                |m: &PurchaseOrderRequestProto| { &m.transactionId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.transactionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingInstrumentId",
                |m: &PurchaseOrderRequestProto| { &m.billingInstrumentId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingInstrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tosAccepted",
                |m: &PurchaseOrderRequestProto| { &m.tosAccepted },
                |m: &mut PurchaseOrderRequestProto| { &mut m.tosAccepted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingCredentialsProto>>(
                "carrierBillingCredentials",
                |m: &PurchaseOrderRequestProto| { &m.carrierBillingCredentials },
                |m: &mut PurchaseOrderRequestProto| { &mut m.carrierBillingCredentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "existingOrderId",
                |m: &PurchaseOrderRequestProto| { &m.existingOrderId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.existingOrderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingInstrumentType",
                |m: &PurchaseOrderRequestProto| { &m.billingInstrumentType },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingInstrumentType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingParametersId",
                |m: &PurchaseOrderRequestProto| { &m.billingParametersId },
                |m: &mut PurchaseOrderRequestProto| { &mut m.billingParametersId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCredentialsProto>>(
                "paypalCredentials",
                |m: &PurchaseOrderRequestProto| { &m.paypalCredentials },
                |m: &mut PurchaseOrderRequestProto| { &mut m.paypalCredentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RiskHeaderInfoProto>>(
                "riskHeaderInfo",
                |m: &PurchaseOrderRequestProto| { &m.riskHeaderInfo },
                |m: &mut PurchaseOrderRequestProto| { &mut m.riskHeaderInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "productType",
                |m: &PurchaseOrderRequestProto| { &m.productType },
                |m: &mut PurchaseOrderRequestProto| { &mut m.productType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &PurchaseOrderRequestProto| { &m.signatureHash },
                |m: &mut PurchaseOrderRequestProto| { &mut m.signatureHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerPayload",
                |m: &PurchaseOrderRequestProto| { &m.developerPayload },
                |m: &mut PurchaseOrderRequestProto| { &mut m.developerPayload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseOrderRequestProto>(
                "PurchaseOrderRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseOrderRequestProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseOrderRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseOrderRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseOrderRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.assetId.clear();
        self.transactionId.clear();
        self.billingInstrumentId.clear();
        self.tosAccepted = ::std::option::Option::None;
        self.carrierBillingCredentials.clear();
        self.existingOrderId.clear();
        self.billingInstrumentType = ::std::option::Option::None;
        self.billingParametersId.clear();
        self.paypalCredentials.clear();
        self.riskHeaderInfo.clear();
        self.productType = ::std::option::Option::None;
        self.signatureHash.clear();
        self.developerPayload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseOrderRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseOrderRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseOrderResponseProto {
    // message fields
    pub deprecatedResultCode: ::std::option::Option<i32>,
    pub purchaseInfo: ::protobuf::SingularPtrField<PurchaseInfoProto>,
    pub asset: ::protobuf::SingularPtrField<ExternalAssetProto>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseOrderResponseProto {
    fn default() -> &'a PurchaseOrderResponseProto {
        <PurchaseOrderResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseOrderResponseProto {
    pub fn new() -> PurchaseOrderResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 deprecatedResultCode = 1;


    pub fn get_deprecatedResultCode(&self) -> i32 {
        self.deprecatedResultCode.unwrap_or(0)
    }

    // optional .PurchaseInfoProto purchaseInfo = 2;


    pub fn get_purchaseInfo(&self) -> &PurchaseInfoProto {
        self.purchaseInfo.as_ref().unwrap_or_else(|| <PurchaseInfoProto as ::protobuf::Message>::default_instance())
    }

    // optional .ExternalAssetProto asset = 3;


    pub fn get_asset(&self) -> &ExternalAssetProto {
        self.asset.as_ref().unwrap_or_else(|| <ExternalAssetProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseResultProto purchaseResult = 4;


    pub fn get_purchaseResult(&self) -> &PurchaseResultProto {
        self.purchaseResult.as_ref().unwrap_or_else(|| <PurchaseResultProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchaseOrderResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deprecatedResultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.asset)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedResultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.asset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedResultCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.purchaseInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.asset.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseOrderResponseProto {
        PurchaseOrderResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deprecatedResultCode",
                |m: &PurchaseOrderResponseProto| { &m.deprecatedResultCode },
                |m: &mut PurchaseOrderResponseProto| { &mut m.deprecatedResultCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseInfoProto>>(
                "purchaseInfo",
                |m: &PurchaseOrderResponseProto| { &m.purchaseInfo },
                |m: &mut PurchaseOrderResponseProto| { &mut m.purchaseInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "asset",
                |m: &PurchaseOrderResponseProto| { &m.asset },
                |m: &mut PurchaseOrderResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>>(
                "purchaseResult",
                |m: &PurchaseOrderResponseProto| { &m.purchaseResult },
                |m: &mut PurchaseOrderResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseOrderResponseProto>(
                "PurchaseOrderResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseOrderResponseProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseOrderResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseOrderResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseOrderResponseProto {
    fn clear(&mut self) {
        self.deprecatedResultCode = ::std::option::Option::None;
        self.purchaseInfo.clear();
        self.asset.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseOrderResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseOrderResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchasePostRequestProto {
    // message fields
    pub gaiaAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub transactionId: ::protobuf::SingularField<::std::string::String>,
    // billinginstrumentinfo: <group>
    pub tosAccepted: ::std::option::Option<bool>,
    pub cbInstrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub paypalAuthConfirmed: ::std::option::Option<bool>,
    pub productType: ::std::option::Option<i32>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchasePostRequestProto {
    fn default() -> &'a PurchasePostRequestProto {
        <PurchasePostRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchasePostRequestProto {
    pub fn new() -> PurchasePostRequestProto {
        ::std::default::Default::default()
    }

    // optional string gaiaAuthToken = 1;


    pub fn get_gaiaAuthToken(&self) -> &str {
        match self.gaiaAuthToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string assetId = 2;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string transactionId = 3;


    pub fn get_transactionId(&self) -> &str {
        match self.transactionId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool tosAccepted = 7;


    pub fn get_tosAccepted(&self) -> bool {
        self.tosAccepted.unwrap_or(false)
    }

    // optional string cbInstrumentKey = 8;


    pub fn get_cbInstrumentKey(&self) -> &str {
        match self.cbInstrumentKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool paypalAuthConfirmed = 11;


    pub fn get_paypalAuthConfirmed(&self) -> bool {
        self.paypalAuthConfirmed.unwrap_or(false)
    }

    // optional int32 productType = 12;


    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }

    // optional .SignatureHashProto signatureHash = 13;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchasePostRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaAuthToken)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transactionId)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosAccepted = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cbInstrumentKey)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.paypalAuthConfirmed = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.transactionId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tosAccepted {
            my_size += 2;
        }
        if let Some(ref v) = self.cbInstrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.paypalAuthConfirmed {
            my_size += 2;
        }
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gaiaAuthToken.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.transactionId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.tosAccepted {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.cbInstrumentKey.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.paypalAuthConfirmed {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.productType {
            os.write_int32(12, v)?;
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostRequestProto {
        PurchasePostRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaAuthToken",
                |m: &PurchasePostRequestProto| { &m.gaiaAuthToken },
                |m: &mut PurchasePostRequestProto| { &mut m.gaiaAuthToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &PurchasePostRequestProto| { &m.assetId },
                |m: &mut PurchasePostRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transactionId",
                |m: &PurchasePostRequestProto| { &m.transactionId },
                |m: &mut PurchasePostRequestProto| { &mut m.transactionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tosAccepted",
                |m: &PurchasePostRequestProto| { &m.tosAccepted },
                |m: &mut PurchasePostRequestProto| { &mut m.tosAccepted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cbInstrumentKey",
                |m: &PurchasePostRequestProto| { &m.cbInstrumentKey },
                |m: &mut PurchasePostRequestProto| { &mut m.cbInstrumentKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "paypalAuthConfirmed",
                |m: &PurchasePostRequestProto| { &m.paypalAuthConfirmed },
                |m: &mut PurchasePostRequestProto| { &mut m.paypalAuthConfirmed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "productType",
                |m: &PurchasePostRequestProto| { &m.productType },
                |m: &mut PurchasePostRequestProto| { &mut m.productType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &PurchasePostRequestProto| { &m.signatureHash },
                |m: &mut PurchasePostRequestProto| { &mut m.signatureHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchasePostRequestProto>(
                "PurchasePostRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostRequestProto {
        static instance: ::protobuf::rt::LazyV2<PurchasePostRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchasePostRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchasePostRequestProto {
    fn clear(&mut self) {
        self.gaiaAuthToken.clear();
        self.assetId.clear();
        self.transactionId.clear();
        self.tosAccepted = ::std::option::Option::None;
        self.cbInstrumentKey.clear();
        self.paypalAuthConfirmed = ::std::option::Option::None;
        self.productType = ::std::option::Option::None;
        self.signatureHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchasePostRequestProto_BillingInstrumentInfo {
    // message fields
    pub billingInstrumentId: ::protobuf::SingularField<::std::string::String>,
    pub creditCard: ::protobuf::SingularPtrField<ExternalCreditCard>,
    pub carrierInstrument: ::protobuf::SingularPtrField<ExternalCarrierBillingInstrumentProto>,
    pub paypalInstrument: ::protobuf::SingularPtrField<ExternalPaypalInstrumentProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchasePostRequestProto_BillingInstrumentInfo {
    fn default() -> &'a PurchasePostRequestProto_BillingInstrumentInfo {
        <PurchasePostRequestProto_BillingInstrumentInfo as ::protobuf::Message>::default_instance()
    }
}

impl PurchasePostRequestProto_BillingInstrumentInfo {
    pub fn new() -> PurchasePostRequestProto_BillingInstrumentInfo {
        ::std::default::Default::default()
    }

    // optional string billingInstrumentId = 5;


    pub fn get_billingInstrumentId(&self) -> &str {
        match self.billingInstrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ExternalCreditCard creditCard = 6;


    pub fn get_creditCard(&self) -> &ExternalCreditCard {
        self.creditCard.as_ref().unwrap_or_else(|| <ExternalCreditCard as ::protobuf::Message>::default_instance())
    }

    // optional .ExternalCarrierBillingInstrumentProto carrierInstrument = 9;


    pub fn get_carrierInstrument(&self) -> &ExternalCarrierBillingInstrumentProto {
        self.carrierInstrument.as_ref().unwrap_or_else(|| <ExternalCarrierBillingInstrumentProto as ::protobuf::Message>::default_instance())
    }

    // optional .ExternalPaypalInstrumentProto paypalInstrument = 10;


    pub fn get_paypalInstrument(&self) -> &ExternalPaypalInstrumentProto {
        self.paypalInstrument.as_ref().unwrap_or_else(|| <ExternalPaypalInstrumentProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchasePostRequestProto_BillingInstrumentInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.creditCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.billingInstrumentId)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creditCard)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierInstrument)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.billingInstrumentId.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierInstrument.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalInstrument.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostRequestProto_BillingInstrumentInfo {
        PurchasePostRequestProto_BillingInstrumentInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "billingInstrumentId",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.billingInstrumentId },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.billingInstrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCreditCard>>(
                "creditCard",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.creditCard },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.creditCard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalCarrierBillingInstrumentProto>>(
                "carrierInstrument",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.carrierInstrument },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.carrierInstrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalPaypalInstrumentProto>>(
                "paypalInstrument",
                |m: &PurchasePostRequestProto_BillingInstrumentInfo| { &m.paypalInstrument },
                |m: &mut PurchasePostRequestProto_BillingInstrumentInfo| { &mut m.paypalInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchasePostRequestProto_BillingInstrumentInfo>(
                "PurchasePostRequestProto.BillingInstrumentInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostRequestProto_BillingInstrumentInfo {
        static instance: ::protobuf::rt::LazyV2<PurchasePostRequestProto_BillingInstrumentInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchasePostRequestProto_BillingInstrumentInfo::new)
    }
}

impl ::protobuf::Clear for PurchasePostRequestProto_BillingInstrumentInfo {
    fn clear(&mut self) {
        self.billingInstrumentId.clear();
        self.creditCard.clear();
        self.carrierInstrument.clear();
        self.paypalInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostRequestProto_BillingInstrumentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostRequestProto_BillingInstrumentInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchasePostResponseProto {
    // message fields
    pub deprecatedResultCode: ::std::option::Option<i32>,
    pub purchaseInfo: ::protobuf::SingularPtrField<PurchaseInfoProto>,
    pub termsOfServiceUrl: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceText: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceName: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceCheckboxText: ::protobuf::SingularField<::std::string::String>,
    pub termsOfServiceHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub purchaseResult: ::protobuf::SingularPtrField<PurchaseResultProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchasePostResponseProto {
    fn default() -> &'a PurchasePostResponseProto {
        <PurchasePostResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchasePostResponseProto {
    pub fn new() -> PurchasePostResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 deprecatedResultCode = 1;


    pub fn get_deprecatedResultCode(&self) -> i32 {
        self.deprecatedResultCode.unwrap_or(0)
    }

    // optional .PurchaseInfoProto purchaseInfo = 2;


    pub fn get_purchaseInfo(&self) -> &PurchaseInfoProto {
        self.purchaseInfo.as_ref().unwrap_or_else(|| <PurchaseInfoProto as ::protobuf::Message>::default_instance())
    }

    // optional string termsOfServiceUrl = 3;


    pub fn get_termsOfServiceUrl(&self) -> &str {
        match self.termsOfServiceUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string termsOfServiceText = 4;


    pub fn get_termsOfServiceText(&self) -> &str {
        match self.termsOfServiceText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string termsOfServiceName = 5;


    pub fn get_termsOfServiceName(&self) -> &str {
        match self.termsOfServiceName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string termsOfServiceCheckboxText = 6;


    pub fn get_termsOfServiceCheckboxText(&self) -> &str {
        match self.termsOfServiceCheckboxText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string termsOfServiceHeaderText = 7;


    pub fn get_termsOfServiceHeaderText(&self) -> &str {
        match self.termsOfServiceHeaderText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .PurchaseResultProto purchaseResult = 8;


    pub fn get_purchaseResult(&self) -> &PurchaseResultProto {
        self.purchaseResult.as_ref().unwrap_or_else(|| <PurchaseResultProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchasePostResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deprecatedResultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceText)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceCheckboxText)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.termsOfServiceHeaderText)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecatedResultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchaseInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.termsOfServiceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.termsOfServiceText.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.termsOfServiceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.termsOfServiceCheckboxText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.termsOfServiceHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecatedResultCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.purchaseInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.termsOfServiceUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.termsOfServiceText.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.termsOfServiceName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.termsOfServiceCheckboxText.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.termsOfServiceHeaderText.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.purchaseResult.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchasePostResponseProto {
        PurchasePostResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deprecatedResultCode",
                |m: &PurchasePostResponseProto| { &m.deprecatedResultCode },
                |m: &mut PurchasePostResponseProto| { &mut m.deprecatedResultCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseInfoProto>>(
                "purchaseInfo",
                |m: &PurchasePostResponseProto| { &m.purchaseInfo },
                |m: &mut PurchasePostResponseProto| { &mut m.purchaseInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsOfServiceUrl",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceUrl },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsOfServiceText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsOfServiceName",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceName },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsOfServiceCheckboxText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceCheckboxText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceCheckboxText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "termsOfServiceHeaderText",
                |m: &PurchasePostResponseProto| { &m.termsOfServiceHeaderText },
                |m: &mut PurchasePostResponseProto| { &mut m.termsOfServiceHeaderText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseResultProto>>(
                "purchaseResult",
                |m: &PurchasePostResponseProto| { &m.purchaseResult },
                |m: &mut PurchasePostResponseProto| { &mut m.purchaseResult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchasePostResponseProto>(
                "PurchasePostResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchasePostResponseProto {
        static instance: ::protobuf::rt::LazyV2<PurchasePostResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchasePostResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchasePostResponseProto {
    fn clear(&mut self) {
        self.deprecatedResultCode = ::std::option::Option::None;
        self.purchaseInfo.clear();
        self.termsOfServiceUrl.clear();
        self.termsOfServiceText.clear();
        self.termsOfServiceName.clear();
        self.termsOfServiceCheckboxText.clear();
        self.termsOfServiceHeaderText.clear();
        self.purchaseResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchasePostResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchasePostResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseProductRequestProto {
    // message fields
    pub productType: ::std::option::Option<i32>,
    pub productId: ::protobuf::SingularField<::std::string::String>,
    pub signatureHash: ::protobuf::SingularPtrField<SignatureHashProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseProductRequestProto {
    fn default() -> &'a PurchaseProductRequestProto {
        <PurchaseProductRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseProductRequestProto {
    pub fn new() -> PurchaseProductRequestProto {
        ::std::default::Default::default()
    }

    // optional int32 productType = 1;


    pub fn get_productType(&self) -> i32 {
        self.productType.unwrap_or(0)
    }

    // optional string productId = 2;


    pub fn get_productId(&self) -> &str {
        match self.productId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SignatureHashProto signatureHash = 3;


    pub fn get_signatureHash(&self) -> &SignatureHashProto {
        self.signatureHash.as_ref().unwrap_or_else(|| <SignatureHashProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchaseProductRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.signatureHash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.productType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.productId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signatureHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.productType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.productId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.productType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.productId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.signatureHash.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseProductRequestProto {
        PurchaseProductRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "productType",
                |m: &PurchaseProductRequestProto| { &m.productType },
                |m: &mut PurchaseProductRequestProto| { &mut m.productType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productId",
                |m: &PurchaseProductRequestProto| { &m.productId },
                |m: &mut PurchaseProductRequestProto| { &mut m.productId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureHashProto>>(
                "signatureHash",
                |m: &PurchaseProductRequestProto| { &m.signatureHash },
                |m: &mut PurchaseProductRequestProto| { &mut m.signatureHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseProductRequestProto>(
                "PurchaseProductRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseProductRequestProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseProductRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseProductRequestProto::new)
    }
}

impl ::protobuf::Clear for PurchaseProductRequestProto {
    fn clear(&mut self) {
        self.productType = ::std::option::Option::None;
        self.productId.clear();
        self.signatureHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseProductRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseProductRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseProductResponseProto {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub itemTitle: ::protobuf::SingularField<::std::string::String>,
    pub itemDescription: ::protobuf::SingularField<::std::string::String>,
    pub merchantField: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseProductResponseProto {
    fn default() -> &'a PurchaseProductResponseProto {
        <PurchaseProductResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseProductResponseProto {
    pub fn new() -> PurchaseProductResponseProto {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string itemTitle = 2;


    pub fn get_itemTitle(&self) -> &str {
        match self.itemTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string itemDescription = 3;


    pub fn get_itemDescription(&self) -> &str {
        match self.itemDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string merchantField = 4;


    pub fn get_merchantField(&self) -> &str {
        match self.merchantField.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseProductResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemDescription)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.merchantField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.itemTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.itemDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.merchantField.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.itemTitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.itemDescription.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.merchantField.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseProductResponseProto {
        PurchaseProductResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &PurchaseProductResponseProto| { &m.title },
                |m: &mut PurchaseProductResponseProto| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "itemTitle",
                |m: &PurchaseProductResponseProto| { &m.itemTitle },
                |m: &mut PurchaseProductResponseProto| { &mut m.itemTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "itemDescription",
                |m: &PurchaseProductResponseProto| { &m.itemDescription },
                |m: &mut PurchaseProductResponseProto| { &mut m.itemDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "merchantField",
                |m: &PurchaseProductResponseProto| { &m.merchantField },
                |m: &mut PurchaseProductResponseProto| { &mut m.merchantField },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseProductResponseProto>(
                "PurchaseProductResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseProductResponseProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseProductResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseProductResponseProto::new)
    }
}

impl ::protobuf::Clear for PurchaseProductResponseProto {
    fn clear(&mut self) {
        self.title.clear();
        self.itemTitle.clear();
        self.itemDescription.clear();
        self.merchantField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseProductResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseProductResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseResultProto {
    // message fields
    pub resultCode: ::std::option::Option<i32>,
    pub resultCodeMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseResultProto {
    fn default() -> &'a PurchaseResultProto {
        <PurchaseResultProto as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseResultProto {
    pub fn new() -> PurchaseResultProto {
        ::std::default::Default::default()
    }

    // optional int32 resultCode = 1;


    pub fn get_resultCode(&self) -> i32 {
        self.resultCode.unwrap_or(0)
    }

    // optional string resultCodeMessage = 2;


    pub fn get_resultCodeMessage(&self) -> &str {
        match self.resultCodeMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseResultProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.resultCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resultCodeMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resultCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.resultCodeMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resultCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.resultCodeMessage.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseResultProto {
        PurchaseResultProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "resultCode",
                |m: &PurchaseResultProto| { &m.resultCode },
                |m: &mut PurchaseResultProto| { &mut m.resultCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resultCodeMessage",
                |m: &PurchaseResultProto| { &m.resultCodeMessage },
                |m: &mut PurchaseResultProto| { &mut m.resultCodeMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseResultProto>(
                "PurchaseResultProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseResultProto {
        static instance: ::protobuf::rt::LazyV2<PurchaseResultProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseResultProto::new)
    }
}

impl ::protobuf::Clear for PurchaseResultProto {
    fn clear(&mut self) {
        self.resultCode = ::std::option::Option::None;
        self.resultCodeMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseResultProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseResultProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuerySuggestionProto {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub estimatedNumResults: ::std::option::Option<i32>,
    pub queryWeight: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySuggestionProto {
    fn default() -> &'a QuerySuggestionProto {
        <QuerySuggestionProto as ::protobuf::Message>::default_instance()
    }
}

impl QuerySuggestionProto {
    pub fn new() -> QuerySuggestionProto {
        ::std::default::Default::default()
    }

    // optional string query = 1;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 estimatedNumResults = 2;


    pub fn get_estimatedNumResults(&self) -> i32 {
        self.estimatedNumResults.unwrap_or(0)
    }

    // optional int32 queryWeight = 3;


    pub fn get_queryWeight(&self) -> i32 {
        self.queryWeight.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumResults = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.queryWeight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.estimatedNumResults {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queryWeight {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.estimatedNumResults {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queryWeight {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionProto {
        QuerySuggestionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QuerySuggestionProto| { &m.query },
                |m: &mut QuerySuggestionProto| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "estimatedNumResults",
                |m: &QuerySuggestionProto| { &m.estimatedNumResults },
                |m: &mut QuerySuggestionProto| { &mut m.estimatedNumResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "queryWeight",
                |m: &QuerySuggestionProto| { &m.queryWeight },
                |m: &mut QuerySuggestionProto| { &mut m.queryWeight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySuggestionProto>(
                "QuerySuggestionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionProto {
        static instance: ::protobuf::rt::LazyV2<QuerySuggestionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySuggestionProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionProto {
    fn clear(&mut self) {
        self.query.clear();
        self.estimatedNumResults = ::std::option::Option::None;
        self.queryWeight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuerySuggestionRequestProto {
    // message fields
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub requestType: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySuggestionRequestProto {
    fn default() -> &'a QuerySuggestionRequestProto {
        <QuerySuggestionRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl QuerySuggestionRequestProto {
    pub fn new() -> QuerySuggestionRequestProto {
        ::std::default::Default::default()
    }

    // optional string query = 1;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 requestType = 2;


    pub fn get_requestType(&self) -> i32 {
        self.requestType.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.requestType = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.requestType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.requestType {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionRequestProto {
        QuerySuggestionRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &QuerySuggestionRequestProto| { &m.query },
                |m: &mut QuerySuggestionRequestProto| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requestType",
                |m: &QuerySuggestionRequestProto| { &m.requestType },
                |m: &mut QuerySuggestionRequestProto| { &mut m.requestType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySuggestionRequestProto>(
                "QuerySuggestionRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionRequestProto {
        static instance: ::protobuf::rt::LazyV2<QuerySuggestionRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySuggestionRequestProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionRequestProto {
    fn clear(&mut self) {
        self.query.clear();
        self.requestType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuerySuggestionResponseProto {
    // message fields
    // suggestion: <group>
    pub estimatedNumAppSuggestions: ::std::option::Option<i32>,
    pub estimatedNumQuerySuggestions: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySuggestionResponseProto {
    fn default() -> &'a QuerySuggestionResponseProto {
        <QuerySuggestionResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl QuerySuggestionResponseProto {
    pub fn new() -> QuerySuggestionResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 estimatedNumAppSuggestions = 4;


    pub fn get_estimatedNumAppSuggestions(&self) -> i32 {
        self.estimatedNumAppSuggestions.unwrap_or(0)
    }

    // optional int32 estimatedNumQuerySuggestions = 5;


    pub fn get_estimatedNumQuerySuggestions(&self) -> i32 {
        self.estimatedNumQuerySuggestions.unwrap_or(0)
    }
}

impl ::protobuf::Message for QuerySuggestionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumAppSuggestions = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimatedNumQuerySuggestions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.estimatedNumAppSuggestions {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.estimatedNumQuerySuggestions {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.estimatedNumAppSuggestions {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.estimatedNumQuerySuggestions {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionResponseProto {
        QuerySuggestionResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "estimatedNumAppSuggestions",
                |m: &QuerySuggestionResponseProto| { &m.estimatedNumAppSuggestions },
                |m: &mut QuerySuggestionResponseProto| { &mut m.estimatedNumAppSuggestions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "estimatedNumQuerySuggestions",
                |m: &QuerySuggestionResponseProto| { &m.estimatedNumQuerySuggestions },
                |m: &mut QuerySuggestionResponseProto| { &mut m.estimatedNumQuerySuggestions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySuggestionResponseProto>(
                "QuerySuggestionResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionResponseProto {
        static instance: ::protobuf::rt::LazyV2<QuerySuggestionResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySuggestionResponseProto::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionResponseProto {
    fn clear(&mut self) {
        self.estimatedNumAppSuggestions = ::std::option::Option::None;
        self.estimatedNumQuerySuggestions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QuerySuggestionResponseProto_Suggestion {
    // message fields
    pub appSuggestion: ::protobuf::SingularPtrField<AppSuggestionProto>,
    pub querySuggestion: ::protobuf::SingularPtrField<QuerySuggestionProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySuggestionResponseProto_Suggestion {
    fn default() -> &'a QuerySuggestionResponseProto_Suggestion {
        <QuerySuggestionResponseProto_Suggestion as ::protobuf::Message>::default_instance()
    }
}

impl QuerySuggestionResponseProto_Suggestion {
    pub fn new() -> QuerySuggestionResponseProto_Suggestion {
        ::std::default::Default::default()
    }

    // optional .AppSuggestionProto appSuggestion = 2;


    pub fn get_appSuggestion(&self) -> &AppSuggestionProto {
        self.appSuggestion.as_ref().unwrap_or_else(|| <AppSuggestionProto as ::protobuf::Message>::default_instance())
    }

    // optional .QuerySuggestionProto querySuggestion = 3;


    pub fn get_querySuggestion(&self) -> &QuerySuggestionProto {
        self.querySuggestion.as_ref().unwrap_or_else(|| <QuerySuggestionProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for QuerySuggestionResponseProto_Suggestion {
    fn is_initialized(&self) -> bool {
        for v in &self.appSuggestion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appSuggestion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.querySuggestion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.appSuggestion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.querySuggestion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.appSuggestion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.querySuggestion.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySuggestionResponseProto_Suggestion {
        QuerySuggestionResponseProto_Suggestion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppSuggestionProto>>(
                "appSuggestion",
                |m: &QuerySuggestionResponseProto_Suggestion| { &m.appSuggestion },
                |m: &mut QuerySuggestionResponseProto_Suggestion| { &mut m.appSuggestion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionProto>>(
                "querySuggestion",
                |m: &QuerySuggestionResponseProto_Suggestion| { &m.querySuggestion },
                |m: &mut QuerySuggestionResponseProto_Suggestion| { &mut m.querySuggestion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuerySuggestionResponseProto_Suggestion>(
                "QuerySuggestionResponseProto.Suggestion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuerySuggestionResponseProto_Suggestion {
        static instance: ::protobuf::rt::LazyV2<QuerySuggestionResponseProto_Suggestion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySuggestionResponseProto_Suggestion::new)
    }
}

impl ::protobuf::Clear for QuerySuggestionResponseProto_Suggestion {
    fn clear(&mut self) {
        self.appSuggestion.clear();
        self.querySuggestion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuerySuggestionResponseProto_Suggestion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySuggestionResponseProto_Suggestion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateCommentRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub creatorId: ::protobuf::SingularField<::std::string::String>,
    pub commentRating: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateCommentRequestProto {
    fn default() -> &'a RateCommentRequestProto {
        <RateCommentRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RateCommentRequestProto {
    pub fn new() -> RateCommentRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string creatorId = 2;


    pub fn get_creatorId(&self) -> &str {
        match self.creatorId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 commentRating = 3;


    pub fn get_commentRating(&self) -> i32 {
        self.commentRating.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateCommentRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creatorId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.commentRating = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.creatorId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.commentRating {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.creatorId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.commentRating {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateCommentRequestProto {
        RateCommentRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &RateCommentRequestProto| { &m.assetId },
                |m: &mut RateCommentRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creatorId",
                |m: &RateCommentRequestProto| { &m.creatorId },
                |m: &mut RateCommentRequestProto| { &mut m.creatorId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "commentRating",
                |m: &RateCommentRequestProto| { &m.commentRating },
                |m: &mut RateCommentRequestProto| { &mut m.commentRating },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateCommentRequestProto>(
                "RateCommentRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateCommentRequestProto {
        static instance: ::protobuf::rt::LazyV2<RateCommentRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateCommentRequestProto::new)
    }
}

impl ::protobuf::Clear for RateCommentRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.creatorId.clear();
        self.commentRating = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateCommentRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateCommentRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateCommentResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateCommentResponseProto {
    fn default() -> &'a RateCommentResponseProto {
        <RateCommentResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RateCommentResponseProto {
    pub fn new() -> RateCommentResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateCommentResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateCommentResponseProto {
        RateCommentResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateCommentResponseProto>(
                "RateCommentResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateCommentResponseProto {
        static instance: ::protobuf::rt::LazyV2<RateCommentResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateCommentResponseProto::new)
    }
}

impl ::protobuf::Clear for RateCommentResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateCommentResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateCommentResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReconstructDatabaseRequestProto {
    // message fields
    pub retrieveFullHistory: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReconstructDatabaseRequestProto {
    fn default() -> &'a ReconstructDatabaseRequestProto {
        <ReconstructDatabaseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReconstructDatabaseRequestProto {
    pub fn new() -> ReconstructDatabaseRequestProto {
        ::std::default::Default::default()
    }

    // optional bool retrieveFullHistory = 1;


    pub fn get_retrieveFullHistory(&self) -> bool {
        self.retrieveFullHistory.unwrap_or(false)
    }
}

impl ::protobuf::Message for ReconstructDatabaseRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retrieveFullHistory = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.retrieveFullHistory {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.retrieveFullHistory {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReconstructDatabaseRequestProto {
        ReconstructDatabaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "retrieveFullHistory",
                |m: &ReconstructDatabaseRequestProto| { &m.retrieveFullHistory },
                |m: &mut ReconstructDatabaseRequestProto| { &mut m.retrieveFullHistory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReconstructDatabaseRequestProto>(
                "ReconstructDatabaseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReconstructDatabaseRequestProto {
        static instance: ::protobuf::rt::LazyV2<ReconstructDatabaseRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReconstructDatabaseRequestProto::new)
    }
}

impl ::protobuf::Clear for ReconstructDatabaseRequestProto {
    fn clear(&mut self) {
        self.retrieveFullHistory = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReconstructDatabaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReconstructDatabaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReconstructDatabaseResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<AssetIdentifierProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReconstructDatabaseResponseProto {
    fn default() -> &'a ReconstructDatabaseResponseProto {
        <ReconstructDatabaseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReconstructDatabaseResponseProto {
    pub fn new() -> ReconstructDatabaseResponseProto {
        ::std::default::Default::default()
    }

    // repeated .AssetIdentifierProto asset = 1;


    pub fn get_asset(&self) -> &[AssetIdentifierProto] {
        &self.asset
    }
}

impl ::protobuf::Message for ReconstructDatabaseResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.asset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReconstructDatabaseResponseProto {
        ReconstructDatabaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetIdentifierProto>>(
                "asset",
                |m: &ReconstructDatabaseResponseProto| { &m.asset },
                |m: &mut ReconstructDatabaseResponseProto| { &mut m.asset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReconstructDatabaseResponseProto>(
                "ReconstructDatabaseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReconstructDatabaseResponseProto {
        static instance: ::protobuf::rt::LazyV2<ReconstructDatabaseResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReconstructDatabaseResponseProto::new)
    }
}

impl ::protobuf::Clear for ReconstructDatabaseResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReconstructDatabaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReconstructDatabaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RefundRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefundRequestProto {
    fn default() -> &'a RefundRequestProto {
        <RefundRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RefundRequestProto {
    pub fn new() -> RefundRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RefundRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundRequestProto {
        RefundRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &RefundRequestProto| { &m.assetId },
                |m: &mut RefundRequestProto| { &mut m.assetId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RefundRequestProto>(
                "RefundRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefundRequestProto {
        static instance: ::protobuf::rt::LazyV2<RefundRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RefundRequestProto::new)
    }
}

impl ::protobuf::Clear for RefundRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RefundResponseProto {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub asset: ::protobuf::SingularPtrField<ExternalAssetProto>,
    pub resultDetail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefundResponseProto {
    fn default() -> &'a RefundResponseProto {
        <RefundResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RefundResponseProto {
    pub fn new() -> RefundResponseProto {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional .ExternalAssetProto asset = 2;


    pub fn get_asset(&self) -> &ExternalAssetProto {
        self.asset.as_ref().unwrap_or_else(|| <ExternalAssetProto as ::protobuf::Message>::default_instance())
    }

    // optional string resultDetail = 3;


    pub fn get_resultDetail(&self) -> &str {
        match self.resultDetail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RefundResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.asset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resultDetail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.asset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resultDetail.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.asset.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resultDetail.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefundResponseProto {
        RefundResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &RefundResponseProto| { &m.result },
                |m: &mut RefundResponseProto| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExternalAssetProto>>(
                "asset",
                |m: &RefundResponseProto| { &m.asset },
                |m: &mut RefundResponseProto| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resultDetail",
                |m: &RefundResponseProto| { &m.resultDetail },
                |m: &mut RefundResponseProto| { &mut m.resultDetail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RefundResponseProto>(
                "RefundResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefundResponseProto {
        static instance: ::protobuf::rt::LazyV2<RefundResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RefundResponseProto::new)
    }
}

impl ::protobuf::Clear for RefundResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.asset.clear();
        self.resultDetail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefundResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefundResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RemoveAssetRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveAssetRequestProto {
    fn default() -> &'a RemoveAssetRequestProto {
        <RemoveAssetRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAssetRequestProto {
    pub fn new() -> RemoveAssetRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RemoveAssetRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveAssetRequestProto {
        RemoveAssetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &RemoveAssetRequestProto| { &m.assetId },
                |m: &mut RemoveAssetRequestProto| { &mut m.assetId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveAssetRequestProto>(
                "RemoveAssetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveAssetRequestProto {
        static instance: ::protobuf::rt::LazyV2<RemoveAssetRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveAssetRequestProto::new)
    }
}

impl ::protobuf::Clear for RemoveAssetRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveAssetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveAssetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RequestPropertiesProto {
    // message fields
    pub userAuthToken: ::protobuf::SingularField<::std::string::String>,
    pub userAuthTokenSecure: ::std::option::Option<bool>,
    pub softwareVersion: ::std::option::Option<i32>,
    pub aid: ::protobuf::SingularField<::std::string::String>,
    pub productNameAndVersion: ::protobuf::SingularField<::std::string::String>,
    pub userLanguage: ::protobuf::SingularField<::std::string::String>,
    pub userCountry: ::protobuf::SingularField<::std::string::String>,
    pub operatorName: ::protobuf::SingularField<::std::string::String>,
    pub simOperatorName: ::protobuf::SingularField<::std::string::String>,
    pub operatorNumericName: ::protobuf::SingularField<::std::string::String>,
    pub simOperatorNumericName: ::protobuf::SingularField<::std::string::String>,
    pub clientId: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestPropertiesProto {
    fn default() -> &'a RequestPropertiesProto {
        <RequestPropertiesProto as ::protobuf::Message>::default_instance()
    }
}

impl RequestPropertiesProto {
    pub fn new() -> RequestPropertiesProto {
        ::std::default::Default::default()
    }

    // optional string userAuthToken = 1;


    pub fn get_userAuthToken(&self) -> &str {
        match self.userAuthToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool userAuthTokenSecure = 2;


    pub fn get_userAuthTokenSecure(&self) -> bool {
        self.userAuthTokenSecure.unwrap_or(false)
    }

    // optional int32 softwareVersion = 3;


    pub fn get_softwareVersion(&self) -> i32 {
        self.softwareVersion.unwrap_or(0)
    }

    // optional string aid = 4;


    pub fn get_aid(&self) -> &str {
        match self.aid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string productNameAndVersion = 5;


    pub fn get_productNameAndVersion(&self) -> &str {
        match self.productNameAndVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userLanguage = 6;


    pub fn get_userLanguage(&self) -> &str {
        match self.userLanguage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userCountry = 7;


    pub fn get_userCountry(&self) -> &str {
        match self.userCountry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string operatorName = 8;


    pub fn get_operatorName(&self) -> &str {
        match self.operatorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string simOperatorName = 9;


    pub fn get_simOperatorName(&self) -> &str {
        match self.simOperatorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string operatorNumericName = 10;


    pub fn get_operatorNumericName(&self) -> &str {
        match self.operatorNumericName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string simOperatorNumericName = 11;


    pub fn get_simOperatorNumericName(&self) -> &str {
        match self.simOperatorNumericName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string clientId = 12;


    pub fn get_clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string loggingId = 13;


    pub fn get_loggingId(&self) -> &str {
        match self.loggingId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RequestPropertiesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userAuthToken)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.userAuthTokenSecure = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.softwareVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.aid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.productNameAndVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userLanguage)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userCountry)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatorName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simOperatorName)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatorNumericName)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simOperatorNumericName)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientId)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loggingId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.userAuthToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.userAuthTokenSecure {
            my_size += 2;
        }
        if let Some(v) = self.softwareVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.aid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.productNameAndVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.userLanguage.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.userCountry.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.operatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.simOperatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.operatorNumericName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.simOperatorNumericName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.userAuthToken.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.userAuthTokenSecure {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.softwareVersion {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.aid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.productNameAndVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.userLanguage.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.userCountry.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.operatorName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.simOperatorName.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.operatorNumericName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.simOperatorNumericName.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.clientId.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.loggingId.as_ref() {
            os.write_string(13, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestPropertiesProto {
        RequestPropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userAuthToken",
                |m: &RequestPropertiesProto| { &m.userAuthToken },
                |m: &mut RequestPropertiesProto| { &mut m.userAuthToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "userAuthTokenSecure",
                |m: &RequestPropertiesProto| { &m.userAuthTokenSecure },
                |m: &mut RequestPropertiesProto| { &mut m.userAuthTokenSecure },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "softwareVersion",
                |m: &RequestPropertiesProto| { &m.softwareVersion },
                |m: &mut RequestPropertiesProto| { &mut m.softwareVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "aid",
                |m: &RequestPropertiesProto| { &m.aid },
                |m: &mut RequestPropertiesProto| { &mut m.aid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "productNameAndVersion",
                |m: &RequestPropertiesProto| { &m.productNameAndVersion },
                |m: &mut RequestPropertiesProto| { &mut m.productNameAndVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userLanguage",
                |m: &RequestPropertiesProto| { &m.userLanguage },
                |m: &mut RequestPropertiesProto| { &mut m.userLanguage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userCountry",
                |m: &RequestPropertiesProto| { &m.userCountry },
                |m: &mut RequestPropertiesProto| { &mut m.userCountry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operatorName",
                |m: &RequestPropertiesProto| { &m.operatorName },
                |m: &mut RequestPropertiesProto| { &mut m.operatorName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "simOperatorName",
                |m: &RequestPropertiesProto| { &m.simOperatorName },
                |m: &mut RequestPropertiesProto| { &mut m.simOperatorName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operatorNumericName",
                |m: &RequestPropertiesProto| { &m.operatorNumericName },
                |m: &mut RequestPropertiesProto| { &mut m.operatorNumericName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "simOperatorNumericName",
                |m: &RequestPropertiesProto| { &m.simOperatorNumericName },
                |m: &mut RequestPropertiesProto| { &mut m.simOperatorNumericName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientId",
                |m: &RequestPropertiesProto| { &m.clientId },
                |m: &mut RequestPropertiesProto| { &mut m.clientId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loggingId",
                |m: &RequestPropertiesProto| { &m.loggingId },
                |m: &mut RequestPropertiesProto| { &mut m.loggingId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestPropertiesProto>(
                "RequestPropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestPropertiesProto {
        static instance: ::protobuf::rt::LazyV2<RequestPropertiesProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestPropertiesProto::new)
    }
}

impl ::protobuf::Clear for RequestPropertiesProto {
    fn clear(&mut self) {
        self.userAuthToken.clear();
        self.userAuthTokenSecure = ::std::option::Option::None;
        self.softwareVersion = ::std::option::Option::None;
        self.aid.clear();
        self.productNameAndVersion.clear();
        self.userLanguage.clear();
        self.userCountry.clear();
        self.operatorName.clear();
        self.simOperatorName.clear();
        self.operatorNumericName.clear();
        self.simOperatorNumericName.clear();
        self.clientId.clear();
        self.loggingId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestPropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPropertiesProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RequestProto {
    // message fields
    pub requestProperties: ::protobuf::SingularPtrField<RequestPropertiesProto>,
    // request: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestProto {
    fn default() -> &'a RequestProto {
        <RequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RequestProto {
    pub fn new() -> RequestProto {
        ::std::default::Default::default()
    }

    // optional .RequestPropertiesProto requestProperties = 1;


    pub fn get_requestProperties(&self) -> &RequestPropertiesProto {
        self.requestProperties.as_ref().unwrap_or_else(|| <RequestPropertiesProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.requestProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requestProperties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requestProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requestProperties.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestProto {
        RequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestPropertiesProto>>(
                "requestProperties",
                |m: &RequestProto| { &m.requestProperties },
                |m: &mut RequestProto| { &mut m.requestProperties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestProto>(
                "RequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestProto {
        static instance: ::protobuf::rt::LazyV2<RequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestProto::new)
    }
}

impl ::protobuf::Clear for RequestProto {
    fn clear(&mut self) {
        self.requestProperties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RequestProto_Request {
    // message fields
    pub requestSpecificProperties: ::protobuf::SingularPtrField<RequestSpecificPropertiesProto>,
    pub assetRequest: ::protobuf::SingularPtrField<AssetsRequestProto>,
    pub commentsRequest: ::protobuf::SingularPtrField<CommentsRequestProto>,
    pub modifyCommentRequest: ::protobuf::SingularPtrField<ModifyCommentRequestProto>,
    pub purchasePostRequest: ::protobuf::SingularPtrField<PurchasePostRequestProto>,
    pub purchaseOrderRequest: ::protobuf::SingularPtrField<PurchaseOrderRequestProto>,
    pub contentSyncRequest: ::protobuf::SingularPtrField<ContentSyncRequestProto>,
    pub getAssetRequest: ::protobuf::SingularPtrField<GetAssetRequestProto>,
    pub getImageRequest: ::protobuf::SingularPtrField<GetImageRequestProto>,
    pub refundRequest: ::protobuf::SingularPtrField<RefundRequestProto>,
    pub purchaseMetadataRequest: ::protobuf::SingularPtrField<PurchaseMetadataRequestProto>,
    pub subCategoriesRequest: ::protobuf::SingularPtrField<GetSubCategoriesRequestProto>,
    pub uninstallReasonRequest: ::protobuf::SingularPtrField<UninstallReasonRequestProto>,
    pub rateCommentRequest: ::protobuf::SingularPtrField<RateCommentRequestProto>,
    pub checkLicenseRequest: ::protobuf::SingularPtrField<CheckLicenseRequestProto>,
    pub getMarketMetadataRequest: ::protobuf::SingularPtrField<GetMarketMetadataRequestProto>,
    pub getCategoriesRequest: ::protobuf::SingularPtrField<GetCategoriesRequestProto>,
    pub getCarrierInfoRequest: ::protobuf::SingularPtrField<GetCarrierInfoRequestProto>,
    pub removeAssetRequest: ::protobuf::SingularPtrField<RemoveAssetRequestProto>,
    pub restoreApplicationsRequest: ::protobuf::SingularPtrField<RestoreApplicationsRequestProto>,
    pub querySuggestionRequest: ::protobuf::SingularPtrField<QuerySuggestionRequestProto>,
    pub billingEventRequest: ::protobuf::SingularPtrField<BillingEventRequestProto>,
    pub paypalPreapprovalRequest: ::protobuf::SingularPtrField<PaypalPreapprovalRequestProto>,
    pub paypalPreapprovalDetailsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsRequestProto>,
    pub paypalCreateAccountRequest: ::protobuf::SingularPtrField<PaypalCreateAccountRequestProto>,
    pub paypalPreapprovalCredentialsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsRequestProto>,
    pub inAppRestoreTransactionsRequest: ::protobuf::SingularPtrField<InAppRestoreTransactionsRequestProto>,
    pub inAppPurchaseInformationRequest: ::protobuf::SingularPtrField<InAppPurchaseInformationRequestProto>,
    pub checkForNotificationsRequest: ::protobuf::SingularPtrField<CheckForNotificationsRequestProto>,
    pub ackNotificationsRequest: ::protobuf::SingularPtrField<AckNotificationsRequestProto>,
    pub purchaseProductRequest: ::protobuf::SingularPtrField<PurchaseProductRequestProto>,
    pub reconstructDatabaseRequest: ::protobuf::SingularPtrField<ReconstructDatabaseRequestProto>,
    pub paypalMassageAddressRequest: ::protobuf::SingularPtrField<PaypalMassageAddressRequestProto>,
    pub getAddressSnippetRequest: ::protobuf::SingularPtrField<GetAddressSnippetRequestProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestProto_Request {
    fn default() -> &'a RequestProto_Request {
        <RequestProto_Request as ::protobuf::Message>::default_instance()
    }
}

impl RequestProto_Request {
    pub fn new() -> RequestProto_Request {
        ::std::default::Default::default()
    }

    // optional .RequestSpecificPropertiesProto requestSpecificProperties = 3;


    pub fn get_requestSpecificProperties(&self) -> &RequestSpecificPropertiesProto {
        self.requestSpecificProperties.as_ref().unwrap_or_else(|| <RequestSpecificPropertiesProto as ::protobuf::Message>::default_instance())
    }

    // optional .AssetsRequestProto assetRequest = 4;


    pub fn get_assetRequest(&self) -> &AssetsRequestProto {
        self.assetRequest.as_ref().unwrap_or_else(|| <AssetsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CommentsRequestProto commentsRequest = 5;


    pub fn get_commentsRequest(&self) -> &CommentsRequestProto {
        self.commentsRequest.as_ref().unwrap_or_else(|| <CommentsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ModifyCommentRequestProto modifyCommentRequest = 6;


    pub fn get_modifyCommentRequest(&self) -> &ModifyCommentRequestProto {
        self.modifyCommentRequest.as_ref().unwrap_or_else(|| <ModifyCommentRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchasePostRequestProto purchasePostRequest = 7;


    pub fn get_purchasePostRequest(&self) -> &PurchasePostRequestProto {
        self.purchasePostRequest.as_ref().unwrap_or_else(|| <PurchasePostRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseOrderRequestProto purchaseOrderRequest = 8;


    pub fn get_purchaseOrderRequest(&self) -> &PurchaseOrderRequestProto {
        self.purchaseOrderRequest.as_ref().unwrap_or_else(|| <PurchaseOrderRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ContentSyncRequestProto contentSyncRequest = 9;


    pub fn get_contentSyncRequest(&self) -> &ContentSyncRequestProto {
        self.contentSyncRequest.as_ref().unwrap_or_else(|| <ContentSyncRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAssetRequestProto getAssetRequest = 10;


    pub fn get_getAssetRequest(&self) -> &GetAssetRequestProto {
        self.getAssetRequest.as_ref().unwrap_or_else(|| <GetAssetRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetImageRequestProto getImageRequest = 11;


    pub fn get_getImageRequest(&self) -> &GetImageRequestProto {
        self.getImageRequest.as_ref().unwrap_or_else(|| <GetImageRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RefundRequestProto refundRequest = 12;


    pub fn get_refundRequest(&self) -> &RefundRequestProto {
        self.refundRequest.as_ref().unwrap_or_else(|| <RefundRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseMetadataRequestProto purchaseMetadataRequest = 13;


    pub fn get_purchaseMetadataRequest(&self) -> &PurchaseMetadataRequestProto {
        self.purchaseMetadataRequest.as_ref().unwrap_or_else(|| <PurchaseMetadataRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetSubCategoriesRequestProto subCategoriesRequest = 14;


    pub fn get_subCategoriesRequest(&self) -> &GetSubCategoriesRequestProto {
        self.subCategoriesRequest.as_ref().unwrap_or_else(|| <GetSubCategoriesRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .UninstallReasonRequestProto uninstallReasonRequest = 16;


    pub fn get_uninstallReasonRequest(&self) -> &UninstallReasonRequestProto {
        self.uninstallReasonRequest.as_ref().unwrap_or_else(|| <UninstallReasonRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RateCommentRequestProto rateCommentRequest = 17;


    pub fn get_rateCommentRequest(&self) -> &RateCommentRequestProto {
        self.rateCommentRequest.as_ref().unwrap_or_else(|| <RateCommentRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckLicenseRequestProto checkLicenseRequest = 18;


    pub fn get_checkLicenseRequest(&self) -> &CheckLicenseRequestProto {
        self.checkLicenseRequest.as_ref().unwrap_or_else(|| <CheckLicenseRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetMarketMetadataRequestProto getMarketMetadataRequest = 19;


    pub fn get_getMarketMetadataRequest(&self) -> &GetMarketMetadataRequestProto {
        self.getMarketMetadataRequest.as_ref().unwrap_or_else(|| <GetMarketMetadataRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCategoriesRequestProto getCategoriesRequest = 21;


    pub fn get_getCategoriesRequest(&self) -> &GetCategoriesRequestProto {
        self.getCategoriesRequest.as_ref().unwrap_or_else(|| <GetCategoriesRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCarrierInfoRequestProto getCarrierInfoRequest = 22;


    pub fn get_getCarrierInfoRequest(&self) -> &GetCarrierInfoRequestProto {
        self.getCarrierInfoRequest.as_ref().unwrap_or_else(|| <GetCarrierInfoRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RemoveAssetRequestProto removeAssetRequest = 23;


    pub fn get_removeAssetRequest(&self) -> &RemoveAssetRequestProto {
        self.removeAssetRequest.as_ref().unwrap_or_else(|| <RemoveAssetRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RestoreApplicationsRequestProto restoreApplicationsRequest = 24;


    pub fn get_restoreApplicationsRequest(&self) -> &RestoreApplicationsRequestProto {
        self.restoreApplicationsRequest.as_ref().unwrap_or_else(|| <RestoreApplicationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .QuerySuggestionRequestProto querySuggestionRequest = 25;


    pub fn get_querySuggestionRequest(&self) -> &QuerySuggestionRequestProto {
        self.querySuggestionRequest.as_ref().unwrap_or_else(|| <QuerySuggestionRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .BillingEventRequestProto billingEventRequest = 26;


    pub fn get_billingEventRequest(&self) -> &BillingEventRequestProto {
        self.billingEventRequest.as_ref().unwrap_or_else(|| <BillingEventRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalRequestProto paypalPreapprovalRequest = 27;


    pub fn get_paypalPreapprovalRequest(&self) -> &PaypalPreapprovalRequestProto {
        self.paypalPreapprovalRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalDetailsRequestProto paypalPreapprovalDetailsRequest = 28;


    pub fn get_paypalPreapprovalDetailsRequest(&self) -> &PaypalPreapprovalDetailsRequestProto {
        self.paypalPreapprovalDetailsRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalDetailsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalCreateAccountRequestProto paypalCreateAccountRequest = 29;


    pub fn get_paypalCreateAccountRequest(&self) -> &PaypalCreateAccountRequestProto {
        self.paypalCreateAccountRequest.as_ref().unwrap_or_else(|| <PaypalCreateAccountRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalCredentialsRequestProto paypalPreapprovalCredentialsRequest = 30;


    pub fn get_paypalPreapprovalCredentialsRequest(&self) -> &PaypalPreapprovalCredentialsRequestProto {
        self.paypalPreapprovalCredentialsRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalCredentialsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppRestoreTransactionsRequestProto inAppRestoreTransactionsRequest = 31;


    pub fn get_inAppRestoreTransactionsRequest(&self) -> &InAppRestoreTransactionsRequestProto {
        self.inAppRestoreTransactionsRequest.as_ref().unwrap_or_else(|| <InAppRestoreTransactionsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppPurchaseInformationRequestProto inAppPurchaseInformationRequest = 32;


    pub fn get_inAppPurchaseInformationRequest(&self) -> &InAppPurchaseInformationRequestProto {
        self.inAppPurchaseInformationRequest.as_ref().unwrap_or_else(|| <InAppPurchaseInformationRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckForNotificationsRequestProto checkForNotificationsRequest = 33;


    pub fn get_checkForNotificationsRequest(&self) -> &CheckForNotificationsRequestProto {
        self.checkForNotificationsRequest.as_ref().unwrap_or_else(|| <CheckForNotificationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .AckNotificationsRequestProto ackNotificationsRequest = 34;


    pub fn get_ackNotificationsRequest(&self) -> &AckNotificationsRequestProto {
        self.ackNotificationsRequest.as_ref().unwrap_or_else(|| <AckNotificationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseProductRequestProto purchaseProductRequest = 35;


    pub fn get_purchaseProductRequest(&self) -> &PurchaseProductRequestProto {
        self.purchaseProductRequest.as_ref().unwrap_or_else(|| <PurchaseProductRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ReconstructDatabaseRequestProto reconstructDatabaseRequest = 36;


    pub fn get_reconstructDatabaseRequest(&self) -> &ReconstructDatabaseRequestProto {
        self.reconstructDatabaseRequest.as_ref().unwrap_or_else(|| <ReconstructDatabaseRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalMassageAddressRequestProto paypalMassageAddressRequest = 37;


    pub fn get_paypalMassageAddressRequest(&self) -> &PaypalMassageAddressRequestProto {
        self.paypalMassageAddressRequest.as_ref().unwrap_or_else(|| <PaypalMassageAddressRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAddressSnippetRequestProto getAddressSnippetRequest = 38;


    pub fn get_getAddressSnippetRequest(&self) -> &GetAddressSnippetRequestProto {
        self.getAddressSnippetRequest.as_ref().unwrap_or_else(|| <GetAddressSnippetRequestProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RequestProto_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.requestSpecificProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.removeAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppPurchaseInformationRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requestSpecificProperties)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assetRequest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commentsRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyCommentRequest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchasePostRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseOrderRequest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contentSyncRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAssetRequest)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getImageRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refundRequest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseMetadataRequest)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subCategoriesRequest)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uninstallReasonRequest)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rateCommentRequest)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkLicenseRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getMarketMetadataRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCategoriesRequest)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCarrierInfoRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.removeAssetRequest)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restoreApplicationsRequest)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.querySuggestionRequest)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingEventRequest)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalRequest)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalDetailsRequest)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalCreateAccountRequest)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalCredentialsRequest)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppRestoreTransactionsRequest)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppPurchaseInformationRequest)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkForNotificationsRequest)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackNotificationsRequest)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseProductRequest)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reconstructDatabaseRequest)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalMassageAddressRequest)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAddressSnippetRequest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requestSpecificProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commentsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchasePostRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseOrderRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contentSyncRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getImageRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refundRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uninstallReasonRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rateCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkLicenseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getMarketMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCarrierInfoRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.removeAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restoreApplicationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.querySuggestionRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingEventRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalCreateAccountRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppPurchaseInformationRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkForNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseProductRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reconstructDatabaseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalMassageAddressRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAddressSnippetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requestSpecificProperties.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assetRequest.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commentsRequest.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyCommentRequest.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchasePostRequest.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseOrderRequest.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contentSyncRequest.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAssetRequest.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getImageRequest.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refundRequest.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseMetadataRequest.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subCategoriesRequest.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uninstallReasonRequest.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rateCommentRequest.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkLicenseRequest.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getMarketMetadataRequest.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCategoriesRequest.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCarrierInfoRequest.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.removeAssetRequest.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restoreApplicationsRequest.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.querySuggestionRequest.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingEventRequest.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalRequest.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalCreateAccountRequest.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsRequest.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppPurchaseInformationRequest.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkForNotificationsRequest.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackNotificationsRequest.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseProductRequest.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reconstructDatabaseRequest.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalMassageAddressRequest.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAddressSnippetRequest.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestProto_Request {
        RequestProto_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestSpecificPropertiesProto>>(
                "requestSpecificProperties",
                |m: &RequestProto_Request| { &m.requestSpecificProperties },
                |m: &mut RequestProto_Request| { &mut m.requestSpecificProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsRequestProto>>(
                "assetRequest",
                |m: &RequestProto_Request| { &m.assetRequest },
                |m: &mut RequestProto_Request| { &mut m.assetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsRequestProto>>(
                "commentsRequest",
                |m: &RequestProto_Request| { &m.commentsRequest },
                |m: &mut RequestProto_Request| { &mut m.commentsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentRequestProto>>(
                "modifyCommentRequest",
                |m: &RequestProto_Request| { &m.modifyCommentRequest },
                |m: &mut RequestProto_Request| { &mut m.modifyCommentRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostRequestProto>>(
                "purchasePostRequest",
                |m: &RequestProto_Request| { &m.purchasePostRequest },
                |m: &mut RequestProto_Request| { &mut m.purchasePostRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderRequestProto>>(
                "purchaseOrderRequest",
                |m: &RequestProto_Request| { &m.purchaseOrderRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseOrderRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncRequestProto>>(
                "contentSyncRequest",
                |m: &RequestProto_Request| { &m.contentSyncRequest },
                |m: &mut RequestProto_Request| { &mut m.contentSyncRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetRequestProto>>(
                "getAssetRequest",
                |m: &RequestProto_Request| { &m.getAssetRequest },
                |m: &mut RequestProto_Request| { &mut m.getAssetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageRequestProto>>(
                "getImageRequest",
                |m: &RequestProto_Request| { &m.getImageRequest },
                |m: &mut RequestProto_Request| { &mut m.getImageRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundRequestProto>>(
                "refundRequest",
                |m: &RequestProto_Request| { &m.refundRequest },
                |m: &mut RequestProto_Request| { &mut m.refundRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataRequestProto>>(
                "purchaseMetadataRequest",
                |m: &RequestProto_Request| { &m.purchaseMetadataRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseMetadataRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesRequestProto>>(
                "subCategoriesRequest",
                |m: &RequestProto_Request| { &m.subCategoriesRequest },
                |m: &mut RequestProto_Request| { &mut m.subCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonRequestProto>>(
                "uninstallReasonRequest",
                |m: &RequestProto_Request| { &m.uninstallReasonRequest },
                |m: &mut RequestProto_Request| { &mut m.uninstallReasonRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentRequestProto>>(
                "rateCommentRequest",
                |m: &RequestProto_Request| { &m.rateCommentRequest },
                |m: &mut RequestProto_Request| { &mut m.rateCommentRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseRequestProto>>(
                "checkLicenseRequest",
                |m: &RequestProto_Request| { &m.checkLicenseRequest },
                |m: &mut RequestProto_Request| { &mut m.checkLicenseRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataRequestProto>>(
                "getMarketMetadataRequest",
                |m: &RequestProto_Request| { &m.getMarketMetadataRequest },
                |m: &mut RequestProto_Request| { &mut m.getMarketMetadataRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesRequestProto>>(
                "getCategoriesRequest",
                |m: &RequestProto_Request| { &m.getCategoriesRequest },
                |m: &mut RequestProto_Request| { &mut m.getCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoRequestProto>>(
                "getCarrierInfoRequest",
                |m: &RequestProto_Request| { &m.getCarrierInfoRequest },
                |m: &mut RequestProto_Request| { &mut m.getCarrierInfoRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoveAssetRequestProto>>(
                "removeAssetRequest",
                |m: &RequestProto_Request| { &m.removeAssetRequest },
                |m: &mut RequestProto_Request| { &mut m.removeAssetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsRequestProto>>(
                "restoreApplicationsRequest",
                |m: &RequestProto_Request| { &m.restoreApplicationsRequest },
                |m: &mut RequestProto_Request| { &mut m.restoreApplicationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionRequestProto>>(
                "querySuggestionRequest",
                |m: &RequestProto_Request| { &m.querySuggestionRequest },
                |m: &mut RequestProto_Request| { &mut m.querySuggestionRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventRequestProto>>(
                "billingEventRequest",
                |m: &RequestProto_Request| { &m.billingEventRequest },
                |m: &mut RequestProto_Request| { &mut m.billingEventRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalRequestProto>>(
                "paypalPreapprovalRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsRequestProto>>(
                "paypalPreapprovalDetailsRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalDetailsRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalDetailsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountRequestProto>>(
                "paypalCreateAccountRequest",
                |m: &RequestProto_Request| { &m.paypalCreateAccountRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalCreateAccountRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsRequestProto>>(
                "paypalPreapprovalCredentialsRequest",
                |m: &RequestProto_Request| { &m.paypalPreapprovalCredentialsRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalPreapprovalCredentialsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsRequestProto>>(
                "inAppRestoreTransactionsRequest",
                |m: &RequestProto_Request| { &m.inAppRestoreTransactionsRequest },
                |m: &mut RequestProto_Request| { &mut m.inAppRestoreTransactionsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationRequestProto>>(
                "inAppPurchaseInformationRequest",
                |m: &RequestProto_Request| { &m.inAppPurchaseInformationRequest },
                |m: &mut RequestProto_Request| { &mut m.inAppPurchaseInformationRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsRequestProto>>(
                "checkForNotificationsRequest",
                |m: &RequestProto_Request| { &m.checkForNotificationsRequest },
                |m: &mut RequestProto_Request| { &mut m.checkForNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsRequestProto>>(
                "ackNotificationsRequest",
                |m: &RequestProto_Request| { &m.ackNotificationsRequest },
                |m: &mut RequestProto_Request| { &mut m.ackNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductRequestProto>>(
                "purchaseProductRequest",
                |m: &RequestProto_Request| { &m.purchaseProductRequest },
                |m: &mut RequestProto_Request| { &mut m.purchaseProductRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseRequestProto>>(
                "reconstructDatabaseRequest",
                |m: &RequestProto_Request| { &m.reconstructDatabaseRequest },
                |m: &mut RequestProto_Request| { &mut m.reconstructDatabaseRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressRequestProto>>(
                "paypalMassageAddressRequest",
                |m: &RequestProto_Request| { &m.paypalMassageAddressRequest },
                |m: &mut RequestProto_Request| { &mut m.paypalMassageAddressRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetRequestProto>>(
                "getAddressSnippetRequest",
                |m: &RequestProto_Request| { &m.getAddressSnippetRequest },
                |m: &mut RequestProto_Request| { &mut m.getAddressSnippetRequest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestProto_Request>(
                "RequestProto.Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestProto_Request {
        static instance: ::protobuf::rt::LazyV2<RequestProto_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestProto_Request::new)
    }
}

impl ::protobuf::Clear for RequestProto_Request {
    fn clear(&mut self) {
        self.requestSpecificProperties.clear();
        self.assetRequest.clear();
        self.commentsRequest.clear();
        self.modifyCommentRequest.clear();
        self.purchasePostRequest.clear();
        self.purchaseOrderRequest.clear();
        self.contentSyncRequest.clear();
        self.getAssetRequest.clear();
        self.getImageRequest.clear();
        self.refundRequest.clear();
        self.purchaseMetadataRequest.clear();
        self.subCategoriesRequest.clear();
        self.uninstallReasonRequest.clear();
        self.rateCommentRequest.clear();
        self.checkLicenseRequest.clear();
        self.getMarketMetadataRequest.clear();
        self.getCategoriesRequest.clear();
        self.getCarrierInfoRequest.clear();
        self.removeAssetRequest.clear();
        self.restoreApplicationsRequest.clear();
        self.querySuggestionRequest.clear();
        self.billingEventRequest.clear();
        self.paypalPreapprovalRequest.clear();
        self.paypalPreapprovalDetailsRequest.clear();
        self.paypalCreateAccountRequest.clear();
        self.paypalPreapprovalCredentialsRequest.clear();
        self.inAppRestoreTransactionsRequest.clear();
        self.inAppPurchaseInformationRequest.clear();
        self.checkForNotificationsRequest.clear();
        self.ackNotificationsRequest.clear();
        self.purchaseProductRequest.clear();
        self.reconstructDatabaseRequest.clear();
        self.paypalMassageAddressRequest.clear();
        self.getAddressSnippetRequest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestProto_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestProto_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RequestSpecificPropertiesProto {
    // message fields
    pub ifNoneMatch: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestSpecificPropertiesProto {
    fn default() -> &'a RequestSpecificPropertiesProto {
        <RequestSpecificPropertiesProto as ::protobuf::Message>::default_instance()
    }
}

impl RequestSpecificPropertiesProto {
    pub fn new() -> RequestSpecificPropertiesProto {
        ::std::default::Default::default()
    }

    // optional string ifNoneMatch = 1;


    pub fn get_ifNoneMatch(&self) -> &str {
        match self.ifNoneMatch.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RequestSpecificPropertiesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ifNoneMatch)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ifNoneMatch.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ifNoneMatch.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestSpecificPropertiesProto {
        RequestSpecificPropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ifNoneMatch",
                |m: &RequestSpecificPropertiesProto| { &m.ifNoneMatch },
                |m: &mut RequestSpecificPropertiesProto| { &mut m.ifNoneMatch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestSpecificPropertiesProto>(
                "RequestSpecificPropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestSpecificPropertiesProto {
        static instance: ::protobuf::rt::LazyV2<RequestSpecificPropertiesProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestSpecificPropertiesProto::new)
    }
}

impl ::protobuf::Clear for RequestSpecificPropertiesProto {
    fn clear(&mut self) {
        self.ifNoneMatch.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestSpecificPropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSpecificPropertiesProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponsePropertiesProto {
    // message fields
    pub result: ::std::option::Option<i32>,
    pub maxAge: ::std::option::Option<i32>,
    pub etag: ::protobuf::SingularField<::std::string::String>,
    pub serverVersion: ::std::option::Option<i32>,
    pub maxAgeConsumable: ::std::option::Option<i32>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponsePropertiesProto {
    fn default() -> &'a ResponsePropertiesProto {
        <ResponsePropertiesProto as ::protobuf::Message>::default_instance()
    }
}

impl ResponsePropertiesProto {
    pub fn new() -> ResponsePropertiesProto {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    // optional int32 maxAge = 2;


    pub fn get_maxAge(&self) -> i32 {
        self.maxAge.unwrap_or(0)
    }

    // optional string etag = 3;


    pub fn get_etag(&self) -> &str {
        match self.etag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 serverVersion = 4;


    pub fn get_serverVersion(&self) -> i32 {
        self.serverVersion.unwrap_or(0)
    }

    // optional int32 maxAgeConsumable = 6;


    pub fn get_maxAgeConsumable(&self) -> i32 {
        self.maxAgeConsumable.unwrap_or(0)
    }

    // optional string errorMessage = 7;


    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .InputValidationError errorInputField = 8;


    pub fn get_errorInputField(&self) -> &[InputValidationError] {
        &self.errorInputField
    }
}

impl ::protobuf::Message for ResponsePropertiesProto {
    fn is_initialized(&self) -> bool {
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxAge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.etag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.serverVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxAgeConsumable = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errorInputField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxAge {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.etag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.serverVersion {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxAgeConsumable {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maxAge {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.etag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.serverVersion {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maxAgeConsumable {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.errorInputField {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponsePropertiesProto {
        ResponsePropertiesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &ResponsePropertiesProto| { &m.result },
                |m: &mut ResponsePropertiesProto| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxAge",
                |m: &ResponsePropertiesProto| { &m.maxAge },
                |m: &mut ResponsePropertiesProto| { &mut m.maxAge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &ResponsePropertiesProto| { &m.etag },
                |m: &mut ResponsePropertiesProto| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "serverVersion",
                |m: &ResponsePropertiesProto| { &m.serverVersion },
                |m: &mut ResponsePropertiesProto| { &mut m.serverVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxAgeConsumable",
                |m: &ResponsePropertiesProto| { &m.maxAgeConsumable },
                |m: &mut ResponsePropertiesProto| { &mut m.maxAgeConsumable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessage",
                |m: &ResponsePropertiesProto| { &m.errorMessage },
                |m: &mut ResponsePropertiesProto| { &mut m.errorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &ResponsePropertiesProto| { &m.errorInputField },
                |m: &mut ResponsePropertiesProto| { &mut m.errorInputField },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponsePropertiesProto>(
                "ResponsePropertiesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponsePropertiesProto {
        static instance: ::protobuf::rt::LazyV2<ResponsePropertiesProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponsePropertiesProto::new)
    }
}

impl ::protobuf::Clear for ResponsePropertiesProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.maxAge = ::std::option::Option::None;
        self.etag.clear();
        self.serverVersion = ::std::option::Option::None;
        self.maxAgeConsumable = ::std::option::Option::None;
        self.errorMessage.clear();
        self.errorInputField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponsePropertiesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponsePropertiesProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponseProto {
    // message fields
    // response: <group>
    pub pendingNotifications: ::protobuf::SingularPtrField<PendingNotificationsProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseProto {
    fn default() -> &'a ResponseProto {
        <ResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ResponseProto {
    pub fn new() -> ResponseProto {
        ::std::default::Default::default()
    }

    // optional .PendingNotificationsProto pendingNotifications = 38;


    pub fn get_pendingNotifications(&self) -> &PendingNotificationsProto {
        self.pendingNotifications.as_ref().unwrap_or_else(|| <PendingNotificationsProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.pendingNotifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pendingNotifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pendingNotifications.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pendingNotifications.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseProto {
        ResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingNotificationsProto>>(
                "pendingNotifications",
                |m: &ResponseProto| { &m.pendingNotifications },
                |m: &mut ResponseProto| { &mut m.pendingNotifications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseProto>(
                "ResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseProto {
        static instance: ::protobuf::rt::LazyV2<ResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseProto::new)
    }
}

impl ::protobuf::Clear for ResponseProto {
    fn clear(&mut self) {
        self.pendingNotifications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponseProto_Response {
    // message fields
    pub responseProperties: ::protobuf::SingularPtrField<ResponsePropertiesProto>,
    pub assetsResponse: ::protobuf::SingularPtrField<AssetsResponseProto>,
    pub commentsResponse: ::protobuf::SingularPtrField<CommentsResponseProto>,
    pub modifyCommentResponse: ::protobuf::SingularPtrField<ModifyCommentResponseProto>,
    pub purchasePostResponse: ::protobuf::SingularPtrField<PurchasePostResponseProto>,
    pub purchaseOrderResponse: ::protobuf::SingularPtrField<PurchaseOrderResponseProto>,
    pub contentSyncResponse: ::protobuf::SingularPtrField<ContentSyncResponseProto>,
    pub getAssetResponse: ::protobuf::SingularPtrField<GetAssetResponseProto>,
    pub getImageResponse: ::protobuf::SingularPtrField<GetImageResponseProto>,
    pub refundResponse: ::protobuf::SingularPtrField<RefundResponseProto>,
    pub purchaseMetadataResponse: ::protobuf::SingularPtrField<PurchaseMetadataResponseProto>,
    pub subCategoriesResponse: ::protobuf::SingularPtrField<GetSubCategoriesResponseProto>,
    pub uninstallReasonResponse: ::protobuf::SingularPtrField<UninstallReasonResponseProto>,
    pub rateCommentResponse: ::protobuf::SingularPtrField<RateCommentResponseProto>,
    pub checkLicenseResponse: ::protobuf::SingularPtrField<CheckLicenseResponseProto>,
    pub getMarketMetadataResponse: ::protobuf::SingularPtrField<GetMarketMetadataResponseProto>,
    pub prefetchedBundle: ::protobuf::RepeatedField<PrefetchedBundleProto>,
    pub getCategoriesResponse: ::protobuf::SingularPtrField<GetCategoriesResponseProto>,
    pub getCarrierInfoResponse: ::protobuf::SingularPtrField<GetCarrierInfoResponseProto>,
    pub restoreApplicationResponse: ::protobuf::SingularPtrField<RestoreApplicationsResponseProto>,
    pub querySuggestionResponse: ::protobuf::SingularPtrField<QuerySuggestionResponseProto>,
    pub billingEventResponse: ::protobuf::SingularPtrField<BillingEventResponseProto>,
    pub paypalPreapprovalResponse: ::protobuf::SingularPtrField<PaypalPreapprovalResponseProto>,
    pub paypalPreapprovalDetailsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsResponseProto>,
    pub paypalCreateAccountResponse: ::protobuf::SingularPtrField<PaypalCreateAccountResponseProto>,
    pub paypalPreapprovalCredentialsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsResponseProto>,
    pub inAppRestoreTransactionsResponse: ::protobuf::SingularPtrField<InAppRestoreTransactionsResponseProto>,
    pub inAppPurchaseInformationResponse: ::protobuf::SingularPtrField<InAppPurchaseInformationResponseProto>,
    pub checkForNotificationsResponse: ::protobuf::SingularPtrField<CheckForNotificationsResponseProto>,
    pub ackNotificationsResponse: ::protobuf::SingularPtrField<AckNotificationsResponseProto>,
    pub purchaseProductResponse: ::protobuf::SingularPtrField<PurchaseProductResponseProto>,
    pub reconstructDatabaseResponse: ::protobuf::SingularPtrField<ReconstructDatabaseResponseProto>,
    pub paypalMassageAddressResponse: ::protobuf::SingularPtrField<PaypalMassageAddressResponseProto>,
    pub getAddressSnippetResponse: ::protobuf::SingularPtrField<GetAddressSnippetResponseProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseProto_Response {
    fn default() -> &'a ResponseProto_Response {
        <ResponseProto_Response as ::protobuf::Message>::default_instance()
    }
}

impl ResponseProto_Response {
    pub fn new() -> ResponseProto_Response {
        ::std::default::Default::default()
    }

    // optional .ResponsePropertiesProto responseProperties = 2;


    pub fn get_responseProperties(&self) -> &ResponsePropertiesProto {
        self.responseProperties.as_ref().unwrap_or_else(|| <ResponsePropertiesProto as ::protobuf::Message>::default_instance())
    }

    // optional .AssetsResponseProto assetsResponse = 3;


    pub fn get_assetsResponse(&self) -> &AssetsResponseProto {
        self.assetsResponse.as_ref().unwrap_or_else(|| <AssetsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CommentsResponseProto commentsResponse = 4;


    pub fn get_commentsResponse(&self) -> &CommentsResponseProto {
        self.commentsResponse.as_ref().unwrap_or_else(|| <CommentsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ModifyCommentResponseProto modifyCommentResponse = 5;


    pub fn get_modifyCommentResponse(&self) -> &ModifyCommentResponseProto {
        self.modifyCommentResponse.as_ref().unwrap_or_else(|| <ModifyCommentResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchasePostResponseProto purchasePostResponse = 6;


    pub fn get_purchasePostResponse(&self) -> &PurchasePostResponseProto {
        self.purchasePostResponse.as_ref().unwrap_or_else(|| <PurchasePostResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseOrderResponseProto purchaseOrderResponse = 7;


    pub fn get_purchaseOrderResponse(&self) -> &PurchaseOrderResponseProto {
        self.purchaseOrderResponse.as_ref().unwrap_or_else(|| <PurchaseOrderResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ContentSyncResponseProto contentSyncResponse = 8;


    pub fn get_contentSyncResponse(&self) -> &ContentSyncResponseProto {
        self.contentSyncResponse.as_ref().unwrap_or_else(|| <ContentSyncResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAssetResponseProto getAssetResponse = 9;


    pub fn get_getAssetResponse(&self) -> &GetAssetResponseProto {
        self.getAssetResponse.as_ref().unwrap_or_else(|| <GetAssetResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetImageResponseProto getImageResponse = 10;


    pub fn get_getImageResponse(&self) -> &GetImageResponseProto {
        self.getImageResponse.as_ref().unwrap_or_else(|| <GetImageResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RefundResponseProto refundResponse = 11;


    pub fn get_refundResponse(&self) -> &RefundResponseProto {
        self.refundResponse.as_ref().unwrap_or_else(|| <RefundResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseMetadataResponseProto purchaseMetadataResponse = 12;


    pub fn get_purchaseMetadataResponse(&self) -> &PurchaseMetadataResponseProto {
        self.purchaseMetadataResponse.as_ref().unwrap_or_else(|| <PurchaseMetadataResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetSubCategoriesResponseProto subCategoriesResponse = 13;


    pub fn get_subCategoriesResponse(&self) -> &GetSubCategoriesResponseProto {
        self.subCategoriesResponse.as_ref().unwrap_or_else(|| <GetSubCategoriesResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .UninstallReasonResponseProto uninstallReasonResponse = 15;


    pub fn get_uninstallReasonResponse(&self) -> &UninstallReasonResponseProto {
        self.uninstallReasonResponse.as_ref().unwrap_or_else(|| <UninstallReasonResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RateCommentResponseProto rateCommentResponse = 16;


    pub fn get_rateCommentResponse(&self) -> &RateCommentResponseProto {
        self.rateCommentResponse.as_ref().unwrap_or_else(|| <RateCommentResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckLicenseResponseProto checkLicenseResponse = 17;


    pub fn get_checkLicenseResponse(&self) -> &CheckLicenseResponseProto {
        self.checkLicenseResponse.as_ref().unwrap_or_else(|| <CheckLicenseResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetMarketMetadataResponseProto getMarketMetadataResponse = 18;


    pub fn get_getMarketMetadataResponse(&self) -> &GetMarketMetadataResponseProto {
        self.getMarketMetadataResponse.as_ref().unwrap_or_else(|| <GetMarketMetadataResponseProto as ::protobuf::Message>::default_instance())
    }

    // repeated .PrefetchedBundleProto prefetchedBundle = 19;


    pub fn get_prefetchedBundle(&self) -> &[PrefetchedBundleProto] {
        &self.prefetchedBundle
    }

    // optional .GetCategoriesResponseProto getCategoriesResponse = 20;


    pub fn get_getCategoriesResponse(&self) -> &GetCategoriesResponseProto {
        self.getCategoriesResponse.as_ref().unwrap_or_else(|| <GetCategoriesResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCarrierInfoResponseProto getCarrierInfoResponse = 21;


    pub fn get_getCarrierInfoResponse(&self) -> &GetCarrierInfoResponseProto {
        self.getCarrierInfoResponse.as_ref().unwrap_or_else(|| <GetCarrierInfoResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RestoreApplicationsResponseProto restoreApplicationResponse = 23;


    pub fn get_restoreApplicationResponse(&self) -> &RestoreApplicationsResponseProto {
        self.restoreApplicationResponse.as_ref().unwrap_or_else(|| <RestoreApplicationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .QuerySuggestionResponseProto querySuggestionResponse = 24;


    pub fn get_querySuggestionResponse(&self) -> &QuerySuggestionResponseProto {
        self.querySuggestionResponse.as_ref().unwrap_or_else(|| <QuerySuggestionResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .BillingEventResponseProto billingEventResponse = 25;


    pub fn get_billingEventResponse(&self) -> &BillingEventResponseProto {
        self.billingEventResponse.as_ref().unwrap_or_else(|| <BillingEventResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalResponseProto paypalPreapprovalResponse = 26;


    pub fn get_paypalPreapprovalResponse(&self) -> &PaypalPreapprovalResponseProto {
        self.paypalPreapprovalResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalDetailsResponseProto paypalPreapprovalDetailsResponse = 27;


    pub fn get_paypalPreapprovalDetailsResponse(&self) -> &PaypalPreapprovalDetailsResponseProto {
        self.paypalPreapprovalDetailsResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalDetailsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalCreateAccountResponseProto paypalCreateAccountResponse = 28;


    pub fn get_paypalCreateAccountResponse(&self) -> &PaypalCreateAccountResponseProto {
        self.paypalCreateAccountResponse.as_ref().unwrap_or_else(|| <PaypalCreateAccountResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalCredentialsResponseProto paypalPreapprovalCredentialsResponse = 29;


    pub fn get_paypalPreapprovalCredentialsResponse(&self) -> &PaypalPreapprovalCredentialsResponseProto {
        self.paypalPreapprovalCredentialsResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalCredentialsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppRestoreTransactionsResponseProto inAppRestoreTransactionsResponse = 30;


    pub fn get_inAppRestoreTransactionsResponse(&self) -> &InAppRestoreTransactionsResponseProto {
        self.inAppRestoreTransactionsResponse.as_ref().unwrap_or_else(|| <InAppRestoreTransactionsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppPurchaseInformationResponseProto inAppPurchaseInformationResponse = 31;


    pub fn get_inAppPurchaseInformationResponse(&self) -> &InAppPurchaseInformationResponseProto {
        self.inAppPurchaseInformationResponse.as_ref().unwrap_or_else(|| <InAppPurchaseInformationResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckForNotificationsResponseProto checkForNotificationsResponse = 32;


    pub fn get_checkForNotificationsResponse(&self) -> &CheckForNotificationsResponseProto {
        self.checkForNotificationsResponse.as_ref().unwrap_or_else(|| <CheckForNotificationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .AckNotificationsResponseProto ackNotificationsResponse = 33;


    pub fn get_ackNotificationsResponse(&self) -> &AckNotificationsResponseProto {
        self.ackNotificationsResponse.as_ref().unwrap_or_else(|| <AckNotificationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseProductResponseProto purchaseProductResponse = 34;


    pub fn get_purchaseProductResponse(&self) -> &PurchaseProductResponseProto {
        self.purchaseProductResponse.as_ref().unwrap_or_else(|| <PurchaseProductResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ReconstructDatabaseResponseProto reconstructDatabaseResponse = 35;


    pub fn get_reconstructDatabaseResponse(&self) -> &ReconstructDatabaseResponseProto {
        self.reconstructDatabaseResponse.as_ref().unwrap_or_else(|| <ReconstructDatabaseResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalMassageAddressResponseProto paypalMassageAddressResponse = 36;


    pub fn get_paypalMassageAddressResponse(&self) -> &PaypalMassageAddressResponseProto {
        self.paypalMassageAddressResponse.as_ref().unwrap_or_else(|| <PaypalMassageAddressResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAddressSnippetResponseProto getAddressSnippetResponse = 37;


    pub fn get_getAddressSnippetResponse(&self) -> &GetAddressSnippetResponseProto {
        self.getAddressSnippetResponse.as_ref().unwrap_or_else(|| <GetAddressSnippetResponseProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ResponseProto_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.responseProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefetchedBundle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppPurchaseInformationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.responseProperties)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assetsResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commentsResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyCommentResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchasePostResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseOrderResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contentSyncResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAssetResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getImageResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refundResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseMetadataResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subCategoriesResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uninstallReasonResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rateCommentResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkLicenseResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getMarketMetadataResponse)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefetchedBundle)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCategoriesResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCarrierInfoResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restoreApplicationResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.querySuggestionResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingEventResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalDetailsResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalCreateAccountResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalCredentialsResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppRestoreTransactionsResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppPurchaseInformationResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkForNotificationsResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackNotificationsResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseProductResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reconstructDatabaseResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalMassageAddressResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAddressSnippetResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.responseProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchasePostResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseOrderResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contentSyncResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAssetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getImageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refundResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uninstallReasonResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rateCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkLicenseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getMarketMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.prefetchedBundle {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.getCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCarrierInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restoreApplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.querySuggestionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingEventResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalCreateAccountResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppPurchaseInformationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkForNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseProductResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reconstructDatabaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalMassageAddressResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAddressSnippetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.responseProperties.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assetsResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commentsResponse.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyCommentResponse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchasePostResponse.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseOrderResponse.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contentSyncResponse.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAssetResponse.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getImageResponse.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refundResponse.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseMetadataResponse.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subCategoriesResponse.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uninstallReasonResponse.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rateCommentResponse.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkLicenseResponse.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getMarketMetadataResponse.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.prefetchedBundle {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.getCategoriesResponse.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCarrierInfoResponse.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restoreApplicationResponse.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.querySuggestionResponse.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingEventResponse.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalCreateAccountResponse.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsResponse.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppPurchaseInformationResponse.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkForNotificationsResponse.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackNotificationsResponse.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseProductResponse.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reconstructDatabaseResponse.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalMassageAddressResponse.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAddressSnippetResponse.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseProto_Response {
        ResponseProto_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponsePropertiesProto>>(
                "responseProperties",
                |m: &ResponseProto_Response| { &m.responseProperties },
                |m: &mut ResponseProto_Response| { &mut m.responseProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsResponseProto>>(
                "assetsResponse",
                |m: &ResponseProto_Response| { &m.assetsResponse },
                |m: &mut ResponseProto_Response| { &mut m.assetsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsResponseProto>>(
                "commentsResponse",
                |m: &ResponseProto_Response| { &m.commentsResponse },
                |m: &mut ResponseProto_Response| { &mut m.commentsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentResponseProto>>(
                "modifyCommentResponse",
                |m: &ResponseProto_Response| { &m.modifyCommentResponse },
                |m: &mut ResponseProto_Response| { &mut m.modifyCommentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostResponseProto>>(
                "purchasePostResponse",
                |m: &ResponseProto_Response| { &m.purchasePostResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchasePostResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderResponseProto>>(
                "purchaseOrderResponse",
                |m: &ResponseProto_Response| { &m.purchaseOrderResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseOrderResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncResponseProto>>(
                "contentSyncResponse",
                |m: &ResponseProto_Response| { &m.contentSyncResponse },
                |m: &mut ResponseProto_Response| { &mut m.contentSyncResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>>(
                "getAssetResponse",
                |m: &ResponseProto_Response| { &m.getAssetResponse },
                |m: &mut ResponseProto_Response| { &mut m.getAssetResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageResponseProto>>(
                "getImageResponse",
                |m: &ResponseProto_Response| { &m.getImageResponse },
                |m: &mut ResponseProto_Response| { &mut m.getImageResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundResponseProto>>(
                "refundResponse",
                |m: &ResponseProto_Response| { &m.refundResponse },
                |m: &mut ResponseProto_Response| { &mut m.refundResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataResponseProto>>(
                "purchaseMetadataResponse",
                |m: &ResponseProto_Response| { &m.purchaseMetadataResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseMetadataResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesResponseProto>>(
                "subCategoriesResponse",
                |m: &ResponseProto_Response| { &m.subCategoriesResponse },
                |m: &mut ResponseProto_Response| { &mut m.subCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonResponseProto>>(
                "uninstallReasonResponse",
                |m: &ResponseProto_Response| { &m.uninstallReasonResponse },
                |m: &mut ResponseProto_Response| { &mut m.uninstallReasonResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentResponseProto>>(
                "rateCommentResponse",
                |m: &ResponseProto_Response| { &m.rateCommentResponse },
                |m: &mut ResponseProto_Response| { &mut m.rateCommentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseResponseProto>>(
                "checkLicenseResponse",
                |m: &ResponseProto_Response| { &m.checkLicenseResponse },
                |m: &mut ResponseProto_Response| { &mut m.checkLicenseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataResponseProto>>(
                "getMarketMetadataResponse",
                |m: &ResponseProto_Response| { &m.getMarketMetadataResponse },
                |m: &mut ResponseProto_Response| { &mut m.getMarketMetadataResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrefetchedBundleProto>>(
                "prefetchedBundle",
                |m: &ResponseProto_Response| { &m.prefetchedBundle },
                |m: &mut ResponseProto_Response| { &mut m.prefetchedBundle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesResponseProto>>(
                "getCategoriesResponse",
                |m: &ResponseProto_Response| { &m.getCategoriesResponse },
                |m: &mut ResponseProto_Response| { &mut m.getCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoResponseProto>>(
                "getCarrierInfoResponse",
                |m: &ResponseProto_Response| { &m.getCarrierInfoResponse },
                |m: &mut ResponseProto_Response| { &mut m.getCarrierInfoResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsResponseProto>>(
                "restoreApplicationResponse",
                |m: &ResponseProto_Response| { &m.restoreApplicationResponse },
                |m: &mut ResponseProto_Response| { &mut m.restoreApplicationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionResponseProto>>(
                "querySuggestionResponse",
                |m: &ResponseProto_Response| { &m.querySuggestionResponse },
                |m: &mut ResponseProto_Response| { &mut m.querySuggestionResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventResponseProto>>(
                "billingEventResponse",
                |m: &ResponseProto_Response| { &m.billingEventResponse },
                |m: &mut ResponseProto_Response| { &mut m.billingEventResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalResponseProto>>(
                "paypalPreapprovalResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsResponseProto>>(
                "paypalPreapprovalDetailsResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalDetailsResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalDetailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountResponseProto>>(
                "paypalCreateAccountResponse",
                |m: &ResponseProto_Response| { &m.paypalCreateAccountResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalCreateAccountResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsResponseProto>>(
                "paypalPreapprovalCredentialsResponse",
                |m: &ResponseProto_Response| { &m.paypalPreapprovalCredentialsResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalPreapprovalCredentialsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsResponseProto>>(
                "inAppRestoreTransactionsResponse",
                |m: &ResponseProto_Response| { &m.inAppRestoreTransactionsResponse },
                |m: &mut ResponseProto_Response| { &mut m.inAppRestoreTransactionsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationResponseProto>>(
                "inAppPurchaseInformationResponse",
                |m: &ResponseProto_Response| { &m.inAppPurchaseInformationResponse },
                |m: &mut ResponseProto_Response| { &mut m.inAppPurchaseInformationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsResponseProto>>(
                "checkForNotificationsResponse",
                |m: &ResponseProto_Response| { &m.checkForNotificationsResponse },
                |m: &mut ResponseProto_Response| { &mut m.checkForNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsResponseProto>>(
                "ackNotificationsResponse",
                |m: &ResponseProto_Response| { &m.ackNotificationsResponse },
                |m: &mut ResponseProto_Response| { &mut m.ackNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductResponseProto>>(
                "purchaseProductResponse",
                |m: &ResponseProto_Response| { &m.purchaseProductResponse },
                |m: &mut ResponseProto_Response| { &mut m.purchaseProductResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseResponseProto>>(
                "reconstructDatabaseResponse",
                |m: &ResponseProto_Response| { &m.reconstructDatabaseResponse },
                |m: &mut ResponseProto_Response| { &mut m.reconstructDatabaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressResponseProto>>(
                "paypalMassageAddressResponse",
                |m: &ResponseProto_Response| { &m.paypalMassageAddressResponse },
                |m: &mut ResponseProto_Response| { &mut m.paypalMassageAddressResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetResponseProto>>(
                "getAddressSnippetResponse",
                |m: &ResponseProto_Response| { &m.getAddressSnippetResponse },
                |m: &mut ResponseProto_Response| { &mut m.getAddressSnippetResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseProto_Response>(
                "ResponseProto.Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseProto_Response {
        static instance: ::protobuf::rt::LazyV2<ResponseProto_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseProto_Response::new)
    }
}

impl ::protobuf::Clear for ResponseProto_Response {
    fn clear(&mut self) {
        self.responseProperties.clear();
        self.assetsResponse.clear();
        self.commentsResponse.clear();
        self.modifyCommentResponse.clear();
        self.purchasePostResponse.clear();
        self.purchaseOrderResponse.clear();
        self.contentSyncResponse.clear();
        self.getAssetResponse.clear();
        self.getImageResponse.clear();
        self.refundResponse.clear();
        self.purchaseMetadataResponse.clear();
        self.subCategoriesResponse.clear();
        self.uninstallReasonResponse.clear();
        self.rateCommentResponse.clear();
        self.checkLicenseResponse.clear();
        self.getMarketMetadataResponse.clear();
        self.prefetchedBundle.clear();
        self.getCategoriesResponse.clear();
        self.getCarrierInfoResponse.clear();
        self.restoreApplicationResponse.clear();
        self.querySuggestionResponse.clear();
        self.billingEventResponse.clear();
        self.paypalPreapprovalResponse.clear();
        self.paypalPreapprovalDetailsResponse.clear();
        self.paypalCreateAccountResponse.clear();
        self.paypalPreapprovalCredentialsResponse.clear();
        self.inAppRestoreTransactionsResponse.clear();
        self.inAppPurchaseInformationResponse.clear();
        self.checkForNotificationsResponse.clear();
        self.ackNotificationsResponse.clear();
        self.purchaseProductResponse.clear();
        self.reconstructDatabaseResponse.clear();
        self.paypalMassageAddressResponse.clear();
        self.getAddressSnippetResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseProto_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseProto_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RestoreApplicationsRequestProto {
    // message fields
    pub backupAndroidId: ::protobuf::SingularField<::std::string::String>,
    pub tosVersion: ::protobuf::SingularField<::std::string::String>,
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreApplicationsRequestProto {
    fn default() -> &'a RestoreApplicationsRequestProto {
        <RestoreApplicationsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreApplicationsRequestProto {
    pub fn new() -> RestoreApplicationsRequestProto {
        ::std::default::Default::default()
    }

    // optional string backupAndroidId = 1;


    pub fn get_backupAndroidId(&self) -> &str {
        match self.backupAndroidId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tosVersion = 2;


    pub fn get_tosVersion(&self) -> &str {
        match self.tosVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DeviceConfigurationProto deviceConfiguration = 3;


    pub fn get_deviceConfiguration(&self) -> &DeviceConfigurationProto {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfigurationProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RestoreApplicationsRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backupAndroidId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosVersion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceConfiguration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backupAndroidId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.tosVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backupAndroidId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.tosVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreApplicationsRequestProto {
        RestoreApplicationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backupAndroidId",
                |m: &RestoreApplicationsRequestProto| { &m.backupAndroidId },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.backupAndroidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosVersion",
                |m: &RestoreApplicationsRequestProto| { &m.tosVersion },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.tosVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>>(
                "deviceConfiguration",
                |m: &RestoreApplicationsRequestProto| { &m.deviceConfiguration },
                |m: &mut RestoreApplicationsRequestProto| { &mut m.deviceConfiguration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreApplicationsRequestProto>(
                "RestoreApplicationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreApplicationsRequestProto {
        static instance: ::protobuf::rt::LazyV2<RestoreApplicationsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreApplicationsRequestProto::new)
    }
}

impl ::protobuf::Clear for RestoreApplicationsRequestProto {
    fn clear(&mut self) {
        self.backupAndroidId.clear();
        self.tosVersion.clear();
        self.deviceConfiguration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreApplicationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreApplicationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RestoreApplicationsResponseProto {
    // message fields
    pub asset: ::protobuf::RepeatedField<GetAssetResponseProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreApplicationsResponseProto {
    fn default() -> &'a RestoreApplicationsResponseProto {
        <RestoreApplicationsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreApplicationsResponseProto {
    pub fn new() -> RestoreApplicationsResponseProto {
        ::std::default::Default::default()
    }

    // repeated .GetAssetResponseProto asset = 1;


    pub fn get_asset(&self) -> &[GetAssetResponseProto] {
        &self.asset
    }
}

impl ::protobuf::Message for RestoreApplicationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.asset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.asset {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreApplicationsResponseProto {
        RestoreApplicationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>>(
                "asset",
                |m: &RestoreApplicationsResponseProto| { &m.asset },
                |m: &mut RestoreApplicationsResponseProto| { &mut m.asset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreApplicationsResponseProto>(
                "RestoreApplicationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreApplicationsResponseProto {
        static instance: ::protobuf::rt::LazyV2<RestoreApplicationsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreApplicationsResponseProto::new)
    }
}

impl ::protobuf::Clear for RestoreApplicationsResponseProto {
    fn clear(&mut self) {
        self.asset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreApplicationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreApplicationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RiskHeaderInfoProto {
    // message fields
    pub hashedDeviceInfo: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RiskHeaderInfoProto {
    fn default() -> &'a RiskHeaderInfoProto {
        <RiskHeaderInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl RiskHeaderInfoProto {
    pub fn new() -> RiskHeaderInfoProto {
        ::std::default::Default::default()
    }

    // optional string hashedDeviceInfo = 1;


    pub fn get_hashedDeviceInfo(&self) -> &str {
        match self.hashedDeviceInfo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RiskHeaderInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hashedDeviceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hashedDeviceInfo.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hashedDeviceInfo.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiskHeaderInfoProto {
        RiskHeaderInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hashedDeviceInfo",
                |m: &RiskHeaderInfoProto| { &m.hashedDeviceInfo },
                |m: &mut RiskHeaderInfoProto| { &mut m.hashedDeviceInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RiskHeaderInfoProto>(
                "RiskHeaderInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RiskHeaderInfoProto {
        static instance: ::protobuf::rt::LazyV2<RiskHeaderInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RiskHeaderInfoProto::new)
    }
}

impl ::protobuf::Clear for RiskHeaderInfoProto {
    fn clear(&mut self) {
        self.hashedDeviceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiskHeaderInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiskHeaderInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SignatureHashProto {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    pub hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignatureHashProto {
    fn default() -> &'a SignatureHashProto {
        <SignatureHashProto as ::protobuf::Message>::default_instance()
    }
}

impl SignatureHashProto {
    pub fn new() -> SignatureHashProto {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional bytes hash = 3;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for SignatureHashProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignatureHashProto {
        SignatureHashProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &SignatureHashProto| { &m.packageName },
                |m: &mut SignatureHashProto| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &SignatureHashProto| { &m.versionCode },
                |m: &mut SignatureHashProto| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &SignatureHashProto| { &m.hash },
                |m: &mut SignatureHashProto| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignatureHashProto>(
                "SignatureHashProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignatureHashProto {
        static instance: ::protobuf::rt::LazyV2<SignatureHashProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignatureHashProto::new)
    }
}

impl ::protobuf::Clear for SignatureHashProto {
    fn clear(&mut self) {
        self.packageName.clear();
        self.versionCode = ::std::option::Option::None;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignatureHashProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureHashProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SignedDataProto {
    // message fields
    pub signedData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignedDataProto {
    fn default() -> &'a SignedDataProto {
        <SignedDataProto as ::protobuf::Message>::default_instance()
    }
}

impl SignedDataProto {
    pub fn new() -> SignedDataProto {
        ::std::default::Default::default()
    }

    // optional string signedData = 1;


    pub fn get_signedData(&self) -> &str {
        match self.signedData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 2;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SignedDataProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedData.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignedDataProto {
        SignedDataProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedData",
                |m: &SignedDataProto| { &m.signedData },
                |m: &mut SignedDataProto| { &mut m.signedData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &SignedDataProto| { &m.signature },
                |m: &mut SignedDataProto| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignedDataProto>(
                "SignedDataProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignedDataProto {
        static instance: ::protobuf::rt::LazyV2<SignedDataProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignedDataProto::new)
    }
}

impl ::protobuf::Clear for SignedDataProto {
    fn clear(&mut self) {
        self.signedData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignedDataProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignedDataProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SingleRequestProto {
    // message fields
    pub requestSpecificProperties: ::protobuf::SingularPtrField<RequestSpecificPropertiesProto>,
    pub assetRequest: ::protobuf::SingularPtrField<AssetsRequestProto>,
    pub commentsRequest: ::protobuf::SingularPtrField<CommentsRequestProto>,
    pub modifyCommentRequest: ::protobuf::SingularPtrField<ModifyCommentRequestProto>,
    pub purchasePostRequest: ::protobuf::SingularPtrField<PurchasePostRequestProto>,
    pub purchaseOrderRequest: ::protobuf::SingularPtrField<PurchaseOrderRequestProto>,
    pub contentSyncRequest: ::protobuf::SingularPtrField<ContentSyncRequestProto>,
    pub getAssetRequest: ::protobuf::SingularPtrField<GetAssetRequestProto>,
    pub getImageRequest: ::protobuf::SingularPtrField<GetImageRequestProto>,
    pub refundRequest: ::protobuf::SingularPtrField<RefundRequestProto>,
    pub purchaseMetadataRequest: ::protobuf::SingularPtrField<PurchaseMetadataRequestProto>,
    pub subCategoriesRequest: ::protobuf::SingularPtrField<GetSubCategoriesRequestProto>,
    pub uninstallReasonRequest: ::protobuf::SingularPtrField<UninstallReasonRequestProto>,
    pub rateCommentRequest: ::protobuf::SingularPtrField<RateCommentRequestProto>,
    pub checkLicenseRequest: ::protobuf::SingularPtrField<CheckLicenseRequestProto>,
    pub getMarketMetadataRequest: ::protobuf::SingularPtrField<GetMarketMetadataRequestProto>,
    pub getCategoriesRequest: ::protobuf::SingularPtrField<GetCategoriesRequestProto>,
    pub getCarrierInfoRequest: ::protobuf::SingularPtrField<GetCarrierInfoRequestProto>,
    pub removeAssetRequest: ::protobuf::SingularPtrField<RemoveAssetRequestProto>,
    pub restoreApplicationsRequest: ::protobuf::SingularPtrField<RestoreApplicationsRequestProto>,
    pub querySuggestionRequest: ::protobuf::SingularPtrField<QuerySuggestionRequestProto>,
    pub billingEventRequest: ::protobuf::SingularPtrField<BillingEventRequestProto>,
    pub paypalPreapprovalRequest: ::protobuf::SingularPtrField<PaypalPreapprovalRequestProto>,
    pub paypalPreapprovalDetailsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsRequestProto>,
    pub paypalCreateAccountRequest: ::protobuf::SingularPtrField<PaypalCreateAccountRequestProto>,
    pub paypalPreapprovalCredentialsRequest: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsRequestProto>,
    pub inAppRestoreTransactionsRequest: ::protobuf::SingularPtrField<InAppRestoreTransactionsRequestProto>,
    pub getInAppPurchaseInformationRequest: ::protobuf::SingularPtrField<InAppPurchaseInformationRequestProto>,
    pub checkForNotificationsRequest: ::protobuf::SingularPtrField<CheckForNotificationsRequestProto>,
    pub ackNotificationsRequest: ::protobuf::SingularPtrField<AckNotificationsRequestProto>,
    pub purchaseProductRequest: ::protobuf::SingularPtrField<PurchaseProductRequestProto>,
    pub reconstructDatabaseRequest: ::protobuf::SingularPtrField<ReconstructDatabaseRequestProto>,
    pub paypalMassageAddressRequest: ::protobuf::SingularPtrField<PaypalMassageAddressRequestProto>,
    pub getAddressSnippetRequest: ::protobuf::SingularPtrField<GetAddressSnippetRequestProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleRequestProto {
    fn default() -> &'a SingleRequestProto {
        <SingleRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SingleRequestProto {
    pub fn new() -> SingleRequestProto {
        ::std::default::Default::default()
    }

    // optional .RequestSpecificPropertiesProto requestSpecificProperties = 3;


    pub fn get_requestSpecificProperties(&self) -> &RequestSpecificPropertiesProto {
        self.requestSpecificProperties.as_ref().unwrap_or_else(|| <RequestSpecificPropertiesProto as ::protobuf::Message>::default_instance())
    }

    // optional .AssetsRequestProto assetRequest = 4;


    pub fn get_assetRequest(&self) -> &AssetsRequestProto {
        self.assetRequest.as_ref().unwrap_or_else(|| <AssetsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CommentsRequestProto commentsRequest = 5;


    pub fn get_commentsRequest(&self) -> &CommentsRequestProto {
        self.commentsRequest.as_ref().unwrap_or_else(|| <CommentsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ModifyCommentRequestProto modifyCommentRequest = 6;


    pub fn get_modifyCommentRequest(&self) -> &ModifyCommentRequestProto {
        self.modifyCommentRequest.as_ref().unwrap_or_else(|| <ModifyCommentRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchasePostRequestProto purchasePostRequest = 7;


    pub fn get_purchasePostRequest(&self) -> &PurchasePostRequestProto {
        self.purchasePostRequest.as_ref().unwrap_or_else(|| <PurchasePostRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseOrderRequestProto purchaseOrderRequest = 8;


    pub fn get_purchaseOrderRequest(&self) -> &PurchaseOrderRequestProto {
        self.purchaseOrderRequest.as_ref().unwrap_or_else(|| <PurchaseOrderRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ContentSyncRequestProto contentSyncRequest = 9;


    pub fn get_contentSyncRequest(&self) -> &ContentSyncRequestProto {
        self.contentSyncRequest.as_ref().unwrap_or_else(|| <ContentSyncRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAssetRequestProto getAssetRequest = 10;


    pub fn get_getAssetRequest(&self) -> &GetAssetRequestProto {
        self.getAssetRequest.as_ref().unwrap_or_else(|| <GetAssetRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetImageRequestProto getImageRequest = 11;


    pub fn get_getImageRequest(&self) -> &GetImageRequestProto {
        self.getImageRequest.as_ref().unwrap_or_else(|| <GetImageRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RefundRequestProto refundRequest = 12;


    pub fn get_refundRequest(&self) -> &RefundRequestProto {
        self.refundRequest.as_ref().unwrap_or_else(|| <RefundRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseMetadataRequestProto purchaseMetadataRequest = 13;


    pub fn get_purchaseMetadataRequest(&self) -> &PurchaseMetadataRequestProto {
        self.purchaseMetadataRequest.as_ref().unwrap_or_else(|| <PurchaseMetadataRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetSubCategoriesRequestProto subCategoriesRequest = 14;


    pub fn get_subCategoriesRequest(&self) -> &GetSubCategoriesRequestProto {
        self.subCategoriesRequest.as_ref().unwrap_or_else(|| <GetSubCategoriesRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .UninstallReasonRequestProto uninstallReasonRequest = 16;


    pub fn get_uninstallReasonRequest(&self) -> &UninstallReasonRequestProto {
        self.uninstallReasonRequest.as_ref().unwrap_or_else(|| <UninstallReasonRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RateCommentRequestProto rateCommentRequest = 17;


    pub fn get_rateCommentRequest(&self) -> &RateCommentRequestProto {
        self.rateCommentRequest.as_ref().unwrap_or_else(|| <RateCommentRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckLicenseRequestProto checkLicenseRequest = 18;


    pub fn get_checkLicenseRequest(&self) -> &CheckLicenseRequestProto {
        self.checkLicenseRequest.as_ref().unwrap_or_else(|| <CheckLicenseRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetMarketMetadataRequestProto getMarketMetadataRequest = 19;


    pub fn get_getMarketMetadataRequest(&self) -> &GetMarketMetadataRequestProto {
        self.getMarketMetadataRequest.as_ref().unwrap_or_else(|| <GetMarketMetadataRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCategoriesRequestProto getCategoriesRequest = 21;


    pub fn get_getCategoriesRequest(&self) -> &GetCategoriesRequestProto {
        self.getCategoriesRequest.as_ref().unwrap_or_else(|| <GetCategoriesRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCarrierInfoRequestProto getCarrierInfoRequest = 22;


    pub fn get_getCarrierInfoRequest(&self) -> &GetCarrierInfoRequestProto {
        self.getCarrierInfoRequest.as_ref().unwrap_or_else(|| <GetCarrierInfoRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RemoveAssetRequestProto removeAssetRequest = 23;


    pub fn get_removeAssetRequest(&self) -> &RemoveAssetRequestProto {
        self.removeAssetRequest.as_ref().unwrap_or_else(|| <RemoveAssetRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .RestoreApplicationsRequestProto restoreApplicationsRequest = 24;


    pub fn get_restoreApplicationsRequest(&self) -> &RestoreApplicationsRequestProto {
        self.restoreApplicationsRequest.as_ref().unwrap_or_else(|| <RestoreApplicationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .QuerySuggestionRequestProto querySuggestionRequest = 25;


    pub fn get_querySuggestionRequest(&self) -> &QuerySuggestionRequestProto {
        self.querySuggestionRequest.as_ref().unwrap_or_else(|| <QuerySuggestionRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .BillingEventRequestProto billingEventRequest = 26;


    pub fn get_billingEventRequest(&self) -> &BillingEventRequestProto {
        self.billingEventRequest.as_ref().unwrap_or_else(|| <BillingEventRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalRequestProto paypalPreapprovalRequest = 27;


    pub fn get_paypalPreapprovalRequest(&self) -> &PaypalPreapprovalRequestProto {
        self.paypalPreapprovalRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalDetailsRequestProto paypalPreapprovalDetailsRequest = 28;


    pub fn get_paypalPreapprovalDetailsRequest(&self) -> &PaypalPreapprovalDetailsRequestProto {
        self.paypalPreapprovalDetailsRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalDetailsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalCreateAccountRequestProto paypalCreateAccountRequest = 29;


    pub fn get_paypalCreateAccountRequest(&self) -> &PaypalCreateAccountRequestProto {
        self.paypalCreateAccountRequest.as_ref().unwrap_or_else(|| <PaypalCreateAccountRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalCredentialsRequestProto paypalPreapprovalCredentialsRequest = 30;


    pub fn get_paypalPreapprovalCredentialsRequest(&self) -> &PaypalPreapprovalCredentialsRequestProto {
        self.paypalPreapprovalCredentialsRequest.as_ref().unwrap_or_else(|| <PaypalPreapprovalCredentialsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppRestoreTransactionsRequestProto inAppRestoreTransactionsRequest = 31;


    pub fn get_inAppRestoreTransactionsRequest(&self) -> &InAppRestoreTransactionsRequestProto {
        self.inAppRestoreTransactionsRequest.as_ref().unwrap_or_else(|| <InAppRestoreTransactionsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppPurchaseInformationRequestProto getInAppPurchaseInformationRequest = 32;


    pub fn get_getInAppPurchaseInformationRequest(&self) -> &InAppPurchaseInformationRequestProto {
        self.getInAppPurchaseInformationRequest.as_ref().unwrap_or_else(|| <InAppPurchaseInformationRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckForNotificationsRequestProto checkForNotificationsRequest = 33;


    pub fn get_checkForNotificationsRequest(&self) -> &CheckForNotificationsRequestProto {
        self.checkForNotificationsRequest.as_ref().unwrap_or_else(|| <CheckForNotificationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .AckNotificationsRequestProto ackNotificationsRequest = 34;


    pub fn get_ackNotificationsRequest(&self) -> &AckNotificationsRequestProto {
        self.ackNotificationsRequest.as_ref().unwrap_or_else(|| <AckNotificationsRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseProductRequestProto purchaseProductRequest = 35;


    pub fn get_purchaseProductRequest(&self) -> &PurchaseProductRequestProto {
        self.purchaseProductRequest.as_ref().unwrap_or_else(|| <PurchaseProductRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .ReconstructDatabaseRequestProto reconstructDatabaseRequest = 36;


    pub fn get_reconstructDatabaseRequest(&self) -> &ReconstructDatabaseRequestProto {
        self.reconstructDatabaseRequest.as_ref().unwrap_or_else(|| <ReconstructDatabaseRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalMassageAddressRequestProto paypalMassageAddressRequest = 37;


    pub fn get_paypalMassageAddressRequest(&self) -> &PaypalMassageAddressRequestProto {
        self.paypalMassageAddressRequest.as_ref().unwrap_or_else(|| <PaypalMassageAddressRequestProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAddressSnippetRequestProto getAddressSnippetRequest = 38;


    pub fn get_getAddressSnippetRequest(&self) -> &GetAddressSnippetRequestProto {
        self.getAddressSnippetRequest.as_ref().unwrap_or_else(|| <GetAddressSnippetRequestProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SingleRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.requestSpecificProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.removeAssetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInAppPurchaseInformationRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requestSpecificProperties)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assetRequest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commentsRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyCommentRequest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchasePostRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseOrderRequest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contentSyncRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAssetRequest)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getImageRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refundRequest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseMetadataRequest)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subCategoriesRequest)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uninstallReasonRequest)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rateCommentRequest)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkLicenseRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getMarketMetadataRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCategoriesRequest)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCarrierInfoRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.removeAssetRequest)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restoreApplicationsRequest)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.querySuggestionRequest)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingEventRequest)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalRequest)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalDetailsRequest)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalCreateAccountRequest)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalCredentialsRequest)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppRestoreTransactionsRequest)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getInAppPurchaseInformationRequest)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkForNotificationsRequest)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackNotificationsRequest)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseProductRequest)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reconstructDatabaseRequest)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalMassageAddressRequest)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAddressSnippetRequest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requestSpecificProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commentsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchasePostRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseOrderRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contentSyncRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getImageRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refundRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uninstallReasonRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rateCommentRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkLicenseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getMarketMetadataRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCategoriesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCarrierInfoRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.removeAssetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restoreApplicationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.querySuggestionRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingEventRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalCreateAccountRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getInAppPurchaseInformationRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkForNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackNotificationsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseProductRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reconstructDatabaseRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalMassageAddressRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAddressSnippetRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requestSpecificProperties.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assetRequest.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commentsRequest.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyCommentRequest.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchasePostRequest.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseOrderRequest.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contentSyncRequest.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAssetRequest.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getImageRequest.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refundRequest.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseMetadataRequest.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subCategoriesRequest.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uninstallReasonRequest.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rateCommentRequest.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkLicenseRequest.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getMarketMetadataRequest.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCategoriesRequest.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCarrierInfoRequest.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.removeAssetRequest.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restoreApplicationsRequest.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.querySuggestionRequest.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingEventRequest.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalRequest.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsRequest.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalCreateAccountRequest.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsRequest.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsRequest.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getInAppPurchaseInformationRequest.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkForNotificationsRequest.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackNotificationsRequest.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseProductRequest.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reconstructDatabaseRequest.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalMassageAddressRequest.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAddressSnippetRequest.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleRequestProto {
        SingleRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestSpecificPropertiesProto>>(
                "requestSpecificProperties",
                |m: &SingleRequestProto| { &m.requestSpecificProperties },
                |m: &mut SingleRequestProto| { &mut m.requestSpecificProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsRequestProto>>(
                "assetRequest",
                |m: &SingleRequestProto| { &m.assetRequest },
                |m: &mut SingleRequestProto| { &mut m.assetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsRequestProto>>(
                "commentsRequest",
                |m: &SingleRequestProto| { &m.commentsRequest },
                |m: &mut SingleRequestProto| { &mut m.commentsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentRequestProto>>(
                "modifyCommentRequest",
                |m: &SingleRequestProto| { &m.modifyCommentRequest },
                |m: &mut SingleRequestProto| { &mut m.modifyCommentRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostRequestProto>>(
                "purchasePostRequest",
                |m: &SingleRequestProto| { &m.purchasePostRequest },
                |m: &mut SingleRequestProto| { &mut m.purchasePostRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderRequestProto>>(
                "purchaseOrderRequest",
                |m: &SingleRequestProto| { &m.purchaseOrderRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseOrderRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncRequestProto>>(
                "contentSyncRequest",
                |m: &SingleRequestProto| { &m.contentSyncRequest },
                |m: &mut SingleRequestProto| { &mut m.contentSyncRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetRequestProto>>(
                "getAssetRequest",
                |m: &SingleRequestProto| { &m.getAssetRequest },
                |m: &mut SingleRequestProto| { &mut m.getAssetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageRequestProto>>(
                "getImageRequest",
                |m: &SingleRequestProto| { &m.getImageRequest },
                |m: &mut SingleRequestProto| { &mut m.getImageRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundRequestProto>>(
                "refundRequest",
                |m: &SingleRequestProto| { &m.refundRequest },
                |m: &mut SingleRequestProto| { &mut m.refundRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataRequestProto>>(
                "purchaseMetadataRequest",
                |m: &SingleRequestProto| { &m.purchaseMetadataRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseMetadataRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesRequestProto>>(
                "subCategoriesRequest",
                |m: &SingleRequestProto| { &m.subCategoriesRequest },
                |m: &mut SingleRequestProto| { &mut m.subCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonRequestProto>>(
                "uninstallReasonRequest",
                |m: &SingleRequestProto| { &m.uninstallReasonRequest },
                |m: &mut SingleRequestProto| { &mut m.uninstallReasonRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentRequestProto>>(
                "rateCommentRequest",
                |m: &SingleRequestProto| { &m.rateCommentRequest },
                |m: &mut SingleRequestProto| { &mut m.rateCommentRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseRequestProto>>(
                "checkLicenseRequest",
                |m: &SingleRequestProto| { &m.checkLicenseRequest },
                |m: &mut SingleRequestProto| { &mut m.checkLicenseRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataRequestProto>>(
                "getMarketMetadataRequest",
                |m: &SingleRequestProto| { &m.getMarketMetadataRequest },
                |m: &mut SingleRequestProto| { &mut m.getMarketMetadataRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesRequestProto>>(
                "getCategoriesRequest",
                |m: &SingleRequestProto| { &m.getCategoriesRequest },
                |m: &mut SingleRequestProto| { &mut m.getCategoriesRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoRequestProto>>(
                "getCarrierInfoRequest",
                |m: &SingleRequestProto| { &m.getCarrierInfoRequest },
                |m: &mut SingleRequestProto| { &mut m.getCarrierInfoRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoveAssetRequestProto>>(
                "removeAssetRequest",
                |m: &SingleRequestProto| { &m.removeAssetRequest },
                |m: &mut SingleRequestProto| { &mut m.removeAssetRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsRequestProto>>(
                "restoreApplicationsRequest",
                |m: &SingleRequestProto| { &m.restoreApplicationsRequest },
                |m: &mut SingleRequestProto| { &mut m.restoreApplicationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionRequestProto>>(
                "querySuggestionRequest",
                |m: &SingleRequestProto| { &m.querySuggestionRequest },
                |m: &mut SingleRequestProto| { &mut m.querySuggestionRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventRequestProto>>(
                "billingEventRequest",
                |m: &SingleRequestProto| { &m.billingEventRequest },
                |m: &mut SingleRequestProto| { &mut m.billingEventRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalRequestProto>>(
                "paypalPreapprovalRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsRequestProto>>(
                "paypalPreapprovalDetailsRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalDetailsRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalDetailsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountRequestProto>>(
                "paypalCreateAccountRequest",
                |m: &SingleRequestProto| { &m.paypalCreateAccountRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalCreateAccountRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsRequestProto>>(
                "paypalPreapprovalCredentialsRequest",
                |m: &SingleRequestProto| { &m.paypalPreapprovalCredentialsRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalPreapprovalCredentialsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsRequestProto>>(
                "inAppRestoreTransactionsRequest",
                |m: &SingleRequestProto| { &m.inAppRestoreTransactionsRequest },
                |m: &mut SingleRequestProto| { &mut m.inAppRestoreTransactionsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationRequestProto>>(
                "getInAppPurchaseInformationRequest",
                |m: &SingleRequestProto| { &m.getInAppPurchaseInformationRequest },
                |m: &mut SingleRequestProto| { &mut m.getInAppPurchaseInformationRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsRequestProto>>(
                "checkForNotificationsRequest",
                |m: &SingleRequestProto| { &m.checkForNotificationsRequest },
                |m: &mut SingleRequestProto| { &mut m.checkForNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsRequestProto>>(
                "ackNotificationsRequest",
                |m: &SingleRequestProto| { &m.ackNotificationsRequest },
                |m: &mut SingleRequestProto| { &mut m.ackNotificationsRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductRequestProto>>(
                "purchaseProductRequest",
                |m: &SingleRequestProto| { &m.purchaseProductRequest },
                |m: &mut SingleRequestProto| { &mut m.purchaseProductRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseRequestProto>>(
                "reconstructDatabaseRequest",
                |m: &SingleRequestProto| { &m.reconstructDatabaseRequest },
                |m: &mut SingleRequestProto| { &mut m.reconstructDatabaseRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressRequestProto>>(
                "paypalMassageAddressRequest",
                |m: &SingleRequestProto| { &m.paypalMassageAddressRequest },
                |m: &mut SingleRequestProto| { &mut m.paypalMassageAddressRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetRequestProto>>(
                "getAddressSnippetRequest",
                |m: &SingleRequestProto| { &m.getAddressSnippetRequest },
                |m: &mut SingleRequestProto| { &mut m.getAddressSnippetRequest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleRequestProto>(
                "SingleRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleRequestProto {
        static instance: ::protobuf::rt::LazyV2<SingleRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleRequestProto::new)
    }
}

impl ::protobuf::Clear for SingleRequestProto {
    fn clear(&mut self) {
        self.requestSpecificProperties.clear();
        self.assetRequest.clear();
        self.commentsRequest.clear();
        self.modifyCommentRequest.clear();
        self.purchasePostRequest.clear();
        self.purchaseOrderRequest.clear();
        self.contentSyncRequest.clear();
        self.getAssetRequest.clear();
        self.getImageRequest.clear();
        self.refundRequest.clear();
        self.purchaseMetadataRequest.clear();
        self.subCategoriesRequest.clear();
        self.uninstallReasonRequest.clear();
        self.rateCommentRequest.clear();
        self.checkLicenseRequest.clear();
        self.getMarketMetadataRequest.clear();
        self.getCategoriesRequest.clear();
        self.getCarrierInfoRequest.clear();
        self.removeAssetRequest.clear();
        self.restoreApplicationsRequest.clear();
        self.querySuggestionRequest.clear();
        self.billingEventRequest.clear();
        self.paypalPreapprovalRequest.clear();
        self.paypalPreapprovalDetailsRequest.clear();
        self.paypalCreateAccountRequest.clear();
        self.paypalPreapprovalCredentialsRequest.clear();
        self.inAppRestoreTransactionsRequest.clear();
        self.getInAppPurchaseInformationRequest.clear();
        self.checkForNotificationsRequest.clear();
        self.ackNotificationsRequest.clear();
        self.purchaseProductRequest.clear();
        self.reconstructDatabaseRequest.clear();
        self.paypalMassageAddressRequest.clear();
        self.getAddressSnippetRequest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SingleResponseProto {
    // message fields
    pub responseProperties: ::protobuf::SingularPtrField<ResponsePropertiesProto>,
    pub assetsResponse: ::protobuf::SingularPtrField<AssetsResponseProto>,
    pub commentsResponse: ::protobuf::SingularPtrField<CommentsResponseProto>,
    pub modifyCommentResponse: ::protobuf::SingularPtrField<ModifyCommentResponseProto>,
    pub purchasePostResponse: ::protobuf::SingularPtrField<PurchasePostResponseProto>,
    pub purchaseOrderResponse: ::protobuf::SingularPtrField<PurchaseOrderResponseProto>,
    pub contentSyncResponse: ::protobuf::SingularPtrField<ContentSyncResponseProto>,
    pub getAssetResponse: ::protobuf::SingularPtrField<GetAssetResponseProto>,
    pub getImageResponse: ::protobuf::SingularPtrField<GetImageResponseProto>,
    pub refundResponse: ::protobuf::SingularPtrField<RefundResponseProto>,
    pub purchaseMetadataResponse: ::protobuf::SingularPtrField<PurchaseMetadataResponseProto>,
    pub subCategoriesResponse: ::protobuf::SingularPtrField<GetSubCategoriesResponseProto>,
    pub uninstallReasonResponse: ::protobuf::SingularPtrField<UninstallReasonResponseProto>,
    pub rateCommentResponse: ::protobuf::SingularPtrField<RateCommentResponseProto>,
    pub checkLicenseResponse: ::protobuf::SingularPtrField<CheckLicenseResponseProto>,
    pub getMarketMetadataResponse: ::protobuf::SingularPtrField<GetMarketMetadataResponseProto>,
    pub getCategoriesResponse: ::protobuf::SingularPtrField<GetCategoriesResponseProto>,
    pub getCarrierInfoResponse: ::protobuf::SingularPtrField<GetCarrierInfoResponseProto>,
    pub restoreApplicationResponse: ::protobuf::SingularPtrField<RestoreApplicationsResponseProto>,
    pub querySuggestionResponse: ::protobuf::SingularPtrField<QuerySuggestionResponseProto>,
    pub billingEventResponse: ::protobuf::SingularPtrField<BillingEventResponseProto>,
    pub paypalPreapprovalResponse: ::protobuf::SingularPtrField<PaypalPreapprovalResponseProto>,
    pub paypalPreapprovalDetailsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalDetailsResponseProto>,
    pub paypalCreateAccountResponse: ::protobuf::SingularPtrField<PaypalCreateAccountResponseProto>,
    pub paypalPreapprovalCredentialsResponse: ::protobuf::SingularPtrField<PaypalPreapprovalCredentialsResponseProto>,
    pub inAppRestoreTransactionsResponse: ::protobuf::SingularPtrField<InAppRestoreTransactionsResponseProto>,
    pub getInAppPurchaseInformationResponse: ::protobuf::SingularPtrField<InAppPurchaseInformationResponseProto>,
    pub checkForNotificationsResponse: ::protobuf::SingularPtrField<CheckForNotificationsResponseProto>,
    pub ackNotificationsResponse: ::protobuf::SingularPtrField<AckNotificationsResponseProto>,
    pub purchaseProductResponse: ::protobuf::SingularPtrField<PurchaseProductResponseProto>,
    pub reconstructDatabaseResponse: ::protobuf::SingularPtrField<ReconstructDatabaseResponseProto>,
    pub paypalMassageAddressResponse: ::protobuf::SingularPtrField<PaypalMassageAddressResponseProto>,
    pub getAddressSnippetResponse: ::protobuf::SingularPtrField<GetAddressSnippetResponseProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleResponseProto {
    fn default() -> &'a SingleResponseProto {
        <SingleResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SingleResponseProto {
    pub fn new() -> SingleResponseProto {
        ::std::default::Default::default()
    }

    // optional .ResponsePropertiesProto responseProperties = 2;


    pub fn get_responseProperties(&self) -> &ResponsePropertiesProto {
        self.responseProperties.as_ref().unwrap_or_else(|| <ResponsePropertiesProto as ::protobuf::Message>::default_instance())
    }

    // optional .AssetsResponseProto assetsResponse = 3;


    pub fn get_assetsResponse(&self) -> &AssetsResponseProto {
        self.assetsResponse.as_ref().unwrap_or_else(|| <AssetsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CommentsResponseProto commentsResponse = 4;


    pub fn get_commentsResponse(&self) -> &CommentsResponseProto {
        self.commentsResponse.as_ref().unwrap_or_else(|| <CommentsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ModifyCommentResponseProto modifyCommentResponse = 5;


    pub fn get_modifyCommentResponse(&self) -> &ModifyCommentResponseProto {
        self.modifyCommentResponse.as_ref().unwrap_or_else(|| <ModifyCommentResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchasePostResponseProto purchasePostResponse = 6;


    pub fn get_purchasePostResponse(&self) -> &PurchasePostResponseProto {
        self.purchasePostResponse.as_ref().unwrap_or_else(|| <PurchasePostResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseOrderResponseProto purchaseOrderResponse = 7;


    pub fn get_purchaseOrderResponse(&self) -> &PurchaseOrderResponseProto {
        self.purchaseOrderResponse.as_ref().unwrap_or_else(|| <PurchaseOrderResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ContentSyncResponseProto contentSyncResponse = 8;


    pub fn get_contentSyncResponse(&self) -> &ContentSyncResponseProto {
        self.contentSyncResponse.as_ref().unwrap_or_else(|| <ContentSyncResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAssetResponseProto getAssetResponse = 9;


    pub fn get_getAssetResponse(&self) -> &GetAssetResponseProto {
        self.getAssetResponse.as_ref().unwrap_or_else(|| <GetAssetResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetImageResponseProto getImageResponse = 10;


    pub fn get_getImageResponse(&self) -> &GetImageResponseProto {
        self.getImageResponse.as_ref().unwrap_or_else(|| <GetImageResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RefundResponseProto refundResponse = 11;


    pub fn get_refundResponse(&self) -> &RefundResponseProto {
        self.refundResponse.as_ref().unwrap_or_else(|| <RefundResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseMetadataResponseProto purchaseMetadataResponse = 12;


    pub fn get_purchaseMetadataResponse(&self) -> &PurchaseMetadataResponseProto {
        self.purchaseMetadataResponse.as_ref().unwrap_or_else(|| <PurchaseMetadataResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetSubCategoriesResponseProto subCategoriesResponse = 13;


    pub fn get_subCategoriesResponse(&self) -> &GetSubCategoriesResponseProto {
        self.subCategoriesResponse.as_ref().unwrap_or_else(|| <GetSubCategoriesResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .UninstallReasonResponseProto uninstallReasonResponse = 15;


    pub fn get_uninstallReasonResponse(&self) -> &UninstallReasonResponseProto {
        self.uninstallReasonResponse.as_ref().unwrap_or_else(|| <UninstallReasonResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RateCommentResponseProto rateCommentResponse = 16;


    pub fn get_rateCommentResponse(&self) -> &RateCommentResponseProto {
        self.rateCommentResponse.as_ref().unwrap_or_else(|| <RateCommentResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckLicenseResponseProto checkLicenseResponse = 17;


    pub fn get_checkLicenseResponse(&self) -> &CheckLicenseResponseProto {
        self.checkLicenseResponse.as_ref().unwrap_or_else(|| <CheckLicenseResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetMarketMetadataResponseProto getMarketMetadataResponse = 18;


    pub fn get_getMarketMetadataResponse(&self) -> &GetMarketMetadataResponseProto {
        self.getMarketMetadataResponse.as_ref().unwrap_or_else(|| <GetMarketMetadataResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCategoriesResponseProto getCategoriesResponse = 20;


    pub fn get_getCategoriesResponse(&self) -> &GetCategoriesResponseProto {
        self.getCategoriesResponse.as_ref().unwrap_or_else(|| <GetCategoriesResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetCarrierInfoResponseProto getCarrierInfoResponse = 21;


    pub fn get_getCarrierInfoResponse(&self) -> &GetCarrierInfoResponseProto {
        self.getCarrierInfoResponse.as_ref().unwrap_or_else(|| <GetCarrierInfoResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .RestoreApplicationsResponseProto restoreApplicationResponse = 23;


    pub fn get_restoreApplicationResponse(&self) -> &RestoreApplicationsResponseProto {
        self.restoreApplicationResponse.as_ref().unwrap_or_else(|| <RestoreApplicationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .QuerySuggestionResponseProto querySuggestionResponse = 24;


    pub fn get_querySuggestionResponse(&self) -> &QuerySuggestionResponseProto {
        self.querySuggestionResponse.as_ref().unwrap_or_else(|| <QuerySuggestionResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .BillingEventResponseProto billingEventResponse = 25;


    pub fn get_billingEventResponse(&self) -> &BillingEventResponseProto {
        self.billingEventResponse.as_ref().unwrap_or_else(|| <BillingEventResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalResponseProto paypalPreapprovalResponse = 26;


    pub fn get_paypalPreapprovalResponse(&self) -> &PaypalPreapprovalResponseProto {
        self.paypalPreapprovalResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalDetailsResponseProto paypalPreapprovalDetailsResponse = 27;


    pub fn get_paypalPreapprovalDetailsResponse(&self) -> &PaypalPreapprovalDetailsResponseProto {
        self.paypalPreapprovalDetailsResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalDetailsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalCreateAccountResponseProto paypalCreateAccountResponse = 28;


    pub fn get_paypalCreateAccountResponse(&self) -> &PaypalCreateAccountResponseProto {
        self.paypalCreateAccountResponse.as_ref().unwrap_or_else(|| <PaypalCreateAccountResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalPreapprovalCredentialsResponseProto paypalPreapprovalCredentialsResponse = 29;


    pub fn get_paypalPreapprovalCredentialsResponse(&self) -> &PaypalPreapprovalCredentialsResponseProto {
        self.paypalPreapprovalCredentialsResponse.as_ref().unwrap_or_else(|| <PaypalPreapprovalCredentialsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppRestoreTransactionsResponseProto inAppRestoreTransactionsResponse = 30;


    pub fn get_inAppRestoreTransactionsResponse(&self) -> &InAppRestoreTransactionsResponseProto {
        self.inAppRestoreTransactionsResponse.as_ref().unwrap_or_else(|| <InAppRestoreTransactionsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .InAppPurchaseInformationResponseProto getInAppPurchaseInformationResponse = 31;


    pub fn get_getInAppPurchaseInformationResponse(&self) -> &InAppPurchaseInformationResponseProto {
        self.getInAppPurchaseInformationResponse.as_ref().unwrap_or_else(|| <InAppPurchaseInformationResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .CheckForNotificationsResponseProto checkForNotificationsResponse = 32;


    pub fn get_checkForNotificationsResponse(&self) -> &CheckForNotificationsResponseProto {
        self.checkForNotificationsResponse.as_ref().unwrap_or_else(|| <CheckForNotificationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .AckNotificationsResponseProto ackNotificationsResponse = 33;


    pub fn get_ackNotificationsResponse(&self) -> &AckNotificationsResponseProto {
        self.ackNotificationsResponse.as_ref().unwrap_or_else(|| <AckNotificationsResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseProductResponseProto purchaseProductResponse = 34;


    pub fn get_purchaseProductResponse(&self) -> &PurchaseProductResponseProto {
        self.purchaseProductResponse.as_ref().unwrap_or_else(|| <PurchaseProductResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .ReconstructDatabaseResponseProto reconstructDatabaseResponse = 35;


    pub fn get_reconstructDatabaseResponse(&self) -> &ReconstructDatabaseResponseProto {
        self.reconstructDatabaseResponse.as_ref().unwrap_or_else(|| <ReconstructDatabaseResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .PaypalMassageAddressResponseProto paypalMassageAddressResponse = 36;


    pub fn get_paypalMassageAddressResponse(&self) -> &PaypalMassageAddressResponseProto {
        self.paypalMassageAddressResponse.as_ref().unwrap_or_else(|| <PaypalMassageAddressResponseProto as ::protobuf::Message>::default_instance())
    }

    // optional .GetAddressSnippetResponseProto getAddressSnippetResponse = 37;


    pub fn get_getAddressSnippetResponse(&self) -> &GetAddressSnippetResponseProto {
        self.getAddressSnippetResponse.as_ref().unwrap_or_else(|| <GetAddressSnippetResponseProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SingleResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.responseProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assetsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commentsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchasePostResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseOrderResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contentSyncResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAssetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getImageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refundResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uninstallReasonResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rateCommentResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkLicenseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getMarketMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCategoriesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getCarrierInfoResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restoreApplicationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.querySuggestionResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingEventResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalCreateAccountResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalPreapprovalCredentialsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppRestoreTransactionsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getInAppPurchaseInformationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkForNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ackNotificationsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseProductResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reconstructDatabaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paypalMassageAddressResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getAddressSnippetResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.responseProperties)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assetsResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commentsResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyCommentResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchasePostResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseOrderResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contentSyncResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAssetResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getImageResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refundResponse)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseMetadataResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subCategoriesResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uninstallReasonResponse)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rateCommentResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkLicenseResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getMarketMetadataResponse)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCategoriesResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getCarrierInfoResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restoreApplicationResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.querySuggestionResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingEventResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalDetailsResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalCreateAccountResponse)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalPreapprovalCredentialsResponse)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppRestoreTransactionsResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getInAppPurchaseInformationResponse)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkForNotificationsResponse)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackNotificationsResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseProductResponse)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reconstructDatabaseResponse)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paypalMassageAddressResponse)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getAddressSnippetResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.responseProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assetsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commentsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchasePostResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseOrderResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contentSyncResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAssetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getImageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refundResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uninstallReasonResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rateCommentResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkLicenseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getMarketMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCategoriesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getCarrierInfoResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restoreApplicationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.querySuggestionResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingEventResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalCreateAccountResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getInAppPurchaseInformationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkForNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ackNotificationsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseProductResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reconstructDatabaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.paypalMassageAddressResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getAddressSnippetResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.responseProperties.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assetsResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commentsResponse.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyCommentResponse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchasePostResponse.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseOrderResponse.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contentSyncResponse.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAssetResponse.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getImageResponse.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refundResponse.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseMetadataResponse.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subCategoriesResponse.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uninstallReasonResponse.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rateCommentResponse.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkLicenseResponse.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getMarketMetadataResponse.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCategoriesResponse.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getCarrierInfoResponse.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restoreApplicationResponse.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.querySuggestionResponse.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingEventResponse.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalDetailsResponse.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalCreateAccountResponse.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalPreapprovalCredentialsResponse.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppRestoreTransactionsResponse.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getInAppPurchaseInformationResponse.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkForNotificationsResponse.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ackNotificationsResponse.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseProductResponse.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reconstructDatabaseResponse.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.paypalMassageAddressResponse.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getAddressSnippetResponse.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleResponseProto {
        SingleResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponsePropertiesProto>>(
                "responseProperties",
                |m: &SingleResponseProto| { &m.responseProperties },
                |m: &mut SingleResponseProto| { &mut m.responseProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetsResponseProto>>(
                "assetsResponse",
                |m: &SingleResponseProto| { &m.assetsResponse },
                |m: &mut SingleResponseProto| { &mut m.assetsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommentsResponseProto>>(
                "commentsResponse",
                |m: &SingleResponseProto| { &m.commentsResponse },
                |m: &mut SingleResponseProto| { &mut m.commentsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyCommentResponseProto>>(
                "modifyCommentResponse",
                |m: &SingleResponseProto| { &m.modifyCommentResponse },
                |m: &mut SingleResponseProto| { &mut m.modifyCommentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchasePostResponseProto>>(
                "purchasePostResponse",
                |m: &SingleResponseProto| { &m.purchasePostResponse },
                |m: &mut SingleResponseProto| { &mut m.purchasePostResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseOrderResponseProto>>(
                "purchaseOrderResponse",
                |m: &SingleResponseProto| { &m.purchaseOrderResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseOrderResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContentSyncResponseProto>>(
                "contentSyncResponse",
                |m: &SingleResponseProto| { &m.contentSyncResponse },
                |m: &mut SingleResponseProto| { &mut m.contentSyncResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAssetResponseProto>>(
                "getAssetResponse",
                |m: &SingleResponseProto| { &m.getAssetResponse },
                |m: &mut SingleResponseProto| { &mut m.getAssetResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetImageResponseProto>>(
                "getImageResponse",
                |m: &SingleResponseProto| { &m.getImageResponse },
                |m: &mut SingleResponseProto| { &mut m.getImageResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RefundResponseProto>>(
                "refundResponse",
                |m: &SingleResponseProto| { &m.refundResponse },
                |m: &mut SingleResponseProto| { &mut m.refundResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseMetadataResponseProto>>(
                "purchaseMetadataResponse",
                |m: &SingleResponseProto| { &m.purchaseMetadataResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseMetadataResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetSubCategoriesResponseProto>>(
                "subCategoriesResponse",
                |m: &SingleResponseProto| { &m.subCategoriesResponse },
                |m: &mut SingleResponseProto| { &mut m.subCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UninstallReasonResponseProto>>(
                "uninstallReasonResponse",
                |m: &SingleResponseProto| { &m.uninstallReasonResponse },
                |m: &mut SingleResponseProto| { &mut m.uninstallReasonResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateCommentResponseProto>>(
                "rateCommentResponse",
                |m: &SingleResponseProto| { &m.rateCommentResponse },
                |m: &mut SingleResponseProto| { &mut m.rateCommentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckLicenseResponseProto>>(
                "checkLicenseResponse",
                |m: &SingleResponseProto| { &m.checkLicenseResponse },
                |m: &mut SingleResponseProto| { &mut m.checkLicenseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetMarketMetadataResponseProto>>(
                "getMarketMetadataResponse",
                |m: &SingleResponseProto| { &m.getMarketMetadataResponse },
                |m: &mut SingleResponseProto| { &mut m.getMarketMetadataResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCategoriesResponseProto>>(
                "getCategoriesResponse",
                |m: &SingleResponseProto| { &m.getCategoriesResponse },
                |m: &mut SingleResponseProto| { &mut m.getCategoriesResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetCarrierInfoResponseProto>>(
                "getCarrierInfoResponse",
                |m: &SingleResponseProto| { &m.getCarrierInfoResponse },
                |m: &mut SingleResponseProto| { &mut m.getCarrierInfoResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreApplicationsResponseProto>>(
                "restoreApplicationResponse",
                |m: &SingleResponseProto| { &m.restoreApplicationResponse },
                |m: &mut SingleResponseProto| { &mut m.restoreApplicationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuerySuggestionResponseProto>>(
                "querySuggestionResponse",
                |m: &SingleResponseProto| { &m.querySuggestionResponse },
                |m: &mut SingleResponseProto| { &mut m.querySuggestionResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingEventResponseProto>>(
                "billingEventResponse",
                |m: &SingleResponseProto| { &m.billingEventResponse },
                |m: &mut SingleResponseProto| { &mut m.billingEventResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalResponseProto>>(
                "paypalPreapprovalResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalDetailsResponseProto>>(
                "paypalPreapprovalDetailsResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalDetailsResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalDetailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalCreateAccountResponseProto>>(
                "paypalCreateAccountResponse",
                |m: &SingleResponseProto| { &m.paypalCreateAccountResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalCreateAccountResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalPreapprovalCredentialsResponseProto>>(
                "paypalPreapprovalCredentialsResponse",
                |m: &SingleResponseProto| { &m.paypalPreapprovalCredentialsResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalPreapprovalCredentialsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppRestoreTransactionsResponseProto>>(
                "inAppRestoreTransactionsResponse",
                |m: &SingleResponseProto| { &m.inAppRestoreTransactionsResponse },
                |m: &mut SingleResponseProto| { &mut m.inAppRestoreTransactionsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppPurchaseInformationResponseProto>>(
                "getInAppPurchaseInformationResponse",
                |m: &SingleResponseProto| { &m.getInAppPurchaseInformationResponse },
                |m: &mut SingleResponseProto| { &mut m.getInAppPurchaseInformationResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckForNotificationsResponseProto>>(
                "checkForNotificationsResponse",
                |m: &SingleResponseProto| { &m.checkForNotificationsResponse },
                |m: &mut SingleResponseProto| { &mut m.checkForNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AckNotificationsResponseProto>>(
                "ackNotificationsResponse",
                |m: &SingleResponseProto| { &m.ackNotificationsResponse },
                |m: &mut SingleResponseProto| { &mut m.ackNotificationsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseProductResponseProto>>(
                "purchaseProductResponse",
                |m: &SingleResponseProto| { &m.purchaseProductResponse },
                |m: &mut SingleResponseProto| { &mut m.purchaseProductResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconstructDatabaseResponseProto>>(
                "reconstructDatabaseResponse",
                |m: &SingleResponseProto| { &m.reconstructDatabaseResponse },
                |m: &mut SingleResponseProto| { &mut m.reconstructDatabaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaypalMassageAddressResponseProto>>(
                "paypalMassageAddressResponse",
                |m: &SingleResponseProto| { &m.paypalMassageAddressResponse },
                |m: &mut SingleResponseProto| { &mut m.paypalMassageAddressResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressSnippetResponseProto>>(
                "getAddressSnippetResponse",
                |m: &SingleResponseProto| { &m.getAddressSnippetResponse },
                |m: &mut SingleResponseProto| { &mut m.getAddressSnippetResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SingleResponseProto>(
                "SingleResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SingleResponseProto {
        static instance: ::protobuf::rt::LazyV2<SingleResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleResponseProto::new)
    }
}

impl ::protobuf::Clear for SingleResponseProto {
    fn clear(&mut self) {
        self.responseProperties.clear();
        self.assetsResponse.clear();
        self.commentsResponse.clear();
        self.modifyCommentResponse.clear();
        self.purchasePostResponse.clear();
        self.purchaseOrderResponse.clear();
        self.contentSyncResponse.clear();
        self.getAssetResponse.clear();
        self.getImageResponse.clear();
        self.refundResponse.clear();
        self.purchaseMetadataResponse.clear();
        self.subCategoriesResponse.clear();
        self.uninstallReasonResponse.clear();
        self.rateCommentResponse.clear();
        self.checkLicenseResponse.clear();
        self.getMarketMetadataResponse.clear();
        self.getCategoriesResponse.clear();
        self.getCarrierInfoResponse.clear();
        self.restoreApplicationResponse.clear();
        self.querySuggestionResponse.clear();
        self.billingEventResponse.clear();
        self.paypalPreapprovalResponse.clear();
        self.paypalPreapprovalDetailsResponse.clear();
        self.paypalCreateAccountResponse.clear();
        self.paypalPreapprovalCredentialsResponse.clear();
        self.inAppRestoreTransactionsResponse.clear();
        self.getInAppPurchaseInformationResponse.clear();
        self.checkForNotificationsResponse.clear();
        self.ackNotificationsResponse.clear();
        self.purchaseProductResponse.clear();
        self.reconstructDatabaseResponse.clear();
        self.paypalMassageAddressResponse.clear();
        self.getAddressSnippetResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StatusBarNotificationProto {
    // message fields
    pub tickerText: ::protobuf::SingularField<::std::string::String>,
    pub contentTitle: ::protobuf::SingularField<::std::string::String>,
    pub contentText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusBarNotificationProto {
    fn default() -> &'a StatusBarNotificationProto {
        <StatusBarNotificationProto as ::protobuf::Message>::default_instance()
    }
}

impl StatusBarNotificationProto {
    pub fn new() -> StatusBarNotificationProto {
        ::std::default::Default::default()
    }

    // optional string tickerText = 1;


    pub fn get_tickerText(&self) -> &str {
        match self.tickerText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contentTitle = 2;


    pub fn get_contentTitle(&self) -> &str {
        match self.contentTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contentText = 3;


    pub fn get_contentText(&self) -> &str {
        match self.contentText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for StatusBarNotificationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tickerText)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentTitle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tickerText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.contentTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.contentText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tickerText.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.contentTitle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.contentText.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusBarNotificationProto {
        StatusBarNotificationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tickerText",
                |m: &StatusBarNotificationProto| { &m.tickerText },
                |m: &mut StatusBarNotificationProto| { &mut m.tickerText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentTitle",
                |m: &StatusBarNotificationProto| { &m.contentTitle },
                |m: &mut StatusBarNotificationProto| { &mut m.contentTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentText",
                |m: &StatusBarNotificationProto| { &m.contentText },
                |m: &mut StatusBarNotificationProto| { &mut m.contentText },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusBarNotificationProto>(
                "StatusBarNotificationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusBarNotificationProto {
        static instance: ::protobuf::rt::LazyV2<StatusBarNotificationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusBarNotificationProto::new)
    }
}

impl ::protobuf::Clear for StatusBarNotificationProto {
    fn clear(&mut self) {
        self.tickerText.clear();
        self.contentTitle.clear();
        self.contentText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusBarNotificationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusBarNotificationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UninstallReasonRequestProto {
    // message fields
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    pub reason: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UninstallReasonRequestProto {
    fn default() -> &'a UninstallReasonRequestProto {
        <UninstallReasonRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UninstallReasonRequestProto {
    pub fn new() -> UninstallReasonRequestProto {
        ::std::default::Default::default()
    }

    // optional string assetId = 1;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 reason = 2;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
}

impl ::protobuf::Message for UninstallReasonRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UninstallReasonRequestProto {
        UninstallReasonRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &UninstallReasonRequestProto| { &m.assetId },
                |m: &mut UninstallReasonRequestProto| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reason",
                |m: &UninstallReasonRequestProto| { &m.reason },
                |m: &mut UninstallReasonRequestProto| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UninstallReasonRequestProto>(
                "UninstallReasonRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UninstallReasonRequestProto {
        static instance: ::protobuf::rt::LazyV2<UninstallReasonRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UninstallReasonRequestProto::new)
    }
}

impl ::protobuf::Clear for UninstallReasonRequestProto {
    fn clear(&mut self) {
        self.assetId.clear();
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UninstallReasonRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UninstallReasonRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UninstallReasonResponseProto {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UninstallReasonResponseProto {
    fn default() -> &'a UninstallReasonResponseProto {
        <UninstallReasonResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UninstallReasonResponseProto {
    pub fn new() -> UninstallReasonResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UninstallReasonResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UninstallReasonResponseProto {
        UninstallReasonResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UninstallReasonResponseProto>(
                "UninstallReasonResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UninstallReasonResponseProto {
        static instance: ::protobuf::rt::LazyV2<UninstallReasonResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UninstallReasonResponseProto::new)
    }
}

impl ::protobuf::Clear for UninstallReasonResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UninstallReasonResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UninstallReasonResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CriticReviewsResponse {
    // message fields
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub aggregateSentiment: ::protobuf::SingularPtrField<Image>,
    pub totalNumReviews: ::std::option::Option<u32>,
    pub percentFavorable: ::std::option::Option<u32>,
    pub sourceText: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularPtrField<Link>,
    pub review: ::protobuf::RepeatedField<Review>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CriticReviewsResponse {
    fn default() -> &'a CriticReviewsResponse {
        <CriticReviewsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CriticReviewsResponse {
    pub fn new() -> CriticReviewsResponse {
        ::std::default::Default::default()
    }

    // optional string title = 1;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image aggregateSentiment = 2;


    pub fn get_aggregateSentiment(&self) -> &Image {
        self.aggregateSentiment.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional uint32 totalNumReviews = 3;


    pub fn get_totalNumReviews(&self) -> u32 {
        self.totalNumReviews.unwrap_or(0)
    }

    // optional uint32 percentFavorable = 4;


    pub fn get_percentFavorable(&self) -> u32 {
        self.percentFavorable.unwrap_or(0)
    }

    // optional string sourceText = 5;


    pub fn get_sourceText(&self) -> &str {
        match self.sourceText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Link source = 6;


    pub fn get_source(&self) -> &Link {
        self.source.as_ref().unwrap_or_else(|| <Link as ::protobuf::Message>::default_instance())
    }

    // repeated .Review review = 7;


    pub fn get_review(&self) -> &[Review] {
        &self.review
    }
}

impl ::protobuf::Message for CriticReviewsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregateSentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregateSentiment)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.totalNumReviews = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.percentFavorable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceText)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.review)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.aggregateSentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.totalNumReviews {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.percentFavorable {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sourceText.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.review {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.aggregateSentiment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.totalNumReviews {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.percentFavorable {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.sourceText.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.review {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CriticReviewsResponse {
        CriticReviewsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CriticReviewsResponse| { &m.title },
                |m: &mut CriticReviewsResponse| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "aggregateSentiment",
                |m: &CriticReviewsResponse| { &m.aggregateSentiment },
                |m: &mut CriticReviewsResponse| { &mut m.aggregateSentiment },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "totalNumReviews",
                |m: &CriticReviewsResponse| { &m.totalNumReviews },
                |m: &mut CriticReviewsResponse| { &mut m.totalNumReviews },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "percentFavorable",
                |m: &CriticReviewsResponse| { &m.percentFavorable },
                |m: &mut CriticReviewsResponse| { &mut m.percentFavorable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceText",
                |m: &CriticReviewsResponse| { &m.sourceText },
                |m: &mut CriticReviewsResponse| { &mut m.sourceText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Link>>(
                "source",
                |m: &CriticReviewsResponse| { &m.source },
                |m: &mut CriticReviewsResponse| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &CriticReviewsResponse| { &m.review },
                |m: &mut CriticReviewsResponse| { &mut m.review },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CriticReviewsResponse>(
                "CriticReviewsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CriticReviewsResponse {
        static instance: ::protobuf::rt::LazyV2<CriticReviewsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CriticReviewsResponse::new)
    }
}

impl ::protobuf::Clear for CriticReviewsResponse {
    fn clear(&mut self) {
        self.title.clear();
        self.aggregateSentiment.clear();
        self.totalNumReviews = ::std::option::Option::None;
        self.percentFavorable = ::std::option::Option::None;
        self.sourceText.clear();
        self.source.clear();
        self.review.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CriticReviewsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CriticReviewsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10googleplay.proto\"\x1b\n\x17AckNotificationResponse:\0\"\xc6\x06\n\
    \x16AndroidAppDeliveryData\x12$\n\x0cdownloadSize\x18\x01\x20\x01(\x03R\
    \x0cdownloadSizeB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\tR\tsignatureB\
    \0\x12\"\n\x0bdownloadUrl\x18\x03\x20\x01(\tR\x0bdownloadUrlB\0\x12:\n\
    \x0eadditionalFile\x18\x04\x20\x03(\x0b2\x10.AppFileMetadataR\x0eadditio\
    nalFileB\0\x12=\n\x12downloadAuthCookie\x18\x05\x20\x03(\x0b2\x0b.HttpCo\
    okieR\x12downloadAuthCookieB\0\x12&\n\rforwardLocked\x18\x06\x20\x01(\
    \x08R\rforwardLockedB\0\x12&\n\rrefundTimeout\x18\x07\x20\x01(\x03R\rref\
    undTimeoutB\0\x12*\n\x0fserverInitiated\x18\x08\x20\x01(\x08R\x0fserverI\
    nitiatedB\0\x12F\n\x1dpostInstallRefundWindowMillis\x18\t\x20\x01(\x03R\
    \x1dpostInstallRefundWindowMillisB\0\x124\n\x14immediateStartNeeded\x18\
    \n\x20\x01(\x08R\x14immediateStartNeededB\0\x124\n\tpatchData\x18\x0b\
    \x20\x01(\x0b2\x14.AndroidAppPatchDataR\tpatchDataB\0\x12?\n\x10encrypti\
    onParams\x18\x0c\x20\x01(\x0b2\x11.EncryptionParamsR\x10encryptionParams\
    B\0\x120\n\x12gzippedDownloadUrl\x18\r\x20\x01(\tR\x12gzippedDownloadUrl\
    B\0\x122\n\x13gzippedDownloadSize\x18\x0e\x20\x01(\x03R\x13gzippedDownlo\
    adSizeB\0\x12B\n\x11splitDeliveryData\x18\x0f\x20\x03(\x0b2\x12.SplitDel\
    iveryDataR\x11splitDeliveryDataB\0\x12*\n\x0finstallLocation\x18\x10\x20\
    \x01(\x05R\x0finstallLocationB\0:\0\"\xad\x02\n\x11SplitDeliveryData\x12\
    \x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12$\n\x0cdownloadSize\x18\x02\
    \x20\x01(\x03R\x0cdownloadSizeB\0\x122\n\x13gzippedDownloadSize\x18\x03\
    \x20\x01(\x03R\x13gzippedDownloadSizeB\0\x12\x1e\n\tsignature\x18\x04\
    \x20\x01(\tR\tsignatureB\0\x12\"\n\x0bdownloadUrl\x18\x05\x20\x01(\tR\
    \x0bdownloadUrlB\0\x120\n\x12gzippedDownloadUrl\x18\x06\x20\x01(\tR\x12g\
    zippedDownloadUrlB\0\x124\n\tpatchData\x18\x07\x20\x01(\x0b2\x14.Android\
    AppPatchDataR\tpatchDataB\0:\0\"\xd9\x01\n\x13AndroidAppPatchData\x12*\n\
    \x0fbaseVersionCode\x18\x01\x20\x01(\x05R\x0fbaseVersionCodeB\0\x12&\n\r\
    baseSignature\x18\x02\x20\x01(\tR\rbaseSignatureB\0\x12\"\n\x0bdownloadU\
    rl\x18\x03\x20\x01(\tR\x0bdownloadUrlB\0\x12\"\n\x0bpatchFormat\x18\x04\
    \x20\x01(\x05R\x0bpatchFormatB\0\x12$\n\x0cmaxPatchSize\x18\x05\x20\x01(\
    \x03R\x0cmaxPatchSizeB\0:\0\"\x8f\x01\n\x0fAppFileMetadata\x12\x1c\n\x08\
    fileType\x18\x01\x20\x01(\x05R\x08fileTypeB\0\x12\"\n\x0bversionCode\x18\
    \x02\x20\x01(\x05R\x0bversionCodeB\0\x12\x14\n\x04size\x18\x03\x20\x01(\
    \x03R\x04sizeB\0\x12\"\n\x0bdownloadUrl\x18\x04\x20\x01(\tR\x0bdownloadU\
    rlB\0:\0\"t\n\x10EncryptionParams\x12\x1a\n\x07version\x18\x01\x20\x01(\
    \x05R\x07versionB\0\x12&\n\rencryptionKey\x18\x02\x20\x01(\tR\rencryptio\
    nKeyB\0\x12\x1a\n\x07hmacKey\x18\x03\x20\x01(\tR\x07hmacKeyB\0:\0\"<\n\n\
    HttpCookie\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12\x16\n\
    \x05value\x18\x02\x20\x01(\tR\x05valueB\0:\0\"\x8d\x04\n\x07Address\x12\
    \x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12$\n\x0caddressLine1\x18\
    \x02\x20\x01(\tR\x0caddressLine1B\0\x12$\n\x0caddressLine2\x18\x03\x20\
    \x01(\tR\x0caddressLine2B\0\x12\x14\n\x04city\x18\x04\x20\x01(\tR\x04cit\
    yB\0\x12\x16\n\x05state\x18\x05\x20\x01(\tR\x05stateB\0\x12\x20\n\nposta\
    lCode\x18\x06\x20\x01(\tR\npostalCodeB\0\x12&\n\rpostalCountry\x18\x07\
    \x20\x01(\tR\rpostalCountryB\0\x12.\n\x11dependentLocality\x18\x08\x20\
    \x01(\tR\x11dependentLocalityB\0\x12\"\n\x0bsortingCode\x18\t\x20\x01(\t\
    R\x0bsortingCodeB\0\x12$\n\x0clanguageCode\x18\n\x20\x01(\tR\x0clanguage\
    CodeB\0\x12\"\n\x0bphoneNumber\x18\x0b\x20\x01(\tR\x0bphoneNumberB\0\x12\
    2\n\x13deprecatedIsReduced\x18\x0c\x20\x01(\x08R\x13deprecatedIsReducedB\
    \0\x12\x1e\n\tfirstName\x18\r\x20\x01(\tR\tfirstNameB\0\x12\x1c\n\x08las\
    tName\x18\x0e\x20\x01(\tR\x08lastNameB\0\x12\x16\n\x05email\x18\x0f\x20\
    \x01(\tR\x05emailB\0:\0\"p\n\nBookAuthor\x12\x14\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\0\x12*\n\x0fdeprecatedQuery\x18\x02\x20\x01(\tR\x0fdep\
    recatedQueryB\0\x12\x1e\n\x05docid\x18\x03\x20\x01(\x0b2\x06.DocidR\x05d\
    ocidB\0:\0\"\xd5\x06\n\x0bBookDetails\x12(\n\x07subject\x18\x03\x20\x03(\
    \x0b2\x0c.BookSubjectR\x07subjectB\0\x12\x1e\n\tpublisher\x18\x04\x20\
    \x01(\tR\tpublisherB\0\x12*\n\x0fpublicationDate\x18\x05\x20\x01(\tR\x0f\
    publicationDateB\0\x12\x14\n\x04isbn\x18\x06\x20\x01(\tR\x04isbnB\0\x12&\
    \n\rnumberOfPages\x18\x07\x20\x01(\x05R\rnumberOfPagesB\0\x12\x1c\n\x08s\
    ubtitle\x18\x08\x20\x01(\tR\x08subtitleB\0\x12%\n\x06author\x18\t\x20\
    \x03(\x0b2\x0b.BookAuthorR\x06authorB\0\x12\x1e\n\treaderUrl\x18\n\x20\
    \x01(\tR\treaderUrlB\0\x12*\n\x0fdownloadEpubUrl\x18\x0b\x20\x01(\tR\x0f\
    downloadEpubUrlB\0\x12(\n\x0edownloadPdfUrl\x18\x0c\x20\x01(\tR\x0edownl\
    oadPdfUrlB\0\x12*\n\x0facsEpubTokenUrl\x18\r\x20\x01(\tR\x0facsEpubToken\
    UrlB\0\x12(\n\x0eacsPdfTokenUrl\x18\x0e\x20\x01(\tR\x0eacsPdfTokenUrlB\0\
    \x12&\n\repubAvailable\x18\x0f\x20\x01(\x08R\repubAvailableB\0\x12$\n\
    \x0cpdfAvailable\x18\x10\x20\x01(\x08R\x0cpdfAvailableB\0\x12(\n\x0eabou\
    tTheAuthor\x18\x11\x20\x01(\tR\x0eaboutTheAuthorB\0\x129\n\nidentifier\
    \x18\x12\x20\x03(\n2\x17.BookDetails.IdentifierR\nidentifierB\0\x120\n\
    \x12fixedLayoutContent\x18\x15\x20\x01(\x08R\x12fixedLayoutContentB\0\
    \x12.\n\x11audioVideoContent\x18\x16\x20\x01(\x08R\x11audioVideoContentB\
    \0\x12$\n\x0cisAgencyBook\x18\x17\x20\x01(\x08R\x0cisAgencyBookB\0\x1aD\
    \n\nIdentifier\x12\x14\n\x04type\x18\x13\x20\x01(\x05R\x04typeB\0\x12\
    \x20\n\nidentifier\x18\x14\x20\x01(\tR\nidentifierB\0:\0\"]\n\x0bBookSub\
    ject\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12\x16\n\x05query\
    \x18\x02\x20\x01(\tR\x05queryB\0\x12\x1e\n\tsubjectId\x18\x03\x20\x01(\t\
    R\tsubjectIdB\0:\0\"n\n\nBrowseLink\x12\x14\n\x04name\x18\x01\x20\x01(\t\
    R\x04nameB\0\x12\x1a\n\x07dataUrl\x18\x03\x20\x01(\tR\x07dataUrlB\0\x12,\
    \n\x10serverLogsCookie\x18\x04\x20\x01(\x0cR\x10serverLogsCookieB\0:\0\"\
    \x88\x02\n\x0eBrowseResponse\x12\"\n\x0bcontentsUrl\x18\x01\x20\x01(\tR\
    \x0bcontentsUrlB\0\x12\x1c\n\x08promoUrl\x18\x02\x20\x01(\tR\x08promoUrl\
    B\0\x12)\n\x08category\x18\x03\x20\x03(\x0b2\x0b.BrowseLinkR\x08category\
    B\0\x12-\n\nbreadcrumb\x18\x04\x20\x03(\x0b2\x0b.BrowseLinkR\nbreadcrumb\
    B\0\x12*\n\tquickLink\x18\x05\x20\x03(\x0b2\n.QuickLinkR\tquickLinkB\0\
    \x12,\n\x10serverLogsCookie\x18\x06\x20\x01(\x0cR\x10serverLogsCookieB\0\
    :\0\"\x84\x02\n\tQuickLink\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04name\
    B\0\x12\x1e\n\x05image\x18\x02\x20\x01(\x0b2\x06.ImageR\x05imageB\0\x12#\
    \n\x04link\x18\x03\x20\x01(\x0b2\r.ResolvedLinkR\x04linkB\0\x12*\n\x0fdi\
    splayRequired\x18\x04\x20\x01(\x08R\x0fdisplayRequiredB\0\x12,\n\x10serv\
    erLogsCookie\x18\x05\x20\x01(\x0cR\x10serverLogsCookieB\0\x12\x1e\n\tbac\
    kendId\x18\x06\x20\x01(\x05R\tbackendIdB\0\x12\x20\n\nprismStyle\x18\x07\
    \x20\x01(\x08R\nprismStyleB\0:\0\"\xa7\x0b\n\x0bBuyResponse\x12K\n\x10pu\
    rchaseResponse\x18\x01\x20\x01(\x0b2\x1d.PurchaseNotificationResponseR\
    \x10purchaseResponseB\0\x12?\n\x0ccheckoutinfo\x18\x02\x20\x01(\n2\x19.B\
    uyResponse.CheckoutInfoR\x0ccheckoutinfoB\0\x12(\n\x0econtinueViaUrl\x18\
    \x08\x20\x01(\tR\x0econtinueViaUrlB\0\x12.\n\x11purchaseStatusUrl\x18\t\
    \x20\x01(\tR\x11purchaseStatusUrlB\0\x12.\n\x11checkoutServiceId\x18\x0c\
    \x20\x01(\tR\x11checkoutServiceIdB\0\x126\n\x15checkoutTokenRequired\x18\
    \r\x20\x01(\x08R\x15checkoutTokenRequiredB\0\x12*\n\x0fbaseCheckoutUrl\
    \x18\x0e\x20\x01(\tR\x0fbaseCheckoutUrlB\0\x12*\n\x0ftosCheckboxHtml\x18\
    %\x20\x03(\tR\x0ftosCheckboxHtmlB\0\x12*\n\x0fpermissionError\x18&\x20\
    \x01(\x05R\x0fpermissionErrorB\0\x12Q\n\x16purchaseStatusResponse\x18'\
    \x20\x01(\x0b2\x17.PurchaseStatusResponseR\x16purchaseStatusResponseB\0\
    \x12(\n\x0epurchaseCookie\x18.\x20\x01(\tR\x0epurchaseCookieB\0\x12*\n\t\
    challenge\x181\x20\x01(\x0b2\n.ChallengeR\tchallengeB\0\x12:\n\x17addIns\
    trumentPromptHtml\x182\x20\x01(\tR\x17addInstrumentPromptHtmlB\0\x12.\n\
    \x11confirmButtonText\x183\x20\x01(\tR\x11confirmButtonTextB\0\x12<\n\
    \x18permissionErrorTitleText\x184\x20\x01(\tR\x18permissionErrorTitleTex\
    tB\0\x12@\n\x1apermissionErrorMessageText\x185\x20\x01(\tR\x1apermission\
    ErrorMessageTextB\0\x12,\n\x10serverLogsCookie\x186\x20\x01(\x0cR\x10ser\
    verLogsCookieB\0\x124\n\x14encodedDeliveryToken\x187\x20\x01(\tR\x14enco\
    dedDeliveryTokenB\0\x1a\xc8\x03\n\x0cCheckoutInfo\x12\x1f\n\x04item\x18\
    \x03\x20\x01(\x0b2\t.LineItemR\x04itemB\0\x12%\n\x07subItem\x18\x04\x20\
    \x03(\x0b2\t.LineItemR\x07subItemB\0\x12E\n\x0echeckoutoption\x18\x05\
    \x20\x03(\n2\x1b.BuyResponse.CheckoutOptionR\x0echeckoutoptionB\0\x126\n\
    \x15deprecatedCheckoutUrl\x18\n\x20\x01(\tR\x15deprecatedCheckoutUrlB\0\
    \x12,\n\x10addInstrumentUrl\x18\x0b\x20\x01(\tR\x10addInstrumentUrlB\0\
    \x12\x20\n\nfooterHtml\x18\x14\x20\x03(\tR\nfooterHtmlB\0\x12<\n\x18elig\
    ibleInstrumentFamily\x18\x1f\x20\x03(\x05R\x18eligibleInstrumentFamilyB\
    \0\x12$\n\x0cfootnoteHtml\x18$\x20\x03(\tR\x0cfootnoteHtmlB\0\x12=\n\x12\
    eligibleInstrument\x18,\x20\x03(\x0b2\x0b.InstrumentR\x12eligibleInstrum\
    entB\0:\0\"\x88\x01\n\x08LineItem\x12\x14\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\0\x12\"\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescriptionB\0\
    \x12\x1e\n\x05offer\x18\x03\x20\x01(\x0b2\x06.OfferR\x05offerB\0\x12\x20\
    \n\x06amount\x18\x04\x20\x01(\x0b2\x06.MoneyR\x06amountB\0:\0\"u\n\x05Mo\
    ney\x12\x18\n\x06micros\x18\x01\x20\x01(\x03R\x06microsB\0\x12$\n\x0ccur\
    rencyCode\x18\x02\x20\x01(\tR\x0ccurrencyCodeB\0\x12*\n\x0fformattedAmou\
    nt\x18\x03\x20\x01(\tR\x0fformattedAmountB\0:\0\"\xc0\x01\n\x1cPurchaseN\
    otificationResponse\x12\x18\n\x06status\x18\x01\x20\x01(\x05R\x06statusB\
    \0\x12*\n\tdebugInfo\x18\x02\x20\x01(\x0b2\n.DebugInfoR\tdebugInfoB\0\
    \x126\n\x15localizedErrorMessage\x18\x03\x20\x01(\tR\x15localizedErrorMe\
    ssageB\0\x12\x20\n\npurchaseId\x18\x04\x20\x01(\tR\npurchaseIdB\0:\0\"\
    \xf6\x02\n\x16PurchaseStatusResponse\x12\x18\n\x06status\x18\x01\x20\x01\
    (\x05R\x06statusB\0\x12\x1e\n\tstatusMsg\x18\x02\x20\x01(\tR\tstatusMsgB\
    \0\x12\"\n\x0bstatusTitle\x18\x03\x20\x01(\tR\x0bstatusTitleB\0\x12$\n\
    \x0cbriefMessage\x18\x04\x20\x01(\tR\x0cbriefMessageB\0\x12\x1a\n\x07inf\
    oUrl\x18\x05\x20\x01(\tR\x07infoUrlB\0\x126\n\rlibraryUpdate\x18\x06\x20\
    \x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdateB\0\x12=\n\x12rejectedInstru\
    ment\x18\x07\x20\x01(\x0b2\x0b.InstrumentR\x12rejectedInstrumentB\0\x12C\
    \n\x0fappDeliveryData\x18\x08\x20\x01(\x0b2\x17.AndroidAppDeliveryDataR\
    \x0fappDeliveryDataB\0:\0\"\x9b\x01\n\x16BillingProfileResponse\x12\x18\
    \n\x06result\x18\x01\x20\x01(\x05R\x06resultB\0\x129\n\x0ebillingProfile\
    \x18\x02\x20\x01(\x0b2\x0f.BillingProfileR\x0ebillingProfileB\0\x12*\n\
    \x0fuserMessageHtml\x18\x03\x20\x01(\tR\x0fuserMessageHtmlB\0:\0\"\xfb\
    \x01\n\x17CheckInstrumentResponse\x128\n\x16userHasValidInstrument\x18\
    \x01\x20\x01(\x08R\x16userHasValidInstrumentB\0\x126\n\x15checkoutTokenR\
    equired\x18\x02\x20\x01(\x08R\x15checkoutTokenRequiredB\0\x12-\n\ninstru\
    ment\x18\x04\x20\x03(\x0b2\x0b.InstrumentR\ninstrumentB\0\x12=\n\x12elig\
    ibleInstrument\x18\x05\x20\x03(\x0b2\x0b.InstrumentR\x12eligibleInstrume\
    ntB\0:\0\"\x8d\x01\n\x1bInstrumentSetupInfoResponse\x124\n\tsetupInfo\
    \x18\x01\x20\x03(\x0b2\x14.InstrumentSetupInfoR\tsetupInfoB\0\x126\n\x15\
    checkoutTokenRequired\x18\x02\x20\x01(\x08R\x15checkoutTokenRequiredB\0:\
    \0\"\xc7\x01\n\x15RedeemGiftCardRequest\x12\"\n\x0bgiftCardPin\x18\x01\
    \x20\x01(\tR\x0bgiftCardPinB\0\x12$\n\x07address\x18\x02\x20\x01(\x0b2\
    \x08.AddressR\x07addressB\0\x12:\n\x17acceptedLegalDocumentId\x18\x03\
    \x20\x03(\tR\x17acceptedLegalDocumentIdB\0\x12&\n\rcheckoutToken\x18\x04\
    \x20\x01(\tR\rcheckoutTokenB\0:\0\"\xfd\x01\n\x16RedeemGiftCardResponse\
    \x12\x18\n\x06result\x18\x01\x20\x01(\x05R\x06resultB\0\x12*\n\x0fuserMe\
    ssageHtml\x18\x02\x20\x01(\tR\x0fuserMessageHtmlB\0\x12\"\n\x0bbalanceHt\
    ml\x18\x03\x20\x01(\tR\x0bbalanceHtmlB\0\x12?\n\x10addressChallenge\x18\
    \x04\x20\x01(\x0b2\x11.AddressChallengeR\x10addressChallengeB\0\x126\n\
    \x15checkoutTokenRequired\x18\x05\x20\x01(\x08R\x15checkoutTokenRequired\
    B\0:\0\"r\n\x17UpdateInstrumentRequest\x12-\n\ninstrument\x18\x01\x20\
    \x01(\x0b2\x0b.InstrumentR\ninstrumentB\0\x12&\n\rcheckoutToken\x18\x02\
    \x20\x01(\tR\rcheckoutTokenB\0:\0\"\xc0\x02\n\x18UpdateInstrumentRespons\
    e\x12\x18\n\x06result\x18\x01\x20\x01(\x05R\x06resultB\0\x12$\n\x0cinstr\
    umentId\x18\x02\x20\x01(\tR\x0cinstrumentIdB\0\x12*\n\x0fuserMessageHtml\
    \x18\x03\x20\x01(\tR\x0fuserMessageHtmlB\0\x12A\n\x0ferrorInputField\x18\
    \x04\x20\x03(\x0b2\x15.InputValidationErrorR\x0ferrorInputFieldB\0\x126\
    \n\x15checkoutTokenRequired\x18\x05\x20\x01(\x08R\x15checkoutTokenRequir\
    edB\0\x12;\n\rredeemedOffer\x18\x06\x20\x01(\x0b2\x13.RedeemedPromoOffer\
    R\rredeemedOfferB\0:\0\"?\n\x1bInitiateAssociationResponse\x12\x1e\n\tus\
    erToken\x18\x01\x20\x01(\tR\tuserTokenB\0:\0\"\xce\x01\n\x19VerifyAssoci\
    ationResponse\x12\x18\n\x06status\x18\x01\x20\x01(\x05R\x06statusB\0\x12\
    2\n\x0ebillingAddress\x18\x02\x20\x01(\x0b2\x08.AddressR\x0ebillingAddre\
    ssB\0\x12-\n\ncarrierTos\x18\x03\x20\x01(\x0b2\x0b.CarrierTosR\ncarrierT\
    osB\0\x122\n\x13carrierErrorMessage\x18\x04\x20\x01(\tR\x13carrierErrorM\
    essageB\0:\0\"\xe0\x03\n\x10AddressChallenge\x124\n\x14responseAddressPa\
    ram\x18\x01\x20\x01(\tR\x14responseAddressParamB\0\x12:\n\x17responseChe\
    ckboxesParam\x18\x02\x20\x01(\tR\x17responseCheckboxesParamB\0\x12\x16\n\
    \x05title\x18\x03\x20\x01(\tR\x05titleB\0\x12*\n\x0fdescriptionHtml\x18\
    \x04\x20\x01(\tR\x0fdescriptionHtmlB\0\x12+\n\x08checkbox\x18\x05\x20\
    \x03(\x0b2\r.FormCheckboxR\x08checkboxB\0\x12$\n\x07address\x18\x06\x20\
    \x01(\x0b2\x08.AddressR\x07addressB\0\x12A\n\x0ferrorInputField\x18\x07\
    \x20\x03(\x0b2\x15.InputValidationErrorR\x0ferrorInputFieldB\0\x12\x1e\n\
    \terrorHtml\x18\x08\x20\x01(\tR\terrorHtmlB\0\x12&\n\rrequiredField\x18\
    \t\x20\x03(\x05R\rrequiredFieldB\0\x126\n\x10supportedCountry\x18\n\x20\
    \x03(\x0b2\x08.CountryR\x10supportedCountryB\0:\0\"\xf6\x03\n\x17Authent\
    icationChallenge\x120\n\x12authenticationType\x18\x01\x20\x01(\x05R\x12a\
    uthenticationTypeB\0\x12J\n\x1fresponseAuthenticationTypeParam\x18\x02\
    \x20\x01(\tR\x1fresponseAuthenticationTypeParamB\0\x12:\n\x17responseRet\
    ryCountParam\x18\x03\x20\x01(\tR\x17responseRetryCountParamB\0\x12(\n\
    \x0egaiaHeaderText\x18\x06\x20\x01(\tR\x0egaiaHeaderTextB\0\x12:\n\x17ga\
    iaDescriptionTextHtml\x18\x07\x20\x01(\tR\x17gaiaDescriptionTextHtmlB\0\
    \x120\n\x12gaiaFooterTextHtml\x18\x08\x20\x01(\tR\x12gaiaFooterTextHtmlB\
    \0\x12?\n\x12gaiaOptOutCheckbox\x18\t\x20\x01(\x0b2\r.FormCheckboxR\x12g\
    aiaOptOutCheckboxB\0\x12F\n\x1dgaiaOptOutDescriptionTextHtml\x18\n\x20\
    \x01(\tR\x1dgaiaOptOutDescriptionTextHtmlB\0:\0\"\xe5\x01\n\tChallenge\
    \x12?\n\x10addressChallenge\x18\x01\x20\x01(\x0b2\x11.AddressChallengeR\
    \x10addressChallengeB\0\x12T\n\x17authenticationChallenge\x18\x02\x20\
    \x01(\x0b2\x18.AuthenticationChallengeR\x17authenticationChallengeB\0\
    \x12?\n\x10webViewChallenge\x18\x03\x20\x01(\x0b2\x11.WebViewChallengeR\
    \x10webViewChallengeB\0:\0\"Q\n\x07Country\x12\x20\n\nregionCode\x18\x01\
    \x20\x01(\tR\nregionCodeB\0\x12\"\n\x0bdisplayName\x18\x02\x20\x01(\tR\
    \x0bdisplayNameB\0:\0\"\x80\x01\n\x0cFormCheckbox\x12\"\n\x0bdescription\
    \x18\x01\x20\x01(\tR\x0bdescriptionB\0\x12\x1a\n\x07checked\x18\x02\x20\
    \x01(\x08R\x07checkedB\0\x12\x1c\n\x08required\x18\x03\x20\x01(\x08R\x08\
    requiredB\0\x12\x10\n\x02id\x18\x04\x20\x01(\tR\x02idB\0:\0\"`\n\x14Inpu\
    tValidationError\x12\x20\n\ninputField\x18\x01\x20\x01(\x05R\ninputField\
    B\0\x12$\n\x0cerrorMessage\x18\x02\x20\x01(\tR\x0cerrorMessageB\0:\0\"\
    \x9a\x02\n\x10WebViewChallenge\x12\x1c\n\x08startUrl\x18\x01\x20\x01(\tR\
    \x08startUrlB\0\x12*\n\x0ftargetUrlRegexp\x18\x02\x20\x01(\tR\x0ftargetU\
    rlRegexpB\0\x12<\n\x18cancelButtonDisplayLabel\x18\x03\x20\x01(\tR\x18ca\
    ncelButtonDisplayLabelB\0\x128\n\x16responseTargetUrlParam\x18\x04\x20\
    \x01(\tR\x16responseTargetUrlParamB\0\x12*\n\x0fcancelUrlRegexp\x18\x05\
    \x20\x01(\tR\x0fcancelUrlRegexpB\0\x12\x16\n\x05title\x18\x06\x20\x01(\t\
    R\x05titleB\0:\0\"\xcf\x02\n\x17AddCreditCardPromoOffer\x12\x20\n\nheade\
    rText\x18\x01\x20\x01(\tR\nheaderTextB\0\x12*\n\x0fdescriptionHtml\x18\
    \x02\x20\x01(\tR\x0fdescriptionHtmlB\0\x12\x1e\n\x05image\x18\x03\x20\
    \x01(\x0b2\x06.ImageR\x05imageB\0\x124\n\x14introductoryTextHtml\x18\x04\
    \x20\x01(\tR\x14introductoryTextHtmlB\0\x12\x20\n\nofferTitle\x18\x05\
    \x20\x01(\tR\nofferTitleB\0\x122\n\x13noActionDescription\x18\x06\x20\
    \x01(\tR\x13noActionDescriptionB\0\x128\n\x16termsAndConditionsHtml\x18\
    \x07\x20\x01(\tR\x16termsAndConditionsHtmlB\0:\0\"c\n\x13AvailablePromoO\
    ffer\x12J\n\x12addCreditCardOffer\x18\x01\x20\x01(\x0b2\x18.AddCreditCar\
    dPromoOfferR\x12addCreditCardOfferB\0:\0\"\xd0\x01\n\x17CheckPromoOfferR\
    esponse\x12>\n\x0eavailableOffer\x18\x01\x20\x03(\x0b2\x14.AvailableProm\
    oOfferR\x0eavailableOfferB\0\x12;\n\rredeemedOffer\x18\x02\x20\x01(\x0b2\
    \x13.RedeemedPromoOfferR\rredeemedOfferB\0\x126\n\x15checkoutTokenRequir\
    ed\x18\x03\x20\x01(\x08R\x15checkoutTokenRequiredB\0:\0\"\x84\x01\n\x12R\
    edeemedPromoOffer\x12\x20\n\nheaderText\x18\x01\x20\x01(\tR\nheaderTextB\
    \0\x12*\n\x0fdescriptionHtml\x18\x02\x20\x01(\tR\x0fdescriptionHtmlB\0\
    \x12\x1e\n\x05image\x18\x03\x20\x01(\x0b2\x06.ImageR\x05imageB\0:\0\"\
    \xa7\x01\n\x11ActiveExperiments\x12<\n\x18clientAlteringExperiment\x18\
    \x01\x20\x03(\tR\x18clientAlteringExperimentB\0\x12*\n\x0fotherExperimen\
    t\x18\x02\x20\x03(\tR\x0fotherExperimentB\0\x12&\n\rgwsExperiment\x18\
    \x03\x20\x03(\x05R\rgwsExperimentB\0:\0\"\xfd\x02\n\x11AndroidClientInfo\
    \x12\x1e\n\tandroidId\x18\x01\x20\x01(\x03R\tandroidIdB\0\x12\x1e\n\tlog\
    gingId\x18\x02\x20\x01(\tR\tloggingIdB\0\x12\x20\n\nsdkVersion\x18\x03\
    \x20\x01(\x05R\nsdkVersionB\0\x12\x16\n\x05model\x18\x04\x20\x01(\tR\x05\
    modelB\0\x12\x1a\n\x07product\x18\x05\x20\x01(\tR\x07productB\0\x12\x1a\
    \n\x07osBuild\x18\x06\x20\x01(\tR\x07osBuildB\0\x12,\n\x10applicationBui\
    ld\x18\x07\x20\x01(\tR\x10applicationBuildB\0\x12\x1c\n\x08hardware\x18\
    \x08\x20\x01(\tR\x08hardwareB\0\x12\x18\n\x06device\x18\t\x20\x01(\tR\
    \x06deviceB\0\x12\x18\n\x06mccMnc\x18\n\x20\x01(\tR\x06mccMncB\0\x12\x18\
    \n\x06locale\x18\x0b\x20\x01(\tR\x06localeB\0\x12\x1a\n\x07country\x18\
    \x0c\x20\x01(\tR\x07countryB\0:\0\"\xf0\x01\n\nClientInfo\x12\x20\n\ncli\
    entType\x18\x01\x20\x01(\x05R\nclientTypeB\0\x12B\n\x11androidClientInfo\
    \x18\x02\x20\x01(\x0b2\x12.AndroidClientInfoR\x11androidClientInfoB\0\
    \x12B\n\x11desktopClientInfo\x18\x03\x20\x01(\x0b2\x12.DesktopClientInfo\
    R\x11desktopClientInfoB\0\x126\n\riosClientInfo\x18\x04\x20\x01(\x0b2\
    \x0e.IosClientInfoR\riosClientInfoB\0:\0\"\xe5\x01\n\x11DesktopClientInf\
    o\x12\x1c\n\x08clientId\x18\x01\x20\x01(\tR\x08clientIdB\0\x12\x1e\n\tlo\
    ggingId\x18\x02\x20\x01(\tR\tloggingIdB\0\x12\x10\n\x02os\x18\x03\x20\
    \x01(\tR\x02osB\0\x12(\n\x0eosMajorVersion\x18\x04\x20\x01(\tR\x0eosMajo\
    rVersionB\0\x12&\n\rosFullVersion\x18\x05\x20\x01(\tR\rosFullVersionB\0\
    \x12,\n\x10applicationBuild\x18\x06\x20\x01(\tR\x10applicationBuildB\0:\
    \0\"&\n\x10ExperimentIdList\x12\x10\n\x02id\x18\x01\x20\x03(\tR\x02idB\0\
    :\0\"\xcf\x01\n\rIosClientInfo\x12\x1c\n\x08clientId\x18\x01\x20\x01(\tR\
    \x08clientIdB\0\x12\x1e\n\tloggingId\x18\x02\x20\x01(\tR\tloggingIdB\0\
    \x12(\n\x0eosMajorVersion\x18\x03\x20\x01(\tR\x0eosMajorVersionB\0\x12&\
    \n\rosFullVersion\x18\x04\x20\x01(\tR\rosFullVersionB\0\x12,\n\x10applic\
    ationBuild\x18\x05\x20\x01(\tR\x10applicationBuildB\0:\0\"\xf0\x01\n\x08\
    LogEvent\x12\"\n\x0beventTimeMs\x18\x01\x20\x01(\x03R\x0beventTimeMsB\0\
    \x12\x12\n\x03tag\x18\x02\x20\x01(\tR\x03tagB\0\x12*\n\x05value\x18\x03\
    \x20\x03(\x0b2\x12.LogEventKeyValuesR\x05valueB\0\x12*\n\x05store\x18\
    \x04\x20\x01(\x0b2\x12.PlayStoreLogEventR\x05storeB\0\x12*\n\x0fsourceEx\
    tension\x18\x06\x20\x01(\x0cR\x0fsourceExtensionB\0\x12&\n\x03exp\x18\
    \x07\x20\x01(\x0b2\x12.ActiveExperimentsR\x03expB\0:\0\"A\n\x11LogEventK\
    eyValues\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05valueB\0:\0\"\xe2\x01\n\nLogRequest\x12-\n\ncl\
    ientInfo\x18\x01\x20\x01(\x0b2\x0b.ClientInfoR\nclientInfoB\0\x12\x1e\n\
    \tlogSource\x18\x02\x20\x01(\x05R\tlogSourceB\0\x12'\n\x08logEvent\x18\
    \x03\x20\x03(\x0b2\t.LogEventR\x08logEventB\0\x12&\n\rrequestTimeMs\x18\
    \x04\x20\x01(\x03R\rrequestTimeMsB\0\x122\n\x13serializedLogEvents\x18\
    \x05\x20\x01(\x0cR\x13serializedLogEventsB\0:\0\"~\n\x0bLogResponse\x126\
    \n\x15nextRequestWaitMillis\x18\x01\x20\x01(\x03R\x15nextRequestWaitMill\
    isB\0\x125\n\x0bexperiments\x18\x02\x20\x01(\x0b2\x11.ExperimentIdListR\
    \x0bexperimentsB\0:\0\"a\n\x05Docid\x12$\n\x0cbackendDocid\x18\x01\x20\
    \x01(\tR\x0cbackendDocidB\0\x12\x14\n\x04type\x18\x02\x20\x01(\x05R\x04t\
    ypeB\0\x12\x1a\n\x07backend\x18\x03\x20\x01(\x05R\x07backendB\0:\0\"\x7f\
    \n\x07Install\x12\x1e\n\tandroidId\x18\x01\x20\x01(\x06R\tandroidIdB\0\
    \x12\x1a\n\x07version\x18\x02\x20\x01(\x05R\x07versionB\0\x12\x1a\n\x07b\
    undled\x18\x03\x20\x01(\x08R\x07bundledB\0\x12\x1a\n\x07pending\x18\x04\
    \x20\x01(\x08R\x07pendingB\0:\0\"\x13\n\x0fGroupLicenseKey:\0\"N\n\x0cLi\
    censeTerms\x12<\n\x0fgroupLicenseKey\x18\x01\x20\x01(\x0b2\x10.GroupLice\
    nseKeyR\x0fgroupLicenseKeyB\0:\0\"\xbd\n\n\x05Offer\x12\x18\n\x06micros\
    \x18\x01\x20\x01(\x03R\x06microsB\0\x12$\n\x0ccurrencyCode\x18\x02\x20\
    \x01(\tR\x0ccurrencyCodeB\0\x12*\n\x0fformattedAmount\x18\x03\x20\x01(\t\
    R\x0fformattedAmountB\0\x120\n\x0econvertedPrice\x18\x04\x20\x03(\x0b2\
    \x06.OfferR\x0econvertedPriceB\0\x124\n\x14checkoutFlowRequired\x18\x05\
    \x20\x01(\x08R\x14checkoutFlowRequiredB\0\x12*\n\x0ffullPriceMicros\x18\
    \x06\x20\x01(\x03R\x0ffullPriceMicrosB\0\x122\n\x13formattedFullAmount\
    \x18\x07\x20\x01(\tR\x13formattedFullAmountB\0\x12\x1e\n\tofferType\x18\
    \x08\x20\x01(\x05R\tofferTypeB\0\x120\n\x0brentalTerms\x18\t\x20\x01(\
    \x0b2\x0c.RentalTermsR\x0brentalTermsB\0\x12\x20\n\nonSaleDate\x18\n\x20\
    \x01(\x03R\nonSaleDateB\0\x12(\n\x0epromotionLabel\x18\x0b\x20\x03(\tR\
    \x0epromotionLabelB\0\x12B\n\x11subscriptionTerms\x18\x0c\x20\x01(\x0b2\
    \x12.SubscriptionTermsR\x11subscriptionTermsB\0\x12&\n\rformattedName\
    \x18\r\x20\x01(\tR\rformattedNameB\0\x124\n\x14formattedDescription\x18\
    \x0e\x20\x01(\tR\x14formattedDescriptionB\0\x12\x1c\n\x08preorder\x18\
    \x0f\x20\x01(\x08R\x08preorderB\0\x12R\n#onSaleDateDisplayTimeZoneOffset\
    Msec\x18\x10\x20\x01(\x05R#onSaleDateDisplayTimeZoneOffsetMsecB\0\x12.\n\
    \x11licensedOfferType\x18\x11\x20\x01(\x05R\x11licensedOfferTypeB\0\x12W\
    \n\x18subscriptionContentTerms\x18\x12\x20\x01(\x0b2\x19.SubscriptionCon\
    tentTermsR\x18subscriptionContentTermsB\0\x12\x1a\n\x07offerId\x18\x13\
    \x20\x01(\tR\x07offerIdB\0\x12H\n\x1epreorderFulfillmentDisplayDate\x18\
    \x14\x20\x01(\x03R\x1epreorderFulfillmentDisplayDateB\0\x123\n\x0clicens\
    eTerms\x18\x15\x20\x01(\x0b2\r.LicenseTermsR\x0clicenseTermsB\0\x12*\n\
    \x0ftemporarilyFree\x18\x16\x20\x01(\x08R\x0ftemporarilyFreeB\0\x123\n\
    \x0cvoucherTerms\x18\x17\x20\x01(\x0b2\r.VoucherTermsR\x0cvoucherTermsB\
    \0\x123\n\x0cofferPayment\x18\x18\x20\x03(\x0b2\r.OfferPaymentR\x0coffer\
    PaymentB\0\x12.\n\x11repeatLastPayment\x18\x19\x20\x01(\x08R\x11repeatLa\
    stPaymentB\0\x12(\n\x0ebuyButtonLabel\x18\x1a\x20\x01(\tR\x0ebuyButtonLa\
    belB\0\x128\n\x16instantPurchaseEnabled\x18\x1b\x20\x01(\x08R\x16instant\
    PurchaseEnabledB\0:\0\";\n\x0bMonthAndDay\x12\x16\n\x05month\x18\x01\x20\
    \x01(\rR\x05monthB\0\x12\x12\n\x03day\x18\x02\x20\x01(\rR\x03dayB\0:\0\"\
    \x89\x01\n\x12OfferPaymentPeriod\x12)\n\x08duration\x18\x01\x20\x01(\x0b\
    2\x0b.TimePeriodR\x08durationB\0\x12$\n\x05start\x18\x02\x20\x01(\x0b2\
    \x0c.MonthAndDayR\x05startB\0\x12\x20\n\x03end\x18\x03\x20\x01(\x0b2\x0c\
    .MonthAndDayR\x03endB\0:\0\"z\n\x14OfferPaymentOverride\x12\x18\n\x06mic\
    ros\x18\x01\x20\x01(\x03R\x06microsB\0\x12$\n\x05start\x18\x02\x20\x01(\
    \x0b2\x0c.MonthAndDayR\x05startB\0\x12\x20\n\x03end\x18\x03\x20\x01(\x0b\
    2\x0c.MonthAndDayR\x03endB\0:\0\"\xe4\x01\n\x0cOfferPayment\x12\x18\n\
    \x06micros\x18\x01\x20\x01(\x03R\x06microsB\0\x12$\n\x0ccurrencyCode\x18\
    \x02\x20\x01(\tR\x0ccurrencyCodeB\0\x12E\n\x12offerPaymentPeriod\x18\x03\
    \x20\x01(\x0b2\x13.OfferPaymentPeriodR\x12offerPaymentPeriodB\0\x12K\n\
    \x14offerPaymentOverride\x18\x04\x20\x03(\x0b2\x15.OfferPaymentOverrideR\
    \x14offerPaymentOverrideB\0:\0\"\x10\n\x0cVoucherTerms:\0\"\x89\x02\n\
    \x0bRentalTerms\x12D\n\x1cdEPRECATEDGrantPeriodSeconds\x18\x01\x20\x01(\
    \x05R\x1cdEPRECATEDGrantPeriodSecondsB\0\x12J\n\x1fdEPRECATEDActivatePer\
    iodSeconds\x18\x02\x20\x01(\x05R\x1fdEPRECATEDActivatePeriodSecondsB\0\
    \x12/\n\x0bgrantPeriod\x18\x03\x20\x01(\x0b2\x0b.TimePeriodR\x0bgrantPer\
    iodB\0\x125\n\x0eactivatePeriod\x18\x04\x20\x01(\x0b2\x0b.TimePeriodR\
    \x0eactivatePeriodB\0:\0\"P\n\nSignedData\x12\x20\n\nsignedData\x18\x01\
    \x20\x01(\tR\nsignedDataB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\tR\tsi\
    gnatureB\0:\0\"Z\n\x18SubscriptionContentTerms\x12<\n\x14requiredSubscri\
    ption\x18\x01\x20\x01(\x0b2\x06.DocidR\x14requiredSubscriptionB\0:\0\"\
    \x7f\n\x11SubscriptionTerms\x127\n\x0frecurringPeriod\x18\x01\x20\x01(\
    \x0b2\x0b.TimePeriodR\x0frecurringPeriodB\0\x12/\n\x0btrialPeriod\x18\
    \x02\x20\x01(\x0b2\x0b.TimePeriodR\x0btrialPeriodB\0:\0\"<\n\nTimePeriod\
    \x12\x14\n\x04unit\x18\x01\x20\x01(\x05R\x04unitB\0\x12\x16\n\x05count\
    \x18\x02\x20\x01(\x05R\x05countB\0:\0\"p\n\x12BillingAddressSpec\x120\n\
    \x12billingAddressType\x18\x01\x20\x01(\x05R\x12billingAddressTypeB\0\
    \x12&\n\rrequiredField\x18\x02\x20\x03(\x05R\rrequiredFieldB\0:\0\"\xd4\
    \x01\n\x0eBillingProfile\x12-\n\ninstrument\x18\x01\x20\x03(\x0b2\x0b.In\
    strumentR\ninstrumentB\0\x12D\n\x1cselectedExternalInstrumentId\x18\x02\
    \x20\x01(\tR\x1cselectedExternalInstrumentIdB\0\x12K\n\x14billingProfile\
    Option\x18\x03\x20\x03(\x0b2\x15.BillingProfileOptionR\x14billingProfile\
    OptionB\0:\0\"\xa1\x02\n\x14BillingProfileOption\x12\x14\n\x04type\x18\
    \x01\x20\x01(\x05R\x04typeB\0\x12$\n\x0cdisplayTitle\x18\x02\x20\x01(\tR\
    \x0cdisplayTitleB\0\x124\n\x14externalInstrumentId\x18\x03\x20\x01(\tR\
    \x14externalInstrumentIdB\0\x12*\n\ttopupInfo\x18\x04\x20\x01(\x0b2\n.To\
    pupInfoR\ttopupInfoB\0\x12i\n\x1ecarrierBillingInstrumentStatus\x18\x05\
    \x20\x01(\x0b2\x1f.CarrierBillingInstrumentStatusR\x1ecarrierBillingInst\
    rumentStatusB\0:\0\"W\n\x19CarrierBillingCredentials\x12\x16\n\x05value\
    \x18\x01\x20\x01(\tR\x05valueB\0\x12\x20\n\nexpiration\x18\x02\x20\x01(\
    \x03R\nexpirationB\0:\0\"\xc7\x03\n\x18CarrierBillingInstrument\x12&\n\r\
    instrumentKey\x18\x01\x20\x01(\tR\rinstrumentKeyB\0\x12\"\n\x0baccountTy\
    pe\x18\x02\x20\x01(\tR\x0baccountTypeB\0\x12$\n\x0ccurrencyCode\x18\x03\
    \x20\x01(\tR\x0ccurrencyCodeB\0\x12,\n\x10transactionLimit\x18\x04\x20\
    \x01(\x03R\x10transactionLimitB\0\x124\n\x14subscriberIdentifier\x18\x05\
    \x20\x01(\tR\x14subscriberIdentifierB\0\x12T\n\x17encryptedSubscriberInf\
    o\x18\x06\x20\x01(\x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscri\
    berInfoB\0\x12>\n\x0bcredentials\x18\x07\x20\x01(\x0b2\x1a.CarrierBillin\
    gCredentialsR\x0bcredentialsB\0\x12=\n\x12acceptedCarrierTos\x18\x08\x20\
    \x01(\x0b2\x0b.CarrierTosR\x12acceptedCarrierTosB\0:\0\"\xb8\x03\n\x1eCa\
    rrierBillingInstrumentStatus\x12-\n\ncarrierTos\x18\x01\x20\x01(\x0b2\
    \x0b.CarrierTosR\ncarrierTosB\0\x122\n\x13associationRequired\x18\x02\
    \x20\x01(\x08R\x13associationRequiredB\0\x12,\n\x10passwordRequired\x18\
    \x03\x20\x01(\x08R\x10passwordRequiredB\0\x12G\n\x15carrierPasswordPromp\
    t\x18\x04\x20\x01(\x0b2\x0f.PasswordPromptR\x15carrierPasswordPromptB\0\
    \x12\x20\n\napiVersion\x18\x05\x20\x01(\x05R\napiVersionB\0\x12\x14\n\
    \x04name\x18\x06\x20\x01(\tR\x04nameB\0\x12B\n\x11deviceAssociation\x18\
    \x07\x20\x01(\x0b2\x12.DeviceAssociationR\x11deviceAssociationB\0\x12>\n\
    \x19carrierSupportPhoneNumber\x18\x08\x20\x01(\tR\x19carrierSupportPhone\
    NumberB\0:\0\"\xd6\x01\n\nCarrierTos\x12*\n\x06dcbTos\x18\x01\x20\x01(\
    \x0b2\x10.CarrierTosEntryR\x06dcbTosB\0\x12*\n\x06piiTos\x18\x02\x20\x01\
    (\x0b2\x10.CarrierTosEntryR\x06piiTosB\0\x126\n\x15needsDcbTosAcceptance\
    \x18\x03\x20\x01(\x08R\x15needsDcbTosAcceptanceB\0\x126\n\x15needsPiiTos\
    Acceptance\x18\x04\x20\x01(\x08R\x15needsPiiTosAcceptanceB\0:\0\"C\n\x0f\
    CarrierTosEntry\x12\x12\n\x03url\x18\x01\x20\x01(\tR\x03urlB\0\x12\x1a\n\
    \x07version\x18\x02\x20\x01(\tR\x07versionB\0:\0\"\x81\x02\n\x14CreditCa\
    rdInstrument\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04typeB\0\x12$\n\
    \x0cescrowHandle\x18\x02\x20\x01(\tR\x0cescrowHandleB\0\x12\x20\n\nlastD\
    igits\x18\x03\x20\x01(\tR\nlastDigitsB\0\x12*\n\x0fexpirationMonth\x18\
    \x04\x20\x01(\x05R\x0fexpirationMonthB\0\x12(\n\x0eexpirationYear\x18\
    \x05\x20\x01(\x05R\x0eexpirationYearB\0\x123\n\x0eescrowEfeParam\x18\x06\
    \x20\x03(\x0b2\t.EfeParamR\x0eescrowEfeParamB\0:\0\"\x8d\x01\n\x11Device\
    Association\x12:\n\x17userTokenRequestMessage\x18\x01\x20\x01(\tR\x17use\
    rTokenRequestMessageB\0\x12:\n\x17userTokenRequestAddress\x18\x02\x20\
    \x01(\tR\x17userTokenRequestAddressB\0:\0\"\x94\x01\n\x0cDisabledInfo\
    \x12(\n\x0edisabledReason\x18\x01\x20\x01(\x05R\x0edisabledReasonB\0\x12\
    2\n\x13disabledMessageHtml\x18\x02\x20\x01(\tR\x13disabledMessageHtmlB\0\
    \x12$\n\x0cerrorMessage\x18\x03\x20\x01(\tR\x0cerrorMessageB\0:\0\"8\n\
    \x08EfeParam\x12\x12\n\x03key\x18\x01\x20\x01(\x05R\x03keyB\0\x12\x16\n\
    \x05value\x18\x02\x20\x01(\tR\x05valueB\0:\0\"\xb5\x05\n\nInstrument\x12\
    4\n\x14externalInstrumentId\x18\x01\x20\x01(\tR\x14externalInstrumentIdB\
    \0\x122\n\x0ebillingAddress\x18\x02\x20\x01(\x0b2\x08.AddressR\x0ebillin\
    gAddressB\0\x127\n\ncreditCard\x18\x03\x20\x01(\x0b2\x15.CreditCardInstr\
    umentR\ncreditCardB\0\x12C\n\x0ecarrierBilling\x18\x04\x20\x01(\x0b2\x19\
    .CarrierBillingInstrumentR\x0ecarrierBillingB\0\x12E\n\x12billingAddress\
    Spec\x18\x05\x20\x01(\x0b2\x13.BillingAddressSpecR\x12billingAddressSpec\
    B\0\x12,\n\x10instrumentFamily\x18\x06\x20\x01(\x05R\x10instrumentFamily\
    B\0\x12U\n\x14carrierBillingStatus\x18\x07\x20\x01(\x0b2\x1f.CarrierBill\
    ingInstrumentStatusR\x14carrierBillingStatusB\0\x12$\n\x0cdisplayTitle\
    \x18\x08\x20\x01(\tR\x0cdisplayTitleB\0\x12>\n\x13topupInfoDeprecated\
    \x18\t\x20\x01(\x0b2\n.TopupInfoR\x13topupInfoDeprecatedB\0\x12\x1a\n\
    \x07version\x18\n\x20\x01(\x05R\x07versionB\0\x12:\n\x0bstoredValue\x18\
    \x0b\x20\x01(\x0b2\x16.StoredValueInstrumentR\x0bstoredValueB\0\x123\n\
    \x0cdisabledInfo\x18\x0c\x20\x03(\x0b2\r.DisabledInfoR\x0cdisabledInfoB\
    \0:\0\"\xec\x01\n\x13InstrumentSetupInfo\x12,\n\x10instrumentFamily\x18\
    \x01\x20\x01(\x05R\x10instrumentFamilyB\0\x12\x1e\n\tsupported\x18\x02\
    \x20\x01(\x08R\tsupportedB\0\x12?\n\x10addressChallenge\x18\x03\x20\x01(\
    \x0b2\x11.AddressChallengeR\x10addressChallengeB\0\x12\"\n\x07balance\
    \x18\x04\x20\x01(\x0b2\x06.MoneyR\x07balanceB\0\x12\x20\n\nfooterHtml\
    \x18\x05\x20\x03(\tR\nfooterHtmlB\0:\0\"\\\n\x0ePasswordPrompt\x12\x18\n\
    \x06prompt\x18\x01\x20\x01(\tR\x06promptB\0\x12.\n\x11forgotPasswordUrl\
    \x18\x02\x20\x01(\tR\x11forgotPasswordUrlB\0:\0\"\x7f\n\x15StoredValueIn\
    strument\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04typeB\0\x12\"\n\x07b\
    alance\x18\x02\x20\x01(\x0b2\x06.MoneyR\x07balanceB\0\x12*\n\ttopupInfo\
    \x18\x03\x20\x01(\x0b2\n.TopupInfoR\ttopupInfoB\0:\0\"\xe1\x01\n\tTopupI\
    nfo\x12J\n\x1foptionsContainerDocidDeprecated\x18\x01\x20\x01(\tR\x1fopt\
    ionsContainerDocidDeprecatedB\0\x12(\n\x0eoptionsListUrl\x18\x02\x20\x01\
    (\tR\x0eoptionsListUrlB\0\x12\x1c\n\x08subtitle\x18\x03\x20\x01(\tR\x08s\
    ubtitleB\0\x12>\n\x15optionsContainerDocid\x18\x04\x20\x01(\x0b2\x06.Doc\
    idR\x15optionsContainerDocidB\0:\0\"m\n\x17ConsumePurchaseResponse\x126\
    \n\rlibraryUpdate\x18\x01\x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdat\
    eB\0\x12\x18\n\x06status\x18\x02\x20\x01(\x05R\x06statusB\0:\0\"\xa7\x02\
    \n\x11ContainerMetadata\x12\x1e\n\tbrowseUrl\x18\x01\x20\x01(\tR\tbrowse\
    UrlB\0\x12\"\n\x0bnextPageUrl\x18\x02\x20\x01(\tR\x0bnextPageUrlB\0\x12\
    \x1e\n\trelevance\x18\x03\x20\x01(\x01R\trelevanceB\0\x12,\n\x10estimate\
    dResults\x18\x04\x20\x01(\x03R\x10estimatedResultsB\0\x12*\n\x0fanalytic\
    sCookie\x18\x05\x20\x01(\tR\x0fanalyticsCookieB\0\x12\x1a\n\x07ordered\
    \x18\x06\x20\x01(\x08R\x07orderedB\0\x126\n\rcontainerView\x18\x07\x20\
    \x03(\x0b2\x0e.ContainerViewR\rcontainerViewB\0:\0\"\x91\x01\n\rContaine\
    rView\x12\x1c\n\x08selected\x18\x01\x20\x01(\x08R\x08selectedB\0\x12\x16\
    \n\x05title\x18\x02\x20\x01(\tR\x05titleB\0\x12\x1a\n\x07listUrl\x18\x03\
    \x20\x01(\tR\x07listUrlB\0\x12,\n\x10serverLogsCookie\x18\x04\x20\x01(\
    \x0cR\x10serverLogsCookieB\0:\0\"\x17\n\x13FlagContentResponse:\0\"\xa9\
    \x0b\n\x15ClientDownloadRequest\x12\x12\n\x03url\x18\x01\x20\x01(\tR\x03\
    urlB\0\x12:\n\x07digests\x18\x02\x20\x01(\x0b2\x1e.ClientDownloadRequest\
    .DigestsR\x07digestsB\0\x12\x18\n\x06length\x18\x03\x20\x01(\x03R\x06len\
    gthB\0\x12?\n\tresources\x18\x04\x20\x03(\x0b2\x1f.ClientDownloadRequest\
    .ResourceR\tresourcesB\0\x12D\n\tsignature\x18\x05\x20\x01(\x0b2$.Client\
    DownloadRequest.SignatureInfoR\tsignatureB\0\x12&\n\ruserInitiated\x18\
    \x06\x20\x01(\x08R\ruserInitiatedB\0\x12\x1e\n\tclientAsn\x18\x08\x20\
    \x03(\tR\tclientAsnB\0\x12$\n\x0cfileBasename\x18\t\x20\x01(\tR\x0cfileB\
    asenameB\0\x12$\n\x0cdownloadType\x18\n\x20\x01(\x05R\x0cdownloadTypeB\0\
    \x12\x18\n\x06locale\x18\x0b\x20\x01(\tR\x06localeB\0\x12:\n\x07apkInfo\
    \x18\x0c\x20\x01(\x0b2\x1e.ClientDownloadRequest.ApkInfoR\x07apkInfoB\0\
    \x12\x1e\n\tandroidId\x18\r\x20\x01(\x06R\tandroidIdB\0\x122\n\x13origin\
    atingPackages\x18\x0f\x20\x03(\tR\x13originatingPackagesB\0\x12Z\n\x14or\
    iginatingSignature\x18\x11\x20\x01(\x0b2$.ClientDownloadRequest.Signatur\
    eInfoR\x14originatingSignatureB\0\x1aS\n\x07ApkInfo\x12\"\n\x0bpackageNa\
    me\x18\x01\x20\x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\x18\x02\
    \x20\x01(\x05R\x0bversionCodeB\0:\0\x1a\xe1\x02\n\x10CertificateChain\
    \x12K\n\x07element\x18\x01\x20\x03(\x0b2/.ClientDownloadRequest.Certific\
    ateChain.ElementR\x07elementB\0\x1a\xfd\x01\n\x07Element\x12\"\n\x0bcert\
    ificate\x18\x01\x20\x01(\x0cR\x0bcertificateB\0\x120\n\x12parsedSuccessf\
    ully\x18\x02\x20\x01(\x08R\x12parsedSuccessfullyB\0\x12\x1a\n\x07subject\
    \x18\x03\x20\x01(\x0cR\x07subjectB\0\x12\x18\n\x06issuer\x18\x04\x20\x01\
    (\x0cR\x06issuerB\0\x12\"\n\x0bfingerprint\x18\x05\x20\x01(\x0cR\x0bfing\
    erprintB\0\x12\x20\n\nexpiryTime\x18\x06\x20\x01(\x03R\nexpiryTimeB\0\
    \x12\x1e\n\tstartTime\x18\x07\x20\x01(\x03R\tstartTimeB\0:\0:\0\x1aO\n\
    \x07Digests\x12\x18\n\x06sha256\x18\x01\x20\x01(\x0cR\x06sha256B\0\x12\
    \x14\n\x04sha1\x18\x02\x20\x01(\x0cR\x04sha1B\0\x12\x12\n\x03md5\x18\x03\
    \x20\x01(\x0cR\x03md5B\0:\0\x1ar\n\x08Resource\x12\x12\n\x03url\x18\x01\
    \x20\x01(\tR\x03urlB\0\x12\x14\n\x04type\x18\x02\x20\x01(\x05R\x04typeB\
    \0\x12\x1c\n\x08remoteIp\x18\x03\x20\x01(\x0cR\x08remoteIpB\0\x12\x1c\n\
    \x08referrer\x18\x04\x20\x01(\tR\x08referrerB\0:\0\x1a\x84\x01\n\rSignat\
    ureInfo\x12U\n\x10certificateChain\x18\x01\x20\x03(\x0b2'.ClientDownload\
    Request.CertificateChainR\x10certificateChainB\0\x12\x1a\n\x07trusted\
    \x18\x02\x20\x01(\x08R\x07trustedB\0:\0:\0\"\xd4\x01\n\x16ClientDownload\
    Response\x12\x1a\n\x07verdict\x18\x01\x20\x01(\x05R\x07verdictB\0\x12>\n\
    \x08moreInfo\x18\x02\x20\x01(\x0b2\x20.ClientDownloadResponse.MoreInfoR\
    \x08moreInfoB\0\x12\x16\n\x05token\x18\x03\x20\x01(\x0cR\x05tokenB\0\x1a\
    D\n\x08MoreInfo\x12\"\n\x0bdescription\x18\x01\x20\x01(\tR\x0bdescriptio\
    nB\0\x12\x12\n\x03url\x18\x02\x20\x01(\tR\x03urlB\0:\0:\0\"\\\n\x1aClien\
    tDownloadStatsRequest\x12$\n\x0cuserDecision\x18\x01\x20\x01(\x05R\x0cus\
    erDecisionB\0\x12\x16\n\x05token\x18\x02\x20\x01(\x0cR\x05tokenB\0:\0\"\
    \x94\x01\n\tDebugInfo\x12\x1a\n\x07message\x18\x01\x20\x03(\tR\x07messag\
    eB\0\x12+\n\x06timing\x18\x02\x20\x03(\n2\x11.DebugInfo.TimingR\x06timin\
    gB\0\x1a<\n\x06Timing\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\
    \x12\x1c\n\x08timeInMs\x18\x04\x20\x01(\x01R\x08timeInMsB\0:\0\"\x83\x01\
    \n\x15DebugSettingsResponse\x122\n\x13playCountryOverride\x18\x01\x20\
    \x01(\tR\x13playCountryOverrideB\0\x124\n\x14playCountryDebugInfo\x18\
    \x02\x20\x01(\tR\x14playCountryDebugInfoB\0:\0\"s\n\x10DeliveryResponse\
    \x12\x18\n\x06status\x18\x01\x20\x01(\x05R\x06statusB\0\x12C\n\x0fappDel\
    iveryData\x18\x02\x20\x01(\x0b2\x17.AndroidAppDeliveryDataR\x0fappDelive\
    ryDataB\0:\0\"0\n\x10BulkDetailsEntry\x12\x1a\n\x03doc\x18\x01\x20\x01(\
    \x0b2\x06.DocV2R\x03docB\0:\0\"\xec\x01\n\x12BulkDetailsRequest\x12\x16\
    \n\x05docid\x18\x01\x20\x03(\tR\x05docidB\0\x12,\n\x10includeChildDocs\
    \x18\x02\x20\x01(\x08R\x10includeChildDocsB\0\x12(\n\x0eincludeDetails\
    \x18\x03\x20\x01(\x08R\x0eincludeDetailsB\0\x12.\n\x11sourcePackageName\
    \x18\x04\x20\x01(\tR\x11sourcePackageNameB\0\x124\n\x14installedVersionC\
    ode\x18\x05\x20\x03(\x05R\x14installedVersionCodeB\0:\0\"B\n\x13BulkDeta\
    ilsResponse\x12)\n\x05entry\x18\x01\x20\x03(\x0b2\x11.BulkDetailsEntryR\
    \x05entryB\0:\0\"\xb5\x02\n\x0fDetailsResponse\x12\x1e\n\x05docV1\x18\
    \x01\x20\x01(\x0b2\x06.DocV1R\x05docV1B\0\x12*\n\x0fanalyticsCookie\x18\
    \x02\x20\x01(\tR\x0fanalyticsCookieB\0\x12)\n\nuserReview\x18\x03\x20\
    \x01(\x0b2\x07.ReviewR\nuserReviewB\0\x12\x1e\n\x05docV2\x18\x04\x20\x01\
    (\x0b2\x06.DocV2R\x05docV2B\0\x12\x20\n\nfooterHtml\x18\x05\x20\x01(\tR\
    \nfooterHtmlB\0\x12,\n\x10serverLogsCookie\x18\x06\x20\x01(\x0cR\x10serv\
    erLogsCookieB\0\x129\n\x0ediscoveryBadge\x18\x07\x20\x03(\x0b2\x0f.Disco\
    veryBadgeR\x0ediscoveryBadgeB\0:\0\"\xe3\x03\n\x0eDiscoveryBadge\x12\x16\
    \n\x05title\x18\x01\x20\x01(\tR\x05titleB\0\x12\x1e\n\x05image\x18\x02\
    \x20\x01(\x0b2\x06.ImageR\x05imageB\0\x12*\n\x0fbackgroundColor\x18\x03\
    \x20\x01(\x05R\x0fbackgroundColorB\0\x12E\n\x12discoveryBadgeLink\x18\
    \x04\x20\x01(\x0b2\x13.DiscoveryBadgeLinkR\x12discoveryBadgeLinkB\0\x12,\
    \n\x10serverLogsCookie\x18\x05\x20\x01(\x0cR\x10serverLogsCookieB\0\x12\
    \x1e\n\tisPlusOne\x18\x06\x20\x01(\x08R\tisPlusOneB\0\x12*\n\x0faggregat\
    eRating\x18\x07\x20\x01(\x02R\x0faggregateRatingB\0\x12(\n\x0euserStarRa\
    ting\x18\x08\x20\x01(\x05R\x0euserStarRatingB\0\x12&\n\rdownloadCount\
    \x18\t\x20\x01(\tR\rdownloadCountB\0\x12&\n\rdownloadUnits\x18\n\x20\x01\
    (\tR\rdownloadUnitsB\0\x120\n\x12contentDescription\x18\x0b\x20\x01(\tR\
    \x12contentDescriptionB\0:\0\"\x8b\x01\n\x12DiscoveryBadgeLink\x12\x1b\n\
    \x04link\x18\x01\x20\x01(\x0b2\x05.LinkR\x04linkB\0\x12(\n\x0euserReview\
    sUrl\x18\x02\x20\x01(\tR\x0euserReviewsUrlB\0\x12,\n\x10criticReviewsUrl\
    \x18\x03\x20\x01(\tR\x10criticReviewsUrlB\0:\0\"\xec\x05\n\x18DeviceConf\
    igurationProto\x12\"\n\x0btouchScreen\x18\x01\x20\x01(\x05R\x0btouchScre\
    enB\0\x12\x1c\n\x08keyboard\x18\x02\x20\x01(\x05R\x08keyboardB\0\x12\x20\
    \n\nnavigation\x18\x03\x20\x01(\x05R\nnavigationB\0\x12$\n\x0cscreenLayo\
    ut\x18\x04\x20\x01(\x05R\x0cscreenLayoutB\0\x12*\n\x0fhasHardKeyboard\
    \x18\x05\x20\x01(\x08R\x0fhasHardKeyboardB\0\x124\n\x14hasFiveWayNavigat\
    ion\x18\x06\x20\x01(\x08R\x14hasFiveWayNavigationB\0\x12&\n\rscreenDensi\
    ty\x18\x07\x20\x01(\x05R\rscreenDensityB\0\x12\"\n\x0bglEsVersion\x18\
    \x08\x20\x01(\x05R\x0bglEsVersionB\0\x122\n\x13systemSharedLibrary\x18\t\
    \x20\x03(\tR\x13systemSharedLibraryB\0\x128\n\x16systemAvailableFeature\
    \x18\n\x20\x03(\tR\x16systemAvailableFeatureB\0\x12(\n\x0enativePlatform\
    \x18\x0b\x20\x03(\tR\x0enativePlatformB\0\x12\"\n\x0bscreenWidth\x18\x0c\
    \x20\x01(\x05R\x0bscreenWidthB\0\x12$\n\x0cscreenHeight\x18\r\x20\x01(\
    \x05R\x0cscreenHeightB\0\x126\n\x15systemSupportedLocale\x18\x0e\x20\x03\
    (\tR\x15systemSupportedLocaleB\0\x12\"\n\x0bglExtension\x18\x0f\x20\x03(\
    \tR\x0bglExtensionB\0\x12\"\n\x0bdeviceClass\x18\x10\x20\x01(\x05R\x0bde\
    viceClassB\0\x124\n\x14maxApkDownloadSizeMb\x18\x11\x20\x01(\x05R\x14max\
    ApkDownloadSizeMbB\0:\0\"\xf3\x06\n\x08Document\x12\x1e\n\x05docid\x18\
    \x01\x20\x01(\x0b2\x06.DocidR\x05docidB\0\x12(\n\nfetchDocid\x18\x02\x20\
    \x01(\x0b2\x06.DocidR\nfetchDocidB\0\x12*\n\x0bsampleDocid\x18\x03\x20\
    \x01(\x0b2\x06.DocidR\x0bsampleDocidB\0\x12\x16\n\x05title\x18\x04\x20\
    \x01(\tR\x05titleB\0\x12\x12\n\x03url\x18\x05\x20\x01(\tR\x03urlB\0\x12\
    \x1a\n\x07snippet\x18\x06\x20\x03(\tR\x07snippetB\0\x122\n\x0fpriceDepre\
    cated\x18\x07\x20\x01(\x0b2\x06.OfferR\x0fpriceDeprecatedB\0\x123\n\x0ca\
    vailability\x18\t\x20\x01(\x0b2\r.AvailabilityR\x0cavailabilityB\0\x12\
    \x1e\n\x05image\x18\n\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12!\n\x05chi\
    ld\x18\x0b\x20\x03(\x0b2\t.DocumentR\x05childB\0\x12<\n\x0faggregateRati\
    ng\x18\r\x20\x01(\x0b2\x10.AggregateRatingR\x0faggregateRatingB\0\x12\
    \x1e\n\x05offer\x18\x0e\x20\x03(\x0b2\x06.OfferR\x05offerB\0\x12?\n\x11t\
    ranslatedSnippet\x18\x0f\x20\x03(\x0b2\x0f.TranslatedTextR\x11translated\
    SnippetB\0\x12<\n\x0fdocumentVariant\x18\x10\x20\x03(\x0b2\x10.DocumentV\
    ariantR\x0fdocumentVariantB\0\x12\x20\n\ncategoryId\x18\x11\x20\x03(\tR\
    \ncategoryIdB\0\x12+\n\ndecoration\x18\x12\x20\x03(\x0b2\t.DocumentR\nde\
    corationB\0\x12#\n\x06parent\x18\x13\x20\x03(\x0b2\t.DocumentR\x06parent\
    B\0\x12,\n\x10privacyPolicyUrl\x18\x14\x20\x01(\tR\x10privacyPolicyUrlB\
    \0\x12(\n\x0econsumptionUrl\x18\x15\x20\x01(\tR\x0econsumptionUrlB\0\x12\
    4\n\x14estimatedNumChildren\x18\x16\x20\x01(\x05R\x14estimatedNumChildre\
    nB\0\x12\x1c\n\x08subtitle\x18\x17\x20\x01(\tR\x08subtitleB\0:\0\"\xe1\
    \x03\n\x0fDocumentVariant\x12&\n\rvariationType\x18\x01\x20\x01(\x05R\rv\
    ariationTypeB\0\x12\x1b\n\x04rule\x18\x02\x20\x01(\x0b2\x05.RuleR\x04rul\
    eB\0\x12\x16\n\x05title\x18\x03\x20\x01(\tR\x05titleB\0\x12\x1a\n\x07sni\
    ppet\x18\x04\x20\x03(\tR\x07snippetB\0\x12&\n\rrecentChanges\x18\x05\x20\
    \x01(\tR\rrecentChangesB\0\x12;\n\x0fautoTranslation\x18\x06\x20\x03(\
    \x0b2\x0f.TranslatedTextR\x0fautoTranslationB\0\x12\x1e\n\x05offer\x18\
    \x07\x20\x03(\x0b2\x06.OfferR\x05offerB\0\x12\x1e\n\tchannelId\x18\t\x20\
    \x01(\x03R\tchannelIdB\0\x12!\n\x05child\x18\n\x20\x03(\x0b2\t.DocumentR\
    \x05childB\0\x12+\n\ndecoration\x18\x0b\x20\x03(\x0b2\t.DocumentR\ndecor\
    ationB\0\x12\x1e\n\x05image\x18\x0c\x20\x03(\x0b2\x06.ImageR\x05imageB\0\
    \x12\x20\n\ncategoryId\x18\r\x20\x03(\tR\ncategoryIdB\0\x12\x1c\n\x08sub\
    title\x18\x0e\x20\x01(\tR\x08subtitleB\0:\0\"\xce\x06\n\x05Image\x12\x1e\
    \n\timageType\x18\x01\x20\x01(\x05R\timageTypeB\0\x120\n\tdimension\x18\
    \x02\x20\x01(\n2\x10.Image.DimensionR\tdimensionB\0\x12\x1c\n\x08imageUr\
    l\x18\x05\x20\x01(\tR\x08imageUrlB\0\x12,\n\x10altTextLocalized\x18\x06\
    \x20\x01(\tR\x10altTextLocalizedB\0\x12\x1e\n\tsecureUrl\x18\x07\x20\x01\
    (\tR\tsecureUrlB\0\x120\n\x12positionInSequence\x18\x08\x20\x01(\x05R\
    \x12positionInSequenceB\0\x128\n\x16supportsFifeUrlOptions\x18\t\x20\x01\
    (\x08R\x16supportsFifeUrlOptionsB\0\x12-\n\x08citation\x18\n\x20\x01(\n2\
    \x0f.Image.CitationR\x08citationB\0\x12*\n\x0fdurationSeconds\x18\x0e\
    \x20\x01(\x05R\x0fdurationSecondsB\0\x12$\n\x0cfillColorRgb\x18\x0f\x20\
    \x01(\tR\x0cfillColorRgbB\0\x12\x1a\n\x07autogen\x18\x10\x20\x01(\x08R\
    \x07autogenB\0\x120\n\x0battribution\x18\x11\x20\x01(\x0b2\x0c.Attributi\
    onR\x0battributionB\0\x120\n\x12backgroundColorRgb\x18\x13\x20\x01(\tR\
    \x12backgroundColorRgbB\0\x12)\n\x07palette\x18\x14\x20\x01(\x0b2\r.Imag\
    ePaletteR\x07paletteB\0\x12\"\n\x0bdeviceClass\x18\x15\x20\x01(\x05R\x0b\
    deviceClassB\0\x12@\n\x1asupportsFifeMonogramOption\x18\x16\x20\x01(\x08\
    R\x1asupportsFifeMonogramOptionB\0\x1a=\n\tDimension\x12\x16\n\x05width\
    \x18\x03\x20\x01(\x05R\x05widthB\0\x12\x18\n\x06height\x18\x04\x20\x01(\
    \x05R\x06heightB\0\x1aH\n\x08Citation\x12(\n\x0etitleLocalized\x18\x0b\
    \x20\x01(\tR\x0etitleLocalizedB\0\x12\x12\n\x03url\x18\x0c\x20\x01(\tR\
    \x03urlB\0:\0\"\x10\n\x0cImagePalette:\0\"\x9b\x01\n\x0bAttribution\x12\
    \"\n\x0bsourceTitle\x18\x01\x20\x01(\tR\x0bsourceTitleB\0\x12\x1e\n\tsou\
    rceUrl\x18\x02\x20\x01(\tR\tsourceUrlB\0\x12$\n\x0clicenseTitle\x18\x03\
    \x20\x01(\tR\x0clicenseTitleB\0\x12\x20\n\nlicenseUrl\x18\x04\x20\x01(\t\
    R\nlicenseUrlB\0:\0\"t\n\x0eTranslatedText\x12\x14\n\x04text\x18\x01\x20\
    \x01(\tR\x04textB\0\x12$\n\x0csourceLocale\x18\x02\x20\x01(\tR\x0csource\
    LocaleB\0\x12$\n\x0ctargetLocale\x18\x03\x20\x01(\tR\x0ctargetLocaleB\0:\
    \0\"\x85\x01\n\x05Badge\x12\x16\n\x05title\x18\x01\x20\x01(\tR\x05titleB\
    \0\x12\x1e\n\x05image\x18\x02\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12\
    \x1e\n\tbrowseUrl\x18\x03\x20\x01(\tR\tbrowseUrlB\0\x12\"\n\x0bdescripti\
    on\x18\x04\x20\x01(\tR\x0bdescriptionB\0:\0\"j\n\x0eBadgeContainer\x12\
    \x16\n\x05title\x18\x01\x20\x01(\tR\x05titleB\0\x12\x1e\n\x05image\x18\
    \x02\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12\x1e\n\x05badge\x18\x03\x20\
    \x03(\x0b2\x06.BadgeR\x05badgeB\0:\0\"A\n\x13ContainerWithBanner\x12(\n\
    \x0ecolorThemeArgb\x18\x01\x20\x01(\tR\x0ecolorThemeArgbB\0:\0\"d\n\x0cD\
    ealOfTheDay\x12(\n\x0efeaturedHeader\x18\x01\x20\x01(\tR\x0efeaturedHead\
    erB\0\x12(\n\x0ecolorThemeArgb\x18\x02\x20\x01(\tR\x0ecolorThemeArgbB\0:\
    \0\"M\n\tDismissal\x12\x12\n\x03url\x18\x01\x20\x01(\tR\x03urlB\0\x12*\n\
    \x0fdescriptionHtml\x18\x02\x20\x01(\tR\x0fdescriptionHtmlB\0:\0\"\x9b\
    \x02\n\x18EditorialSeriesContainer\x12\"\n\x0bseriesTitle\x18\x01\x20\
    \x01(\tR\x0bseriesTitleB\0\x12(\n\x0eseriesSubtitle\x18\x02\x20\x01(\tR\
    \x0eseriesSubtitleB\0\x12$\n\x0cepisodeTitle\x18\x03\x20\x01(\tR\x0cepis\
    odeTitleB\0\x12*\n\x0fepisodeSubtitle\x18\x04\x20\x01(\tR\x0fepisodeSubt\
    itleB\0\x12(\n\x0ecolorThemeArgb\x18\x05\x20\x01(\tR\x0ecolorThemeArgbB\
    \0\x123\n\x0cvideoSnippet\x18\x06\x20\x03(\x0b2\r.VideoSnippetR\x0cvideo\
    SnippetB\0:\0\"s\n\x04Link\x12\x12\n\x03uri\x18\x01\x20\x01(\tR\x03uriB\
    \0\x123\n\x0cresolvedLink\x18\x02\x20\x01(\x0b2\r.ResolvedLinkR\x0cresol\
    vedLinkB\0\x12\x20\n\nuriBackend\x18\x03\x20\x01(\x05R\nuriBackendB\0:\0\
    \"l\n\nNextBanner\x12\x16\n\x05title\x18\x01\x20\x01(\tR\x05titleB\0\x12\
    \x1c\n\x08subtitle\x18\x02\x20\x01(\tR\x08subtitleB\0\x12&\n\rcolorTextA\
    rgb\x18\x03\x20\x01(\tR\rcolorTextArgbB\0:\0\"\x8f\x01\n\x0fOBSOLETE_Rea\
    son\x12\"\n\x0bbriefReason\x18\x01\x20\x01(\tR\x0bbriefReasonB\0\x128\n\
    \x16oBSOLETEDetailedReason\x18\x02\x20\x01(\tR\x16oBSOLETEDetailedReason\
    B\0\x12\x1c\n\x08uniqueId\x18\x03\x20\x01(\tR\x08uniqueIdB\0:\0\"\xa7\
    \x01\n\x0bPlusOneData\x12\x1e\n\tsetByUser\x18\x01\x20\x01(\x08R\tsetByU\
    serB\0\x12\x16\n\x05total\x18\x02\x20\x01(\x03R\x05totalB\0\x12$\n\x0cci\
    rclesTotal\x18\x03\x20\x01(\x03R\x0ccirclesTotalB\0\x128\n\x0fcirclesPro\
    files\x18\x04\x20\x03(\x0b2\x0c.PlusProfileR\x0fcirclesProfilesB\0:\0\"\
    \xb3\x01\n\x0bPromotedDoc\x12\x16\n\x05title\x18\x01\x20\x01(\tR\x05titl\
    eB\0\x12\x1c\n\x08subtitle\x18\x02\x20\x01(\tR\x08subtitleB\0\x12\x1e\n\
    \x05image\x18\x03\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12*\n\x0fdescrip\
    tionHtml\x18\x04\x20\x01(\tR\x0fdescriptionHtmlB\0\x12\x20\n\ndetailsUrl\
    \x18\x05\x20\x01(\tR\ndetailsUrlB\0:\0\"\xde\x01\n\x06Reason\x12*\n\x0fd\
    escriptionHtml\x18\x03\x20\x01(\tR\x0fdescriptionHtmlB\0\x12E\n\x12reaso\
    nPlusProfiles\x18\x04\x20\x01(\x0b2\x13.ReasonPlusProfilesR\x12reasonPlu\
    sProfilesB\0\x123\n\x0creasonReview\x18\x05\x20\x01(\x0b2\r.ReasonReview\
    R\x0creasonReviewB\0\x12*\n\tdismissal\x18\x07\x20\x01(\x0b2\n.Dismissal\
    R\tdismissalB\0:\0\"\x86\x01\n\x12ReasonPlusProfiles\x12<\n\x18localized\
    DescriptionHtml\x18\x01\x20\x01(\tR\x18localizedDescriptionHtmlB\0\x120\
    \n\x0bplusProfile\x18\x02\x20\x03(\x0b2\x0c.PlusProfileR\x0bplusProfileB\
    \0:\0\"3\n\x0cReasonReview\x12!\n\x06review\x18\x01\x20\x01(\x0b2\x07.Re\
    viewR\x06reviewB\0:\0\"\x1c\n\x18RecommendationsContainer:\0\"\x95\x01\n\
    \x0fSectionMetadata\x12\x18\n\x06header\x18\x01\x20\x01(\tR\x06headerB\0\
    \x12\x1a\n\x07listUrl\x18\x02\x20\x01(\tR\x07listUrlB\0\x12\x1e\n\tbrows\
    eUrl\x18\x03\x20\x01(\tR\tbrowseUrlB\0\x12*\n\x0fdescriptionHtml\x18\x04\
    \x20\x01(\tR\x0fdescriptionHtmlB\0:\0\"\xcf\x02\n\rSeriesAntenna\x12\"\n\
    \x0bseriesTitle\x18\x01\x20\x01(\tR\x0bseriesTitleB\0\x12(\n\x0eseriesSu\
    btitle\x18\x02\x20\x01(\tR\x0eseriesSubtitleB\0\x12$\n\x0cepisodeTitle\
    \x18\x03\x20\x01(\tR\x0cepisodeTitleB\0\x12*\n\x0fepisodeSubtitle\x18\
    \x04\x20\x01(\tR\x0fepisodeSubtitleB\0\x12(\n\x0ecolorThemeArgb\x18\x05\
    \x20\x01(\tR\x0ecolorThemeArgbB\0\x128\n\rsectionTracks\x18\x06\x20\x01(\
    \x0b2\x10.SectionMetadataR\rsectionTracksB\0\x128\n\rsectionAlbums\x18\
    \x07\x20\x01(\x0b2\x10.SectionMetadataR\rsectionAlbumsB\0:\0\"\xae\x01\n\
    \x11SuggestionReasons\x12!\n\x06reason\x18\x02\x20\x03(\x0b2\x07.ReasonR\
    \x06reasonB\0\x128\n\x10neutralDismissal\x18\x04\x20\x01(\x0b2\n.Dismiss\
    alR\x10neutralDismissalB\0\x12:\n\x11positiveDismissal\x18\x05\x20\x01(\
    \x0b2\n.DismissalR\x11positiveDismissalB\0:\0\"\xa3\x07\n\x08Template\
    \x126\n\rseriesAntenna\x18\x01\x20\x01(\x0b2\x0e.SeriesAntennaR\rseriesA\
    ntennaB\0\x127\n\x0etileGraphic2X1\x18\x02\x20\x01(\x0b2\r.TileTemplateR\
    \x0etileGraphic2X1B\0\x127\n\x0etileGraphic4X2\x18\x03\x20\x01(\x0b2\r.T\
    ileTemplateR\x0etileGraphic4X2B\0\x12O\n\x1atileGraphicColoredTitle2X1\
    \x18\x04\x20\x01(\x0b2\r.TileTemplateR\x1atileGraphicColoredTitle2X1B\0\
    \x12S\n\x1ctileGraphicUpperLeftTitle2X1\x18\x05\x20\x01(\x0b2\r.TileTemp\
    lateR\x1ctileGraphicUpperLeftTitle2X1B\0\x12W\n\x1etileDetailsReflectedG\
    raphic2X2\x18\x06\x20\x01(\x0b2\r.TileTemplateR\x1etileDetailsReflectedG\
    raphic2X2B\0\x12;\n\x10tileFourBlock4X2\x18\x07\x20\x01(\x0b2\r.TileTemp\
    lateR\x10tileFourBlock4X2B\0\x12H\n\x13containerWithBanner\x18\x08\x20\
    \x01(\x0b2\x14.ContainerWithBannerR\x13containerWithBannerB\0\x123\n\x0c\
    dealOfTheDay\x18\t\x20\x01(\x0b2\r.DealOfTheDayR\x0cdealOfTheDayB\0\x12O\
    \n\x1atileGraphicColoredTitle4X2\x18\n\x20\x01(\x0b2\r.TileTemplateR\x1a\
    tileGraphicColoredTitle4X2B\0\x12W\n\x18editorialSeriesContainer\x18\x0b\
    \x20\x01(\x0b2\x19.EditorialSeriesContainerR\x18editorialSeriesContainer\
    B\0\x12W\n\x18recommendationsContainer\x18\x0c\x20\x01(\x0b2\x19.Recomme\
    ndationsContainerR\x18recommendationsContainerB\0\x12-\n\nnextBanner\x18\
    \r\x20\x01(\x0b2\x0b.NextBannerR\nnextBannerB\0:\0\"b\n\x0cTileTemplate\
    \x12(\n\x0ecolorThemeArgb\x18\x01\x20\x01(\tR\x0ecolorThemeArgbB\0\x12&\
    \n\rcolorTextArgb\x18\x02\x20\x01(\tR\rcolorTextArgbB\0:\0\"l\n\x0cVideo\
    Snippet\x12\x1e\n\x05image\x18\x01\x20\x03(\x0b2\x06.ImageR\x05imageB\0\
    \x12\x16\n\x05title\x18\x02\x20\x01(\tR\x05titleB\0\x12\"\n\x0bdescripti\
    on\x18\x03\x20\x01(\tR\x0bdescriptionB\0:\0\"9\n\x07Warning\x12,\n\x10lo\
    calizedMessage\x18\x01\x20\x01(\tR\x10localizedMessageB\0:\0\"\x89\x01\n\
    \x0cAlbumDetails\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12)\n\
    \x07details\x18\x02\x20\x01(\x0b2\r.MusicDetailsR\x07detailsB\0\x126\n\r\
    displayArtist\x18\x03\x20\x01(\x0b2\x0e.ArtistDetailsR\rdisplayArtistB\0\
    :\0\"\xb4\x01\n\nDependency\x12\"\n\x0bpackageName\x18\x01\x20\x01(\tR\
    \x0bpackageNameB\0\x12(\n\x0eminVersionCode\x18\x02\x20\x01(\x05R\x0emin\
    VersionCodeB\0\x12*\n\x0fversionCodeMask\x18\x03\x20\x01(\x05R\x0fversio\
    nCodeMaskB\0\x12*\n\x0fskipPermissions\x18\x04\x20\x01(\x08R\x0fskipPerm\
    issionsB\0:\0\"\xb1\x01\n\x0eInstallDetails\x12*\n\x0finstallLocation\
    \x18\x01\x20\x01(\x05R\x0finstallLocationB\0\x12\x14\n\x04size\x18\x02\
    \x20\x01(\x03R\x04sizeB\0\x12-\n\ndependency\x18\x03\x20\x01(\x0b2\x0b.D\
    ependencyR\ndependencyB\0\x12,\n\x10targetSdkVersion\x18\x04\x20\x01(\
    \x05R\x10targetSdkVersionB\0:\0\"\xe7\n\n\nAppDetails\x12&\n\rdeveloperN\
    ame\x18\x01\x20\x01(\tR\rdeveloperNameB\0\x120\n\x12majorVersionNumber\
    \x18\x02\x20\x01(\x05R\x12majorVersionNumberB\0\x12\"\n\x0bversionCode\
    \x18\x03\x20\x01(\x05R\x0bversionCodeB\0\x12&\n\rversionString\x18\x04\
    \x20\x01(\tR\rversionStringB\0\x12\x16\n\x05title\x18\x05\x20\x01(\tR\
    \x05titleB\0\x12\"\n\x0bappCategory\x18\x07\x20\x03(\tR\x0bappCategoryB\
    \0\x12&\n\rcontentRating\x18\x08\x20\x01(\x05R\rcontentRatingB\0\x12,\n\
    \x10installationSize\x18\t\x20\x01(\x03R\x10installationSizeB\0\x12\x20\
    \n\npermission\x18\n\x20\x03(\tR\npermissionB\0\x12(\n\x0edeveloperEmail\
    \x18\x0b\x20\x01(\tR\x0edeveloperEmailB\0\x12,\n\x10developerWebsite\x18\
    \x0c\x20\x01(\tR\x10developerWebsiteB\0\x12$\n\x0cnumDownloads\x18\r\x20\
    \x01(\tR\x0cnumDownloadsB\0\x12\"\n\x0bpackageName\x18\x0e\x20\x01(\tR\
    \x0bpackageNameB\0\x12.\n\x11recentChangesHtml\x18\x0f\x20\x01(\tR\x11re\
    centChangesHtmlB\0\x12\x20\n\nuploadDate\x18\x10\x20\x01(\tR\nuploadDate\
    B\0\x12#\n\x04file\x18\x11\x20\x03(\x0b2\r.FileMetadataR\x04fileB\0\x12\
    \x1a\n\x07appType\x18\x12\x20\x01(\tR\x07appTypeB\0\x12*\n\x0fcertificat\
    eHash\x18\x13\x20\x03(\tR\x0fcertificateHashB\0\x12*\n\x0fvariesByAccoun\
    t\x18\x15\x20\x01(\x08R\x0fvariesByAccountB\0\x129\n\x0ecertificateSet\
    \x18\x16\x20\x03(\x0b2\x0f.CertificateSetR\x0ecertificateSetB\0\x12f\n-a\
    utoAcquireFreeAppIfHigherVersionAvailableTag\x18\x17\x20\x03(\tR-autoAcq\
    uireFreeAppIfHigherVersionAvailableTagB\0\x12\"\n\x0bdeclaresIab\x18\x18\
    \x20\x01(\x08R\x0bdeclaresIabB\0\x12\x1a\n\x07splitId\x18\x19\x20\x03(\t\
    R\x07splitIdB\0\x12*\n\x0fgamepadRequired\x18\x1a\x20\x01(\x08R\x0fgamep\
    adRequiredB\0\x12,\n\x10externallyHosted\x18\x1b\x20\x01(\x08R\x10extern\
    allyHostedB\0\x124\n\x14everExternallyHosted\x18\x1c\x20\x01(\x08R\x14ev\
    erExternallyHostedB\0\x12$\n\x0cinstallNotes\x18\x1e\x20\x01(\tR\x0cinst\
    allNotesB\0\x12*\n\x0finstallLocation\x18\x1f\x20\x01(\x05R\x0finstallLo\
    cationB\0\x12,\n\x10targetSdkVersion\x18\x20\x20\x01(\x05R\x10targetSdkV\
    ersionB\0\x12B\n\x1bhasPreregistrationPromoCode\x18!\x20\x01(\tR\x1bhasP\
    reregistrationPromoCodeB\0\x129\n\x0einstallDetails\x18\"\x20\x01(\x0b2\
    \x0f.InstallDetailsR\x0einstallDetailsB\0:\0\">\n\x0eCertificateSet\x12*\
    \n\x0fcertificateHash\x18\x01\x20\x03(\tR\x0fcertificateHashB\0:\0\"W\n\
    \rAppPermission\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x120\n\
    \x12permissionRequired\x18\x02\x20\x01(\x08R\x12permissionRequiredB\0:\0\
    \"\x87\x01\n\rArtistDetails\x12\x20\n\ndetailsUrl\x18\x01\x20\x01(\tR\nd\
    etailsUrlB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12<\n\rex\
    ternalLinks\x18\x03\x20\x01(\x0b2\x14.ArtistExternalLinksR\rexternalLink\
    sB\0:\0\"\x9f\x01\n\x13ArtistExternalLinks\x12\x20\n\nwebsiteUrl\x18\x01\
    \x20\x03(\tR\nwebsiteUrlB\0\x124\n\x14googlePlusProfileUrl\x18\x02\x20\
    \x01(\tR\x14googlePlusProfileUrlB\0\x12.\n\x11youtubeChannelUrl\x18\x03\
    \x20\x01(\tR\x11youtubeChannelUrlB\0:\0\"\x87\x05\n\x0fDocumentDetails\
    \x12-\n\nappDetails\x18\x01\x20\x01(\x0b2\x0b.AppDetailsR\nappDetailsB\0\
    \x123\n\x0calbumDetails\x18\x02\x20\x01(\x0b2\r.AlbumDetailsR\x0calbumDe\
    tailsB\0\x126\n\rartistDetails\x18\x03\x20\x01(\x0b2\x0e.ArtistDetailsR\
    \rartistDetailsB\0\x120\n\x0bsongDetails\x18\x04\x20\x01(\x0b2\x0c.SongD\
    etailsR\x0bsongDetailsB\0\x120\n\x0bbookDetails\x18\x05\x20\x01(\x0b2\
    \x0c.BookDetailsR\x0bbookDetailsB\0\x123\n\x0cvideoDetails\x18\x06\x20\
    \x01(\x0b2\r.VideoDetailsR\x0cvideoDetailsB\0\x12H\n\x13subscriptionDeta\
    ils\x18\x07\x20\x01(\x0b2\x14.SubscriptionDetailsR\x13subscriptionDetail\
    sB\0\x12<\n\x0fmagazineDetails\x18\x08\x20\x01(\x0b2\x10.MagazineDetails\
    R\x0fmagazineDetailsB\0\x126\n\rtvShowDetails\x18\t\x20\x01(\x0b2\x0e.Tv\
    ShowDetailsR\rtvShowDetailsB\0\x12<\n\x0ftvSeasonDetails\x18\n\x20\x01(\
    \x0b2\x10.TvSeasonDetailsR\x0ftvSeasonDetailsB\0\x12?\n\x10tvEpisodeDeta\
    ils\x18\x0b\x20\x01(\x0b2\x11.TvEpisodeDetailsR\x10tvEpisodeDetailsB\0:\
    \0\"R\n\x0cPatchDetails\x12*\n\x0fbaseVersionCode\x18\x01\x20\x01(\x05R\
    \x0fbaseVersionCodeB\0\x12\x14\n\x04size\x18\x02\x20\x01(\x03R\x04sizeB\
    \0:\0\"\xe3\x01\n\x0cFileMetadata\x12\x1c\n\x08fileType\x18\x01\x20\x01(\
    \x05R\x08fileTypeB\0\x12\"\n\x0bversionCode\x18\x02\x20\x01(\x05R\x0bver\
    sionCodeB\0\x12\x14\n\x04size\x18\x03\x20\x01(\x03R\x04sizeB\0\x12\x1a\n\
    \x07splitId\x18\x04\x20\x01(\tR\x07splitIdB\0\x12(\n\x0ecompressedSize\
    \x18\x05\x20\x01(\x03R\x0ecompressedSizeB\0\x123\n\x0cpatchDetails\x18\
    \x06\x20\x03(\x0b2\r.PatchDetailsR\x0cpatchDetailsB\0:\0\"\x81\x02\n\x0f\
    MagazineDetails\x12,\n\x10parentDetailsUrl\x18\x01\x20\x01(\tR\x10parent\
    DetailsUrlB\0\x12N\n!deviceAvailabilityDescriptionHtml\x18\x02\x20\x01(\
    \tR!deviceAvailabilityDescriptionHtmlB\0\x12(\n\x0epsvDescription\x18\
    \x03\x20\x01(\tR\x0epsvDescriptionB\0\x12D\n\x1cdeliveryFrequencyDescrip\
    tion\x18\x04\x20\x01(\tR\x1cdeliveryFrequencyDescriptionB\0:\0\"\xaa\x02\
    \n\x0cMusicDetails\x12\x1e\n\tcensoring\x18\x01\x20\x01(\x05R\tcensoring\
    B\0\x12\"\n\x0bdurationSec\x18\x02\x20\x01(\x05R\x0bdurationSecB\0\x122\
    \n\x13originalReleaseDate\x18\x03\x20\x01(\tR\x13originalReleaseDateB\0\
    \x12\x16\n\x05label\x18\x04\x20\x01(\tR\x05labelB\0\x12(\n\x06artist\x18\
    \x05\x20\x03(\x0b2\x0e.ArtistDetailsR\x06artistB\0\x12\x16\n\x05genre\
    \x18\x06\x20\x03(\tR\x05genreB\0\x12\"\n\x0breleaseDate\x18\x07\x20\x01(\
    \tR\x0breleaseDateB\0\x12\"\n\x0breleaseType\x18\x08\x20\x03(\x05R\x0bre\
    leaseTypeB\0:\0\"g\n\x0bNewsDetails\x12,\n\x10parentDetailsUrl\x18\x01\
    \x20\x01(\tR\x10parentDetailsUrlB\0\x12(\n\x0epsvDescription\x18\x03\x20\
    \x01(\tR\x0epsvDescriptionB\0:\0\"\x8e\x02\n\x0bSongDetails\x12\x14\n\
    \x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12)\n\x07details\x18\x02\x20\
    \x01(\x0b2\r.MusicDetailsR\x07detailsB\0\x12\x1e\n\talbumName\x18\x03\
    \x20\x01(\tR\talbumNameB\0\x12\"\n\x0btrackNumber\x18\x04\x20\x01(\x05R\
    \x0btrackNumberB\0\x12\x20\n\npreviewUrl\x18\x05\x20\x01(\tR\npreviewUrl\
    B\0\x126\n\rdisplayArtist\x18\x06\x20\x01(\x0b2\x0e.ArtistDetailsR\rdisp\
    layArtistB\0\x12\x1e\n\x05badge\x18\x07\x20\x01(\x0b2\x06.BadgeR\x05badg\
    eB\0:\0\"I\n\x13SubscriptionDetails\x120\n\x12subscriptionPeriod\x18\x01\
    \x20\x01(\x05R\x12subscriptionPeriodB\0:\0\"\xa5\x01\n\x07Trailer\x12\
    \x1e\n\ttrailerId\x18\x01\x20\x01(\tR\ttrailerIdB\0\x12\x16\n\x05title\
    \x18\x02\x20\x01(\tR\x05titleB\0\x12$\n\x0cthumbnailUrl\x18\x03\x20\x01(\
    \tR\x0cthumbnailUrlB\0\x12\x1c\n\x08watchUrl\x18\x04\x20\x01(\tR\x08watc\
    hUrlB\0\x12\x1c\n\x08duration\x18\x05\x20\x01(\tR\x08durationB\0:\0\"\
    \x8c\x01\n\x10TvEpisodeDetails\x12,\n\x10parentDetailsUrl\x18\x01\x20\
    \x01(\tR\x10parentDetailsUrlB\0\x12$\n\x0cepisodeIndex\x18\x02\x20\x01(\
    \x05R\x0cepisodeIndexB\0\x12\"\n\x0breleaseDate\x18\x03\x20\x01(\tR\x0br\
    eleaseDateB\0:\0\"\x89\x02\n\x0fTvSeasonDetails\x12,\n\x10parentDetailsU\
    rl\x18\x01\x20\x01(\tR\x10parentDetailsUrlB\0\x12\"\n\x0bseasonIndex\x18\
    \x02\x20\x01(\x05R\x0bseasonIndexB\0\x12\"\n\x0breleaseDate\x18\x03\x20\
    \x01(\tR\x0breleaseDateB\0\x12\"\n\x0bbroadcaster\x18\x04\x20\x01(\tR\
    \x0bbroadcasterB\0\x12$\n\x0cepisodeCount\x18\x05\x20\x01(\x05R\x0cepiso\
    deCountB\0\x124\n\x14expectedEpisodeCount\x18\x06\x20\x01(\x05R\x14expec\
    tedEpisodeCountB\0:\0\"\x95\x01\n\rTvShowDetails\x12\"\n\x0bseasonCount\
    \x18\x01\x20\x01(\x05R\x0bseasonCountB\0\x12\x1e\n\tstartYear\x18\x02\
    \x20\x01(\x05R\tstartYearB\0\x12\x1a\n\x07endYear\x18\x03\x20\x01(\x05R\
    \x07endYearB\0\x12\"\n\x0bbroadcaster\x18\x04\x20\x01(\tR\x0bbroadcaster\
    B\0:\0\"a\n\x0bVideoCredit\x12\x20\n\ncreditType\x18\x01\x20\x01(\x05R\n\
    creditTypeB\0\x12\x18\n\x06credit\x18\x02\x20\x01(\tR\x06creditB\0\x12\
    \x14\n\x04name\x18\x03\x20\x03(\tR\x04nameB\0:\0\"\x9e\x03\n\x0cVideoDet\
    ails\x12&\n\x06credit\x18\x01\x20\x03(\x0b2\x0c.VideoCreditR\x06creditB\
    \0\x12\x1c\n\x08duration\x18\x02\x20\x01(\tR\x08durationB\0\x12\"\n\x0br\
    eleaseDate\x18\x03\x20\x01(\tR\x0breleaseDateB\0\x12&\n\rcontentRating\
    \x18\x04\x20\x01(\tR\rcontentRatingB\0\x12\x16\n\x05likes\x18\x05\x20\
    \x01(\x03R\x05likesB\0\x12\x1c\n\x08dislikes\x18\x06\x20\x01(\x03R\x08di\
    slikesB\0\x12\x16\n\x05genre\x18\x07\x20\x03(\tR\x05genreB\0\x12$\n\x07t\
    railer\x18\x08\x20\x03(\x0b2\x08.TrailerR\x07trailerB\0\x122\n\nrentalTe\
    rm\x18\t\x20\x03(\x0b2\x10.VideoRentalTermR\nrentalTermB\0\x12&\n\raudio\
    Language\x18\n\x20\x03(\tR\raudioLanguageB\0\x12*\n\x0fcaptionLanguage\
    \x18\x0b\x20\x03(\tR\x0fcaptionLanguageB\0:\0\"\xee\x01\n\x0fVideoRental\
    Term\x12\x1e\n\tofferType\x18\x01\x20\x01(\x05R\tofferTypeB\0\x12.\n\x11\
    offerAbbreviation\x18\x02\x20\x01(\tR\x11offerAbbreviationB\0\x12$\n\x0c\
    rentalHeader\x18\x03\x20\x01(\tR\x0crentalHeaderB\0\x12+\n\x04term\x18\
    \x04\x20\x03(\n2\x15.VideoRentalTerm.TermR\x04termB\0\x1a6\n\x04Term\x12\
    \x18\n\x06header\x18\x05\x20\x01(\tR\x06headerB\0\x12\x14\n\x04body\x18\
    \x06\x20\x01(\tR\x04bodyB\0:\0\"\xa2\x03\n\x06Bucket\x12$\n\x08document\
    \x18\x01\x20\x03(\x0b2\x06.DocV1R\x08documentB\0\x12\"\n\x0bmultiCorpus\
    \x18\x02\x20\x01(\x08R\x0bmultiCorpusB\0\x12\x16\n\x05title\x18\x03\x20\
    \x01(\tR\x05titleB\0\x12\x1a\n\x07iconUrl\x18\x04\x20\x01(\tR\x07iconUrl\
    B\0\x12*\n\x0ffullContentsUrl\x18\x05\x20\x01(\tR\x0ffullContentsUrlB\0\
    \x12\x1e\n\trelevance\x18\x06\x20\x01(\x01R\trelevanceB\0\x12,\n\x10esti\
    matedResults\x18\x07\x20\x01(\x03R\x10estimatedResultsB\0\x12*\n\x0fanal\
    yticsCookie\x18\x08\x20\x01(\tR\x0fanalyticsCookieB\0\x122\n\x13fullCont\
    entsListUrl\x18\t\x20\x01(\tR\x13fullContentsListUrlB\0\x12\"\n\x0bnextP\
    ageUrl\x18\n\x20\x01(\tR\x0bnextPageUrlB\0\x12\x1a\n\x07ordered\x18\x0b\
    \x20\x01(\x08R\x07orderedB\0:\0\"O\n\x0cListResponse\x12!\n\x06bucket\
    \x18\x01\x20\x03(\x0b2\x07.BucketR\x06bucketB\0\x12\x1a\n\x03doc\x18\x02\
    \x20\x03(\x0b2\x06.DocV2R\x03docB\0:\0\"\x92\x05\n\x05DocV1\x12)\n\tfins\
    kyDoc\x18\x01\x20\x01(\x0b2\t.DocumentR\tfinskyDocB\0\x12\x16\n\x05docid\
    \x18\x02\x20\x01(\tR\x05docidB\0\x12\x20\n\ndetailsUrl\x18\x03\x20\x01(\
    \tR\ndetailsUrlB\0\x12\x20\n\nreviewsUrl\x18\x04\x20\x01(\tR\nreviewsUrl\
    B\0\x12(\n\x0erelatedListUrl\x18\x05\x20\x01(\tR\x0erelatedListUrlB\0\
    \x12&\n\rmoreByListUrl\x18\x06\x20\x01(\tR\rmoreByListUrlB\0\x12\x1c\n\
    \x08shareUrl\x18\x07\x20\x01(\tR\x08shareUrlB\0\x12\x1a\n\x07creator\x18\
    \x08\x20\x01(\tR\x07creatorB\0\x12,\n\x07details\x18\t\x20\x01(\x0b2\x10\
    .DocumentDetailsR\x07detailsB\0\x12*\n\x0fdescriptionHtml\x18\n\x20\x01(\
    \tR\x0fdescriptionHtmlB\0\x12,\n\x10relatedBrowseUrl\x18\x0b\x20\x01(\tR\
    \x10relatedBrowseUrlB\0\x12*\n\x0fmoreByBrowseUrl\x18\x0c\x20\x01(\tR\
    \x0fmoreByBrowseUrlB\0\x12&\n\rrelatedHeader\x18\r\x20\x01(\tR\rrelatedH\
    eaderB\0\x12$\n\x0cmoreByHeader\x18\x0e\x20\x01(\tR\x0cmoreByHeaderB\0\
    \x12\x16\n\x05title\x18\x0f\x20\x01(\tR\x05titleB\0\x120\n\x0bplusOneDat\
    a\x18\x10\x20\x01(\x0b2\x0c.PlusOneDataR\x0bplusOneDataB\0\x12(\n\x0ewar\
    ningMessage\x18\x11\x20\x01(\tR\x0ewarningMessageB\0:\0\"\x91\x0b\n\x0bA\
    nnotations\x12:\n\x0esectionRelated\x18\x01\x20\x01(\x0b2\x10.SectionMet\
    adataR\x0esectionRelatedB\0\x128\n\rsectionMoreBy\x18\x02\x20\x01(\x0b2\
    \x10.SectionMetadataR\rsectionMoreByB\0\x120\n\x0bplusOneData\x18\x03\
    \x20\x01(\x0b2\x0c.PlusOneDataR\x0bplusOneDataB\0\x12$\n\x07warning\x18\
    \x04\x20\x03(\x0b2\x08.WarningR\x07warningB\0\x12@\n\x11sectionBodyOfWor\
    k\x18\x05\x20\x01(\x0b2\x10.SectionMetadataR\x11sectionBodyOfWorkB\0\x12\
    B\n\x12sectionCoreContent\x18\x06\x20\x01(\x0b2\x10.SectionMetadataR\x12\
    sectionCoreContentB\0\x12'\n\x08template\x18\x07\x20\x01(\x0b2\t.Templat\
    eR\x08templateB\0\x122\n\x0fbadgeForCreator\x18\x08\x20\x03(\x0b2\x06.Ba\
    dgeR\x0fbadgeForCreatorB\0\x12*\n\x0bbadgeForDoc\x18\t\x20\x03(\x0b2\x06\
    .BadgeR\x0bbadgeForDocB\0\x12\x1b\n\x04link\x18\n\x20\x01(\x0b2\x05.Link\
    R\x04linkB\0\x12>\n\x10sectionCrossSell\x18\x0b\x20\x01(\x0b2\x10.Sectio\
    nMetadataR\x10sectionCrossSellB\0\x12H\n\x15sectionRelatedDocType\x18\
    \x0c\x20\x01(\x0b2\x10.SectionMetadataR\x15sectionRelatedDocTypeB\0\x120\
    \n\x0bpromotedDoc\x18\r\x20\x03(\x0b2\x0c.PromotedDocR\x0bpromotedDocB\0\
    \x12\x1e\n\tofferNote\x18\x0e\x20\x01(\tR\tofferNoteB\0\x12,\n\x0csubscr\
    iption\x18\x10\x20\x03(\x0b2\x06.DocV2R\x0csubscriptionB\0\x12:\n\x0eoBS\
    OLETEReason\x18\x11\x20\x01(\x0b2\x10.OBSOLETE_ReasonR\x0eoBSOLETEReason\
    B\0\x12,\n\x10privacyPolicyUrl\x18\x12\x20\x01(\tR\x10privacyPolicyUrlB\
    \0\x12B\n\x11suggestionReasons\x18\x13\x20\x01(\x0b2\x12.SuggestionReaso\
    nsR\x11suggestionReasonsB\0\x12H\n\x19optimalDeviceClassWarning\x18\x14\
    \x20\x01(\x0b2\x08.WarningR\x19optimalDeviceClassWarningB\0\x12?\n\x11do\
    cBadgeContainer\x18\x15\x20\x03(\x0b2\x0f.BadgeContainerR\x11docBadgeCon\
    tainerB\0\x12L\n\x17sectionSuggestForRating\x18\x16\x20\x01(\x0b2\x10.Se\
    ctionMetadataR\x17sectionSuggestForRatingB\0\x12F\n\x14sectionRateAndRev\
    iew\x18\x17\x20\x01(\x0b2\x10.SectionMetadataR\x14sectionRateAndReviewB\
    \0\x12N\n\x18sectionPurchaseCrossSell\x18\x18\x20\x01(\x0b2\x10.SectionM\
    etadataR\x18sectionPurchaseCrossSellB\0\x123\n\x0coverflowLink\x18\x19\
    \x20\x03(\x0b2\r.OverflowLinkR\x0coverflowLinkB\0\x12(\n\ncreatorDoc\x18\
    \x1a\x20\x01(\x0b2\x06.DocV2R\ncreatorDocB\0:\0\"E\n\x0cOverflowLink\x12\
    \x16\n\x05title\x18\x01\x20\x01(\tR\x05titleB\0\x12\x1b\n\x04link\x18\
    \x02\x20\x01(\x0b2\x05.LinkR\x04linkB\0:\0\"\x7f\n\tReviewTip\x12\x18\n\
    \x06tipUrl\x18\x01\x20\x01(\tR\x06tipUrlB\0\x12\x14\n\x04text\x18\x02\
    \x20\x01(\tR\x04textB\0\x12\x1c\n\x08polarity\x18\x03\x20\x01(\x05R\x08p\
    olarityB\0\x12\"\n\x0breviewCount\x18\x04\x20\x01(\x03R\x0breviewCountB\
    \0:\0\"\xd3\n\n\x05DocV2\x12\x16\n\x05docid\x18\x01\x20\x01(\tR\x05docid\
    B\0\x12$\n\x0cbackendDocid\x18\x02\x20\x01(\tR\x0cbackendDocidB\0\x12\
    \x1a\n\x07docType\x18\x03\x20\x01(\x05R\x07docTypeB\0\x12\x1e\n\tbackend\
    Id\x18\x04\x20\x01(\x05R\tbackendIdB\0\x12\x16\n\x05title\x18\x05\x20\
    \x01(\tR\x05titleB\0\x12\x1a\n\x07creator\x18\x06\x20\x01(\tR\x07creator\
    B\0\x12*\n\x0fdescriptionHtml\x18\x07\x20\x01(\tR\x0fdescriptionHtmlB\0\
    \x12\x1e\n\x05offer\x18\x08\x20\x03(\x0b2\x06.OfferR\x05offerB\0\x123\n\
    \x0cavailability\x18\t\x20\x01(\x0b2\r.AvailabilityR\x0cavailabilityB\0\
    \x12\x1e\n\x05image\x18\n\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12\x1e\n\
    \x05child\x18\x0b\x20\x03(\x0b2\x06.DocV2R\x05childB\0\x12B\n\x11contain\
    erMetadata\x18\x0c\x20\x01(\x0b2\x12.ContainerMetadataR\x11containerMeta\
    dataB\0\x12,\n\x07details\x18\r\x20\x01(\x0b2\x10.DocumentDetailsR\x07de\
    tailsB\0\x12<\n\x0faggregateRating\x18\x0e\x20\x01(\x0b2\x10.AggregateRa\
    tingR\x0faggregateRatingB\0\x120\n\x0bannotations\x18\x0f\x20\x01(\x0b2\
    \x0c.AnnotationsR\x0bannotationsB\0\x12\x20\n\ndetailsUrl\x18\x10\x20\
    \x01(\tR\ndetailsUrlB\0\x12\x1c\n\x08shareUrl\x18\x11\x20\x01(\tR\x08sha\
    reUrlB\0\x12\x20\n\nreviewsUrl\x18\x12\x20\x01(\tR\nreviewsUrlB\0\x12\
    \x20\n\nbackendUrl\x18\x13\x20\x01(\tR\nbackendUrlB\0\x120\n\x12purchase\
    DetailsUrl\x18\x14\x20\x01(\tR\x12purchaseDetailsUrlB\0\x12*\n\x0fdetail\
    sReusable\x18\x15\x20\x01(\x08R\x0fdetailsReusableB\0\x12\x1c\n\x08subti\
    tle\x18\x16\x20\x01(\tR\x08subtitleB\0\x12>\n\x19translatedDescriptionHt\
    ml\x18\x17\x20\x01(\tR\x19translatedDescriptionHtmlB\0\x12,\n\x10serverL\
    ogsCookie\x18\x18\x20\x01(\x0cR\x10serverLogsCookieB\0\x129\n\x0eproduct\
    Details\x18\x19\x20\x01(\x0b2\x0f.ProductDetailsR\x0eproductDetailsB\0\
    \x12\x18\n\x06mature\x18\x1a\x20\x01(\x08R\x06matureB\0\x128\n\x16promot\
    ionalDescription\x18\x1b\x20\x01(\tR\x16promotionalDescriptionB\0\x12D\n\
    \x1cavailabileForPreregistration\x18\x1d\x20\x01(\x08R\x1cavailabileForP\
    reregistrationB\0\x12\x1e\n\x03tip\x18\x1e\x20\x03(\x0b2\n.ReviewTipR\
    \x03tipB\0\x12\"\n\x0bsnippetsUrl\x18\x1f\x20\x01(\tR\x0bsnippetsUrlB\0\
    \x12.\n\x11forceShareability\x18\x20\x20\x01(\x08R\x11forceShareabilityB\
    \0\x12@\n\x1auseWishlistAsPrimaryAction\x18!\x20\x01(\x08R\x1auseWishlis\
    tAsPrimaryActionB\0:\0\"^\n\x0eProductDetails\x12\x16\n\x05title\x18\x01\
    \x20\x01(\tR\x05titleB\0\x122\n\x07section\x18\x02\x20\x03(\x0b2\x16.Pro\
    ductDetailsSectionR\x07sectionB\0:\0\"q\n\x15ProductDetailsSection\x12\
    \x16\n\x05title\x18\x01\x20\x01(\tR\x05titleB\0\x12>\n\x0bdescription\
    \x18\x03\x20\x03(\x0b2\x1a.ProductDetailsDescriptionR\x0bdescriptionB\0:\
    \0\"a\n\x19ProductDetailsDescription\x12\x1e\n\x05image\x18\x01\x20\x01(\
    \x0b2\x06.ImageR\x05imageB\0\x12\"\n\x0bdescription\x18\x02\x20\x01(\tR\
    \x0bdescriptionB\0:\0\"\xf7\x01\n\x17EncryptedSubscriberInfo\x12\x14\n\
    \x04data\x18\x01\x20\x01(\tR\x04dataB\0\x12$\n\x0cencryptedKey\x18\x02\
    \x20\x01(\tR\x0cencryptedKeyB\0\x12\x1e\n\tsignature\x18\x03\x20\x01(\tR\
    \tsignatureB\0\x12\x20\n\ninitVector\x18\x04\x20\x01(\tR\ninitVectorB\0\
    \x12,\n\x10googleKeyVersion\x18\x05\x20\x01(\x05R\x10googleKeyVersionB\0\
    \x12.\n\x11carrierKeyVersion\x18\x06\x20\x01(\x05R\x11carrierKeyVersionB\
    \0:\0\"\xe6\x05\n\x0cAvailability\x12\"\n\x0brestriction\x18\x05\x20\x01\
    (\x05R\x0brestrictionB\0\x12\x1e\n\tofferType\x18\x06\x20\x01(\x05R\toff\
    erTypeB\0\x12\x1b\n\x04rule\x18\x07\x20\x01(\x0b2\x05.RuleR\x04ruleB\0\
    \x12|\n\x20perdeviceavailabilityrestriction\x18\t\x20\x03(\n2..Availabil\
    ity.PerDeviceAvailabilityRestrictionR\x20perdeviceavailabilityrestrictio\
    nB\0\x12,\n\x10availableIfOwned\x18\r\x20\x01(\x08R\x10availableIfOwnedB\
    \0\x12$\n\x07install\x18\x0e\x20\x03(\x0b2\x08.InstallR\x07installB\0\
    \x127\n\nfilterInfo\x18\x10\x20\x01(\x0b2\x15.FilterEvaluationInfoR\nfil\
    terInfoB\0\x126\n\rownershipInfo\x18\x11\x20\x01(\x0b2\x0e.OwnershipInfo\
    R\rownershipInfoB\0\x12H\n\x13availabilityProblem\x18\x12\x20\x03(\x0b2\
    \x14.AvailabilityProblemR\x13availabilityProblemB\0\x12\x18\n\x06hidden\
    \x18\x15\x20\x01(\x08R\x06hiddenB\0\x1a\xcb\x01\n\x20PerDeviceAvailabili\
    tyRestriction\x12\x1e\n\tandroidId\x18\n\x20\x01(\x06R\tandroidIdB\0\x12\
    .\n\x11deviceRestriction\x18\x0b\x20\x01(\x05R\x11deviceRestrictionB\0\
    \x12\x1e\n\tchannelId\x18\x0c\x20\x01(\x03R\tchannelIdB\0\x127\n\nfilter\
    Info\x18\x0f\x20\x01(\x0b2\x15.FilterEvaluationInfoR\nfilterInfoB\0:\0\"\
    a\n\x13AvailabilityProblem\x12\"\n\x0bproblemType\x18\x01\x20\x01(\x05R\
    \x0bproblemTypeB\0\x12$\n\x0cmissingValue\x18\x02\x20\x03(\tR\x0cmissing\
    ValueB\0:\0\"S\n\x14FilterEvaluationInfo\x129\n\x0eruleEvaluation\x18\
    \x01\x20\x03(\x0b2\x0f.RuleEvaluationR\x0eruleEvaluationB\0:\0\"\xcd\x03\
    \n\x04Rule\x12\x18\n\x06negate\x18\x01\x20\x01(\x08R\x06negateB\0\x12\
    \x1c\n\x08operator\x18\x02\x20\x01(\x05R\x08operatorB\0\x12\x12\n\x03key\
    \x18\x03\x20\x01(\x05R\x03keyB\0\x12\x1e\n\tstringArg\x18\x04\x20\x03(\t\
    R\tstringArgB\0\x12\x1a\n\x07longArg\x18\x05\x20\x03(\x03R\x07longArgB\0\
    \x12\x1e\n\tdoubleArg\x18\x06\x20\x03(\x01R\tdoubleArgB\0\x12!\n\x07subr\
    ule\x18\x07\x20\x03(\x0b2\x05.RuleR\x07subruleB\0\x12$\n\x0cresponseCode\
    \x18\x08\x20\x01(\x05R\x0cresponseCodeB\0\x12\x1a\n\x07comment\x18\t\x20\
    \x01(\tR\x07commentB\0\x12&\n\rstringArgHash\x18\n\x20\x03(\x06R\rstring\
    ArgHashB\0\x12\x1c\n\x08constArg\x18\x0b\x20\x03(\x05R\x08constArgB\0\
    \x12:\n\x17availabilityProblemType\x18\x0c\x20\x01(\x05R\x17availability\
    ProblemTypeB\0\x124\n\x14includeMissingValues\x18\r\x20\x01(\x08R\x14inc\
    ludeMissingValuesB\0:\0\"\xe7\x01\n\x0eRuleEvaluation\x12\x1b\n\x04rule\
    \x18\x01\x20\x01(\x0b2\x05.RuleR\x04ruleB\0\x12.\n\x11actualStringValue\
    \x18\x02\x20\x03(\tR\x11actualStringValueB\0\x12*\n\x0factualLongValue\
    \x18\x03\x20\x03(\x03R\x0factualLongValueB\0\x12*\n\x0factualBoolValue\
    \x18\x04\x20\x03(\x08R\x0factualBoolValueB\0\x12.\n\x11actualDoubleValue\
    \x18\x05\x20\x03(\x01R\x11actualDoubleValueB\0:\0\"h\n\x10GroupLicenseIn\
    fo\x12.\n\x11licensedOfferType\x18\x01\x20\x01(\x05R\x11licensedOfferTyp\
    eB\0\x12\"\n\x0bgaiaGroupId\x18\x02\x20\x01(\x06R\x0bgaiaGroupIdB\0:\0\"\
    <\n\x14LicensedDocumentInfo\x12\"\n\x0bgaiaGroupId\x18\x01\x20\x03(\x06R\
    \x0bgaiaGroupIdB\0:\0\"\xc9\x01\n\x11LibraryAppDetails\x12*\n\x0fcertifi\
    cateHash\x18\x02\x20\x01(\tR\x0fcertificateHashB\0\x12@\n\x1arefundTimeo\
    utTimestampMsec\x18\x03\x20\x01(\x03R\x1arefundTimeoutTimestampMsecB\0\
    \x12D\n\x1cpostDeliveryRefundWindowMsec\x18\x04\x20\x01(\x03R\x1cpostDel\
    iveryRefundWindowMsecB\0:\0\"i\n\x13LibraryInAppDetails\x120\n\x12signed\
    PurchaseData\x18\x01\x20\x01(\tR\x12signedPurchaseDataB\0\x12\x1e\n\tsig\
    nature\x18\x02\x20\x01(\tR\tsignatureB\0:\0\"\x94\x03\n\x0fLibraryMutati\
    on\x12\x1e\n\x05docid\x18\x01\x20\x01(\x0b2\x06.DocidR\x05docidB\0\x12\
    \x1e\n\tofferType\x18\x02\x20\x01(\x05R\tofferTypeB\0\x12$\n\x0cdocument\
    Hash\x18\x03\x20\x01(\x03R\x0cdocumentHashB\0\x12\x1a\n\x07deleted\x18\
    \x04\x20\x01(\x08R\x07deletedB\0\x124\n\nappDetails\x18\x05\x20\x01(\x0b\
    2\x12.LibraryAppDetailsR\nappDetailsB\0\x12O\n\x13subscriptionDetails\
    \x18\x06\x20\x01(\x0b2\x1b.LibrarySubscriptionDetailsR\x13subscriptionDe\
    tailsB\0\x12:\n\x0cinAppDetails\x18\x07\x20\x01(\x0b2\x14.LibraryInAppDe\
    tailsR\x0cinAppDetailsB\0\x12:\n\x17validUntilTimestampMsec\x18\x08\x20\
    \x01(\x03R\x17validUntilTimestampMsecB\0:\0\"\xde\x02\n\x1aLibrarySubscr\
    iptionDetails\x12:\n\x17initiationTimestampMsec\x18\x01\x20\x01(\x03R\
    \x17initiationTimestampMsecB\0\x12N\n!deprecatedValidUntilTimestampMsec\
    \x18\x02\x20\x01(\x03R!deprecatedValidUntilTimestampMsecB\0\x12$\n\x0cau\
    toRenewing\x18\x03\x20\x01(\x08R\x0cautoRenewingB\0\x12:\n\x17trialUntil\
    TimestampMsec\x18\x04\x20\x01(\x03R\x17trialUntilTimestampMsecB\0\x120\n\
    \x12signedPurchaseData\x18\x05\x20\x01(\tR\x12signedPurchaseDataB\0\x12\
    \x1e\n\tsignature\x18\x06\x20\x01(\tR\tsignatureB\0:\0\"\xd5\x01\n\rLibr\
    aryUpdate\x12\x18\n\x06status\x18\x01\x20\x01(\x05R\x06statusB\0\x12\x18\
    \n\x06corpus\x18\x02\x20\x01(\x05R\x06corpusB\0\x12\"\n\x0bserverToken\
    \x18\x03\x20\x01(\x0cR\x0bserverTokenB\0\x12.\n\x08mutation\x18\x04\x20\
    \x03(\x0b2\x10.LibraryMutationR\x08mutationB\0\x12\x1a\n\x07hasMore\x18\
    \x05\x20\x01(\x08R\x07hasMoreB\0\x12\x1e\n\tlibraryId\x18\x06\x20\x01(\t\
    R\tlibraryIdB\0:\0\"\xbc\x01\n\x12ClientLibraryState\x12\x18\n\x06corpus\
    \x18\x01\x20\x01(\x05R\x06corpusB\0\x12\"\n\x0bserverToken\x18\x02\x20\
    \x01(\x0cR\x0bserverTokenB\0\x12\"\n\x0bhashCodeSum\x18\x03\x20\x01(\x03\
    R\x0bhashCodeSumB\0\x12\"\n\x0blibrarySize\x18\x04\x20\x01(\x05R\x0blibr\
    arySizeB\0\x12\x1e\n\tlibraryId\x18\x05\x20\x01(\tR\tlibraryIdB\0:\0\"X\
    \n\x19LibraryReplicationRequest\x129\n\x0clibraryState\x18\x01\x20\x03(\
    \x0b2\x13.ClientLibraryStateR\x0clibraryStateB\0:\0\"H\n\x1aLibraryRepli\
    cationResponse\x12(\n\x06update\x18\x01\x20\x03(\x0b2\x0e.LibraryUpdateR\
    \x06updateB\0:\0\"\xad\x01\n\rClickLogEvent\x12\x1e\n\teventTime\x18\x01\
    \x20\x01(\x03R\teventTimeB\0\x12\x12\n\x03url\x18\x02\x20\x01(\tR\x03url\
    B\0\x12\x18\n\x06listId\x18\x03\x20\x01(\tR\x06listIdB\0\x12\"\n\x0brefe\
    rrerUrl\x18\x04\x20\x01(\tR\x0breferrerUrlB\0\x12(\n\x0ereferrerListId\
    \x18\x05\x20\x01(\tR\x0ereferrerListIdB\0:\0\"\xb4\x01\n\x14ModifyLibrar\
    yRequest\x12\x1e\n\tlibraryId\x18\x01\x20\x01(\tR\tlibraryIdB\0\x12\"\n\
    \x0bforAddDocid\x18\x02\x20\x03(\tR\x0bforAddDocidB\0\x12*\n\x0fforRemov\
    alDocid\x18\x03\x20\x03(\tR\x0fforRemovalDocidB\0\x12*\n\x0fforArchiveDo\
    cid\x18\x04\x20\x03(\tR\x0fforArchiveDocidB\0:\0\"Q\n\x15ModifyLibraryRe\
    sponse\x126\n\rlibraryUpdate\x18\x01\x20\x01(\x0b2\x0e.LibraryUpdateR\rl\
    ibraryUpdateB\0:\0\"^\n\x1aAndroidAppNotificationData\x12\"\n\x0bversion\
    Code\x18\x01\x20\x01(\x05R\x0bversionCodeB\0\x12\x1a\n\x07assetId\x18\
    \x02\x20\x01(\tR\x07assetIdB\0:\0\"y\n\x15InAppNotificationData\x12*\n\
    \x0fcheckoutOrderId\x18\x01\x20\x01(\tR\x0fcheckoutOrderIdB\0\x122\n\x13\
    inAppNotificationId\x18\x02\x20\x01(\tR\x13inAppNotificationIdB\0:\0\"P\
    \n\x10LibraryDirtyData\x12\x1a\n\x07backend\x18\x01\x20\x01(\x05R\x07bac\
    kendB\0\x12\x1e\n\tlibraryId\x18\x02\x20\x01(\tR\tlibraryIdB\0:\0\"\x91\
    \x06\n\x0cNotification\x12,\n\x10notificationType\x18\x01\x20\x01(\x05R\
    \x10notificationTypeB\0\x12\x1e\n\ttimestamp\x18\x03\x20\x01(\x03R\ttime\
    stampB\0\x12\x1e\n\x05docid\x18\x04\x20\x01(\x0b2\x06.DocidR\x05docidB\0\
    \x12\x1c\n\x08docTitle\x18\x05\x20\x01(\tR\x08docTitleB\0\x12\x1e\n\tuse\
    rEmail\x18\x06\x20\x01(\tR\tuserEmailB\0\x127\n\x07appData\x18\x07\x20\
    \x01(\x0b2\x1b.AndroidAppNotificationDataR\x07appDataB\0\x12C\n\x0fappDe\
    liveryData\x18\x08\x20\x01(\x0b2\x17.AndroidAppDeliveryDataR\x0fappDeliv\
    eryDataB\0\x12H\n\x13purchaseRemovalData\x18\t\x20\x01(\x0b2\x14.Purchas\
    eRemovalDataR\x13purchaseRemovalDataB\0\x12K\n\x14userNotificationData\
    \x18\n\x20\x01(\x0b2\x15.UserNotificationDataR\x14userNotificationDataB\
    \0\x12N\n\x15inAppNotificationData\x18\x0b\x20\x01(\x0b2\x16.InAppNotifi\
    cationDataR\x15inAppNotificationDataB\0\x12K\n\x14purchaseDeclinedData\
    \x18\x0c\x20\x01(\x0b2\x15.PurchaseDeclinedDataR\x14purchaseDeclinedData\
    B\0\x12(\n\x0enotificationId\x18\r\x20\x01(\tR\x0enotificationIdB\0\x126\
    \n\rlibraryUpdate\x18\x0e\x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdat\
    eB\0\x12?\n\x10libraryDirtyData\x18\x0f\x20\x01(\x0b2\x11.LibraryDirtyDa\
    taR\x10libraryDirtyDataB\0:\0\"`\n\x14PurchaseDeclinedData\x12\x18\n\x06\
    reason\x18\x01\x20\x01(\x05R\x06reasonB\0\x12,\n\x10showNotification\x18\
    \x02\x20\x01(\x08R\x10showNotificationB\0:\0\"7\n\x13PurchaseRemovalData\
    \x12\x1e\n\tmalicious\x18\x01\x20\x01(\x08R\tmaliciousB\0:\0\"\xde\x01\n\
    \x14UserNotificationData\x12.\n\x11notificationTitle\x18\x01\x20\x01(\tR\
    \x11notificationTitleB\0\x12,\n\x10notificationText\x18\x02\x20\x01(\tR\
    \x10notificationTextB\0\x12\x20\n\ntickerText\x18\x03\x20\x01(\tR\nticke\
    rTextB\0\x12\"\n\x0bdialogTitle\x18\x04\x20\x01(\tR\x0bdialogTitleB\0\
    \x12\x20\n\ndialogText\x18\x05\x20\x01(\tR\ndialogTextB\0:\0\"\xe0\x05\n\
    \rOwnershipInfo\x12:\n\x17initiationTimestampMsec\x18\x01\x20\x01(\x03R\
    \x17initiationTimestampMsecB\0\x12:\n\x17validUntilTimestampMsec\x18\x02\
    \x20\x01(\x03R\x17validUntilTimestampMsecB\0\x12$\n\x0cautoRenewing\x18\
    \x03\x20\x01(\x08R\x0cautoRenewingB\0\x12@\n\x1arefundTimeoutTimestampMs\
    ec\x18\x04\x20\x01(\x03R\x1arefundTimeoutTimestampMsecB\0\x12D\n\x1cpost\
    DeliveryRefundWindowMsec\x18\x05\x20\x01(\x03R\x1cpostDeliveryRefundWind\
    owMsecB\0\x12C\n\x15developerPurchaseInfo\x18\x06\x20\x01(\x0b2\x0b.Sign\
    edDataR\x15developerPurchaseInfoB\0\x12\x20\n\npreordered\x18\x07\x20\
    \x01(\x08R\npreorderedB\0\x12\x18\n\x06hidden\x18\x08\x20\x01(\x08R\x06h\
    iddenB\0\x120\n\x0brentalTerms\x18\t\x20\x01(\x0b2\x0c.RentalTermsR\x0br\
    entalTermsB\0\x12?\n\x10groupLicenseInfo\x18\n\x20\x01(\x0b2\x11.GroupLi\
    censeInfoR\x10groupLicenseInfoB\0\x12K\n\x14licensedDocumentInfo\x18\x0b\
    \x20\x01(\x0b2\x15.LicensedDocumentInfoR\x14licensedDocumentInfoB\0\x12\
    \x1c\n\x08quantity\x18\x0c\x20\x01(\x05R\x08quantityB\0\x12H\n\x1elibrar\
    yExpirationTimestampMsec\x18\x0e\x20\x01(\x03R\x1elibraryExpirationTimes\
    tampMsecB\0:\0\"i\n\x07AppData\x12\x1a\n\x07version\x18\x01\x20\x01(\x05\
    R\x07versionB\0\x12\x20\n\noldVersion\x18\x02\x20\x01(\x05R\noldVersionB\
    \0\x12\x1e\n\tsystemApp\x18\x03\x20\x01(\x08R\tsystemAppB\0:\0\"\x83\x04\
    \n\x1ePlayStoreBackgroundActionEvent\x12\x14\n\x04type\x18\x01\x20\x01(\
    \x05R\x04typeB\0\x12\x1c\n\x08document\x18\x02\x20\x01(\tR\x08documentB\
    \0\x12\x18\n\x06reason\x18\x03\x20\x01(\tR\x06reasonB\0\x12\x1e\n\terror\
    Code\x18\x04\x20\x01(\x05R\terrorCodeB\0\x12&\n\rexceptionType\x18\x05\
    \x20\x01(\tR\rexceptionTypeB\0\x12,\n\x10serverLogsCookie\x18\x06\x20\
    \x01(\x0cR\x10serverLogsCookieB\0\x12\x1e\n\tofferType\x18\x07\x20\x01(\
    \x05R\tofferTypeB\0\x12\"\n\x0bfromSetting\x18\x08\x20\x01(\x05R\x0bfrom\
    SettingB\0\x12\x1e\n\ttoSetting\x18\t\x20\x01(\x05R\ttoSettingB\0\x129\n\
    \x0bsessionInfo\x18\n\x20\x01(\x0b2\x15.PlayStoreSessionDataR\x0bsession\
    InfoB\0\x12$\n\x07appData\x18\x0b\x20\x01(\x0b2\x08.AppDataR\x07appDataB\
    \0\x12*\n\x0fserverLatencyMs\x18\x0c\x20\x01(\x03R\x0fserverLatencyMsB\0\
    \x12*\n\x0fclientLatencyMs\x18\r\x20\x01(\x03R\x0fclientLatencyMsB\0:\0\
    \"P\n\x13PlayStoreClickEvent\x127\n\x0belementPath\x18\x01\x20\x03(\x0b2\
    \x13.PlayStoreUiElementR\x0belementPathB\0:\0\"d\n\x16PlayStoreDeepLinkE\
    vent\x12\"\n\x0bexternalUrl\x18\x01\x20\x01(\tR\x0bexternalUrlB\0\x12$\n\
    \x0cresolvedType\x18\x02\x20\x01(\x05R\x0cresolvedTypeB\0:\0\"\x94\x01\n\
    \x18PlayStoreImpressionEvent\x12)\n\x04tree\x18\x01\x20\x01(\x0b2\x13.Pl\
    ayStoreUiElementR\x04treeB\0\x129\n\x0creferrerPath\x18\x02\x20\x03(\x0b\
    2\x13.PlayStoreUiElementR\x0creferrerPathB\0\x12\x10\n\x02id\x18\x03\x20\
    \x01(\x03R\x02idB\0:\0\"\xb7\x02\n\x11PlayStoreLogEvent\x12;\n\nimpressi\
    on\x18\x01\x20\x01(\x0b2\x19.PlayStoreImpressionEventR\nimpressionB\0\
    \x12,\n\x05click\x18\x03\x20\x01(\x0b2\x14.PlayStoreClickEventR\x05click\
    B\0\x12M\n\x10backgroundAction\x18\x04\x20\x01(\x0b2\x1f.PlayStoreBackgr\
    oundActionEventR\x10backgroundActionB\0\x12/\n\x06search\x18\x05\x20\x01\
    (\x0b2\x15.PlayStoreSearchEventR\x06searchB\0\x125\n\x08deepLink\x18\x06\
    \x20\x01(\x0b2\x17.PlayStoreDeepLinkEventR\x08deepLinkB\0:\0\"r\n\x14Pla\
    yStoreSearchEvent\x12\x16\n\x05query\x18\x01\x20\x01(\tR\x05queryB\0\x12\
    \x1c\n\x08queryUrl\x18\x02\x20\x01(\tR\x08queryUrlB\0\x12\"\n\x0breferre\
    rUrl\x18\x03\x20\x01(\tR\x0breferrerUrlB\0:\0\"\xd6\x05\n\x14PlayStoreSe\
    ssionData\x12:\n\x17globalAutoUpdateEnabled\x18\x01\x20\x01(\x08R\x17glo\
    balAutoUpdateEnabledB\0\x12D\n\x1cglobalAutoUpdateOverWifiOnly\x18\x02\
    \x20\x01(\x08R\x1cglobalAutoUpdateOverWifiOnlyB\0\x12T\n$autoUpdateClean\
    upDialogNumTimesShown\x18\x03\x20\x01(\x05R$autoUpdateCleanupDialogNumTi\
    mesShownB\0\x12\"\n\x0bnetworkType\x18\x04\x20\x01(\x05R\x0bnetworkTypeB\
    \0\x12(\n\x0enetworkSubType\x18\x05\x20\x01(\x05R\x0enetworkSubTypeB\0\
    \x122\n\x13numAccountsOnDevice\x18\x06\x20\x01(\x05R\x13numAccountsOnDev\
    iceB\0\x12,\n\x10numInstalledApps\x18\x07\x20\x01(\x05R\x10numInstalledA\
    ppsB\0\x12D\n\x1cnumAutoUpdatingInstalledApps\x18\x08\x20\x01(\x05R\x1cn\
    umAutoUpdatingInstalledAppsB\0\x12J\n\x1fnumInstalledAppsNotAutoUpdating\
    \x18\t\x20\x01(\x05R\x1fnumInstalledAppsNotAutoUpdatingB\0\x12<\n\x18gai\
    aPasswordAuthOptedOut\x18\n\x20\x01(\x08R\x18gaiaPasswordAuthOptedOutB\0\
    \x120\n\x12contentFilterLevel\x18\x0b\x20\x01(\x05R\x12contentFilterLeve\
    lB\0\x122\n\x13allowUnknownSources\x18\x0c\x20\x01(\x08R\x13allowUnknown\
    SourcesB\0:\0\"\xce\x01\n\x12PlayStoreUiElement\x12\x14\n\x04type\x18\
    \x01\x20\x01(\x05R\x04typeB\0\x12,\n\x10serverLogsCookie\x18\x02\x20\x01\
    (\x0cR\x10serverLogsCookieB\0\x12E\n\x10clientLogsCookie\x18\x03\x20\x01\
    (\x0b2\x17.PlayStoreUiElementInfoR\x10clientLogsCookieB\0\x12+\n\x05chil\
    d\x18\x04\x20\x03(\x0b2\x13.PlayStoreUiElementR\x05childB\0:\0\"\xf2\x01\
    \n\x16PlayStoreUiElementInfo\x12P\n\x0einstrumentInfo\x18\x01\x20\x01(\
    \x0b2&.PlayStoreUiElementInfo.InstrumentInfoR\x0einstrumentInfoB\0\x12\"\
    \n\x0bserialDocid\x18\x02\x20\x01(\tR\x0bserialDocidB\0\x1a`\n\x0eInstru\
    mentInfo\x12,\n\x10instrumentFamily\x18\x01\x20\x01(\x05R\x10instrumentF\
    amilyB\0\x12\x1e\n\tisDefault\x18\x02\x20\x01(\x08R\tisDefaultB\0:\0:\0\
    \"\x8d\x01\n\x0bPlusProfile\x12\"\n\x0bdisplayName\x18\x02\x20\x01(\tR\
    \x0bdisplayNameB\0\x12*\n\x0fprofileImageUrl\x18\x04\x20\x01(\tR\x0fprof\
    ileImageUrlB\0\x12,\n\x0cprofileImage\x18\x05\x20\x01(\x0b2\x06.ImageR\
    \x0cprofileImageB\0:\0\"\x13\n\x0fPlusOneResponse:\0\"I\n\x13PlusProfile\
    Response\x120\n\x0bplusProfile\x18\x01\x20\x01(\x0b2\x0c.PlusProfileR\
    \x0bplusProfileB\0:\0\"\xf9\x03\n\nClientCart\x12\x16\n\x05title\x18\x01\
    \x20\x01(\tR\x05titleB\0\x12(\n\x0eformattedPrice\x18\x02\x20\x01(\tR\
    \x0eformattedPriceB\0\x124\n\x14purchaseContextToken\x18\x03\x20\x01(\tR\
    \x14purchaseContextTokenB\0\x12-\n\ninstrument\x18\x04\x20\x01(\x0b2\x0b\
    .InstrumentR\ninstrumentB\0\x120\n\x12extendedDetailHtml\x18\x05\x20\x03\
    (\tR\x12extendedDetailHtmlB\0\x12\x20\n\nfooterHtml\x18\x06\x20\x01(\tR\
    \nfooterHtmlB\0\x12:\n\x17addInstrumentPromptHtml\x18\x07\x20\x01(\tR\
    \x17addInstrumentPromptHtmlB\0\x12\x20\n\nbuttonText\x18\x08\x20\x01(\tR\
    \nbuttonTextB\0\x12J\n\x19completePurchaseChallenge\x18\t\x20\x01(\x0b2\
    \n.ChallengeR\x19completePurchaseChallengeB\0\x12\"\n\x0bpriceByline\x18\
    \n\x20\x01(\tR\x0bpriceBylineB\0\x12\x20\n\ndetailHtml\x18\x0b\x20\x03(\
    \tR\ndetailHtmlB\0:\0\"\xac\x02\n\x16CommitPurchaseResponse\x129\n\x0epu\
    rchaseStatus\x18\x01\x20\x01(\x0b2\x0f.PurchaseStatusR\x0epurchaseStatus\
    B\0\x12*\n\tchallenge\x18\x02\x20\x01(\x0b2\n.ChallengeR\tchallengeB\0\
    \x126\n\rlibraryUpdate\x18\x03\x20\x03(\x0b2\x0e.LibraryUpdateR\rlibrary\
    UpdateB\0\x12C\n\x0fappDeliveryData\x18\x04\x20\x01(\x0b2\x17.AndroidApp\
    DeliveryDataR\x0fappDeliveryDataB\0\x12,\n\x10serverLogsCookie\x18\x05\
    \x20\x01(\x0cR\x10serverLogsCookieB\0:\0\"\x8b\x02\n\x17PreparePurchaseR\
    esponse\x129\n\x0epurchaseStatus\x18\x01\x20\x01(\x0b2\x0f.PurchaseStatu\
    sR\x0epurchaseStatusB\0\x12*\n\tchallenge\x18\x02\x20\x01(\x0b2\n.Challe\
    ngeR\tchallengeB\0\x12!\n\x04cart\x18\x03\x20\x01(\x0b2\x0b.ClientCartR\
    \x04cartB\0\x126\n\rlibraryUpdate\x18\x04\x20\x03(\x0b2\x0e.LibraryUpdat\
    eR\rlibraryUpdateB\0\x12,\n\x10serverLogsCookie\x18\x05\x20\x01(\x0cR\
    \x10serverLogsCookieB\0:\0\"\x8e\x01\n\x0ePurchaseStatus\x12\x20\n\nstat\
    usCode\x18\x01\x20\x01(\x05R\nstatusCodeB\0\x12,\n\x10errorMessageHtml\
    \x18\x02\x20\x01(\tR\x10errorMessageHtmlB\0\x12*\n\x0fpermissionError\
    \x18\x03\x20\x01(\x05R\x0fpermissionErrorB\0:\0\"\x20\n\x1cRateSuggested\
    ContentResponse:\0\"\xf7\x03\n\x0fAggregateRating\x12\x14\n\x04type\x18\
    \x01\x20\x01(\x05R\x04typeB\0\x12\x20\n\nstarRating\x18\x02\x20\x01(\x02\
    R\nstarRatingB\0\x12$\n\x0cratingsCount\x18\x03\x20\x01(\x04R\x0cratings\
    CountB\0\x12(\n\x0eoneStarRatings\x18\x04\x20\x01(\x04R\x0eoneStarRating\
    sB\0\x12(\n\x0etwoStarRatings\x18\x05\x20\x01(\x04R\x0etwoStarRatingsB\0\
    \x12,\n\x10threeStarRatings\x18\x06\x20\x01(\x04R\x10threeStarRatingsB\0\
    \x12*\n\x0ffourStarRatings\x18\x07\x20\x01(\x04R\x0ffourStarRatingsB\0\
    \x12*\n\x0ffiveStarRatings\x18\x08\x20\x01(\x04R\x0ffiveStarRatingsB\0\
    \x12&\n\rthumbsUpCount\x18\t\x20\x01(\x04R\rthumbsUpCountB\0\x12*\n\x0ft\
    humbsDownCount\x18\n\x20\x01(\x04R\x0fthumbsDownCountB\0\x12$\n\x0ccomme\
    ntCount\x18\x0b\x20\x01(\x04R\x0ccommentCountB\0\x120\n\x12bayesianMeanR\
    ating\x18\x0c\x20\x01(\x01R\x12bayesianMeanRatingB\0:\0\"\xa0\x01\n\x0eD\
    irectPurchase\x12\x20\n\ndetailsUrl\x18\x01\x20\x01(\tR\ndetailsUrlB\0\
    \x12&\n\rpurchaseDocid\x18\x02\x20\x01(\tR\rpurchaseDocidB\0\x12\"\n\x0b\
    parentDocid\x18\x03\x20\x01(\tR\x0bparentDocidB\0\x12\x1e\n\tofferType\
    \x18\x04\x20\x01(\x05R\tofferTypeB\0:\0\"`\n\x0eRedeemGiftCard\x12\"\n\
    \x0bprefillCode\x18\x01\x20\x01(\tR\x0bprefillCodeB\0\x12(\n\x0epartnerP\
    ayload\x18\x02\x20\x01(\tR\x0epartnerPayloadB\0:\0\"\xaa\x03\n\x0cResolv\
    edLink\x12\x20\n\ndetailsUrl\x18\x01\x20\x01(\tR\ndetailsUrlB\0\x12\x1e\
    \n\tbrowseUrl\x18\x02\x20\x01(\tR\tbrowseUrlB\0\x12\x1e\n\tsearchUrl\x18\
    \x03\x20\x01(\tR\tsearchUrlB\0\x129\n\x0edirectPurchase\x18\x04\x20\x01(\
    \x0b2\x0f.DirectPurchaseR\x0edirectPurchaseB\0\x12\x1a\n\x07homeUrl\x18\
    \x05\x20\x01(\tR\x07homeUrlB\0\x129\n\x0eredeemGiftCard\x18\x06\x20\x01(\
    \x0b2\x0f.RedeemGiftCardR\x0eredeemGiftCardB\0\x12,\n\x10serverLogsCooki\
    e\x18\x07\x20\x01(\x0cR\x10serverLogsCookieB\0\x12\x1e\n\x05docid\x18\
    \x08\x20\x01(\x0b2\x06.DocidR\x05docidB\0\x12\"\n\x0bwishlistUrl\x18\t\
    \x20\x01(\tR\x0bwishlistUrlB\0\x12\x1a\n\x07backend\x18\n\x20\x01(\x05R\
    \x07backendB\0\x12\x16\n\x05query\x18\x0b\x20\x01(\tR\x05queryB\0:\0\"\
    \xd1$\n\x07Payload\x123\n\x0clistResponse\x18\x01\x20\x01(\x0b2\r.ListRe\
    sponseR\x0clistResponseB\0\x12<\n\x0fdetailsResponse\x18\x02\x20\x01(\
    \x0b2\x10.DetailsResponseR\x0fdetailsResponseB\0\x129\n\x0ereviewRespons\
    e\x18\x03\x20\x01(\x0b2\x0f.ReviewResponseR\x0ereviewResponseB\0\x120\n\
    \x0bbuyResponse\x18\x04\x20\x01(\x0b2\x0c.BuyResponseR\x0bbuyResponseB\0\
    \x129\n\x0esearchResponse\x18\x05\x20\x01(\x0b2\x0f.SearchResponseR\x0es\
    earchResponseB\0\x120\n\x0btocResponse\x18\x06\x20\x01(\x0b2\x0c.TocResp\
    onseR\x0btocResponseB\0\x129\n\x0ebrowseResponse\x18\x07\x20\x01(\x0b2\
    \x0f.BrowseResponseR\x0ebrowseResponseB\0\x12Q\n\x16purchaseStatusRespon\
    se\x18\x08\x20\x01(\x0b2\x17.PurchaseStatusResponseR\x16purchaseStatusRe\
    sponseB\0\x12W\n\x18updateInstrumentResponse\x18\t\x20\x01(\x0b2\x19.Upd\
    ateInstrumentResponseR\x18updateInstrumentResponseB\0\x120\n\x0blogRespo\
    nse\x18\n\x20\x01(\x0b2\x0c.LogResponseR\x0blogResponseB\0\x12T\n\x17che\
    ckInstrumentResponse\x18\x0b\x20\x01(\x0b2\x18.CheckInstrumentResponseR\
    \x17checkInstrumentResponseB\0\x12<\n\x0fplusOneResponse\x18\x0c\x20\x01\
    (\x0b2\x10.PlusOneResponseR\x0fplusOneResponseB\0\x12H\n\x13flagContentR\
    esponse\x18\r\x20\x01(\x0b2\x14.FlagContentResponseR\x13flagContentRespo\
    nseB\0\x12T\n\x17ackNotificationResponse\x18\x0e\x20\x01(\x0b2\x18.AckNo\
    tificationResponseR\x17ackNotificationResponseB\0\x12`\n\x1binitiateAsso\
    ciationResponse\x18\x0f\x20\x01(\x0b2\x1c.InitiateAssociationResponseR\
    \x1binitiateAssociationResponseB\0\x12Z\n\x19verifyAssociationResponse\
    \x18\x10\x20\x01(\x0b2\x1a.VerifyAssociationResponseR\x19verifyAssociati\
    onResponseB\0\x12]\n\x1alibraryReplicationResponse\x18\x11\x20\x01(\x0b2\
    \x1b.LibraryReplicationResponseR\x1alibraryReplicationResponseB\0\x129\n\
    \x0erevokeResponse\x18\x12\x20\x01(\x0b2\x0f.RevokeResponseR\x0erevokeRe\
    sponseB\0\x12H\n\x13bulkDetailsResponse\x18\x13\x20\x01(\x0b2\x14.BulkDe\
    tailsResponseR\x13bulkDetailsResponseB\0\x12A\n\x13resolveLinkResponse\
    \x18\x14\x20\x01(\x0b2\r.ResolvedLinkR\x13resolveLinkResponseB\0\x12?\n\
    \x10deliveryResponse\x18\x15\x20\x01(\x0b2\x11.DeliveryResponseR\x10deli\
    veryResponseB\0\x12B\n\x11acceptTosResponse\x18\x16\x20\x01(\x0b2\x12.Ac\
    ceptTosResponseR\x11acceptTosResponseB\0\x12c\n\x1crateSuggestedContentR\
    esponse\x18\x17\x20\x01(\x0b2\x1d.RateSuggestedContentResponseR\x1crateS\
    uggestedContentResponseB\0\x12T\n\x17checkPromoOfferResponse\x18\x18\x20\
    \x01(\x0b2\x18.CheckPromoOfferResponseR\x17checkPromoOfferResponseB\0\
    \x12`\n\x1binstrumentSetupInfoResponse\x18\x19\x20\x01(\x0b2\x1c.Instrum\
    entSetupInfoResponseR\x1binstrumentSetupInfoResponseB\0\x12Q\n\x16redeem\
    GiftCardResponse\x18\x1a\x20\x01(\x0b2\x17.RedeemGiftCardResponseR\x16re\
    deemGiftCardResponseB\0\x12N\n\x15modifyLibraryResponse\x18\x1b\x20\x01(\
    \x0b2\x16.ModifyLibraryResponseR\x15modifyLibraryResponseB\0\x12]\n\x1au\
    ploadDeviceConfigResponse\x18\x1c\x20\x01(\x0b2\x1b.UploadDeviceConfigRe\
    sponseR\x1auploadDeviceConfigResponseB\0\x12H\n\x13plusProfileResponse\
    \x18\x1d\x20\x01(\x0b2\x14.PlusProfileResponseR\x13plusProfileResponseB\
    \0\x12T\n\x17consumePurchaseResponse\x18\x1e\x20\x01(\x0b2\x18.ConsumePu\
    rchaseResponseR\x17consumePurchaseResponseB\0\x12Q\n\x16billingProfileRe\
    sponse\x18\x1f\x20\x01(\x0b2\x17.BillingProfileResponseR\x16billingProfi\
    leResponseB\0\x12T\n\x17preparePurchaseResponse\x18\x20\x20\x01(\x0b2\
    \x18.PreparePurchaseResponseR\x17preparePurchaseResponseB\0\x12Q\n\x16co\
    mmitPurchaseResponse\x18!\x20\x01(\x0b2\x17.CommitPurchaseResponseR\x16c\
    ommitPurchaseResponseB\0\x12N\n\x15debugSettingsResponse\x18\"\x20\x01(\
    \x0b2\x16.DebugSettingsResponseR\x15debugSettingsResponseB\0\x12N\n\x15c\
    heckIabPromoResponse\x18#\x20\x01(\x0b2\x16.CheckIabPromoResponseR\x15ch\
    eckIabPromoResponseB\0\x12c\n\x1cuserActivitySettingsResponse\x18$\x20\
    \x01(\x0b2\x1d.UserActivitySettingsResponseR\x1cuserActivitySettingsResp\
    onseB\0\x12]\n\x1arecordUserActivityResponse\x18%\x20\x01(\x0b2\x1b.Reco\
    rdUserActivityResponseR\x1arecordUserActivityResponseB\0\x12E\n\x12redee\
    mCodeResponse\x18&\x20\x01(\x0b2\x13.RedeemCodeResponseR\x12redeemCodeRe\
    sponseB\0\x12E\n\x12selfUpdateResponse\x18'\x20\x01(\x0b2\x13.SelfUpdate\
    ResponseR\x12selfUpdateResponseB\0\x12N\n\x15searchSuggestResponse\x18(\
    \x20\x01(\x0b2\x16.searchSuggestResponseR\x15searchSuggestResponseB\0\
    \x12~\n%getInitialInstrumentFlowStateResponse\x18)\x20\x01(\x0b2&.GetIni\
    tialInstrumentFlowStateResponseR%getInitialInstrumentFlowStateResponseB\
    \0\x12W\n\x18createInstrumentResponse\x18*\x20\x01(\x0b2\x19.CreateInstr\
    umentResponseR\x18createInstrumentResponseB\0\x12B\n\x11challengeRespons\
    e\x18+\x20\x01(\x0b2\x12.ChallengeResponseR\x11challengeResponseB\0\x12^\
    \n\x1bbackupDeviceChoicesResponse\x18,\x20\x01(\x0b2\x1a.BackDeviceChoic\
    esResponseR\x1bbackupDeviceChoicesResponseB\0\x12f\n\x1dbackupDocumentCh\
    oicesResponse\x18-\x20\x01(\x0b2\x1e.BackupDocumentChoicesResponseR\x1db\
    ackupDocumentChoicesResponseB\0\x12H\n\x13earlyUpdateResponse\x18.\x20\
    \x01(\x0b2\x14.EarlyUpdateResponseR\x13earlyUpdateResponseB\0\x12?\n\x10\
    preloadsResponse\x18/\x20\x01(\x0b2\x11.PreloadsResponseR\x10preloadsRes\
    ponseB\0\x12E\n\x12myAccountsResponse\x180\x20\x01(\x0b2\x13.MyAccountsR\
    esponseR\x12myAccountsResponseB\0\x12N\n\x15contentFilterResponse\x181\
    \x20\x01(\x0b2\x16.ContentFilterResponseR\x15contentFilterResponseB\0\
    \x12H\n\x13experimentsResponse\x182\x20\x01(\x0b2\x14.ExperimentsRespons\
    eR\x13experimentsResponseB\0\x129\n\x0esurveyResponse\x183\x20\x01(\x0b2\
    \x0f.SurveyResponseR\x0esurveyResponseB\0\x123\n\x0cpingResponse\x184\
    \x20\x01(\x0b2\r.PingResponseR\x0cpingResponseB\0\x12Z\n\x19updateUserSe\
    ttingResponse\x185\x20\x01(\x0b2\x1a.UpdateUserSettingResponseR\x19updat\
    eUserSettingResponseB\0\x12T\n\x17getUserSettingsREsponse\x186\x20\x01(\
    \x0b2\x18.GetUserSettingsResponseR\x17getUserSettingsREsponseB\0\x12]\n\
    \x1agetSharingSettingsResponse\x188\x20\x01(\x0b2\x1b.GetSharingSettings\
    ResponseR\x1agetSharingSettingsResponseB\0\x12f\n\x1dupdateSharingSettin\
    gsResponse\x189\x20\x01(\x0b2\x1e.UpdateSharingSettingsResponseR\x1dupda\
    teSharingSettingsResponseB\0\x12Q\n\x16reviewSnippetsResponse\x18:\x20\
    \x01(\x0b2\x17.ReviewSnippetsResponseR\x16reviewSnippetsResponseB\0\x12c\
    \n\x1cdocumentSharingStateResponse\x18;\x20\x01(\x0b2\x1d.DocumentSharin\
    gStateResponseR\x1cdocumentSharingStateResponseB\0\x12Q\n\x16moduleDeliv\
    eryResponse\x18F\x20\x01(\x0b2\x17.ModuleDeliveryResponseR\x16moduleDeli\
    veryResponseB\0:\0\"\x19\n\x15CheckIabPromoResponse:\0\"\x20\n\x1cUserAc\
    tivitySettingsResponse:\0\"\x1e\n\x1aRecordUserActivityResponse:\0\"\x16\
    \n\x12RedeemCodeResponse:\0\"\x16\n\x12SelfUpdateResponse:\0\"\x19\n\x15\
    searchSuggestResponse:\0\")\n%GetInitialInstrumentFlowStateResponse:\0\"\
    \x1c\n\x18CreateInstrumentResponse:\0\"\x15\n\x11ChallengeResponse:\0\"\
    \x1d\n\x19BackDeviceChoicesResponse:\0\"!\n\x1dBackupDocumentChoicesResp\
    onse:\0\"\x17\n\x13EarlyUpdateResponse:\0\"\x14\n\x10PreloadsResponse:\0\
    \"\x16\n\x12MyAccountsResponse:\0\"\x19\n\x15ContentFilterResponse:\0\"\
    \x17\n\x13ExperimentsResponse:\0\"\x12\n\x0eSurveyResponse:\0\"\x10\n\
    \x0cPingResponse:\0\"\x1d\n\x19UpdateUserSettingResponse:\0\"\x1b\n\x17G\
    etUserSettingsResponse:\0\"\x1e\n\x1aGetSharingSettingsResponse:\0\"!\n\
    \x1dUpdateSharingSettingsResponse:\0\"\x1a\n\x16ReviewSnippetsResponse:\
    \0\"\x20\n\x1cDocumentSharingStateResponse:\0\"\x1a\n\x16ModuleDeliveryR\
    esponse:\0\"\x84\x01\n\x08PreFetch\x12\x12\n\x03url\x18\x01\x20\x01(\tR\
    \x03urlB\0\x12\x1c\n\x08response\x18\x02\x20\x01(\x0cR\x08responseB\0\
    \x12\x14\n\x04etag\x18\x03\x20\x01(\tR\x04etagB\0\x12\x12\n\x03ttl\x18\
    \x04\x20\x01(\x03R\x03ttlB\0\x12\x1a\n\x07softTtl\x18\x05\x20\x01(\x03R\
    \x07softTtlB\0:\0\"\x81\x02\n\x0fResponseWrapper\x12$\n\x07payload\x18\
    \x01\x20\x01(\x0b2\x08.PayloadR\x07payloadB\0\x12-\n\x08commands\x18\x02\
    \x20\x01(\x0b2\x0f.ServerCommandsR\x08commandsB\0\x12'\n\x08preFetch\x18\
    \x03\x20\x03(\x0b2\t.PreFetchR\x08preFetchB\0\x123\n\x0cnotification\x18\
    \x04\x20\x03(\x0b2\r.NotificationR\x0cnotificationB\0\x129\n\x0eserverMe\
    tadata\x18\x05\x20\x01(\x0b2\x0f.ServerMetadataR\x0eserverMetadataB\0:\0\
    \"\x9a\x01\n\x0eServerCommands\x12\x20\n\nclearCache\x18\x01\x20\x01(\
    \x08R\nclearCacheB\0\x122\n\x13displayErrorMessage\x18\x02\x20\x01(\tR\
    \x13displayErrorMessageB\0\x120\n\x12logErrorStacktrace\x18\x03\x20\x01(\
    \tR\x12logErrorStacktraceB\0:\0\":\n\x0eServerMetadata\x12&\n\rlatencyMi\
    llis\x18\x01\x20\x01(\x03R\rlatencyMillisB\0:\0\"a\n\x12GetReviewsRespon\
    se\x12!\n\x06review\x18\x01\x20\x03(\x0b2\x07.ReviewR\x06reviewB\0\x12&\
    \n\rmatchingCount\x18\x02\x20\x01(\x03R\rmatchingCountB\0:\0\"\x94\x04\n\
    \x06Review\x12\x20\n\nauthorName\x18\x01\x20\x01(\tR\nauthorNameB\0\x12\
    \x12\n\x03url\x18\x02\x20\x01(\tR\x03urlB\0\x12\x18\n\x06source\x18\x03\
    \x20\x01(\tR\x06sourceB\0\x12*\n\x0fdocumentVersion\x18\x04\x20\x01(\tR\
    \x0fdocumentVersionB\0\x12&\n\rtimestampMsec\x18\x05\x20\x01(\x03R\rtime\
    stampMsecB\0\x12\x20\n\nstarRating\x18\x06\x20\x01(\x05R\nstarRatingB\0\
    \x12\x16\n\x05title\x18\x07\x20\x01(\tR\x05titleB\0\x12\x1a\n\x07comment\
    \x18\x08\x20\x01(\tR\x07commentB\0\x12\x1e\n\tcommentId\x18\t\x20\x01(\t\
    R\tcommentIdB\0\x12\x20\n\ndeviceName\x18\x13\x20\x01(\tR\ndeviceNameB\0\
    \x12\x1e\n\treplyText\x18\x1d\x20\x01(\tR\treplyTextB\0\x120\n\x12replyT\
    imestampMsec\x18\x1e\x20\x01(\x03R\x12replyTimestampMsecB\0\x120\n\x0bpl\
    usProfile\x18\x1f\x20\x01(\x0b2\x0c.PlusProfileR\x0bplusProfileB\0\x12\
    \x20\n\x06author\x18!\x20\x01(\x0b2\x06.DocV2R\x06authorB\0\x12&\n\tsent\
    iment\x18\"\x20\x01(\x0b2\x06.ImageR\tsentimentB\0:\0\"\xa0\x01\n\x0eRev\
    iewResponse\x127\n\x0bgetResponse\x18\x01\x20\x01(\x0b2\x13.GetReviewsRe\
    sponseR\x0bgetResponseB\0\x12\"\n\x0bnextPageUrl\x18\x02\x20\x01(\tR\x0b\
    nextPageUrlB\0\x12/\n\rupdatedReview\x18\x03\x20\x01(\x0b2\x07.ReviewR\r\
    updatedReviewB\0:\0\"J\n\x0eRevokeResponse\x126\n\rlibraryUpdate\x18\x01\
    \x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdateB\0:\0\"\xa3\x01\n\rRela\
    tedSearch\x12\x1e\n\tsearchUrl\x18\x01\x20\x01(\tR\tsearchUrlB\0\x12\x18\
    \n\x06header\x18\x02\x20\x01(\tR\x06headerB\0\x12\x1e\n\tbackendId\x18\
    \x03\x20\x01(\x05R\tbackendIdB\0\x12\x1a\n\x07docType\x18\x04\x20\x01(\
    \x05R\x07docTypeB\0\x12\x1a\n\x07current\x18\x05\x20\x01(\x08R\x07curren\
    tB\0:\0\"\xb3\x02\n\x0eSearchResponse\x12&\n\roriginalQuery\x18\x01\x20\
    \x01(\tR\roriginalQueryB\0\x12(\n\x0esuggestedQuery\x18\x02\x20\x01(\tR\
    \x0esuggestedQueryB\0\x12(\n\x0eaggregateQuery\x18\x03\x20\x01(\x08R\x0e\
    aggregateQueryB\0\x12!\n\x06bucket\x18\x04\x20\x03(\x0b2\x07.BucketR\x06\
    bucketB\0\x12\x1a\n\x03doc\x18\x05\x20\x03(\x0b2\x06.DocV2R\x03docB\0\
    \x126\n\rrelatedSearch\x18\x06\x20\x03(\x0b2\x0e.RelatedSearchR\rrelated\
    SearchB\0\x12,\n\x10serverLogsCookie\x18\x07\x20\x01(\x0cR\x10serverLogs\
    CookieB\0:\0\"\x8c\x01\n\rBillingConfig\x12K\n\x14carrierBillingConfig\
    \x18\x01\x20\x01(\x0b2\x15.CarrierBillingConfigR\x14carrierBillingConfig\
    B\0\x12,\n\x10maxIabApiVersion\x18\x02\x20\x01(\x05R\x10maxIabApiVersion\
    B\0:\0\"\x8e\x03\n\x14CarrierBillingConfig\x12\x10\n\x02id\x18\x01\x20\
    \x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12\
    \x20\n\napiVersion\x18\x03\x20\x01(\x05R\napiVersionB\0\x12*\n\x0fprovis\
    ioningUrl\x18\x04\x20\x01(\tR\x0fprovisioningUrlB\0\x12(\n\x0ecredential\
    sUrl\x18\x05\x20\x01(\tR\x0ecredentialsUrlB\0\x12\"\n\x0btosRequired\x18\
    \x06\x20\x01(\x08R\x0btosRequiredB\0\x12N\n!perTransactionCredentialsReq\
    uired\x18\x07\x20\x01(\x08R!perTransactionCredentialsRequiredB\0\x12`\n*\
    sendSubscriberIdWithCarrierBillingRequests\x18\x08\x20\x01(\x08R*sendSub\
    scriberIdWithCarrierBillingRequestsB\0:\0\"\xb2\x01\n\x0eCorpusMetadata\
    \x12\x1a\n\x07backend\x18\x01\x20\x01(\x05R\x07backendB\0\x12\x14\n\x04n\
    ame\x18\x02\x20\x01(\tR\x04nameB\0\x12\x20\n\nlandingUrl\x18\x03\x20\x01\
    (\tR\nlandingUrlB\0\x12\"\n\x0blibraryName\x18\x04\x20\x01(\tR\x0blibrar\
    yNameB\0\x12&\n\rrecsWidgetUrl\x18\x06\x20\x01(\tR\rrecsWidgetUrlB\0:\0\
    \"5\n\x0bExperiments\x12$\n\x0cexperimentId\x18\x01\x20\x03(\tR\x0cexper\
    imentIdB\0:\0\"P\n\x10SelfUpdateConfig\x12:\n\x17latestClientVersionCode\
    \x18\x01\x20\x01(\x05R\x17latestClientVersionCodeB\0:\0\"\x8c\x05\n\x0bT\
    ocResponse\x12)\n\x06corpus\x18\x01\x20\x03(\x0b2\x0f.CorpusMetadataR\
    \x06corpusB\0\x124\n\x14tosVersionDeprecated\x18\x02\x20\x01(\x05R\x14to\
    sVersionDeprecatedB\0\x12\x20\n\ntosContent\x18\x03\x20\x01(\tR\ntosCont\
    entB\0\x12\x1a\n\x07homeUrl\x18\x04\x20\x01(\tR\x07homeUrlB\0\x120\n\x0b\
    experiments\x18\x05\x20\x01(\x0b2\x0c.ExperimentsR\x0bexperimentsB\0\x12\
    H\n\x1etosCheckboxTextMarketingEmails\x18\x06\x20\x01(\tR\x1etosCheckbox\
    TextMarketingEmailsB\0\x12\x1c\n\x08tosToken\x18\x07\x20\x01(\tR\x08tosT\
    okenB\0\x123\n\x0cuserSettings\x18\x08\x20\x01(\x0b2\r.UserSettingsR\x0c\
    userSettingsB\0\x12*\n\x0ficonOverrideUrl\x18\t\x20\x01(\tR\x0ficonOverr\
    ideUrlB\0\x12?\n\x10selfUpdateConfig\x18\n\x20\x01(\x0b2\x11.SelfUpdateC\
    onfigR\x10selfUpdateConfigB\0\x12@\n\x1arequiresUploadDeviceConfig\x18\
    \x0b\x20\x01(\x08R\x1arequiresUploadDeviceConfigB\0\x126\n\rbillingConfi\
    g\x18\x0c\x20\x01(\x0b2\x0e.BillingConfigR\rbillingConfigB\0\x12&\n\rrec\
    sWidgetUrl\x18\r\x20\x01(\tR\rrecsWidgetUrlB\0:\0\"`\n\x0cUserSettings\
    \x12N\n!tosCheckboxMarketingEmailsOptedIn\x18\x01\x20\x01(\x08R!tosCheck\
    boxMarketingEmailsOptedInB\0:\0\"\x15\n\x11AcceptTosResponse:\0\"\xc2\
    \x01\n\x19UploadDeviceConfigRequest\x12M\n\x13deviceConfiguration\x18\
    \x01\x20\x01(\x0b2\x19.DeviceConfigurationProtoR\x13deviceConfigurationB\
    \0\x12$\n\x0cmanufacturer\x18\x02\x20\x01(\tR\x0cmanufacturerB\0\x12.\n\
    \x11gcmRegistrationId\x18\x03\x20\x01(\tR\x11gcmRegistrationIdB\0:\0\"Z\
    \n\x1aUploadDeviceConfigResponse\x12:\n\x17uploadDeviceConfigToken\x18\
    \x01\x20\x01(\tR\x17uploadDeviceConfigTokenB\0:\0\"\xb9\x01\n\x1cAckNoti\
    ficationsRequestProto\x12(\n\x0enotificationId\x18\x01\x20\x03(\tR\x0eno\
    tificationIdB\0\x12;\n\rsignatureHash\x18\x02\x20\x01(\x0b2\x13.Signatur\
    eHashProtoR\rsignatureHashB\0\x120\n\x12nackNotificationId\x18\x03\x20\
    \x03(\tR\x12nackNotificationIdB\0:\0\"!\n\x1dAckNotificationsResponsePro\
    to:\0\"\xfc\x01\n\x0cAddressProto\x12\x1c\n\x08address1\x18\x01\x20\x01(\
    \tR\x08address1B\0\x12\x1c\n\x08address2\x18\x02\x20\x01(\tR\x08address2\
    B\0\x12\x14\n\x04city\x18\x03\x20\x01(\tR\x04cityB\0\x12\x16\n\x05state\
    \x18\x04\x20\x01(\tR\x05stateB\0\x12\x20\n\npostalCode\x18\x05\x20\x01(\
    \tR\npostalCodeB\0\x12\x1a\n\x07country\x18\x06\x20\x01(\tR\x07countryB\
    \0\x12\x14\n\x04name\x18\x07\x20\x01(\tR\x04nameB\0\x12\x14\n\x04type\
    \x18\x08\x20\x01(\tR\x04typeB\0\x12\x16\n\x05phone\x18\t\x20\x01(\tR\x05\
    phoneB\0:\0\"<\n\x0cAppDataProto\x12\x12\n\x03key\x18\x01\x20\x01(\tR\
    \x03keyB\0\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\0:\0\"K\n\
    \x12AppSuggestionProto\x123\n\tassetInfo\x18\x01\x20\x01(\x0b2\x13.Exter\
    nalAssetProtoR\tassetInfoB\0:\0\"|\n\x14AssetIdentifierProto\x12\"\n\x0b\
    packageName\x18\x01\x20\x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\
    \x18\x02\x20\x01(\x05R\x0bversionCodeB\0\x12\x1a\n\x07assetId\x18\x03\
    \x20\x01(\tR\x07assetIdB\0:\0\"\xa6\x05\n\x12AssetsRequestProto\x12\x1e\
    \n\tassetType\x18\x01\x20\x01(\x05R\tassetTypeB\0\x12\x16\n\x05query\x18\
    \x02\x20\x01(\tR\x05queryB\0\x12\x20\n\ncategoryId\x18\x03\x20\x01(\tR\n\
    categoryIdB\0\x12\x1a\n\x07assetId\x18\x04\x20\x03(\tR\x07assetIdB\0\x12\
    8\n\x16retrieveVendingHistory\x18\x05\x20\x01(\x08R\x16retrieveVendingHi\
    storyB\0\x124\n\x14retrieveExtendedInfo\x18\x06\x20\x01(\x08R\x14retriev\
    eExtendedInfoB\0\x12\x1e\n\tsortOrder\x18\x07\x20\x01(\x05R\tsortOrderB\
    \0\x12\x20\n\nstartIndex\x18\x08\x20\x01(\x03R\nstartIndexB\0\x12\x20\n\
    \nnumEntries\x18\t\x20\x01(\x03R\nnumEntriesB\0\x12\x20\n\nviewFilter\
    \x18\n\x20\x01(\x05R\nviewFilterB\0\x12\"\n\x0brankingType\x18\x0b\x20\
    \x01(\tR\x0brankingTypeB\0\x128\n\x16retrieveCarrierChannel\x18\x0c\x20\
    \x01(\x08R\x16retrieveCarrierChannelB\0\x128\n\x16pendingDownloadAssetId\
    \x18\r\x20\x03(\tR\x16pendingDownloadAssetIdB\0\x12>\n\x19reconstructVen\
    dingHistory\x18\x0e\x20\x01(\x08R\x19reconstructVendingHistoryB\0\x12.\n\
    \x11unfilteredResults\x18\x0f\x20\x01(\x08R\x11unfilteredResultsB\0\x12\
    \x1a\n\x07badgeId\x18\x10\x20\x03(\tR\x07badgeIdB\0:\0\"\xb9\x02\n\x13As\
    setsResponseProto\x12+\n\x05asset\x18\x01\x20\x03(\x0b2\x13.ExternalAsse\
    tProtoR\x05assetB\0\x12*\n\x0fnumTotalEntries\x18\x02\x20\x01(\x03R\x0fn\
    umTotalEntriesB\0\x12(\n\x0ecorrectedQuery\x18\x03\x20\x01(\tR\x0ecorrec\
    tedQueryB\0\x121\n\x08altAsset\x18\x04\x20\x03(\x0b2\x13.ExternalAssetPr\
    otoR\x08altAssetB\0\x122\n\x13numCorrectedEntries\x18\x05\x20\x01(\x03R\
    \x13numCorrectedEntriesB\0\x12\x18\n\x06header\x18\x06\x20\x01(\tR\x06he\
    aderB\0\x12\x1c\n\x08listType\x18\x07\x20\x01(\x05R\x08listTypeB\0:\0\"\
    \x98\x02\n\x18BillingEventRequestProto\x12\x1e\n\teventType\x18\x01\x20\
    \x01(\x05R\teventTypeB\0\x122\n\x13billingParametersId\x18\x02\x20\x01(\
    \tR\x13billingParametersIdB\0\x12&\n\rresultSuccess\x18\x03\x20\x01(\x08\
    R\rresultSuccessB\0\x12&\n\rclientMessage\x18\x04\x20\x01(\tR\rclientMes\
    sageB\0\x12V\n\x11carrierInstrument\x18\x05\x20\x01(\x0b2&.ExternalCarri\
    erBillingInstrumentProtoR\x11carrierInstrumentB\0:\0\"\x1d\n\x19BillingE\
    ventResponseProto:\0\"\x83\x06\n\x15BillingParameterProto\x12\x10\n\x02i\
    d\x18\x01\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04\
    nameB\0\x12\x18\n\x06mncMcc\x18\x03\x20\x03(\tR\x06mncMccB\0\x12\x20\n\n\
    backendUrl\x18\x04\x20\x03(\tR\nbackendUrlB\0\x12\x18\n\x06iconId\x18\
    \x05\x20\x01(\tR\x06iconIdB\0\x126\n\x15billingInstrumentType\x18\x06\
    \x20\x01(\x05R\x15billingInstrumentTypeB\0\x12&\n\rapplicationId\x18\x07\
    \x20\x01(\tR\rapplicationIdB\0\x12\x18\n\x06tosUrl\x18\x08\x20\x01(\tR\
    \x06tosUrlB\0\x126\n\x15instrumentTosRequired\x18\t\x20\x01(\x08R\x15ins\
    trumentTosRequiredB\0\x12\x20\n\napiVersion\x18\n\x20\x01(\x05R\napiVers\
    ionB\0\x12N\n!perTransactionCredentialsRequired\x18\x0b\x20\x01(\x08R!pe\
    rTransactionCredentialsRequiredB\0\x12`\n*sendSubscriberIdWithCarrierBil\
    lingRequests\x18\x0c\x20\x01(\x08R*sendSubscriberIdWithCarrierBillingReq\
    uestsB\0\x12:\n\x17deviceAssociationMethod\x18\r\x20\x01(\x05R\x17device\
    AssociationMethodB\0\x12:\n\x17userTokenRequestMessage\x18\x0e\x20\x01(\
    \tR\x17userTokenRequestMessageB\0\x12:\n\x17userTokenRequestAddress\x18\
    \x0f\x20\x01(\tR\x17userTokenRequestAddressB\0\x120\n\x12passphraseRequi\
    red\x18\x10\x20\x01(\x08R\x12passphraseRequiredB\0:\0\"x\n\x1eCarrierBil\
    lingCredentialsProto\x12\"\n\x0bcredentials\x18\x01\x20\x01(\tR\x0bcrede\
    ntialsB\0\x120\n\x12credentialsTimeout\x18\x02\x20\x01(\x03R\x12credenti\
    alsTimeoutB\0:\0\"\xab\x03\n\rCategoryProto\x12\x1e\n\tassetType\x18\x02\
    \x20\x01(\x05R\tassetTypeB\0\x12\x20\n\ncategoryId\x18\x03\x20\x01(\tR\n\
    categoryIdB\0\x12*\n\x0fcategoryDisplay\x18\x04\x20\x01(\tR\x0fcategoryD\
    isplayB\0\x12,\n\x10categorySubtitle\x18\x05\x20\x01(\tR\x10categorySubt\
    itleB\0\x12.\n\x11promotedAssetsNew\x18\x06\x20\x03(\tR\x11promotedAsset\
    sNewB\0\x120\n\x12promotedAssetsHome\x18\x07\x20\x03(\tR\x12promotedAsse\
    tsHomeB\0\x126\n\rsubCategories\x18\x08\x20\x03(\x0b2\x0e.CategoryProtoR\
    \rsubCategoriesB\0\x120\n\x12promotedAssetsPaid\x18\t\x20\x03(\tR\x12pro\
    motedAssetsPaidB\0\x120\n\x12promotedAssetsFree\x18\n\x20\x03(\tR\x12pro\
    motedAssetsFreeB\0:\0\"M\n!CheckForNotificationsRequestProto\x12&\n\rala\
    rmDuration\x18\x01\x20\x01(\x03R\ralarmDurationB\0:\0\"&\n\"CheckForNoti\
    ficationsResponseProto:\0\"|\n\x18CheckLicenseRequestProto\x12\"\n\x0bpa\
    ckageName\x18\x01\x20\x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\
    \x18\x02\x20\x01(\x05R\x0bversionCodeB\0\x12\x16\n\x05nonce\x18\x03\x20\
    \x01(\x03R\x05nonceB\0:\0\"\x85\x01\n\x19CheckLicenseResponseProto\x12$\
    \n\x0cresponseCode\x18\x01\x20\x01(\x05R\x0cresponseCodeB\0\x12\x20\n\ns\
    ignedData\x18\x02\x20\x01(\tR\nsignedDataB\0\x12\x1e\n\tsignature\x18\
    \x03\x20\x01(\tR\tsignatureB\0:\0\"\xdc\x01\n\x14CommentsRequestProto\
    \x12\x1a\n\x07assetId\x18\x01\x20\x01(\tR\x07assetIdB\0\x12\x20\n\nstart\
    Index\x18\x02\x20\x01(\x03R\nstartIndexB\0\x12\x20\n\nnumEntries\x18\x03\
    \x20\x01(\x03R\nnumEntriesB\0\x12:\n\x17shouldReturnSelfComment\x18\x04\
    \x20\x01(\x08R\x17shouldReturnSelfCommentB\0\x12&\n\rassetReferrer\x18\
    \x05\x20\x01(\tR\rassetReferrerB\0:\0\"\xb3\x01\n\x15CommentsResponsePro\
    to\x121\n\x07comment\x18\x01\x20\x03(\x0b2\x15.ExternalCommentProtoR\x07\
    commentB\0\x12*\n\x0fnumTotalEntries\x18\x02\x20\x01(\x03R\x0fnumTotalEn\
    triesB\0\x129\n\x0bselfComment\x18\x03\x20\x01(\x0b2\x15.ExternalComment\
    ProtoR\x0bselfCommentB\0:\0\"\xa2\x05\n\x17ContentSyncRequestProto\x12\"\
    \n\x0bincremental\x18\x01\x20\x01(\x08R\x0bincrementalB\0\x12Z\n\x11asse\
    tinstallstate\x18\x02\x20\x03(\n2*.ContentSyncRequestProto.AssetInstallS\
    tateR\x11assetinstallstateB\0\x12B\n\tsystemapp\x18\n\x20\x03(\n2\".Cont\
    entSyncRequestProto.SystemAppR\tsystemappB\0\x120\n\x12sideloadedAppCoun\
    t\x18\x0e\x20\x01(\x05R\x12sideloadedAppCountB\0\x1a\x8d\x02\n\x11AssetI\
    nstallState\x12\x1a\n\x07assetId\x18\x03\x20\x01(\tR\x07assetIdB\0\x12\
    \x20\n\nassetState\x18\x04\x20\x01(\x05R\nassetStateB\0\x12\"\n\x0binsta\
    llTime\x18\x05\x20\x01(\x03R\x0binstallTimeB\0\x12&\n\runinstallTime\x18\
    \x06\x20\x01(\x03R\runinstallTimeB\0\x12\"\n\x0bpackageName\x18\x07\x20\
    \x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\x18\x08\x20\x01(\x05R\
    \x0bversionCodeB\0\x12&\n\rassetReferrer\x18\t\x20\x01(\tR\rassetReferre\
    rB\0\x1a\x7f\n\tSystemApp\x12\"\n\x0bpackageName\x18\x0b\x20\x01(\tR\x0b\
    packageNameB\0\x12\"\n\x0bversionCode\x18\x0c\x20\x01(\x05R\x0bversionCo\
    deB\0\x12*\n\x0fcertificateHash\x18\r\x20\x03(\tR\x0fcertificateHashB\0:\
    \0\"P\n\x18ContentSyncResponseProto\x122\n\x13numUpdatesAvailable\x18\
    \x01\x20\x01(\x05R\x13numUpdatesAvailableB\0:\0\"]\n\x10DataMessageProto\
    \x12\x1c\n\x08category\x18\x01\x20\x01(\tR\x08categoryB\0\x12)\n\x07appD\
    ata\x18\x03\x20\x03(\x0b2\r.AppDataProtoR\x07appDataB\0:\0\"o\n\x11Downl\
    oadInfoProto\x12\x1a\n\x07apkSize\x18\x01\x20\x01(\x03R\x07apkSizeB\0\
    \x12<\n\x0eadditionalFile\x18\x02\x20\x03(\x0b2\x12.FileMetadataProtoR\
    \x0eadditionalFileB\0:\0\"\xaf\x10\n\x12ExternalAssetProto\x12\x10\n\x02\
    id\x18\x01\x20\x01(\tR\x02idB\0\x12\x16\n\x05title\x18\x02\x20\x01(\tR\
    \x05titleB\0\x12\x1e\n\tassetType\x18\x03\x20\x01(\x05R\tassetTypeB\0\
    \x12\x16\n\x05owner\x18\x04\x20\x01(\tR\x05ownerB\0\x12\x1a\n\x07version\
    \x18\x05\x20\x01(\tR\x07versionB\0\x12\x16\n\x05price\x18\x06\x20\x01(\t\
    R\x05priceB\0\x12&\n\raverageRating\x18\x07\x20\x01(\tR\raverageRatingB\
    \0\x12\x20\n\nnumRatings\x18\x08\x20\x01(\x03R\nnumRatingsB\0\x12[\n\x13\
    purchaseinformation\x18\t\x20\x01(\n2'.ExternalAssetProto.PurchaseInform\
    ationR\x13purchaseinformationB\0\x12F\n\x0cextendedinfo\x18\x0c\x20\x01(\
    \n2\x20.ExternalAssetProto.ExtendedInfoR\x0cextendedinfoB\0\x12\x1a\n\
    \x07ownerId\x18\x16\x20\x01(\tR\x07ownerIdB\0\x12\"\n\x0bpackageName\x18\
    \x18\x20\x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\x18\x19\x20\
    \x01(\x05R\x0bversionCodeB\0\x12$\n\x0cbundledAsset\x18\x1d\x20\x01(\x08\
    R\x0cbundledAssetB\0\x12&\n\rpriceCurrency\x18\x20\x20\x01(\tR\rpriceCur\
    rencyB\0\x12\"\n\x0bpriceMicros\x18!\x20\x01(\x03R\x0bpriceMicrosB\0\x12\
    $\n\x0cfilterReason\x18#\x20\x01(\tR\x0cfilterReasonB\0\x12.\n\x11actual\
    SellerPrice\x18(\x20\x01(\tR\x11actualSellerPriceB\0\x121\n\x08appBadge\
    \x18/\x20\x03(\x0b2\x13.ExternalBadgeProtoR\x08appBadgeB\0\x125\n\nowner\
    Badge\x180\x20\x03(\x0b2\x13.ExternalBadgeProtoR\nownerBadgeB\0\x1a\xd1\
    \x01\n\x13PurchaseInformation\x12$\n\x0cpurchaseTime\x18\n\x20\x01(\x03R\
    \x0cpurchaseTimeB\0\x12.\n\x11refundTimeoutTime\x18\x0b\x20\x01(\x03R\
    \x11refundTimeoutTimeB\0\x12.\n\x11refundStartPolicy\x18-\x20\x01(\x05R\
    \x11refundStartPolicyB\0\x124\n\x14refundWindowDuration\x18.\x20\x01(\
    \x03R\x14refundWindowDurationB\0\x1a\xa7\x08\n\x0cExtendedInfo\x12\"\n\
    \x0bdescription\x18\r\x20\x01(\tR\x0bdescriptionB\0\x12&\n\rdownloadCoun\
    t\x18\x0e\x20\x01(\x03R\rdownloadCountB\0\x12:\n\x17applicationPermissio\
    nId\x18\x0f\x20\x03(\tR\x17applicationPermissionIdB\0\x12<\n\x18required\
    InstallationSize\x18\x10\x20\x01(\x03R\x18requiredInstallationSizeB\0\
    \x12\"\n\x0bpackageName\x18\x11\x20\x01(\tR\x0bpackageNameB\0\x12\x1c\n\
    \x08category\x18\x12\x20\x01(\tR\x08categoryB\0\x12&\n\rforwardLocked\
    \x18\x13\x20\x01(\x08R\rforwardLockedB\0\x12$\n\x0ccontactEmail\x18\x14\
    \x20\x01(\tR\x0ccontactEmailB\0\x122\n\x13everInstalledByUser\x18\x15\
    \x20\x01(\x08R\x13everInstalledByUserB\0\x122\n\x13downloadCountString\
    \x18\x17\x20\x01(\tR\x13downloadCountStringB\0\x12$\n\x0ccontactPhone\
    \x18\x1a\x20\x01(\tR\x0ccontactPhoneB\0\x12(\n\x0econtactWebsite\x18\x1b\
    \x20\x01(\tR\x0econtactWebsiteB\0\x128\n\x16nextPurchaseRefundable\x18\
    \x1c\x20\x01(\x08R\x16nextPurchaseRefundableB\0\x12(\n\x0enumScreenshots\
    \x18\x1e\x20\x01(\x05R\x0enumScreenshotsB\0\x128\n\x16promotionalDescrip\
    tion\x18\x1f\x20\x01(\tR\x16promotionalDescriptionB\0\x12,\n\x10serverAs\
    setState\x18\"\x20\x01(\x05R\x10serverAssetStateB\0\x120\n\x12contentRat\
    ingLevel\x18$\x20\x01(\x05R\x12contentRatingLevelB\0\x122\n\x13contentRa\
    tingString\x18%\x20\x01(\tR\x13contentRatingStringB\0\x12&\n\rrecentChan\
    ges\x18&\x20\x01(\tR\rrecentChangesB\0\x12U\n\x11packagedependency\x18'\
    \x20\x03(\n2%.ExternalAssetProto.PackageDependencyR\x11packagedependency\
    B\0\x12\x1e\n\tvideoLink\x18+\x20\x01(\tR\tvideoLinkB\0\x128\n\x0cdownlo\
    adInfo\x181\x20\x01(\x0b2\x12.DownloadInfoProtoR\x0cdownloadInfoB\0:\0\"\
    G\n\x17ExternalBadgeImageProto\x12\x16\n\x05usage\x18\x01\x20\x01(\x05R\
    \x05usageB\0\x12\x12\n\x03url\x18\x02\x20\x01(\tR\x03urlB\0:\0\"\xd0\x01\
    \n\x12ExternalBadgeProto\x12(\n\x0elocalizedTitle\x18\x01\x20\x01(\tR\
    \x0elocalizedTitleB\0\x124\n\x14localizedDescription\x18\x02\x20\x01(\tR\
    \x14localizedDescriptionB\0\x12:\n\nbadgeImage\x18\x03\x20\x03(\x0b2\x18\
    .ExternalBadgeImageProtoR\nbadgeImageB\0\x12\x1c\n\x08searchId\x18\x04\
    \x20\x01(\tR\x08searchIdB\0:\0\"\xb3\x04\n%ExternalCarrierBillingInstrum\
    entProto\x12&\n\rinstrumentKey\x18\x01\x20\x01(\tR\rinstrumentKeyB\0\x12\
    4\n\x14subscriberIdentifier\x18\x02\x20\x01(\tR\x14subscriberIdentifierB\
    \0\x12\"\n\x0baccountType\x18\x03\x20\x01(\tR\x0baccountTypeB\0\x120\n\
    \x12subscriberCurrency\x18\x04\x20\x01(\tR\x12subscriberCurrencyB\0\x12,\
    \n\x10transactionLimit\x18\x05\x20\x01(\x04R\x10transactionLimitB\0\x12(\
    \n\x0esubscriberName\x18\x06\x20\x01(\tR\x0esubscriberNameB\0\x12\x1c\n\
    \x08address1\x18\x07\x20\x01(\tR\x08address1B\0\x12\x1c\n\x08address2\
    \x18\x08\x20\x01(\tR\x08address2B\0\x12\x14\n\x04city\x18\t\x20\x01(\tR\
    \x04cityB\0\x12\x16\n\x05state\x18\n\x20\x01(\tR\x05stateB\0\x12\x20\n\n\
    postalCode\x18\x0b\x20\x01(\tR\npostalCodeB\0\x12\x1a\n\x07country\x18\
    \x0c\x20\x01(\tR\x07countryB\0\x12T\n\x17encryptedSubscriberInfo\x18\r\
    \x20\x01(\x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscriberInfoB\
    \0:\0\"\xb2\x01\n\x14ExternalCommentProto\x12\x14\n\x04body\x18\x01\x20\
    \x01(\tR\x04bodyB\0\x12\x18\n\x06rating\x18\x02\x20\x01(\x05R\x06ratingB\
    \0\x12\"\n\x0bcreatorName\x18\x03\x20\x01(\tR\x0bcreatorNameB\0\x12$\n\
    \x0ccreationTime\x18\x04\x20\x01(\x03R\x0ccreationTimeB\0\x12\x1e\n\tcre\
    atorId\x18\x05\x20\x01(\tR\tcreatorIdB\0:\0\"\x96\x03\n\x12ExternalCredi\
    tCard\x12\x14\n\x04type\x18\x01\x20\x01(\tR\x04typeB\0\x12\x20\n\nlastDi\
    gits\x18\x02\x20\x01(\tR\nlastDigitsB\0\x12\x1a\n\x07expYear\x18\x03\x20\
    \x01(\x05R\x07expYearB\0\x12\x1c\n\x08expMonth\x18\x04\x20\x01(\x05R\x08\
    expMonthB\0\x12\x20\n\npersonName\x18\x05\x20\x01(\tR\npersonNameB\0\x12\
    \"\n\x0bcountryCode\x18\x06\x20\x01(\tR\x0bcountryCodeB\0\x12\x20\n\npos\
    talCode\x18\x07\x20\x01(\tR\npostalCodeB\0\x12\"\n\x0bmakeDefault\x18\
    \x08\x20\x01(\x08R\x0bmakeDefaultB\0\x12\x1c\n\x08address1\x18\t\x20\x01\
    (\tR\x08address1B\0\x12\x1c\n\x08address2\x18\n\x20\x01(\tR\x08address2B\
    \0\x12\x14\n\x04city\x18\x0b\x20\x01(\tR\x04cityB\0\x12\x16\n\x05state\
    \x18\x0c\x20\x01(\tR\x05stateB\0\x12\x16\n\x05phone\x18\r\x20\x01(\tR\
    \x05phoneB\0:\0\"\xa0\x02\n\x1dExternalPaypalInstrumentProto\x12&\n\rins\
    trumentKey\x18\x01\x20\x01(\tR\rinstrumentKeyB\0\x12(\n\x0epreapprovalKe\
    y\x18\x02\x20\x01(\tR\x0epreapprovalKeyB\0\x12\"\n\x0bpaypalEmail\x18\
    \x03\x20\x01(\tR\x0bpaypalEmailB\0\x125\n\rpaypalAddress\x18\x04\x20\x01\
    (\x0b2\r.AddressProtoR\rpaypalAddressB\0\x12P\n\"multiplePaypalInstrumen\
    tsSupported\x18\x05\x20\x01(\x08R\"multiplePaypalInstrumentsSupportedB\0\
    :\0\"\x91\x01\n\x11FileMetadataProto\x12\x1c\n\x08fileType\x18\x01\x20\
    \x01(\x05R\x08fileTypeB\0\x12\"\n\x0bversionCode\x18\x02\x20\x01(\x05R\
    \x0bversionCodeB\0\x12\x14\n\x04size\x18\x03\x20\x01(\x03R\x04sizeB\0\
    \x12\"\n\x0bdownloadUrl\x18\x04\x20\x01(\tR\x0bdownloadUrlB\0:\0\"w\n\
    \x1dGetAddressSnippetRequestProto\x12T\n\x17encryptedSubscriberInfo\x18\
    \x01\x20\x01(\x0b2\x18.EncryptedSubscriberInfoR\x17encryptedSubscriberIn\
    foB\0:\0\"L\n\x1eGetAddressSnippetResponseProto\x12(\n\x0eaddressSnippet\
    \x18\x01\x20\x01(\tR\x0eaddressSnippetB\0:\0\"d\n\x14GetAssetRequestProt\
    o\x12\x1a\n\x07assetId\x18\x01\x20\x01(\tR\x07assetIdB\0\x12.\n\x11direc\
    tDownloadKey\x18\x02\x20\x01(\tR\x11directDownloadKeyB\0:\0\"\xf5\x05\n\
    \x15GetAssetResponseProto\x12I\n\x0cinstallasset\x18\x01\x20\x01(\n2#.Ge\
    tAssetResponseProto.InstallAssetR\x0cinstallassetB\0\x12<\n\x0eadditiona\
    lFile\x18\x0f\x20\x03(\x0b2\x12.FileMetadataProtoR\x0eadditionalFileB\0\
    \x1a\xd0\x04\n\x0cInstallAsset\x12\x1a\n\x07assetId\x18\x02\x20\x01(\tR\
    \x07assetIdB\0\x12\x1e\n\tassetName\x18\x03\x20\x01(\tR\tassetNameB\0\
    \x12\x1e\n\tassetType\x18\x04\x20\x01(\tR\tassetTypeB\0\x12$\n\x0cassetP\
    ackage\x18\x05\x20\x01(\tR\x0cassetPackageB\0\x12\x1a\n\x07blobUrl\x18\
    \x06\x20\x01(\tR\x07blobUrlB\0\x12(\n\x0eassetSignature\x18\x07\x20\x01(\
    \tR\x0eassetSignatureB\0\x12\x1e\n\tassetSize\x18\x08\x20\x01(\x03R\tass\
    etSizeB\0\x122\n\x13refundTimeoutMillis\x18\t\x20\x01(\x03R\x13refundTim\
    eoutMillisB\0\x12&\n\rforwardLocked\x18\n\x20\x01(\x08R\rforwardLockedB\
    \0\x12\x1a\n\x07secured\x18\x0b\x20\x01(\x08R\x07securedB\0\x12\"\n\x0bv\
    ersionCode\x18\x0c\x20\x01(\x05R\x0bversionCodeB\0\x128\n\x16downloadAut\
    hCookieName\x18\r\x20\x01(\tR\x16downloadAuthCookieNameB\0\x12:\n\x17dow\
    nloadAuthCookieValue\x18\x0e\x20\x01(\tR\x17downloadAuthCookieValueB\0\
    \x12F\n\x1dpostInstallRefundWindowMillis\x18\x10\x20\x01(\x03R\x1dpostIn\
    stallRefundWindowMillisB\0:\0\"\x1e\n\x1aGetCarrierInfoRequestProto:\0\"\
    \xb1\x02\n\x1bGetCarrierInfoResponseProto\x126\n\x15carrierChannelEnable\
    d\x18\x01\x20\x01(\x08R\x15carrierChannelEnabledB\0\x12*\n\x0fcarrierLog\
    oIcon\x18\x02\x20\x01(\x0cR\x0fcarrierLogoIconB\0\x12&\n\rcarrierBanner\
    \x18\x03\x20\x01(\x0cR\rcarrierBannerB\0\x12*\n\x0fcarrierSubtitle\x18\
    \x04\x20\x01(\tR\x0fcarrierSubtitleB\0\x12$\n\x0ccarrierTitle\x18\x05\
    \x20\x01(\tR\x0ccarrierTitleB\0\x122\n\x13carrierImageDensity\x18\x06\
    \x20\x01(\x05R\x13carrierImageDensityB\0:\0\"M\n\x19GetCategoriesRequest\
    Proto\x12.\n\x11prefetchPromoData\x18\x01\x20\x01(\x08R\x11prefetchPromo\
    DataB\0:\0\"P\n\x1aGetCategoriesResponseProto\x120\n\ncategories\x18\x01\
    \x20\x03(\x0b2\x0e.CategoryProtoR\ncategoriesB\0:\0\"\xb8\x02\n\x14GetIm\
    ageRequestProto\x12\x1a\n\x07assetId\x18\x01\x20\x01(\tR\x07assetIdB\0\
    \x12\x20\n\nimageUsage\x18\x03\x20\x01(\x05R\nimageUsageB\0\x12\x1a\n\
    \x07imageId\x18\x04\x20\x01(\tR\x07imageIdB\0\x122\n\x13screenPropertyWi\
    dth\x18\x05\x20\x01(\x05R\x13screenPropertyWidthB\0\x124\n\x14screenProp\
    ertyHeight\x18\x06\x20\x01(\x05R\x14screenPropertyHeightB\0\x126\n\x15sc\
    reenPropertyDensity\x18\x07\x20\x01(\x05R\x15screenPropertyDensityB\0\
    \x12\"\n\x0bproductType\x18\x08\x20\x01(\x05R\x0bproductTypeB\0:\0\"_\n\
    \x15GetImageResponseProto\x12\x1e\n\timageData\x18\x01\x20\x01(\x0cR\tim\
    ageDataB\0\x12$\n\x0cimageDensity\x18\x02\x20\x01(\x05R\x0cimageDensityB\
    \0:\0\"\x86\x03\n\x1dGetMarketMetadataRequestProto\x12*\n\x0flastRequest\
    Time\x18\x01\x20\x01(\x03R\x0flastRequestTimeB\0\x12M\n\x13deviceConfigu\
    ration\x18\x02\x20\x01(\x0b2\x19.DeviceConfigurationProtoR\x13deviceConf\
    igurationB\0\x12&\n\rdeviceRoaming\x18\x03\x20\x01(\x08R\rdeviceRoamingB\
    \0\x122\n\x13marketSignatureHash\x18\x04\x20\x03(\tR\x13marketSignatureH\
    ashB\0\x12&\n\rcontentRating\x18\x05\x20\x01(\x05R\rcontentRatingB\0\x12\
    *\n\x0fdeviceModelName\x18\x06\x20\x01(\tR\x0fdeviceModelNameB\0\x128\n\
    \x16deviceManufacturerName\x18\x07\x20\x01(\tR\x16deviceManufacturerName\
    B\0:\0\"\x82\x04\n\x1eGetMarketMetadataResponseProto\x12:\n\x17latestCli\
    entVersionCode\x18\x01\x20\x01(\x05R\x17latestClientVersionCodeB\0\x12*\
    \n\x0flatestClientUrl\x18\x02\x20\x01(\tR\x0flatestClientUrlB\0\x12*\n\
    \x0fpaidAppsEnabled\x18\x03\x20\x01(\x08R\x0fpaidAppsEnabledB\0\x12D\n\
    \x10billingParameter\x18\x04\x20\x03(\x0b2\x16.BillingParameterProtoR\
    \x10billingParameterB\0\x120\n\x12commentPostEnabled\x18\x05\x20\x01(\
    \x08R\x12commentPostEnabledB\0\x124\n\x14billingEventsEnabled\x18\x06\
    \x20\x01(\x08R\x14billingEventsEnabledB\0\x12(\n\x0ewarningMessage\x18\
    \x07\x20\x01(\tR\x0ewarningMessageB\0\x122\n\x13inAppBillingEnabled\x18\
    \x08\x20\x01(\x08R\x13inAppBillingEnabledB\0\x12>\n\x19inAppBillingMaxAp\
    iVersion\x18\t\x20\x01(\x05R\x19inAppBillingMaxApiVersionB\0:\0\"@\n\x1c\
    GetSubCategoriesRequestProto\x12\x1e\n\tassetType\x18\x01\x20\x01(\x05R\
    \tassetTypeB\0:\0\"\xda\x01\n\x1dGetSubCategoriesResponseProto\x12N\n\
    \x0bsubcategory\x18\x01\x20\x03(\n2*.GetSubCategoriesResponseProto.SubCa\
    tegoryR\x0bsubcategoryB\0\x1ag\n\x0bSubCategory\x120\n\x12subCategoryDis\
    play\x18\x02\x20\x01(\tR\x12subCategoryDisplayB\0\x12&\n\rsubCategoryId\
    \x18\x03\x20\x01(\tR\rsubCategoryIdB\0:\0\"\x89\x02\n$InAppPurchaseInfor\
    mationRequestProto\x12;\n\rsignatureHash\x18\x01\x20\x01(\x0b2\x13.Signa\
    tureHashProtoR\rsignatureHashB\0\x12\x16\n\x05nonce\x18\x02\x20\x01(\x03\
    R\x05nonceB\0\x12(\n\x0enotificationId\x18\x03\x20\x03(\tR\x0enotificati\
    onIdB\0\x120\n\x12signatureAlgorithm\x18\x04\x20\x01(\tR\x12signatureAlg\
    orithmB\0\x12.\n\x11billingApiVersion\x18\x05\x20\x01(\x05R\x11billingAp\
    iVersionB\0:\0\"\xfa\x01\n%InAppPurchaseInformationResponseProto\x12:\n\
    \x0esignedResponse\x18\x01\x20\x01(\x0b2\x10.SignedDataProtoR\x0esignedR\
    esponseB\0\x12S\n\x15statusBarNotification\x18\x02\x20\x03(\x0b2\x1b.Sta\
    tusBarNotificationProtoR\x15statusBarNotificationB\0\x12>\n\x0epurchaseR\
    esult\x18\x03\x20\x01(\x0b2\x14.PurchaseResultProtoR\x0epurchaseResultB\
    \0:\0\"\xdf\x01\n$InAppRestoreTransactionsRequestProto\x12;\n\rsignature\
    Hash\x18\x01\x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHashB\0\x12\
    \x16\n\x05nonce\x18\x02\x20\x01(\x03R\x05nonceB\0\x120\n\x12signatureAlg\
    orithm\x18\x03\x20\x01(\tR\x12signatureAlgorithmB\0\x12.\n\x11billingApi\
    Version\x18\x04\x20\x01(\x05R\x11billingApiVersionB\0:\0\"\xa5\x01\n%InA\
    ppRestoreTransactionsResponseProto\x12:\n\x0esignedResponse\x18\x01\x20\
    \x01(\x0b2\x10.SignedDataProtoR\x0esignedResponseB\0\x12>\n\x0epurchaseR\
    esult\x18\x02\x20\x01(\x0b2\x14.PurchaseResultProtoR\x0epurchaseResultB\
    \0:\0\"\x9a\x02\n\x19ModifyCommentRequestProto\x12\x1a\n\x07assetId\x18\
    \x01\x20\x01(\tR\x07assetIdB\0\x121\n\x07comment\x18\x02\x20\x01(\x0b2\
    \x15.ExternalCommentProtoR\x07commentB\0\x12&\n\rdeleteComment\x18\x03\
    \x20\x01(\x08R\rdeleteCommentB\0\x12\x1e\n\tflagAsset\x18\x04\x20\x01(\
    \x08R\tflagAssetB\0\x12\x1c\n\x08flagType\x18\x05\x20\x01(\x05R\x08flagT\
    ypeB\0\x12\"\n\x0bflagMessage\x18\x06\x20\x01(\tR\x0bflagMessageB\0\x12\
    \"\n\x0bnonFlagFlow\x18\x07\x20\x01(\x08R\x0bnonFlagFlowB\0:\0\"\x1e\n\
    \x1aModifyCommentResponseProto:\0\"\xbe\x01\n\x16PaypalCountryInfoProto\
    \x12.\n\x11birthDateRequired\x18\x01\x20\x01(\x08R\x11birthDateRequiredB\
    \0\x12\x1a\n\x07tosText\x18\x02\x20\x01(\tR\x07tosTextB\0\x124\n\x14bill\
    ingAgreementText\x18\x03\x20\x01(\tR\x14billingAgreementTextB\0\x12\x20\
    \n\npreTosText\x18\x04\x20\x01(\tR\npreTosTextB\0:\0\"\xac\x01\n\x1fPayp\
    alCreateAccountRequestProto\x12\x1e\n\tfirstName\x18\x01\x20\x01(\tR\tfi\
    rstNameB\0\x12\x1c\n\x08lastName\x18\x02\x20\x01(\tR\x08lastNameB\0\x12)\
    \n\x07address\x18\x03\x20\x01(\x0b2\r.AddressProtoR\x07addressB\0\x12\
    \x1e\n\tbirthDate\x18\x04\x20\x01(\tR\tbirthDateB\0:\0\"R\n\x20PaypalCre\
    ateAccountResponseProto\x12,\n\x10createAccountKey\x18\x01\x20\x01(\tR\
    \x10createAccountKeyB\0:\0\"h\n\x16PaypalCredentialsProto\x12(\n\x0eprea\
    pprovalKey\x18\x01\x20\x01(\tR\x0epreapprovalKeyB\0\x12\"\n\x0bpaypalEma\
    il\x18\x02\x20\x01(\tR\x0bpaypalEmailB\0:\0\"O\n\x20PaypalMassageAddress\
    RequestProto\x12)\n\x07address\x18\x01\x20\x01(\x0b2\r.AddressProtoR\x07\
    addressB\0:\0\"P\n!PaypalMassageAddressResponseProto\x12)\n\x07address\
    \x18\x01\x20\x01(\x0b2\r.AddressProtoR\x07addressB\0:\0\"\x88\x01\n(Payp\
    alPreapprovalCredentialsRequestProto\x12&\n\rgaiaAuthToken\x18\x01\x20\
    \x01(\tR\rgaiaAuthTokenB\0\x122\n\x13billingInstrumentId\x18\x02\x20\x01\
    (\tR\x13billingInstrumentIdB\0:\0\"\xa1\x01\n)PaypalPreapprovalCredentia\
    lsResponseProto\x12\x20\n\nresultCode\x18\x01\x20\x01(\x05R\nresultCodeB\
    \0\x12,\n\x10paypalAccountKey\x18\x02\x20\x01(\tR\x10paypalAccountKeyB\0\
    \x12\"\n\x0bpaypalEmail\x18\x03\x20\x01(\tR\x0bpaypalEmailB\0:\0\"t\n$Pa\
    ypalPreapprovalDetailsRequestProto\x12\x20\n\ngetAddress\x18\x01\x20\x01\
    (\x08R\ngetAddressB\0\x12(\n\x0epreapprovalKey\x18\x02\x20\x01(\tR\x0epr\
    eapprovalKeyB\0:\0\"x\n%PaypalPreapprovalDetailsResponseProto\x12\"\n\
    \x0bpaypalEmail\x18\x01\x20\x01(\tR\x0bpaypalEmailB\0\x12)\n\x07address\
    \x18\x02\x20\x01(\x0b2\r.AddressProtoR\x07addressB\0:\0\"!\n\x1dPaypalPr\
    eapprovalRequestProto:\0\"L\n\x1ePaypalPreapprovalResponseProto\x12(\n\
    \x0epreapprovalKey\x18\x01\x20\x01(\tR\x0epreapprovalKeyB\0:\0\"\x82\x01\
    \n\x19PendingNotificationsProto\x127\n\x0cnotification\x18\x01\x20\x03(\
    \x0b2\x11.DataMessageProtoR\x0cnotificationB\0\x12*\n\x0fnextCheckMillis\
    \x18\x02\x20\x01(\x03R\x0fnextCheckMillisB\0:\0\"~\n\x15PrefetchedBundle\
    Proto\x12/\n\x07request\x18\x01\x20\x01(\x0b2\x13.SingleRequestProtoR\
    \x07requestB\0\x122\n\x08response\x18\x02\x20\x01(\x0b2\x14.SingleRespon\
    seProtoR\x08responseB\0:\0\"\xb3\x02\n\x15PurchaseCartInfoProto\x12\x1e\
    \n\titemPrice\x18\x01\x20\x01(\tR\titemPriceB\0\x12$\n\x0ctaxInclusive\
    \x18\x02\x20\x01(\tR\x0ctaxInclusiveB\0\x12$\n\x0ctaxExclusive\x18\x03\
    \x20\x01(\tR\x0ctaxExclusiveB\0\x12\x16\n\x05total\x18\x04\x20\x01(\tR\
    \x05totalB\0\x12\x20\n\ntaxMessage\x18\x05\x20\x01(\tR\ntaxMessageB\0\
    \x12&\n\rfooterMessage\x18\x06\x20\x01(\tR\rfooterMessageB\0\x12&\n\rpri\
    ceCurrency\x18\x07\x20\x01(\tR\rpriceCurrencyB\0\x12\"\n\x0bpriceMicros\
    \x18\x08\x20\x01(\x03R\x0bpriceMicrosB\0:\0\"\xcf\x04\n\x11PurchaseInfoP\
    roto\x12&\n\rtransactionId\x18\x01\x20\x01(\tR\rtransactionIdB\0\x124\n\
    \x08cartInfo\x18\x02\x20\x01(\x0b2\x16.PurchaseCartInfoProtoR\x08cartInf\
    oB\0\x12W\n\x12billinginstruments\x18\x03\x20\x01(\n2%.PurchaseInfoProto\
    .BillingInstrumentsR\x12billinginstrumentsB\0\x12,\n\x10errorInputFields\
    \x18\t\x20\x03(\x05R\x10errorInputFieldsB\0\x12$\n\x0crefundPolicy\x18\n\
    \x20\x01(\tR\x0crefundPolicyB\0\x12&\n\ruserCanAddGdd\x18\x0c\x20\x01(\
    \x08R\ruserCanAddGddB\0\x12:\n\x17eligibleInstrumentTypes\x18\r\x20\x03(\
    \x05R\x17eligibleInstrumentTypesB\0\x12\x1a\n\x07orderId\x18\x0f\x20\x01\
    (\tR\x07orderIdB\0\x1a\xac\x01\n\x12BillingInstruments\x12T\n\x11billing\
    instrument\x18\x04\x20\x03(\n2$.PurchaseInfoProto.BillingInstrumentR\x11\
    billinginstrumentB\0\x12@\n\x1adefaultBillingInstrumentId\x18\x08\x20\
    \x01(\tR\x1adefaultBillingInstrumentIdB\0:\0\"\xaa\x01\n\x1cPurchaseMeta\
    dataRequestProto\x12P\n\"deprecatedRetrieveBillingCountries\x18\x01\x20\
    \x01(\x08R\"deprecatedRetrieveBillingCountriesB\0\x126\n\x15billingInstr\
    umentType\x18\x02\x20\x01(\x05R\x15billingInstrumentTypeB\0:\0\"\xbc\x01\
    \n\x1dPurchaseMetadataResponseProto\x12H\n\tcountries\x18\x01\x20\x01(\n\
    2(.PurchaseMetadataResponseProto.CountriesR\tcountriesB\0\x1aO\n\tCountr\
    ies\x12B\n\x07country\x18\x02\x20\x03(\n2&.PurchaseMetadataResponseProto\
    .CountryR\x07countryB\0:\0\"\xf2\x05\n\x19PurchaseOrderRequestProto\x12&\
    \n\rgaiaAuthToken\x18\x01\x20\x01(\tR\rgaiaAuthTokenB\0\x12\x1a\n\x07ass\
    etId\x18\x02\x20\x01(\tR\x07assetIdB\0\x12&\n\rtransactionId\x18\x03\x20\
    \x01(\tR\rtransactionIdB\0\x122\n\x13billingInstrumentId\x18\x04\x20\x01\
    (\tR\x13billingInstrumentIdB\0\x12\"\n\x0btosAccepted\x18\x05\x20\x01(\
    \x08R\x0btosAcceptedB\0\x12_\n\x19carrierBillingCredentials\x18\x06\x20\
    \x01(\x0b2\x1f.CarrierBillingCredentialsProtoR\x19carrierBillingCredenti\
    alsB\0\x12*\n\x0fexistingOrderId\x18\x07\x20\x01(\tR\x0fexistingOrderIdB\
    \0\x126\n\x15billingInstrumentType\x18\x08\x20\x01(\x05R\x15billingInstr\
    umentTypeB\0\x122\n\x13billingParametersId\x18\t\x20\x01(\tR\x13billingP\
    arametersIdB\0\x12G\n\x11paypalCredentials\x18\n\x20\x01(\x0b2\x17.Paypa\
    lCredentialsProtoR\x11paypalCredentialsB\0\x12>\n\x0eriskHeaderInfo\x18\
    \x0b\x20\x01(\x0b2\x14.RiskHeaderInfoProtoR\x0eriskHeaderInfoB\0\x12\"\n\
    \x0bproductType\x18\x0c\x20\x01(\x05R\x0bproductTypeB\0\x12;\n\rsignatur\
    eHash\x18\r\x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHashB\0\x12,\
    \n\x10developerPayload\x18\x0e\x20\x01(\tR\x10developerPayloadB\0:\0\"\
    \xfb\x01\n\x1aPurchaseOrderResponseProto\x124\n\x14deprecatedResultCode\
    \x18\x01\x20\x01(\x05R\x14deprecatedResultCodeB\0\x128\n\x0cpurchaseInfo\
    \x18\x02\x20\x01(\x0b2\x12.PurchaseInfoProtoR\x0cpurchaseInfoB\0\x12+\n\
    \x05asset\x18\x03\x20\x01(\x0b2\x13.ExternalAssetProtoR\x05assetB\0\x12>\
    \n\x0epurchaseResult\x18\x04\x20\x01(\x0b2\x14.PurchaseResultProtoR\x0ep\
    urchaseResultB\0:\0\"\x81\x06\n\x18PurchasePostRequestProto\x12&\n\rgaia\
    AuthToken\x18\x01\x20\x01(\tR\rgaiaAuthTokenB\0\x12\x1a\n\x07assetId\x18\
    \x02\x20\x01(\tR\x07assetIdB\0\x12&\n\rtransactionId\x18\x03\x20\x01(\tR\
    \rtransactionIdB\0\x12g\n\x15billinginstrumentinfo\x18\x04\x20\x01(\n2/.\
    PurchasePostRequestProto.BillingInstrumentInfoR\x15billinginstrumentinfo\
    B\0\x12\"\n\x0btosAccepted\x18\x07\x20\x01(\x08R\x0btosAcceptedB\0\x12*\
    \n\x0fcbInstrumentKey\x18\x08\x20\x01(\tR\x0fcbInstrumentKeyB\0\x122\n\
    \x13paypalAuthConfirmed\x18\x0b\x20\x01(\x08R\x13paypalAuthConfirmedB\0\
    \x12\"\n\x0bproductType\x18\x0c\x20\x01(\x05R\x0bproductTypeB\0\x12;\n\r\
    signatureHash\x18\r\x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHash\
    B\0\x1a\xa8\x02\n\x15BillingInstrumentInfo\x122\n\x13billingInstrumentId\
    \x18\x05\x20\x01(\tR\x13billingInstrumentIdB\0\x125\n\ncreditCard\x18\
    \x06\x20\x01(\x0b2\x13.ExternalCreditCardR\ncreditCardB\0\x12V\n\x11carr\
    ierInstrument\x18\t\x20\x01(\x0b2&.ExternalCarrierBillingInstrumentProto\
    R\x11carrierInstrumentB\0\x12L\n\x10paypalInstrument\x18\n\x20\x01(\x0b2\
    \x1e.ExternalPaypalInstrumentProtoR\x10paypalInstrumentB\0:\0\"\xe1\x03\
    \n\x19PurchasePostResponseProto\x124\n\x14deprecatedResultCode\x18\x01\
    \x20\x01(\x05R\x14deprecatedResultCodeB\0\x128\n\x0cpurchaseInfo\x18\x02\
    \x20\x01(\x0b2\x12.PurchaseInfoProtoR\x0cpurchaseInfoB\0\x12.\n\x11terms\
    OfServiceUrl\x18\x03\x20\x01(\tR\x11termsOfServiceUrlB\0\x120\n\x12terms\
    OfServiceText\x18\x04\x20\x01(\tR\x12termsOfServiceTextB\0\x120\n\x12ter\
    msOfServiceName\x18\x05\x20\x01(\tR\x12termsOfServiceNameB\0\x12@\n\x1at\
    ermsOfServiceCheckboxText\x18\x06\x20\x01(\tR\x1atermsOfServiceCheckboxT\
    extB\0\x12<\n\x18termsOfServiceHeaderText\x18\x07\x20\x01(\tR\x18termsOf\
    ServiceHeaderTextB\0\x12>\n\x0epurchaseResult\x18\x08\x20\x01(\x0b2\x14.\
    PurchaseResultProtoR\x0epurchaseResultB\0:\0\"\xa0\x01\n\x1bPurchaseProd\
    uctRequestProto\x12\"\n\x0bproductType\x18\x01\x20\x01(\x05R\x0bproductT\
    ypeB\0\x12\x1e\n\tproductId\x18\x02\x20\x01(\tR\tproductIdB\0\x12;\n\rsi\
    gnatureHash\x18\x03\x20\x01(\x0b2\x13.SignatureHashProtoR\rsignatureHash\
    B\0:\0\"\xac\x01\n\x1cPurchaseProductResponseProto\x12\x16\n\x05title\
    \x18\x01\x20\x01(\tR\x05titleB\0\x12\x1e\n\titemTitle\x18\x02\x20\x01(\t\
    R\titemTitleB\0\x12*\n\x0fitemDescription\x18\x03\x20\x01(\tR\x0fitemDes\
    criptionB\0\x12&\n\rmerchantField\x18\x04\x20\x01(\tR\rmerchantFieldB\0:\
    \0\"i\n\x13PurchaseResultProto\x12\x20\n\nresultCode\x18\x01\x20\x01(\
    \x05R\nresultCodeB\0\x12.\n\x11resultCodeMessage\x18\x02\x20\x01(\tR\x11\
    resultCodeMessageB\0:\0\"\x88\x01\n\x14QuerySuggestionProto\x12\x16\n\
    \x05query\x18\x01\x20\x01(\tR\x05queryB\0\x122\n\x13estimatedNumResults\
    \x18\x02\x20\x01(\x05R\x13estimatedNumResultsB\0\x12\"\n\x0bqueryWeight\
    \x18\x03\x20\x01(\x05R\x0bqueryWeightB\0:\0\"[\n\x1bQuerySuggestionReque\
    stProto\x12\x16\n\x05query\x18\x01\x20\x01(\tR\x05queryB\0\x12\"\n\x0bre\
    questType\x18\x02\x20\x01(\x05R\x0brequestTypeB\0:\0\"\x83\x03\n\x1cQuer\
    ySuggestionResponseProto\x12J\n\nsuggestion\x18\x01\x20\x03(\n2(.QuerySu\
    ggestionResponseProto.SuggestionR\nsuggestionB\0\x12@\n\x1aestimatedNumA\
    ppSuggestions\x18\x04\x20\x01(\x05R\x1aestimatedNumAppSuggestionsB\0\x12\
    D\n\x1cestimatedNumQuerySuggestions\x18\x05\x20\x01(\x05R\x1cestimatedNu\
    mQuerySuggestionsB\0\x1a\x8c\x01\n\nSuggestion\x12;\n\rappSuggestion\x18\
    \x02\x20\x01(\x0b2\x13.AppSuggestionProtoR\rappSuggestionB\0\x12A\n\x0fq\
    uerySuggestion\x18\x03\x20\x01(\x0b2\x15.QuerySuggestionProtoR\x0fqueryS\
    uggestionB\0:\0\"\x7f\n\x17RateCommentRequestProto\x12\x1a\n\x07assetId\
    \x18\x01\x20\x01(\tR\x07assetIdB\0\x12\x1e\n\tcreatorId\x18\x02\x20\x01(\
    \tR\tcreatorIdB\0\x12&\n\rcommentRating\x18\x03\x20\x01(\x05R\rcommentRa\
    tingB\0:\0\"\x1c\n\x18RateCommentResponseProto:\0\"W\n\x1fReconstructDat\
    abaseRequestProto\x122\n\x13retrieveFullHistory\x18\x01\x20\x01(\x08R\
    \x13retrieveFullHistoryB\0:\0\"S\n\x20ReconstructDatabaseResponseProto\
    \x12-\n\x05asset\x18\x01\x20\x03(\x0b2\x15.AssetIdentifierProtoR\x05asse\
    tB\0:\0\"2\n\x12RefundRequestProto\x12\x1a\n\x07assetId\x18\x01\x20\x01(\
    \tR\x07assetIdB\0:\0\"\x84\x01\n\x13RefundResponseProto\x12\x18\n\x06res\
    ult\x18\x01\x20\x01(\x05R\x06resultB\0\x12+\n\x05asset\x18\x02\x20\x01(\
    \x0b2\x13.ExternalAssetProtoR\x05assetB\0\x12$\n\x0cresultDetail\x18\x03\
    \x20\x01(\tR\x0cresultDetailB\0:\0\"7\n\x17RemoveAssetRequestProto\x12\
    \x1a\n\x07assetId\x18\x01\x20\x01(\tR\x07assetIdB\0:\0\"\xb6\x04\n\x16Re\
    questPropertiesProto\x12&\n\ruserAuthToken\x18\x01\x20\x01(\tR\ruserAuth\
    TokenB\0\x122\n\x13userAuthTokenSecure\x18\x02\x20\x01(\x08R\x13userAuth\
    TokenSecureB\0\x12*\n\x0fsoftwareVersion\x18\x03\x20\x01(\x05R\x0fsoftwa\
    reVersionB\0\x12\x12\n\x03aid\x18\x04\x20\x01(\tR\x03aidB\0\x126\n\x15pr\
    oductNameAndVersion\x18\x05\x20\x01(\tR\x15productNameAndVersionB\0\x12$\
    \n\x0cuserLanguage\x18\x06\x20\x01(\tR\x0cuserLanguageB\0\x12\"\n\x0buse\
    rCountry\x18\x07\x20\x01(\tR\x0buserCountryB\0\x12$\n\x0coperatorName\
    \x18\x08\x20\x01(\tR\x0coperatorNameB\0\x12*\n\x0fsimOperatorName\x18\t\
    \x20\x01(\tR\x0fsimOperatorNameB\0\x122\n\x13operatorNumericName\x18\n\
    \x20\x01(\tR\x13operatorNumericNameB\0\x128\n\x16simOperatorNumericName\
    \x18\x0b\x20\x01(\tR\x16simOperatorNumericNameB\0\x12\x1c\n\x08clientId\
    \x18\x0c\x20\x01(\tR\x08clientIdB\0\x12\x1e\n\tloggingId\x18\r\x20\x01(\
    \tR\tloggingIdB\0:\0\"\xd8\x18\n\x0cRequestProto\x12G\n\x11requestProper\
    ties\x18\x01\x20\x01(\x0b2\x17.RequestPropertiesProtoR\x11requestPropert\
    iesB\0\x121\n\x07request\x18\x02\x20\x03(\n2\x15.RequestProto.RequestR\
    \x07requestB\0\x1a\xc9\x17\n\x07Request\x12_\n\x19requestSpecificPropert\
    ies\x18\x03\x20\x01(\x0b2\x1f.RequestSpecificPropertiesProtoR\x19request\
    SpecificPropertiesB\0\x129\n\x0cassetRequest\x18\x04\x20\x01(\x0b2\x13.A\
    ssetsRequestProtoR\x0cassetRequestB\0\x12A\n\x0fcommentsRequest\x18\x05\
    \x20\x01(\x0b2\x15.CommentsRequestProtoR\x0fcommentsRequestB\0\x12P\n\
    \x14modifyCommentRequest\x18\x06\x20\x01(\x0b2\x1a.ModifyCommentRequestP\
    rotoR\x14modifyCommentRequestB\0\x12M\n\x13purchasePostRequest\x18\x07\
    \x20\x01(\x0b2\x19.PurchasePostRequestProtoR\x13purchasePostRequestB\0\
    \x12P\n\x14purchaseOrderRequest\x18\x08\x20\x01(\x0b2\x1a.PurchaseOrderR\
    equestProtoR\x14purchaseOrderRequestB\0\x12J\n\x12contentSyncRequest\x18\
    \t\x20\x01(\x0b2\x18.ContentSyncRequestProtoR\x12contentSyncRequestB\0\
    \x12A\n\x0fgetAssetRequest\x18\n\x20\x01(\x0b2\x15.GetAssetRequestProtoR\
    \x0fgetAssetRequestB\0\x12A\n\x0fgetImageRequest\x18\x0b\x20\x01(\x0b2\
    \x15.GetImageRequestProtoR\x0fgetImageRequestB\0\x12;\n\rrefundRequest\
    \x18\x0c\x20\x01(\x0b2\x13.RefundRequestProtoR\rrefundRequestB\0\x12Y\n\
    \x17purchaseMetadataRequest\x18\r\x20\x01(\x0b2\x1d.PurchaseMetadataRequ\
    estProtoR\x17purchaseMetadataRequestB\0\x12S\n\x14subCategoriesRequest\
    \x18\x0e\x20\x01(\x0b2\x1d.GetSubCategoriesRequestProtoR\x14subCategorie\
    sRequestB\0\x12V\n\x16uninstallReasonRequest\x18\x10\x20\x01(\x0b2\x1c.U\
    ninstallReasonRequestProtoR\x16uninstallReasonRequestB\0\x12J\n\x12rateC\
    ommentRequest\x18\x11\x20\x01(\x0b2\x18.RateCommentRequestProtoR\x12rate\
    CommentRequestB\0\x12M\n\x13checkLicenseRequest\x18\x12\x20\x01(\x0b2\
    \x19.CheckLicenseRequestProtoR\x13checkLicenseRequestB\0\x12\\\n\x18getM\
    arketMetadataRequest\x18\x13\x20\x01(\x0b2\x1e.GetMarketMetadataRequestP\
    rotoR\x18getMarketMetadataRequestB\0\x12P\n\x14getCategoriesRequest\x18\
    \x15\x20\x01(\x0b2\x1a.GetCategoriesRequestProtoR\x14getCategoriesReques\
    tB\0\x12S\n\x15getCarrierInfoRequest\x18\x16\x20\x01(\x0b2\x1b.GetCarrie\
    rInfoRequestProtoR\x15getCarrierInfoRequestB\0\x12J\n\x12removeAssetRequ\
    est\x18\x17\x20\x01(\x0b2\x18.RemoveAssetRequestProtoR\x12removeAssetReq\
    uestB\0\x12b\n\x1arestoreApplicationsRequest\x18\x18\x20\x01(\x0b2\x20.R\
    estoreApplicationsRequestProtoR\x1arestoreApplicationsRequestB\0\x12V\n\
    \x16querySuggestionRequest\x18\x19\x20\x01(\x0b2\x1c.QuerySuggestionRequ\
    estProtoR\x16querySuggestionRequestB\0\x12M\n\x13billingEventRequest\x18\
    \x1a\x20\x01(\x0b2\x19.BillingEventRequestProtoR\x13billingEventRequestB\
    \0\x12\\\n\x18paypalPreapprovalRequest\x18\x1b\x20\x01(\x0b2\x1e.PaypalP\
    reapprovalRequestProtoR\x18paypalPreapprovalRequestB\0\x12q\n\x1fpaypalP\
    reapprovalDetailsRequest\x18\x1c\x20\x01(\x0b2%.PaypalPreapprovalDetails\
    RequestProtoR\x1fpaypalPreapprovalDetailsRequestB\0\x12b\n\x1apaypalCrea\
    teAccountRequest\x18\x1d\x20\x01(\x0b2\x20.PaypalCreateAccountRequestPro\
    toR\x1apaypalCreateAccountRequestB\0\x12}\n#paypalPreapprovalCredentials\
    Request\x18\x1e\x20\x01(\x0b2).PaypalPreapprovalCredentialsRequestProtoR\
    #paypalPreapprovalCredentialsRequestB\0\x12q\n\x1finAppRestoreTransactio\
    nsRequest\x18\x1f\x20\x01(\x0b2%.InAppRestoreTransactionsRequestProtoR\
    \x1finAppRestoreTransactionsRequestB\0\x12q\n\x1finAppPurchaseInformatio\
    nRequest\x18\x20\x20\x01(\x0b2%.InAppPurchaseInformationRequestProtoR\
    \x1finAppPurchaseInformationRequestB\0\x12h\n\x1ccheckForNotificationsRe\
    quest\x18!\x20\x01(\x0b2\".CheckForNotificationsRequestProtoR\x1ccheckFo\
    rNotificationsRequestB\0\x12Y\n\x17ackNotificationsRequest\x18\"\x20\x01\
    (\x0b2\x1d.AckNotificationsRequestProtoR\x17ackNotificationsRequestB\0\
    \x12V\n\x16purchaseProductRequest\x18#\x20\x01(\x0b2\x1c.PurchaseProduct\
    RequestProtoR\x16purchaseProductRequestB\0\x12b\n\x1areconstructDatabase\
    Request\x18$\x20\x01(\x0b2\x20.ReconstructDatabaseRequestProtoR\x1arecon\
    structDatabaseRequestB\0\x12e\n\x1bpaypalMassageAddressRequest\x18%\x20\
    \x01(\x0b2!.PaypalMassageAddressRequestProtoR\x1bpaypalMassageAddressReq\
    uestB\0\x12\\\n\x18getAddressSnippetRequest\x18&\x20\x01(\x0b2\x1e.GetAd\
    dressSnippetRequestProtoR\x18getAddressSnippetRequestB\0:\0\"F\n\x1eRequ\
    estSpecificPropertiesProto\x12\"\n\x0bifNoneMatch\x18\x01\x20\x01(\tR\
    \x0bifNoneMatchB\0:\0\"\xa4\x02\n\x17ResponsePropertiesProto\x12\x18\n\
    \x06result\x18\x01\x20\x01(\x05R\x06resultB\0\x12\x18\n\x06maxAge\x18\
    \x02\x20\x01(\x05R\x06maxAgeB\0\x12\x14\n\x04etag\x18\x03\x20\x01(\tR\
    \x04etagB\0\x12&\n\rserverVersion\x18\x04\x20\x01(\x05R\rserverVersionB\
    \0\x12,\n\x10maxAgeConsumable\x18\x06\x20\x01(\x05R\x10maxAgeConsumableB\
    \0\x12$\n\x0cerrorMessage\x18\x07\x20\x01(\tR\x0cerrorMessageB\0\x12A\n\
    \x0ferrorInputField\x18\x08\x20\x03(\x0b2\x15.InputValidationErrorR\x0fe\
    rrorInputFieldB\0:\0\"\xad\x19\n\rResponseProto\x125\n\x08response\x18\
    \x01\x20\x03(\n2\x17.ResponseProto.ResponseR\x08responseB\0\x12P\n\x14pe\
    ndingNotifications\x18&\x20\x01(\x0b2\x1a.PendingNotificationsProtoR\x14\
    pendingNotificationsB\0\x1a\x90\x18\n\x08Response\x12J\n\x12responseProp\
    erties\x18\x02\x20\x01(\x0b2\x18.ResponsePropertiesProtoR\x12responsePro\
    pertiesB\0\x12>\n\x0eassetsResponse\x18\x03\x20\x01(\x0b2\x14.AssetsResp\
    onseProtoR\x0eassetsResponseB\0\x12D\n\x10commentsResponse\x18\x04\x20\
    \x01(\x0b2\x16.CommentsResponseProtoR\x10commentsResponseB\0\x12S\n\x15m\
    odifyCommentResponse\x18\x05\x20\x01(\x0b2\x1b.ModifyCommentResponseProt\
    oR\x15modifyCommentResponseB\0\x12P\n\x14purchasePostResponse\x18\x06\
    \x20\x01(\x0b2\x1a.PurchasePostResponseProtoR\x14purchasePostResponseB\0\
    \x12S\n\x15purchaseOrderResponse\x18\x07\x20\x01(\x0b2\x1b.PurchaseOrder\
    ResponseProtoR\x15purchaseOrderResponseB\0\x12M\n\x13contentSyncResponse\
    \x18\x08\x20\x01(\x0b2\x19.ContentSyncResponseProtoR\x13contentSyncRespo\
    nseB\0\x12D\n\x10getAssetResponse\x18\t\x20\x01(\x0b2\x16.GetAssetRespon\
    seProtoR\x10getAssetResponseB\0\x12D\n\x10getImageResponse\x18\n\x20\x01\
    (\x0b2\x16.GetImageResponseProtoR\x10getImageResponseB\0\x12>\n\x0erefun\
    dResponse\x18\x0b\x20\x01(\x0b2\x14.RefundResponseProtoR\x0erefundRespon\
    seB\0\x12\\\n\x18purchaseMetadataResponse\x18\x0c\x20\x01(\x0b2\x1e.Purc\
    haseMetadataResponseProtoR\x18purchaseMetadataResponseB\0\x12V\n\x15subC\
    ategoriesResponse\x18\r\x20\x01(\x0b2\x1e.GetSubCategoriesResponseProtoR\
    \x15subCategoriesResponseB\0\x12Y\n\x17uninstallReasonResponse\x18\x0f\
    \x20\x01(\x0b2\x1d.UninstallReasonResponseProtoR\x17uninstallReasonRespo\
    nseB\0\x12M\n\x13rateCommentResponse\x18\x10\x20\x01(\x0b2\x19.RateComme\
    ntResponseProtoR\x13rateCommentResponseB\0\x12P\n\x14checkLicenseRespons\
    e\x18\x11\x20\x01(\x0b2\x1a.CheckLicenseResponseProtoR\x14checkLicenseRe\
    sponseB\0\x12_\n\x19getMarketMetadataResponse\x18\x12\x20\x01(\x0b2\x1f.\
    GetMarketMetadataResponseProtoR\x19getMarketMetadataResponseB\0\x12D\n\
    \x10prefetchedBundle\x18\x13\x20\x03(\x0b2\x16.PrefetchedBundleProtoR\
    \x10prefetchedBundleB\0\x12S\n\x15getCategoriesResponse\x18\x14\x20\x01(\
    \x0b2\x1b.GetCategoriesResponseProtoR\x15getCategoriesResponseB\0\x12V\n\
    \x16getCarrierInfoResponse\x18\x15\x20\x01(\x0b2\x1c.GetCarrierInfoRespo\
    nseProtoR\x16getCarrierInfoResponseB\0\x12c\n\x1arestoreApplicationRespo\
    nse\x18\x17\x20\x01(\x0b2!.RestoreApplicationsResponseProtoR\x1arestoreA\
    pplicationResponseB\0\x12Y\n\x17querySuggestionResponse\x18\x18\x20\x01(\
    \x0b2\x1d.QuerySuggestionResponseProtoR\x17querySuggestionResponseB\0\
    \x12P\n\x14billingEventResponse\x18\x19\x20\x01(\x0b2\x1a.BillingEventRe\
    sponseProtoR\x14billingEventResponseB\0\x12_\n\x19paypalPreapprovalRespo\
    nse\x18\x1a\x20\x01(\x0b2\x1f.PaypalPreapprovalResponseProtoR\x19paypalP\
    reapprovalResponseB\0\x12t\n\x20paypalPreapprovalDetailsResponse\x18\x1b\
    \x20\x01(\x0b2&.PaypalPreapprovalDetailsResponseProtoR\x20paypalPreappro\
    valDetailsResponseB\0\x12e\n\x1bpaypalCreateAccountResponse\x18\x1c\x20\
    \x01(\x0b2!.PaypalCreateAccountResponseProtoR\x1bpaypalCreateAccountResp\
    onseB\0\x12\x80\x01\n$paypalPreapprovalCredentialsResponse\x18\x1d\x20\
    \x01(\x0b2*.PaypalPreapprovalCredentialsResponseProtoR$paypalPreapproval\
    CredentialsResponseB\0\x12t\n\x20inAppRestoreTransactionsResponse\x18\
    \x1e\x20\x01(\x0b2&.InAppRestoreTransactionsResponseProtoR\x20inAppResto\
    reTransactionsResponseB\0\x12t\n\x20inAppPurchaseInformationResponse\x18\
    \x1f\x20\x01(\x0b2&.InAppPurchaseInformationResponseProtoR\x20inAppPurch\
    aseInformationResponseB\0\x12k\n\x1dcheckForNotificationsResponse\x18\
    \x20\x20\x01(\x0b2#.CheckForNotificationsResponseProtoR\x1dcheckForNotif\
    icationsResponseB\0\x12\\\n\x18ackNotificationsResponse\x18!\x20\x01(\
    \x0b2\x1e.AckNotificationsResponseProtoR\x18ackNotificationsResponseB\0\
    \x12Y\n\x17purchaseProductResponse\x18\"\x20\x01(\x0b2\x1d.PurchaseProdu\
    ctResponseProtoR\x17purchaseProductResponseB\0\x12e\n\x1breconstructData\
    baseResponse\x18#\x20\x01(\x0b2!.ReconstructDatabaseResponseProtoR\x1bre\
    constructDatabaseResponseB\0\x12h\n\x1cpaypalMassageAddressResponse\x18$\
    \x20\x01(\x0b2\".PaypalMassageAddressResponseProtoR\x1cpaypalMassageAddr\
    essResponseB\0\x12_\n\x19getAddressSnippetResponse\x18%\x20\x01(\x0b2\
    \x1f.GetAddressSnippetResponseProtoR\x19getAddressSnippetResponseB\0:\0\
    \"\xc0\x01\n\x1fRestoreApplicationsRequestProto\x12*\n\x0fbackupAndroidI\
    d\x18\x01\x20\x01(\tR\x0fbackupAndroidIdB\0\x12\x20\n\ntosVersion\x18\
    \x02\x20\x01(\tR\ntosVersionB\0\x12M\n\x13deviceConfiguration\x18\x03\
    \x20\x01(\x0b2\x19.DeviceConfigurationProtoR\x13deviceConfigurationB\0:\
    \0\"T\n\x20RestoreApplicationsResponseProto\x12.\n\x05asset\x18\x01\x20\
    \x03(\x0b2\x16.GetAssetResponseProtoR\x05assetB\0:\0\"E\n\x13RiskHeaderI\
    nfoProto\x12,\n\x10hashedDeviceInfo\x18\x01\x20\x01(\tR\x10hashedDeviceI\
    nfoB\0:\0\"t\n\x12SignatureHashProto\x12\"\n\x0bpackageName\x18\x01\x20\
    \x01(\tR\x0bpackageNameB\0\x12\"\n\x0bversionCode\x18\x02\x20\x01(\x05R\
    \x0bversionCodeB\0\x12\x14\n\x04hash\x18\x03\x20\x01(\x0cR\x04hashB\0:\0\
    \"U\n\x0fSignedDataProto\x12\x20\n\nsignedData\x18\x01\x20\x01(\tR\nsign\
    edDataB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\tR\tsignatureB\0:\0\"\
    \xdc\x17\n\x12SingleRequestProto\x12_\n\x19requestSpecificProperties\x18\
    \x03\x20\x01(\x0b2\x1f.RequestSpecificPropertiesProtoR\x19requestSpecifi\
    cPropertiesB\0\x129\n\x0cassetRequest\x18\x04\x20\x01(\x0b2\x13.AssetsRe\
    questProtoR\x0cassetRequestB\0\x12A\n\x0fcommentsRequest\x18\x05\x20\x01\
    (\x0b2\x15.CommentsRequestProtoR\x0fcommentsRequestB\0\x12P\n\x14modifyC\
    ommentRequest\x18\x06\x20\x01(\x0b2\x1a.ModifyCommentRequestProtoR\x14mo\
    difyCommentRequestB\0\x12M\n\x13purchasePostRequest\x18\x07\x20\x01(\x0b\
    2\x19.PurchasePostRequestProtoR\x13purchasePostRequestB\0\x12P\n\x14purc\
    haseOrderRequest\x18\x08\x20\x01(\x0b2\x1a.PurchaseOrderRequestProtoR\
    \x14purchaseOrderRequestB\0\x12J\n\x12contentSyncRequest\x18\t\x20\x01(\
    \x0b2\x18.ContentSyncRequestProtoR\x12contentSyncRequestB\0\x12A\n\x0fge\
    tAssetRequest\x18\n\x20\x01(\x0b2\x15.GetAssetRequestProtoR\x0fgetAssetR\
    equestB\0\x12A\n\x0fgetImageRequest\x18\x0b\x20\x01(\x0b2\x15.GetImageRe\
    questProtoR\x0fgetImageRequestB\0\x12;\n\rrefundRequest\x18\x0c\x20\x01(\
    \x0b2\x13.RefundRequestProtoR\rrefundRequestB\0\x12Y\n\x17purchaseMetada\
    taRequest\x18\r\x20\x01(\x0b2\x1d.PurchaseMetadataRequestProtoR\x17purch\
    aseMetadataRequestB\0\x12S\n\x14subCategoriesRequest\x18\x0e\x20\x01(\
    \x0b2\x1d.GetSubCategoriesRequestProtoR\x14subCategoriesRequestB\0\x12V\
    \n\x16uninstallReasonRequest\x18\x10\x20\x01(\x0b2\x1c.UninstallReasonRe\
    questProtoR\x16uninstallReasonRequestB\0\x12J\n\x12rateCommentRequest\
    \x18\x11\x20\x01(\x0b2\x18.RateCommentRequestProtoR\x12rateCommentReques\
    tB\0\x12M\n\x13checkLicenseRequest\x18\x12\x20\x01(\x0b2\x19.CheckLicens\
    eRequestProtoR\x13checkLicenseRequestB\0\x12\\\n\x18getMarketMetadataReq\
    uest\x18\x13\x20\x01(\x0b2\x1e.GetMarketMetadataRequestProtoR\x18getMark\
    etMetadataRequestB\0\x12P\n\x14getCategoriesRequest\x18\x15\x20\x01(\x0b\
    2\x1a.GetCategoriesRequestProtoR\x14getCategoriesRequestB\0\x12S\n\x15ge\
    tCarrierInfoRequest\x18\x16\x20\x01(\x0b2\x1b.GetCarrierInfoRequestProto\
    R\x15getCarrierInfoRequestB\0\x12J\n\x12removeAssetRequest\x18\x17\x20\
    \x01(\x0b2\x18.RemoveAssetRequestProtoR\x12removeAssetRequestB\0\x12b\n\
    \x1arestoreApplicationsRequest\x18\x18\x20\x01(\x0b2\x20.RestoreApplicat\
    ionsRequestProtoR\x1arestoreApplicationsRequestB\0\x12V\n\x16querySugges\
    tionRequest\x18\x19\x20\x01(\x0b2\x1c.QuerySuggestionRequestProtoR\x16qu\
    erySuggestionRequestB\0\x12M\n\x13billingEventRequest\x18\x1a\x20\x01(\
    \x0b2\x19.BillingEventRequestProtoR\x13billingEventRequestB\0\x12\\\n\
    \x18paypalPreapprovalRequest\x18\x1b\x20\x01(\x0b2\x1e.PaypalPreapproval\
    RequestProtoR\x18paypalPreapprovalRequestB\0\x12q\n\x1fpaypalPreapproval\
    DetailsRequest\x18\x1c\x20\x01(\x0b2%.PaypalPreapprovalDetailsRequestPro\
    toR\x1fpaypalPreapprovalDetailsRequestB\0\x12b\n\x1apaypalCreateAccountR\
    equest\x18\x1d\x20\x01(\x0b2\x20.PaypalCreateAccountRequestProtoR\x1apay\
    palCreateAccountRequestB\0\x12}\n#paypalPreapprovalCredentialsRequest\
    \x18\x1e\x20\x01(\x0b2).PaypalPreapprovalCredentialsRequestProtoR#paypal\
    PreapprovalCredentialsRequestB\0\x12q\n\x1finAppRestoreTransactionsReque\
    st\x18\x1f\x20\x01(\x0b2%.InAppRestoreTransactionsRequestProtoR\x1finApp\
    RestoreTransactionsRequestB\0\x12w\n\"getInAppPurchaseInformationRequest\
    \x18\x20\x20\x01(\x0b2%.InAppPurchaseInformationRequestProtoR\"getInAppP\
    urchaseInformationRequestB\0\x12h\n\x1ccheckForNotificationsRequest\x18!\
    \x20\x01(\x0b2\".CheckForNotificationsRequestProtoR\x1ccheckForNotificat\
    ionsRequestB\0\x12Y\n\x17ackNotificationsRequest\x18\"\x20\x01(\x0b2\x1d\
    .AckNotificationsRequestProtoR\x17ackNotificationsRequestB\0\x12V\n\x16p\
    urchaseProductRequest\x18#\x20\x01(\x0b2\x1c.PurchaseProductRequestProto\
    R\x16purchaseProductRequestB\0\x12b\n\x1areconstructDatabaseRequest\x18$\
    \x20\x01(\x0b2\x20.ReconstructDatabaseRequestProtoR\x1areconstructDataba\
    seRequestB\0\x12e\n\x1bpaypalMassageAddressRequest\x18%\x20\x01(\x0b2!.P\
    aypalMassageAddressRequestProtoR\x1bpaypalMassageAddressRequestB\0\x12\\\
    \n\x18getAddressSnippetRequest\x18&\x20\x01(\x0b2\x1e.GetAddressSnippetR\
    equestProtoR\x18getAddressSnippetRequestB\0:\0\"\xdd\x17\n\x13SingleResp\
    onseProto\x12J\n\x12responseProperties\x18\x02\x20\x01(\x0b2\x18.Respons\
    ePropertiesProtoR\x12responsePropertiesB\0\x12>\n\x0eassetsResponse\x18\
    \x03\x20\x01(\x0b2\x14.AssetsResponseProtoR\x0eassetsResponseB\0\x12D\n\
    \x10commentsResponse\x18\x04\x20\x01(\x0b2\x16.CommentsResponseProtoR\
    \x10commentsResponseB\0\x12S\n\x15modifyCommentResponse\x18\x05\x20\x01(\
    \x0b2\x1b.ModifyCommentResponseProtoR\x15modifyCommentResponseB\0\x12P\n\
    \x14purchasePostResponse\x18\x06\x20\x01(\x0b2\x1a.PurchasePostResponseP\
    rotoR\x14purchasePostResponseB\0\x12S\n\x15purchaseOrderResponse\x18\x07\
    \x20\x01(\x0b2\x1b.PurchaseOrderResponseProtoR\x15purchaseOrderResponseB\
    \0\x12M\n\x13contentSyncResponse\x18\x08\x20\x01(\x0b2\x19.ContentSyncRe\
    sponseProtoR\x13contentSyncResponseB\0\x12D\n\x10getAssetResponse\x18\t\
    \x20\x01(\x0b2\x16.GetAssetResponseProtoR\x10getAssetResponseB\0\x12D\n\
    \x10getImageResponse\x18\n\x20\x01(\x0b2\x16.GetImageResponseProtoR\x10g\
    etImageResponseB\0\x12>\n\x0erefundResponse\x18\x0b\x20\x01(\x0b2\x14.Re\
    fundResponseProtoR\x0erefundResponseB\0\x12\\\n\x18purchaseMetadataRespo\
    nse\x18\x0c\x20\x01(\x0b2\x1e.PurchaseMetadataResponseProtoR\x18purchase\
    MetadataResponseB\0\x12V\n\x15subCategoriesResponse\x18\r\x20\x01(\x0b2\
    \x1e.GetSubCategoriesResponseProtoR\x15subCategoriesResponseB\0\x12Y\n\
    \x17uninstallReasonResponse\x18\x0f\x20\x01(\x0b2\x1d.UninstallReasonRes\
    ponseProtoR\x17uninstallReasonResponseB\0\x12M\n\x13rateCommentResponse\
    \x18\x10\x20\x01(\x0b2\x19.RateCommentResponseProtoR\x13rateCommentRespo\
    nseB\0\x12P\n\x14checkLicenseResponse\x18\x11\x20\x01(\x0b2\x1a.CheckLic\
    enseResponseProtoR\x14checkLicenseResponseB\0\x12_\n\x19getMarketMetadat\
    aResponse\x18\x12\x20\x01(\x0b2\x1f.GetMarketMetadataResponseProtoR\x19g\
    etMarketMetadataResponseB\0\x12S\n\x15getCategoriesResponse\x18\x14\x20\
    \x01(\x0b2\x1b.GetCategoriesResponseProtoR\x15getCategoriesResponseB\0\
    \x12V\n\x16getCarrierInfoResponse\x18\x15\x20\x01(\x0b2\x1c.GetCarrierIn\
    foResponseProtoR\x16getCarrierInfoResponseB\0\x12c\n\x1arestoreApplicati\
    onResponse\x18\x17\x20\x01(\x0b2!.RestoreApplicationsResponseProtoR\x1ar\
    estoreApplicationResponseB\0\x12Y\n\x17querySuggestionResponse\x18\x18\
    \x20\x01(\x0b2\x1d.QuerySuggestionResponseProtoR\x17querySuggestionRespo\
    nseB\0\x12P\n\x14billingEventResponse\x18\x19\x20\x01(\x0b2\x1a.BillingE\
    ventResponseProtoR\x14billingEventResponseB\0\x12_\n\x19paypalPreapprova\
    lResponse\x18\x1a\x20\x01(\x0b2\x1f.PaypalPreapprovalResponseProtoR\x19p\
    aypalPreapprovalResponseB\0\x12t\n\x20paypalPreapprovalDetailsResponse\
    \x18\x1b\x20\x01(\x0b2&.PaypalPreapprovalDetailsResponseProtoR\x20paypal\
    PreapprovalDetailsResponseB\0\x12e\n\x1bpaypalCreateAccountResponse\x18\
    \x1c\x20\x01(\x0b2!.PaypalCreateAccountResponseProtoR\x1bpaypalCreateAcc\
    ountResponseB\0\x12\x80\x01\n$paypalPreapprovalCredentialsResponse\x18\
    \x1d\x20\x01(\x0b2*.PaypalPreapprovalCredentialsResponseProtoR$paypalPre\
    approvalCredentialsResponseB\0\x12t\n\x20inAppRestoreTransactionsRespons\
    e\x18\x1e\x20\x01(\x0b2&.InAppRestoreTransactionsResponseProtoR\x20inApp\
    RestoreTransactionsResponseB\0\x12z\n#getInAppPurchaseInformationRespons\
    e\x18\x1f\x20\x01(\x0b2&.InAppPurchaseInformationResponseProtoR#getInApp\
    PurchaseInformationResponseB\0\x12k\n\x1dcheckForNotificationsResponse\
    \x18\x20\x20\x01(\x0b2#.CheckForNotificationsResponseProtoR\x1dcheckForN\
    otificationsResponseB\0\x12\\\n\x18ackNotificationsResponse\x18!\x20\x01\
    (\x0b2\x1e.AckNotificationsResponseProtoR\x18ackNotificationsResponseB\0\
    \x12Y\n\x17purchaseProductResponse\x18\"\x20\x01(\x0b2\x1d.PurchaseProdu\
    ctResponseProtoR\x17purchaseProductResponseB\0\x12e\n\x1breconstructData\
    baseResponse\x18#\x20\x01(\x0b2!.ReconstructDatabaseResponseProtoR\x1bre\
    constructDatabaseResponseB\0\x12h\n\x1cpaypalMassageAddressResponse\x18$\
    \x20\x01(\x0b2\".PaypalMassageAddressResponseProtoR\x1cpaypalMassageAddr\
    essResponseB\0\x12_\n\x19getAddressSnippetResponse\x18%\x20\x01(\x0b2\
    \x1f.GetAddressSnippetResponseProtoR\x19getAddressSnippetResponseB\0:\0\
    \"\x8a\x01\n\x1aStatusBarNotificationProto\x12\x20\n\ntickerText\x18\x01\
    \x20\x01(\tR\ntickerTextB\0\x12$\n\x0ccontentTitle\x18\x02\x20\x01(\tR\
    \x0ccontentTitleB\0\x12\"\n\x0bcontentText\x18\x03\x20\x01(\tR\x0bconten\
    tTextB\0:\0\"U\n\x1bUninstallReasonRequestProto\x12\x1a\n\x07assetId\x18\
    \x01\x20\x01(\tR\x07assetIdB\0\x12\x18\n\x06reason\x18\x02\x20\x01(\x05R\
    \x06reasonB\0:\0\"\x20\n\x1cUninstallReasonResponseProto:\0\"\xab\x02\n\
    \x15CriticReviewsResponse\x12\x16\n\x05title\x18\x01\x20\x01(\tR\x05titl\
    eB\0\x128\n\x12aggregateSentiment\x18\x02\x20\x01(\x0b2\x06.ImageR\x12ag\
    gregateSentimentB\0\x12*\n\x0ftotalNumReviews\x18\x03\x20\x01(\rR\x0ftot\
    alNumReviewsB\0\x12,\n\x10percentFavorable\x18\x04\x20\x01(\rR\x10percen\
    tFavorableB\0\x12\x20\n\nsourceText\x18\x05\x20\x01(\tR\nsourceTextB\0\
    \x12\x1f\n\x06source\x18\x06\x20\x01(\x0b2\x05.LinkR\x06sourceB\0\x12!\n\
    \x06review\x18\x07\x20\x03(\x0b2\x07.ReviewR\x06reviewB\0:\0B\0b\x06prot\
    o2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
