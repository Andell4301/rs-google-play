// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `googleplay.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppDeliveryData {
    // message fields
    pub downloadSize: ::std::option::Option<i64>,
    pub sha1: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub additionalFile: ::protobuf::RepeatedField<AppFileMetadata>,
    pub downloadAuthCookie: ::protobuf::RepeatedField<HttpCookie>,
    pub forwardLocked: ::std::option::Option<bool>,
    pub refundTimeout: ::std::option::Option<i64>,
    pub serverInitiated: ::std::option::Option<bool>,
    pub postInstallRefundWindowMillis: ::std::option::Option<i64>,
    pub immediateStartNeeded: ::std::option::Option<bool>,
    pub patchData: ::protobuf::SingularPtrField<AndroidAppPatchData>,
    pub encryptionParams: ::protobuf::SingularPtrField<EncryptionParams>,
    pub downloadUrlGzipped: ::protobuf::SingularField<::std::string::String>,
    pub downloadSizeGzipped: ::std::option::Option<i64>,
    pub split: ::protobuf::RepeatedField<Split>,
    pub sha256: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppDeliveryData {
    fn default() -> &'a AndroidAppDeliveryData {
        <AndroidAppDeliveryData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppDeliveryData {
    pub fn new() -> AndroidAppDeliveryData {
        ::std::default::Default::default()
    }

    // optional int64 downloadSize = 1;


    pub fn get_downloadSize(&self) -> i64 {
        self.downloadSize.unwrap_or(0)
    }

    // optional string sha1 = 2;


    pub fn get_sha1(&self) -> &str {
        match self.sha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .AppFileMetadata additionalFile = 4;


    pub fn get_additionalFile(&self) -> &[AppFileMetadata] {
        &self.additionalFile
    }

    // repeated .HttpCookie downloadAuthCookie = 5;


    pub fn get_downloadAuthCookie(&self) -> &[HttpCookie] {
        &self.downloadAuthCookie
    }

    // optional bool forwardLocked = 6;


    pub fn get_forwardLocked(&self) -> bool {
        self.forwardLocked.unwrap_or(false)
    }

    // optional int64 refundTimeout = 7;


    pub fn get_refundTimeout(&self) -> i64 {
        self.refundTimeout.unwrap_or(0)
    }

    // optional bool serverInitiated = 8;


    pub fn get_serverInitiated(&self) -> bool {
        self.serverInitiated.unwrap_or(false)
    }

    // optional int64 postInstallRefundWindowMillis = 9;


    pub fn get_postInstallRefundWindowMillis(&self) -> i64 {
        self.postInstallRefundWindowMillis.unwrap_or(0)
    }

    // optional bool immediateStartNeeded = 10;


    pub fn get_immediateStartNeeded(&self) -> bool {
        self.immediateStartNeeded.unwrap_or(false)
    }

    // optional .AndroidAppPatchData patchData = 11;


    pub fn get_patchData(&self) -> &AndroidAppPatchData {
        self.patchData.as_ref().unwrap_or_else(|| <AndroidAppPatchData as ::protobuf::Message>::default_instance())
    }

    // optional .EncryptionParams encryptionParams = 12;


    pub fn get_encryptionParams(&self) -> &EncryptionParams {
        self.encryptionParams.as_ref().unwrap_or_else(|| <EncryptionParams as ::protobuf::Message>::default_instance())
    }

    // optional string downloadUrlGzipped = 13;


    pub fn get_downloadUrlGzipped(&self) -> &str {
        match self.downloadUrlGzipped.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 downloadSizeGzipped = 14;


    pub fn get_downloadSizeGzipped(&self) -> i64 {
        self.downloadSizeGzipped.unwrap_or(0)
    }

    // repeated .Split split = 15;


    pub fn get_split(&self) -> &[Split] {
        &self.split
    }

    // optional string sha256 = 19;


    pub fn get_sha256(&self) -> &str {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidAppDeliveryData {
    fn is_initialized(&self) -> bool {
        for v in &self.additionalFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downloadAuthCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patchData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryptionParams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.split {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sha1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additionalFile)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.downloadAuthCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forwardLocked = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeout = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serverInitiated = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postInstallRefundWindowMillis = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.immediateStartNeeded = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patchData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptionParams)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrlGzipped)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.downloadSizeGzipped = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.split)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.downloadSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.additionalFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.downloadAuthCookie {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.forwardLocked {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeout {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.serverInitiated {
            my_size += 2;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.immediateStartNeeded {
            my_size += 2;
        }
        if let Some(ref v) = self.patchData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryptionParams.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.downloadSizeGzipped {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.split {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.downloadSize {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.sha1.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.additionalFile {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.downloadAuthCookie {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.forwardLocked {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.refundTimeout {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.serverInitiated {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.postInstallRefundWindowMillis {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.immediateStartNeeded {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.patchData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryptionParams.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.downloadSizeGzipped {
            os.write_int64(14, v)?;
        }
        for v in &self.split {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_string(19, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppDeliveryData {
        AndroidAppDeliveryData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloadSize",
                |m: &AndroidAppDeliveryData| { &m.downloadSize },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha1",
                |m: &AndroidAppDeliveryData| { &m.sha1 },
                |m: &mut AndroidAppDeliveryData| { &mut m.sha1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AndroidAppDeliveryData| { &m.downloadUrl },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppFileMetadata>>(
                "additionalFile",
                |m: &AndroidAppDeliveryData| { &m.additionalFile },
                |m: &mut AndroidAppDeliveryData| { &mut m.additionalFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HttpCookie>>(
                "downloadAuthCookie",
                |m: &AndroidAppDeliveryData| { &m.downloadAuthCookie },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadAuthCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forwardLocked",
                |m: &AndroidAppDeliveryData| { &m.forwardLocked },
                |m: &mut AndroidAppDeliveryData| { &mut m.forwardLocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeout",
                |m: &AndroidAppDeliveryData| { &m.refundTimeout },
                |m: &mut AndroidAppDeliveryData| { &mut m.refundTimeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "serverInitiated",
                |m: &AndroidAppDeliveryData| { &m.serverInitiated },
                |m: &mut AndroidAppDeliveryData| { &mut m.serverInitiated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postInstallRefundWindowMillis",
                |m: &AndroidAppDeliveryData| { &m.postInstallRefundWindowMillis },
                |m: &mut AndroidAppDeliveryData| { &mut m.postInstallRefundWindowMillis },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "immediateStartNeeded",
                |m: &AndroidAppDeliveryData| { &m.immediateStartNeeded },
                |m: &mut AndroidAppDeliveryData| { &mut m.immediateStartNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppPatchData>>(
                "patchData",
                |m: &AndroidAppDeliveryData| { &m.patchData },
                |m: &mut AndroidAppDeliveryData| { &mut m.patchData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionParams>>(
                "encryptionParams",
                |m: &AndroidAppDeliveryData| { &m.encryptionParams },
                |m: &mut AndroidAppDeliveryData| { &mut m.encryptionParams },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrlGzipped",
                |m: &AndroidAppDeliveryData| { &m.downloadUrlGzipped },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadUrlGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "downloadSizeGzipped",
                |m: &AndroidAppDeliveryData| { &m.downloadSizeGzipped },
                |m: &mut AndroidAppDeliveryData| { &mut m.downloadSizeGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Split>>(
                "split",
                |m: &AndroidAppDeliveryData| { &m.split },
                |m: &mut AndroidAppDeliveryData| { &mut m.split },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha256",
                |m: &AndroidAppDeliveryData| { &m.sha256 },
                |m: &mut AndroidAppDeliveryData| { &mut m.sha256 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppDeliveryData>(
                "AndroidAppDeliveryData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppDeliveryData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppDeliveryData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppDeliveryData::new)
    }
}

impl ::protobuf::Clear for AndroidAppDeliveryData {
    fn clear(&mut self) {
        self.downloadSize = ::std::option::Option::None;
        self.sha1.clear();
        self.downloadUrl.clear();
        self.additionalFile.clear();
        self.downloadAuthCookie.clear();
        self.forwardLocked = ::std::option::Option::None;
        self.refundTimeout = ::std::option::Option::None;
        self.serverInitiated = ::std::option::Option::None;
        self.postInstallRefundWindowMillis = ::std::option::Option::None;
        self.immediateStartNeeded = ::std::option::Option::None;
        self.patchData.clear();
        self.encryptionParams.clear();
        self.downloadUrlGzipped.clear();
        self.downloadSizeGzipped = ::std::option::Option::None;
        self.split.clear();
        self.sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppDeliveryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppDeliveryData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Split {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub size: ::std::option::Option<i64>,
    pub sizeGzipped: ::std::option::Option<i64>,
    pub sha1: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrlGzipped: ::protobuf::SingularField<::std::string::String>,
    pub sha256: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Split {
    fn default() -> &'a Split {
        <Split as ::protobuf::Message>::default_instance()
    }
}

impl Split {
    pub fn new() -> Split {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional int64 sizeGzipped = 3;


    pub fn get_sizeGzipped(&self) -> i64 {
        self.sizeGzipped.unwrap_or(0)
    }

    // optional string sha1 = 4;


    pub fn get_sha1(&self) -> &str {
        match self.sha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 5;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrlGzipped = 6;


    pub fn get_downloadUrlGzipped(&self) -> &str {
        match self.downloadUrlGzipped.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sha256 = 9;


    pub fn get_sha256(&self) -> &str {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Split {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sizeGzipped = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sha1)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrlGzipped)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sizeGzipped {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.sizeGzipped {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.sha1.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Split {
        Split::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Split| { &m.name },
                |m: &mut Split| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Split| { &m.size },
                |m: &mut Split| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sizeGzipped",
                |m: &Split| { &m.sizeGzipped },
                |m: &mut Split| { &mut m.sizeGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha1",
                |m: &Split| { &m.sha1 },
                |m: &mut Split| { &mut m.sha1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &Split| { &m.downloadUrl },
                |m: &mut Split| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrlGzipped",
                |m: &Split| { &m.downloadUrlGzipped },
                |m: &mut Split| { &mut m.downloadUrlGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha256",
                |m: &Split| { &m.sha256 },
                |m: &mut Split| { &mut m.sha256 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Split>(
                "Split",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Split {
        static instance: ::protobuf::rt::LazyV2<Split> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Split::new)
    }
}

impl ::protobuf::Clear for Split {
    fn clear(&mut self) {
        self.name.clear();
        self.size = ::std::option::Option::None;
        self.sizeGzipped = ::std::option::Option::None;
        self.sha1.clear();
        self.downloadUrl.clear();
        self.downloadUrlGzipped.clear();
        self.sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Split {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Split {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppPatchData {
    // message fields
    pub baseVersionCode: ::std::option::Option<i32>,
    pub baseSha1: ::protobuf::SingularField<::std::string::String>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub patchFormat: ::std::option::Option<i32>,
    pub maxPatchSize: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppPatchData {
    fn default() -> &'a AndroidAppPatchData {
        <AndroidAppPatchData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppPatchData {
    pub fn new() -> AndroidAppPatchData {
        ::std::default::Default::default()
    }

    // optional int32 baseVersionCode = 1;


    pub fn get_baseVersionCode(&self) -> i32 {
        self.baseVersionCode.unwrap_or(0)
    }

    // optional string baseSha1 = 2;


    pub fn get_baseSha1(&self) -> &str {
        match self.baseSha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadUrl = 3;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 patchFormat = 4;


    pub fn get_patchFormat(&self) -> i32 {
        self.patchFormat.unwrap_or(0)
    }

    // optional int64 maxPatchSize = 5;


    pub fn get_maxPatchSize(&self) -> i64 {
        self.maxPatchSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidAppPatchData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.baseVersionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseSha1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.patchFormat = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxPatchSize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.baseVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.baseSha1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.patchFormat {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxPatchSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.baseVersionCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.baseSha1.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.patchFormat {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maxPatchSize {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppPatchData {
        AndroidAppPatchData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "baseVersionCode",
                |m: &AndroidAppPatchData| { &m.baseVersionCode },
                |m: &mut AndroidAppPatchData| { &mut m.baseVersionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baseSha1",
                |m: &AndroidAppPatchData| { &m.baseSha1 },
                |m: &mut AndroidAppPatchData| { &mut m.baseSha1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AndroidAppPatchData| { &m.downloadUrl },
                |m: &mut AndroidAppPatchData| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "patchFormat",
                |m: &AndroidAppPatchData| { &m.patchFormat },
                |m: &mut AndroidAppPatchData| { &mut m.patchFormat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxPatchSize",
                |m: &AndroidAppPatchData| { &m.maxPatchSize },
                |m: &mut AndroidAppPatchData| { &mut m.maxPatchSize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppPatchData>(
                "AndroidAppPatchData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppPatchData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppPatchData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppPatchData::new)
    }
}

impl ::protobuf::Clear for AndroidAppPatchData {
    fn clear(&mut self) {
        self.baseVersionCode = ::std::option::Option::None;
        self.baseSha1.clear();
        self.downloadUrl.clear();
        self.patchFormat = ::std::option::Option::None;
        self.maxPatchSize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppPatchData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppPatchData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppFileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    pub downloadUrl: ::protobuf::SingularField<::std::string::String>,
    pub sizeGzipped: ::std::option::Option<i64>,
    pub downloadUrlGzipped: ::protobuf::SingularField<::std::string::String>,
    pub sha1: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppFileMetadata {
    fn default() -> &'a AppFileMetadata {
        <AppFileMetadata as ::protobuf::Message>::default_instance()
    }
}

impl AppFileMetadata {
    pub fn new() -> AppFileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;


    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }

    // optional string downloadUrl = 4;


    pub fn get_downloadUrl(&self) -> &str {
        match self.downloadUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 sizeGzipped = 6;


    pub fn get_sizeGzipped(&self) -> i64 {
        self.sizeGzipped.unwrap_or(0)
    }

    // optional string downloadUrlGzipped = 7;


    pub fn get_downloadUrlGzipped(&self) -> &str {
        match self.downloadUrlGzipped.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sha1 = 8;


    pub fn get_sha1(&self) -> &str {
        match self.sha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppFileMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sizeGzipped = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadUrlGzipped)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sha1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.sizeGzipped {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.sha1.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.downloadUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.sizeGzipped {
            os.write_int64(6, v)?;
        }
        if let Some(ref v) = self.downloadUrlGzipped.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.sha1.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppFileMetadata {
        AppFileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fileType",
                |m: &AppFileMetadata| { &m.fileType },
                |m: &mut AppFileMetadata| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AppFileMetadata| { &m.versionCode },
                |m: &mut AppFileMetadata| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &AppFileMetadata| { &m.size },
                |m: &mut AppFileMetadata| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrl",
                |m: &AppFileMetadata| { &m.downloadUrl },
                |m: &mut AppFileMetadata| { &mut m.downloadUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sizeGzipped",
                |m: &AppFileMetadata| { &m.sizeGzipped },
                |m: &mut AppFileMetadata| { &mut m.sizeGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadUrlGzipped",
                |m: &AppFileMetadata| { &m.downloadUrlGzipped },
                |m: &mut AppFileMetadata| { &mut m.downloadUrlGzipped },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha1",
                |m: &AppFileMetadata| { &m.sha1 },
                |m: &mut AppFileMetadata| { &mut m.sha1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppFileMetadata>(
                "AppFileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppFileMetadata {
        static instance: ::protobuf::rt::LazyV2<AppFileMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppFileMetadata::new)
    }
}

impl ::protobuf::Clear for AppFileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.downloadUrl.clear();
        self.sizeGzipped = ::std::option::Option::None;
        self.downloadUrlGzipped.clear();
        self.sha1.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppFileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppFileMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EncryptionParams {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub encryptionKey: ::protobuf::SingularField<::std::string::String>,
    pub hmacKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionParams {
    fn default() -> &'a EncryptionParams {
        <EncryptionParams as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionParams {
    pub fn new() -> EncryptionParams {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional string encryptionKey = 2;


    pub fn get_encryptionKey(&self) -> &str {
        match self.encryptionKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hmacKey = 3;


    pub fn get_hmacKey(&self) -> &str {
        match self.hmacKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EncryptionParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptionKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hmacKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.hmacKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.hmacKey.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionParams {
        EncryptionParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &EncryptionParams| { &m.version },
                |m: &mut EncryptionParams| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryptionKey",
                |m: &EncryptionParams| { &m.encryptionKey },
                |m: &mut EncryptionParams| { &mut m.encryptionKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hmacKey",
                |m: &EncryptionParams| { &m.hmacKey },
                |m: &mut EncryptionParams| { &mut m.hmacKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptionParams>(
                "EncryptionParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionParams {
        static instance: ::protobuf::rt::LazyV2<EncryptionParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionParams::new)
    }
}

impl ::protobuf::Clear for EncryptionParams {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.encryptionKey.clear();
        self.hmacKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HttpCookie {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpCookie {
    fn default() -> &'a HttpCookie {
        <HttpCookie as ::protobuf::Message>::default_instance()
    }
}

impl HttpCookie {
    pub fn new() -> HttpCookie {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for HttpCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpCookie {
        HttpCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HttpCookie| { &m.name },
                |m: &mut HttpCookie| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HttpCookie| { &m.value },
                |m: &mut HttpCookie| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpCookie>(
                "HttpCookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpCookie {
        static instance: ::protobuf::rt::LazyV2<HttpCookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpCookie::new)
    }
}

impl ::protobuf::Clear for HttpCookie {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Address {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub addressLine1: ::protobuf::SingularField<::std::string::String>,
    pub addressLine2: ::protobuf::SingularField<::std::string::String>,
    pub city: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularField<::std::string::String>,
    pub postalCode: ::protobuf::SingularField<::std::string::String>,
    pub postalCountry: ::protobuf::SingularField<::std::string::String>,
    pub dependentLocality: ::protobuf::SingularField<::std::string::String>,
    pub sortingCode: ::protobuf::SingularField<::std::string::String>,
    pub languageCode: ::protobuf::SingularField<::std::string::String>,
    pub phoneNumber: ::protobuf::SingularField<::std::string::String>,
    pub isReduced: ::std::option::Option<bool>,
    pub firstName: ::protobuf::SingularField<::std::string::String>,
    pub lastName: ::protobuf::SingularField<::std::string::String>,
    pub email: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addressLine1 = 2;


    pub fn get_addressLine1(&self) -> &str {
        match self.addressLine1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addressLine2 = 3;


    pub fn get_addressLine2(&self) -> &str {
        match self.addressLine2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city = 4;


    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state = 5;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCode = 6;


    pub fn get_postalCode(&self) -> &str {
        match self.postalCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postalCountry = 7;


    pub fn get_postalCountry(&self) -> &str {
        match self.postalCountry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dependentLocality = 8;


    pub fn get_dependentLocality(&self) -> &str {
        match self.dependentLocality.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sortingCode = 9;


    pub fn get_sortingCode(&self) -> &str {
        match self.sortingCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string languageCode = 10;


    pub fn get_languageCode(&self) -> &str {
        match self.languageCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string phoneNumber = 11;


    pub fn get_phoneNumber(&self) -> &str {
        match self.phoneNumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool isReduced = 12;


    pub fn get_isReduced(&self) -> bool {
        self.isReduced.unwrap_or(false)
    }

    // optional string firstName = 13;


    pub fn get_firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastName = 14;


    pub fn get_lastName(&self) -> &str {
        match self.lastName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string email = 15;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressLine2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postalCountry)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dependentLocality)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sortingCode)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.languageCode)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phoneNumber)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isReduced = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.addressLine1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.addressLine2.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.postalCountry.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.dependentLocality.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.sortingCode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.languageCode.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.phoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.isReduced {
            my_size += 2;
        }
        if let Some(ref v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.lastName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.addressLine1.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.addressLine2.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.postalCode.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.postalCountry.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.dependentLocality.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.sortingCode.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.languageCode.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.phoneNumber.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.isReduced {
            os.write_bool(12, v)?;
        }
        if let Some(ref v) = self.firstName.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.lastName.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Address| { &m.name },
                |m: &mut Address| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressLine1",
                |m: &Address| { &m.addressLine1 },
                |m: &mut Address| { &mut m.addressLine1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressLine2",
                |m: &Address| { &m.addressLine2 },
                |m: &mut Address| { &mut m.addressLine2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city",
                |m: &Address| { &m.city },
                |m: &mut Address| { &mut m.city },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &Address| { &m.state },
                |m: &mut Address| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCode",
                |m: &Address| { &m.postalCode },
                |m: &mut Address| { &mut m.postalCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postalCountry",
                |m: &Address| { &m.postalCountry },
                |m: &mut Address| { &mut m.postalCountry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dependentLocality",
                |m: &Address| { &m.dependentLocality },
                |m: &mut Address| { &mut m.dependentLocality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortingCode",
                |m: &Address| { &m.sortingCode },
                |m: &mut Address| { &mut m.sortingCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "languageCode",
                |m: &Address| { &m.languageCode },
                |m: &mut Address| { &mut m.languageCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phoneNumber",
                |m: &Address| { &m.phoneNumber },
                |m: &mut Address| { &mut m.phoneNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isReduced",
                |m: &Address| { &m.isReduced },
                |m: &mut Address| { &mut m.isReduced },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstName",
                |m: &Address| { &m.firstName },
                |m: &mut Address| { &mut m.firstName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastName",
                |m: &Address| { &m.lastName },
                |m: &mut Address| { &mut m.lastName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &Address| { &m.email },
                |m: &mut Address| { &mut m.email },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::LazyV2<Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.name.clear();
        self.addressLine1.clear();
        self.addressLine2.clear();
        self.city.clear();
        self.state.clear();
        self.postalCode.clear();
        self.postalCountry.clear();
        self.dependentLocality.clear();
        self.sortingCode.clear();
        self.languageCode.clear();
        self.phoneNumber.clear();
        self.isReduced = ::std::option::Option::None;
        self.firstName.clear();
        self.lastName.clear();
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookAuthor {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub deprecatedQuery: ::protobuf::SingularField<::std::string::String>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookAuthor {
    fn default() -> &'a BookAuthor {
        <BookAuthor as ::protobuf::Message>::default_instance()
    }
}

impl BookAuthor {
    pub fn new() -> BookAuthor {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deprecatedQuery = 2;


    pub fn get_deprecatedQuery(&self) -> &str {
        match self.deprecatedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Docid docid = 3;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BookAuthor {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedQuery)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.deprecatedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.deprecatedQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookAuthor {
        BookAuthor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BookAuthor| { &m.name },
                |m: &mut BookAuthor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deprecatedQuery",
                |m: &BookAuthor| { &m.deprecatedQuery },
                |m: &mut BookAuthor| { &mut m.deprecatedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &BookAuthor| { &m.docid },
                |m: &mut BookAuthor| { &mut m.docid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookAuthor>(
                "BookAuthor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookAuthor {
        static instance: ::protobuf::rt::LazyV2<BookAuthor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookAuthor::new)
    }
}

impl ::protobuf::Clear for BookAuthor {
    fn clear(&mut self) {
        self.name.clear();
        self.deprecatedQuery.clear();
        self.docid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookAuthor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookAuthor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookDetails {
    // message fields
    pub subject: ::protobuf::RepeatedField<BookSubject>,
    pub publisher: ::protobuf::SingularField<::std::string::String>,
    pub publicationDate: ::protobuf::SingularField<::std::string::String>,
    pub isbn: ::protobuf::SingularField<::std::string::String>,
    pub numberOfPages: ::std::option::Option<i32>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub author: ::protobuf::RepeatedField<BookAuthor>,
    pub readerUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadEpubUrl: ::protobuf::SingularField<::std::string::String>,
    pub downloadPdfUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsEpubTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub acsPdfTokenUrl: ::protobuf::SingularField<::std::string::String>,
    pub epubAvailable: ::std::option::Option<bool>,
    pub pdfAvailable: ::std::option::Option<bool>,
    pub aboutTheAuthor: ::protobuf::SingularField<::std::string::String>,
    // identifier: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookDetails {
    fn default() -> &'a BookDetails {
        <BookDetails as ::protobuf::Message>::default_instance()
    }
}

impl BookDetails {
    pub fn new() -> BookDetails {
        ::std::default::Default::default()
    }

    // repeated .BookSubject subject = 3;


    pub fn get_subject(&self) -> &[BookSubject] {
        &self.subject
    }

    // optional string publisher = 4;


    pub fn get_publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string publicationDate = 5;


    pub fn get_publicationDate(&self) -> &str {
        match self.publicationDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string isbn = 6;


    pub fn get_isbn(&self) -> &str {
        match self.isbn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 numberOfPages = 7;


    pub fn get_numberOfPages(&self) -> i32 {
        self.numberOfPages.unwrap_or(0)
    }

    // optional string subtitle = 8;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .BookAuthor author = 9;


    pub fn get_author(&self) -> &[BookAuthor] {
        &self.author
    }

    // optional string readerUrl = 10;


    pub fn get_readerUrl(&self) -> &str {
        match self.readerUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadEpubUrl = 11;


    pub fn get_downloadEpubUrl(&self) -> &str {
        match self.downloadEpubUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string downloadPdfUrl = 12;


    pub fn get_downloadPdfUrl(&self) -> &str {
        match self.downloadPdfUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string acsEpubTokenUrl = 13;


    pub fn get_acsEpubTokenUrl(&self) -> &str {
        match self.acsEpubTokenUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string acsPdfTokenUrl = 14;


    pub fn get_acsPdfTokenUrl(&self) -> &str {
        match self.acsPdfTokenUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool epubAvailable = 15;


    pub fn get_epubAvailable(&self) -> bool {
        self.epubAvailable.unwrap_or(false)
    }

    // optional bool pdfAvailable = 16;


    pub fn get_pdfAvailable(&self) -> bool {
        self.pdfAvailable.unwrap_or(false)
    }

    // optional string aboutTheAuthor = 17;


    pub fn get_aboutTheAuthor(&self) -> &str {
        match self.aboutTheAuthor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.subject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publisher)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.publicationDate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.isbn)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numberOfPages = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.author)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.readerUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadEpubUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadPdfUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsEpubTokenUrl)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.acsPdfTokenUrl)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.epubAvailable = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pdfAvailable = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.aboutTheAuthor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subject {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.publisher.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.publicationDate.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.isbn.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.numberOfPages {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.author {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.readerUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.downloadEpubUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.downloadPdfUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.acsEpubTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.acsPdfTokenUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.epubAvailable {
            my_size += 2;
        }
        if let Some(v) = self.pdfAvailable {
            my_size += 3;
        }
        if let Some(ref v) = self.aboutTheAuthor.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subject {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.publisher.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.publicationDate.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.isbn.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.numberOfPages {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.author {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.readerUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.downloadEpubUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.downloadPdfUrl.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.acsEpubTokenUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.acsPdfTokenUrl.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.epubAvailable {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.pdfAvailable {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.aboutTheAuthor.as_ref() {
            os.write_string(17, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails {
        BookDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookSubject>>(
                "subject",
                |m: &BookDetails| { &m.subject },
                |m: &mut BookDetails| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "publisher",
                |m: &BookDetails| { &m.publisher },
                |m: &mut BookDetails| { &mut m.publisher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "publicationDate",
                |m: &BookDetails| { &m.publicationDate },
                |m: &mut BookDetails| { &mut m.publicationDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "isbn",
                |m: &BookDetails| { &m.isbn },
                |m: &mut BookDetails| { &mut m.isbn },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numberOfPages",
                |m: &BookDetails| { &m.numberOfPages },
                |m: &mut BookDetails| { &mut m.numberOfPages },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &BookDetails| { &m.subtitle },
                |m: &mut BookDetails| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookAuthor>>(
                "author",
                |m: &BookDetails| { &m.author },
                |m: &mut BookDetails| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "readerUrl",
                |m: &BookDetails| { &m.readerUrl },
                |m: &mut BookDetails| { &mut m.readerUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadEpubUrl",
                |m: &BookDetails| { &m.downloadEpubUrl },
                |m: &mut BookDetails| { &mut m.downloadEpubUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadPdfUrl",
                |m: &BookDetails| { &m.downloadPdfUrl },
                |m: &mut BookDetails| { &mut m.downloadPdfUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acsEpubTokenUrl",
                |m: &BookDetails| { &m.acsEpubTokenUrl },
                |m: &mut BookDetails| { &mut m.acsEpubTokenUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acsPdfTokenUrl",
                |m: &BookDetails| { &m.acsPdfTokenUrl },
                |m: &mut BookDetails| { &mut m.acsPdfTokenUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "epubAvailable",
                |m: &BookDetails| { &m.epubAvailable },
                |m: &mut BookDetails| { &mut m.epubAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pdfAvailable",
                |m: &BookDetails| { &m.pdfAvailable },
                |m: &mut BookDetails| { &mut m.pdfAvailable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "aboutTheAuthor",
                |m: &BookDetails| { &m.aboutTheAuthor },
                |m: &mut BookDetails| { &mut m.aboutTheAuthor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookDetails>(
                "BookDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails {
        static instance: ::protobuf::rt::LazyV2<BookDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookDetails::new)
    }
}

impl ::protobuf::Clear for BookDetails {
    fn clear(&mut self) {
        self.subject.clear();
        self.publisher.clear();
        self.publicationDate.clear();
        self.isbn.clear();
        self.numberOfPages = ::std::option::Option::None;
        self.subtitle.clear();
        self.author.clear();
        self.readerUrl.clear();
        self.downloadEpubUrl.clear();
        self.downloadPdfUrl.clear();
        self.acsEpubTokenUrl.clear();
        self.acsPdfTokenUrl.clear();
        self.epubAvailable = ::std::option::Option::None;
        self.pdfAvailable = ::std::option::Option::None;
        self.aboutTheAuthor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookDetails_Identifier {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookDetails_Identifier {
    fn default() -> &'a BookDetails_Identifier {
        <BookDetails_Identifier as ::protobuf::Message>::default_instance()
    }
}

impl BookDetails_Identifier {
    pub fn new() -> BookDetails_Identifier {
        ::std::default::Default::default()
    }

    // optional int32 type = 19;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string identifier = 20;


    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookDetails_Identifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(19, v)?;
        }
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_string(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookDetails_Identifier {
        BookDetails_Identifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &BookDetails_Identifier| { &m.field_type },
                |m: &mut BookDetails_Identifier| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &BookDetails_Identifier| { &m.identifier },
                |m: &mut BookDetails_Identifier| { &mut m.identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookDetails_Identifier>(
                "BookDetails.Identifier",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookDetails_Identifier {
        static instance: ::protobuf::rt::LazyV2<BookDetails_Identifier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookDetails_Identifier::new)
    }
}

impl ::protobuf::Clear for BookDetails_Identifier {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookDetails_Identifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookDetails_Identifier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BookSubject {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub query: ::protobuf::SingularField<::std::string::String>,
    pub subjectId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BookSubject {
    fn default() -> &'a BookSubject {
        <BookSubject as ::protobuf::Message>::default_instance()
    }
}

impl BookSubject {
    pub fn new() -> BookSubject {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string query = 2;


    pub fn get_query(&self) -> &str {
        match self.query.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string subjectId = 3;


    pub fn get_subjectId(&self) -> &str {
        match self.subjectId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BookSubject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subjectId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.query.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.subjectId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.subjectId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BookSubject {
        BookSubject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BookSubject| { &m.name },
                |m: &mut BookSubject| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &BookSubject| { &m.query },
                |m: &mut BookSubject| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subjectId",
                |m: &BookSubject| { &m.subjectId },
                |m: &mut BookSubject| { &mut m.subjectId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BookSubject>(
                "BookSubject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BookSubject {
        static instance: ::protobuf::rt::LazyV2<BookSubject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BookSubject::new)
    }
}

impl ::protobuf::Clear for BookSubject {
    fn clear(&mut self) {
        self.name.clear();
        self.query.clear();
        self.subjectId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BookSubject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BookSubject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BrowseLink {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub dataUrl: ::protobuf::SingularField<::std::string::String>,
    pub icon: ::protobuf::SingularPtrField<Image>,
    pub unknownCategoryContainer: ::protobuf::SingularPtrField<UnknownCategoryContainer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BrowseLink {
    fn default() -> &'a BrowseLink {
        <BrowseLink as ::protobuf::Message>::default_instance()
    }
}

impl BrowseLink {
    pub fn new() -> BrowseLink {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dataUrl = 3;


    pub fn get_dataUrl(&self) -> &str {
        match self.dataUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image icon = 5;


    pub fn get_icon(&self) -> &Image {
        self.icon.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional .UnknownCategoryContainer unknownCategoryContainer = 4;


    pub fn get_unknownCategoryContainer(&self) -> &UnknownCategoryContainer {
        self.unknownCategoryContainer.as_ref().unwrap_or_else(|| <UnknownCategoryContainer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BrowseLink {
    fn is_initialized(&self) -> bool {
        for v in &self.icon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unknownCategoryContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dataUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.icon)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknownCategoryContainer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dataUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unknownCategoryContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dataUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unknownCategoryContainer.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseLink {
        BrowseLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BrowseLink| { &m.name },
                |m: &mut BrowseLink| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataUrl",
                |m: &BrowseLink| { &m.dataUrl },
                |m: &mut BrowseLink| { &mut m.dataUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "icon",
                |m: &BrowseLink| { &m.icon },
                |m: &mut BrowseLink| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnknownCategoryContainer>>(
                "unknownCategoryContainer",
                |m: &BrowseLink| { &m.unknownCategoryContainer },
                |m: &mut BrowseLink| { &mut m.unknownCategoryContainer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BrowseLink>(
                "BrowseLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseLink {
        static instance: ::protobuf::rt::LazyV2<BrowseLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BrowseLink::new)
    }
}

impl ::protobuf::Clear for BrowseLink {
    fn clear(&mut self) {
        self.name.clear();
        self.dataUrl.clear();
        self.icon.clear();
        self.unknownCategoryContainer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UnknownCategoryContainer {
    // message fields
    pub categoryIdContainer: ::protobuf::SingularPtrField<CategoryIdContainer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnknownCategoryContainer {
    fn default() -> &'a UnknownCategoryContainer {
        <UnknownCategoryContainer as ::protobuf::Message>::default_instance()
    }
}

impl UnknownCategoryContainer {
    pub fn new() -> UnknownCategoryContainer {
        ::std::default::Default::default()
    }

    // optional .CategoryIdContainer categoryIdContainer = 5;


    pub fn get_categoryIdContainer(&self) -> &CategoryIdContainer {
        self.categoryIdContainer.as_ref().unwrap_or_else(|| <CategoryIdContainer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for UnknownCategoryContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.categoryIdContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.categoryIdContainer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.categoryIdContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.categoryIdContainer.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownCategoryContainer {
        UnknownCategoryContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryIdContainer>>(
                "categoryIdContainer",
                |m: &UnknownCategoryContainer| { &m.categoryIdContainer },
                |m: &mut UnknownCategoryContainer| { &mut m.categoryIdContainer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnknownCategoryContainer>(
                "UnknownCategoryContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnknownCategoryContainer {
        static instance: ::protobuf::rt::LazyV2<UnknownCategoryContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnknownCategoryContainer::new)
    }
}

impl ::protobuf::Clear for UnknownCategoryContainer {
    fn clear(&mut self) {
        self.categoryIdContainer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownCategoryContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownCategoryContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CategoryIdContainer {
    // message fields
    pub categoryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CategoryIdContainer {
    fn default() -> &'a CategoryIdContainer {
        <CategoryIdContainer as ::protobuf::Message>::default_instance()
    }
}

impl CategoryIdContainer {
    pub fn new() -> CategoryIdContainer {
        ::std::default::Default::default()
    }

    // optional string categoryId = 4;


    pub fn get_categoryId(&self) -> &str {
        match self.categoryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CategoryIdContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.categoryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.categoryId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.categoryId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoryIdContainer {
        CategoryIdContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &CategoryIdContainer| { &m.categoryId },
                |m: &mut CategoryIdContainer| { &mut m.categoryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CategoryIdContainer>(
                "CategoryIdContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoryIdContainer {
        static instance: ::protobuf::rt::LazyV2<CategoryIdContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CategoryIdContainer::new)
    }
}

impl ::protobuf::Clear for CategoryIdContainer {
    fn clear(&mut self) {
        self.categoryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoryIdContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryIdContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BrowseResponse {
    // message fields
    pub contentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub promoUrl: ::protobuf::SingularField<::std::string::String>,
    pub category: ::protobuf::RepeatedField<BrowseLink>,
    pub breadcrumb: ::protobuf::RepeatedField<BrowseLink>,
    pub categoryContainer: ::protobuf::SingularPtrField<CategoryContainer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BrowseResponse {
    fn default() -> &'a BrowseResponse {
        <BrowseResponse as ::protobuf::Message>::default_instance()
    }
}

impl BrowseResponse {
    pub fn new() -> BrowseResponse {
        ::std::default::Default::default()
    }

    // optional string contentsUrl = 1;


    pub fn get_contentsUrl(&self) -> &str {
        match self.contentsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string promoUrl = 2;


    pub fn get_promoUrl(&self) -> &str {
        match self.promoUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .BrowseLink category = 3;


    pub fn get_category(&self) -> &[BrowseLink] {
        &self.category
    }

    // repeated .BrowseLink breadcrumb = 4;


    pub fn get_breadcrumb(&self) -> &[BrowseLink] {
        &self.breadcrumb
    }

    // optional .CategoryContainer categoryContainer = 9;


    pub fn get_categoryContainer(&self) -> &CategoryContainer {
        self.categoryContainer.as_ref().unwrap_or_else(|| <CategoryContainer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BrowseResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.category {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.breadcrumb {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.categoryContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.promoUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.category)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.breadcrumb)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.categoryContainer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.promoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.category {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.breadcrumb {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.categoryContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contentsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.promoUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.category {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.breadcrumb {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.categoryContainer.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BrowseResponse {
        BrowseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentsUrl",
                |m: &BrowseResponse| { &m.contentsUrl },
                |m: &mut BrowseResponse| { &mut m.contentsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promoUrl",
                |m: &BrowseResponse| { &m.promoUrl },
                |m: &mut BrowseResponse| { &mut m.promoUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "category",
                |m: &BrowseResponse| { &m.category },
                |m: &mut BrowseResponse| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "breadcrumb",
                |m: &BrowseResponse| { &m.breadcrumb },
                |m: &mut BrowseResponse| { &mut m.breadcrumb },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryContainer>>(
                "categoryContainer",
                |m: &BrowseResponse| { &m.categoryContainer },
                |m: &mut BrowseResponse| { &mut m.categoryContainer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BrowseResponse>(
                "BrowseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BrowseResponse {
        static instance: ::protobuf::rt::LazyV2<BrowseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BrowseResponse::new)
    }
}

impl ::protobuf::Clear for BrowseResponse {
    fn clear(&mut self) {
        self.contentsUrl.clear();
        self.promoUrl.clear();
        self.category.clear();
        self.breadcrumb.clear();
        self.categoryContainer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BrowseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BrowseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CategoryContainer {
    // message fields
    pub category: ::protobuf::RepeatedField<BrowseLink>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CategoryContainer {
    fn default() -> &'a CategoryContainer {
        <CategoryContainer as ::protobuf::Message>::default_instance()
    }
}

impl CategoryContainer {
    pub fn new() -> CategoryContainer {
        ::std::default::Default::default()
    }

    // repeated .BrowseLink category = 4;


    pub fn get_category(&self) -> &[BrowseLink] {
        &self.category
    }
}

impl ::protobuf::Message for CategoryContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.category {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.category)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.category {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.category {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoryContainer {
        CategoryContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseLink>>(
                "category",
                |m: &CategoryContainer| { &m.category },
                |m: &mut CategoryContainer| { &mut m.category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CategoryContainer>(
                "CategoryContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoryContainer {
        static instance: ::protobuf::rt::LazyV2<CategoryContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CategoryContainer::new)
    }
}

impl ::protobuf::Clear for CategoryContainer {
    fn clear(&mut self) {
        self.category.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoryContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AddressChallenge {
    // message fields
    pub responseAddressParam: ::protobuf::SingularField<::std::string::String>,
    pub responseCheckboxesParam: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub checkbox: ::protobuf::RepeatedField<FormCheckbox>,
    pub address: ::protobuf::SingularPtrField<Address>,
    pub errorInputField: ::protobuf::RepeatedField<InputValidationError>,
    pub errorHtml: ::protobuf::SingularField<::std::string::String>,
    pub requiredField: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressChallenge {
    fn default() -> &'a AddressChallenge {
        <AddressChallenge as ::protobuf::Message>::default_instance()
    }
}

impl AddressChallenge {
    pub fn new() -> AddressChallenge {
        ::std::default::Default::default()
    }

    // optional string responseAddressParam = 1;


    pub fn get_responseAddressParam(&self) -> &str {
        match self.responseAddressParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string responseCheckboxesParam = 2;


    pub fn get_responseCheckboxesParam(&self) -> &str {
        match self.responseCheckboxesParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 4;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .FormCheckbox checkbox = 5;


    pub fn get_checkbox(&self) -> &[FormCheckbox] {
        &self.checkbox
    }

    // optional .Address address = 6;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // repeated .InputValidationError errorInputField = 7;


    pub fn get_errorInputField(&self) -> &[InputValidationError] {
        &self.errorInputField
    }

    // optional string errorHtml = 8;


    pub fn get_errorHtml(&self) -> &str {
        match self.errorHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 requiredField = 9;


    pub fn get_requiredField(&self) -> &[i32] {
        &self.requiredField
    }
}

impl ::protobuf::Message for AddressChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.checkbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errorInputField {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAddressParam)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseCheckboxesParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.checkbox)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errorInputField)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorHtml)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.responseAddressParam.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.responseCheckboxesParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.checkbox {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorInputField {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.errorHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.responseAddressParam.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.responseCheckboxesParam.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.checkbox {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errorInputField {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.errorHtml.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.requiredField {
            os.write_int32(9, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressChallenge {
        AddressChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseAddressParam",
                |m: &AddressChallenge| { &m.responseAddressParam },
                |m: &mut AddressChallenge| { &mut m.responseAddressParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseCheckboxesParam",
                |m: &AddressChallenge| { &m.responseCheckboxesParam },
                |m: &mut AddressChallenge| { &mut m.responseCheckboxesParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &AddressChallenge| { &m.title },
                |m: &mut AddressChallenge| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &AddressChallenge| { &m.descriptionHtml },
                |m: &mut AddressChallenge| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FormCheckbox>>(
                "checkbox",
                |m: &AddressChallenge| { &m.checkbox },
                |m: &mut AddressChallenge| { &mut m.checkbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &AddressChallenge| { &m.address },
                |m: &mut AddressChallenge| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputValidationError>>(
                "errorInputField",
                |m: &AddressChallenge| { &m.errorInputField },
                |m: &mut AddressChallenge| { &mut m.errorInputField },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorHtml",
                |m: &AddressChallenge| { &m.errorHtml },
                |m: &mut AddressChallenge| { &mut m.errorHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &AddressChallenge| { &m.requiredField },
                |m: &mut AddressChallenge| { &mut m.requiredField },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressChallenge>(
                "AddressChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressChallenge {
        static instance: ::protobuf::rt::LazyV2<AddressChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressChallenge::new)
    }
}

impl ::protobuf::Clear for AddressChallenge {
    fn clear(&mut self) {
        self.responseAddressParam.clear();
        self.responseCheckboxesParam.clear();
        self.title.clear();
        self.descriptionHtml.clear();
        self.checkbox.clear();
        self.address.clear();
        self.errorInputField.clear();
        self.errorHtml.clear();
        self.requiredField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AuthenticationChallenge {
    // message fields
    pub authenticationType: ::std::option::Option<i32>,
    pub responseAuthenticationTypeParam: ::protobuf::SingularField<::std::string::String>,
    pub responseRetryCountParam: ::protobuf::SingularField<::std::string::String>,
    pub pinHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub pinDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    pub gaiaHeaderText: ::protobuf::SingularField<::std::string::String>,
    pub gaiaDescriptionTextHtml: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticationChallenge {
    fn default() -> &'a AuthenticationChallenge {
        <AuthenticationChallenge as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationChallenge {
    pub fn new() -> AuthenticationChallenge {
        ::std::default::Default::default()
    }

    // optional int32 authenticationType = 1;


    pub fn get_authenticationType(&self) -> i32 {
        self.authenticationType.unwrap_or(0)
    }

    // optional string responseAuthenticationTypeParam = 2;


    pub fn get_responseAuthenticationTypeParam(&self) -> &str {
        match self.responseAuthenticationTypeParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string responseRetryCountParam = 3;


    pub fn get_responseRetryCountParam(&self) -> &str {
        match self.responseRetryCountParam.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string pinHeaderText = 4;


    pub fn get_pinHeaderText(&self) -> &str {
        match self.pinHeaderText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string pinDescriptionTextHtml = 5;


    pub fn get_pinDescriptionTextHtml(&self) -> &str {
        match self.pinDescriptionTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gaiaHeaderText = 6;


    pub fn get_gaiaHeaderText(&self) -> &str {
        match self.gaiaHeaderText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gaiaDescriptionTextHtml = 7;


    pub fn get_gaiaDescriptionTextHtml(&self) -> &str {
        match self.gaiaDescriptionTextHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AuthenticationChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.authenticationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseAuthenticationTypeParam)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.responseRetryCountParam)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pinHeaderText)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pinDescriptionTextHtml)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaHeaderText)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gaiaDescriptionTextHtml)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authenticationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.responseAuthenticationTypeParam.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.responseRetryCountParam.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pinHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.pinDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.gaiaHeaderText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.gaiaDescriptionTextHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authenticationType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.responseAuthenticationTypeParam.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.responseRetryCountParam.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pinHeaderText.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.pinDescriptionTextHtml.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.gaiaHeaderText.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.gaiaDescriptionTextHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationChallenge {
        AuthenticationChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "authenticationType",
                |m: &AuthenticationChallenge| { &m.authenticationType },
                |m: &mut AuthenticationChallenge| { &mut m.authenticationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseAuthenticationTypeParam",
                |m: &AuthenticationChallenge| { &m.responseAuthenticationTypeParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseAuthenticationTypeParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "responseRetryCountParam",
                |m: &AuthenticationChallenge| { &m.responseRetryCountParam },
                |m: &mut AuthenticationChallenge| { &mut m.responseRetryCountParam },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pinHeaderText",
                |m: &AuthenticationChallenge| { &m.pinHeaderText },
                |m: &mut AuthenticationChallenge| { &mut m.pinHeaderText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pinDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.pinDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.pinDescriptionTextHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaHeaderText",
                |m: &AuthenticationChallenge| { &m.gaiaHeaderText },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaHeaderText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gaiaDescriptionTextHtml",
                |m: &AuthenticationChallenge| { &m.gaiaDescriptionTextHtml },
                |m: &mut AuthenticationChallenge| { &mut m.gaiaDescriptionTextHtml },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticationChallenge>(
                "AuthenticationChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationChallenge {
        static instance: ::protobuf::rt::LazyV2<AuthenticationChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticationChallenge::new)
    }
}

impl ::protobuf::Clear for AuthenticationChallenge {
    fn clear(&mut self) {
        self.authenticationType = ::std::option::Option::None;
        self.responseAuthenticationTypeParam.clear();
        self.responseRetryCountParam.clear();
        self.pinHeaderText.clear();
        self.pinDescriptionTextHtml.clear();
        self.gaiaHeaderText.clear();
        self.gaiaDescriptionTextHtml.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuyResponse {
    // message fields
    pub purchaseResponse: ::protobuf::SingularPtrField<PurchaseNotificationResponse>,
    // checkoutinfo: <group>
    pub continueViaUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseStatusUrl: ::protobuf::SingularField<::std::string::String>,
    pub checkoutServiceId: ::protobuf::SingularField<::std::string::String>,
    pub checkoutTokenRequired: ::std::option::Option<bool>,
    pub baseCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosCheckboxHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub iabPermissionError: ::std::option::Option<i32>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub purchaseCookie: ::protobuf::SingularField<::std::string::String>,
    pub challenge: ::protobuf::SingularPtrField<Challenge>,
    pub downloadToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyResponse {
    fn default() -> &'a BuyResponse {
        <BuyResponse as ::protobuf::Message>::default_instance()
    }
}

impl BuyResponse {
    pub fn new() -> BuyResponse {
        ::std::default::Default::default()
    }

    // optional .PurchaseNotificationResponse purchaseResponse = 1;


    pub fn get_purchaseResponse(&self) -> &PurchaseNotificationResponse {
        self.purchaseResponse.as_ref().unwrap_or_else(|| <PurchaseNotificationResponse as ::protobuf::Message>::default_instance())
    }

    // optional string continueViaUrl = 8;


    pub fn get_continueViaUrl(&self) -> &str {
        match self.continueViaUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseStatusUrl = 9;


    pub fn get_purchaseStatusUrl(&self) -> &str {
        match self.purchaseStatusUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string checkoutServiceId = 12;


    pub fn get_checkoutServiceId(&self) -> &str {
        match self.checkoutServiceId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool checkoutTokenRequired = 13;


    pub fn get_checkoutTokenRequired(&self) -> bool {
        self.checkoutTokenRequired.unwrap_or(false)
    }

    // optional string baseCheckoutUrl = 14;


    pub fn get_baseCheckoutUrl(&self) -> &str {
        match self.baseCheckoutUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string tosCheckboxHtml = 37;


    pub fn get_tosCheckboxHtml(&self) -> &[::std::string::String] {
        &self.tosCheckboxHtml
    }

    // optional int32 iabPermissionError = 38;


    pub fn get_iabPermissionError(&self) -> i32 {
        self.iabPermissionError.unwrap_or(0)
    }

    // optional .PurchaseStatusResponse purchaseStatusResponse = 39;


    pub fn get_purchaseStatusResponse(&self) -> &PurchaseStatusResponse {
        self.purchaseStatusResponse.as_ref().unwrap_or_else(|| <PurchaseStatusResponse as ::protobuf::Message>::default_instance())
    }

    // optional string purchaseCookie = 46;


    pub fn get_purchaseCookie(&self) -> &str {
        match self.purchaseCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Challenge challenge = 49;


    pub fn get_challenge(&self) -> &Challenge {
        self.challenge.as_ref().unwrap_or_else(|| <Challenge as ::protobuf::Message>::default_instance())
    }

    // optional string downloadToken = 55;


    pub fn get_downloadToken(&self) -> &str {
        match self.downloadToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BuyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.purchaseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.continueViaUrl)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseStatusUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutServiceId)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutTokenRequired = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.baseCheckoutUrl)?;
                },
                37 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tosCheckboxHtml)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.iabPermissionError = ::std::option::Option::Some(tmp);
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseCookie)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.challenge)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.purchaseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.continueViaUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.purchaseStatusUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.checkoutServiceId.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.checkoutTokenRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.baseCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.tosCheckboxHtml {
            my_size += ::protobuf::rt::string_size(37, &value);
        };
        if let Some(v) = self.iabPermissionError {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(46, &v);
        }
        if let Some(ref v) = self.challenge.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downloadToken.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.purchaseResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.continueViaUrl.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.purchaseStatusUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.checkoutServiceId.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.checkoutTokenRequired {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.baseCheckoutUrl.as_ref() {
            os.write_string(14, &v)?;
        }
        for v in &self.tosCheckboxHtml {
            os.write_string(37, &v)?;
        };
        if let Some(v) = self.iabPermissionError {
            os.write_int32(38, v)?;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseCookie.as_ref() {
            os.write_string(46, &v)?;
        }
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downloadToken.as_ref() {
            os.write_string(55, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse {
        BuyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseNotificationResponse>>(
                "purchaseResponse",
                |m: &BuyResponse| { &m.purchaseResponse },
                |m: &mut BuyResponse| { &mut m.purchaseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "continueViaUrl",
                |m: &BuyResponse| { &m.continueViaUrl },
                |m: &mut BuyResponse| { &mut m.continueViaUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseStatusUrl",
                |m: &BuyResponse| { &m.purchaseStatusUrl },
                |m: &mut BuyResponse| { &mut m.purchaseStatusUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutServiceId",
                |m: &BuyResponse| { &m.checkoutServiceId },
                |m: &mut BuyResponse| { &mut m.checkoutServiceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutTokenRequired",
                |m: &BuyResponse| { &m.checkoutTokenRequired },
                |m: &mut BuyResponse| { &mut m.checkoutTokenRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "baseCheckoutUrl",
                |m: &BuyResponse| { &m.baseCheckoutUrl },
                |m: &mut BuyResponse| { &mut m.baseCheckoutUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosCheckboxHtml",
                |m: &BuyResponse| { &m.tosCheckboxHtml },
                |m: &mut BuyResponse| { &mut m.tosCheckboxHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "iabPermissionError",
                |m: &BuyResponse| { &m.iabPermissionError },
                |m: &mut BuyResponse| { &mut m.iabPermissionError },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>>(
                "purchaseStatusResponse",
                |m: &BuyResponse| { &m.purchaseStatusResponse },
                |m: &mut BuyResponse| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseCookie",
                |m: &BuyResponse| { &m.purchaseCookie },
                |m: &mut BuyResponse| { &mut m.purchaseCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Challenge>>(
                "challenge",
                |m: &BuyResponse| { &m.challenge },
                |m: &mut BuyResponse| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadToken",
                |m: &BuyResponse| { &m.downloadToken },
                |m: &mut BuyResponse| { &mut m.downloadToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyResponse>(
                "BuyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse {
        static instance: ::protobuf::rt::LazyV2<BuyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyResponse::new)
    }
}

impl ::protobuf::Clear for BuyResponse {
    fn clear(&mut self) {
        self.purchaseResponse.clear();
        self.continueViaUrl.clear();
        self.purchaseStatusUrl.clear();
        self.checkoutServiceId.clear();
        self.checkoutTokenRequired = ::std::option::Option::None;
        self.baseCheckoutUrl.clear();
        self.tosCheckboxHtml.clear();
        self.iabPermissionError = ::std::option::Option::None;
        self.purchaseStatusResponse.clear();
        self.purchaseCookie.clear();
        self.challenge.clear();
        self.downloadToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuyResponse_CheckoutInfo {
    // message fields
    pub item: ::protobuf::SingularPtrField<LineItem>,
    pub subItem: ::protobuf::RepeatedField<LineItem>,
    // checkoutoption: <group>
    pub deprecatedCheckoutUrl: ::protobuf::SingularField<::std::string::String>,
    pub addInstrumentUrl: ::protobuf::SingularField<::std::string::String>,
    pub footerHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrumentFamily: ::std::vec::Vec<i32>,
    pub footnoteHtml: ::protobuf::RepeatedField<::std::string::String>,
    pub eligibleInstrument: ::protobuf::RepeatedField<Instrument>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyResponse_CheckoutInfo {
    fn default() -> &'a BuyResponse_CheckoutInfo {
        <BuyResponse_CheckoutInfo as ::protobuf::Message>::default_instance()
    }
}

impl BuyResponse_CheckoutInfo {
    pub fn new() -> BuyResponse_CheckoutInfo {
        ::std::default::Default::default()
    }

    // optional .LineItem item = 3;


    pub fn get_item(&self) -> &LineItem {
        self.item.as_ref().unwrap_or_else(|| <LineItem as ::protobuf::Message>::default_instance())
    }

    // repeated .LineItem subItem = 4;


    pub fn get_subItem(&self) -> &[LineItem] {
        &self.subItem
    }

    // optional string deprecatedCheckoutUrl = 10;


    pub fn get_deprecatedCheckoutUrl(&self) -> &str {
        match self.deprecatedCheckoutUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string addInstrumentUrl = 11;


    pub fn get_addInstrumentUrl(&self) -> &str {
        match self.addInstrumentUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string footerHtml = 20;


    pub fn get_footerHtml(&self) -> &[::std::string::String] {
        &self.footerHtml
    }

    // repeated int32 eligibleInstrumentFamily = 31;


    pub fn get_eligibleInstrumentFamily(&self) -> &[i32] {
        &self.eligibleInstrumentFamily
    }

    // repeated string footnoteHtml = 36;


    pub fn get_footnoteHtml(&self) -> &[::std::string::String] {
        &self.footnoteHtml
    }

    // repeated .Instrument eligibleInstrument = 44;


    pub fn get_eligibleInstrument(&self) -> &[Instrument] {
        &self.eligibleInstrument
    }
}

impl ::protobuf::Message for BuyResponse_CheckoutInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subItem {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eligibleInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subItem)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deprecatedCheckoutUrl)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addInstrumentUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.eligibleInstrumentFamily)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.footnoteHtml)?;
                },
                44 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.eligibleInstrument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subItem {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.deprecatedCheckoutUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.addInstrumentUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.footerHtml {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.eligibleInstrumentFamily {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.footnoteHtml {
            my_size += ::protobuf::rt::string_size(36, &value);
        };
        for value in &self.eligibleInstrument {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subItem {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.deprecatedCheckoutUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.addInstrumentUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.footerHtml {
            os.write_string(20, &v)?;
        };
        for v in &self.eligibleInstrumentFamily {
            os.write_int32(31, *v)?;
        };
        for v in &self.footnoteHtml {
            os.write_string(36, &v)?;
        };
        for v in &self.eligibleInstrument {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyResponse_CheckoutInfo {
        BuyResponse_CheckoutInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "item",
                |m: &BuyResponse_CheckoutInfo| { &m.item },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LineItem>>(
                "subItem",
                |m: &BuyResponse_CheckoutInfo| { &m.subItem },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.subItem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deprecatedCheckoutUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.deprecatedCheckoutUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.deprecatedCheckoutUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addInstrumentUrl",
                |m: &BuyResponse_CheckoutInfo| { &m.addInstrumentUrl },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.addInstrumentUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footerHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eligibleInstrumentFamily",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrumentFamily },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footnoteHtml",
                |m: &BuyResponse_CheckoutInfo| { &m.footnoteHtml },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.footnoteHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "eligibleInstrument",
                |m: &BuyResponse_CheckoutInfo| { &m.eligibleInstrument },
                |m: &mut BuyResponse_CheckoutInfo| { &mut m.eligibleInstrument },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyResponse_CheckoutInfo>(
                "BuyResponse.CheckoutInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyResponse_CheckoutInfo {
        static instance: ::protobuf::rt::LazyV2<BuyResponse_CheckoutInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyResponse_CheckoutInfo::new)
    }
}

impl ::protobuf::Clear for BuyResponse_CheckoutInfo {
    fn clear(&mut self) {
        self.item.clear();
        self.subItem.clear();
        self.deprecatedCheckoutUrl.clear();
        self.addInstrumentUrl.clear();
        self.footerHtml.clear();
        self.eligibleInstrumentFamily.clear();
        self.footnoteHtml.clear();
        self.eligibleInstrument.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyResponse_CheckoutInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyResponse_CheckoutInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Challenge {
    // message fields
    pub addressChallenge: ::protobuf::SingularPtrField<AddressChallenge>,
    pub authenticationChallenge: ::protobuf::SingularPtrField<AuthenticationChallenge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Challenge {
    fn default() -> &'a Challenge {
        <Challenge as ::protobuf::Message>::default_instance()
    }
}

impl Challenge {
    pub fn new() -> Challenge {
        ::std::default::Default::default()
    }

    // optional .AddressChallenge addressChallenge = 1;


    pub fn get_addressChallenge(&self) -> &AddressChallenge {
        self.addressChallenge.as_ref().unwrap_or_else(|| <AddressChallenge as ::protobuf::Message>::default_instance())
    }

    // optional .AuthenticationChallenge authenticationChallenge = 2;


    pub fn get_authenticationChallenge(&self) -> &AuthenticationChallenge {
        self.authenticationChallenge.as_ref().unwrap_or_else(|| <AuthenticationChallenge as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Challenge {
    fn is_initialized(&self) -> bool {
        for v in &self.addressChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticationChallenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressChallenge)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticationChallenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addressChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authenticationChallenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addressChallenge.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authenticationChallenge.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Challenge {
        Challenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressChallenge>>(
                "addressChallenge",
                |m: &Challenge| { &m.addressChallenge },
                |m: &mut Challenge| { &mut m.addressChallenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationChallenge>>(
                "authenticationChallenge",
                |m: &Challenge| { &m.authenticationChallenge },
                |m: &mut Challenge| { &mut m.authenticationChallenge },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Challenge>(
                "Challenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Challenge {
        static instance: ::protobuf::rt::LazyV2<Challenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Challenge::new)
    }
}

impl ::protobuf::Clear for Challenge {
    fn clear(&mut self) {
        self.addressChallenge.clear();
        self.authenticationChallenge.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Challenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FormCheckbox {
    // message fields
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub checked: ::std::option::Option<bool>,
    pub required: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormCheckbox {
    fn default() -> &'a FormCheckbox {
        <FormCheckbox as ::protobuf::Message>::default_instance()
    }
}

impl FormCheckbox {
    pub fn new() -> FormCheckbox {
        ::std::default::Default::default()
    }

    // optional string description = 1;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool checked = 2;


    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }

    // optional bool required = 3;


    pub fn get_required(&self) -> bool {
        self.required.unwrap_or(false)
    }
}

impl ::protobuf::Message for FormCheckbox {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        if let Some(v) = self.required {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FormCheckbox {
        FormCheckbox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &FormCheckbox| { &m.description },
                |m: &mut FormCheckbox| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checked",
                |m: &FormCheckbox| { &m.checked },
                |m: &mut FormCheckbox| { &mut m.checked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "required",
                |m: &FormCheckbox| { &m.required },
                |m: &mut FormCheckbox| { &mut m.required },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FormCheckbox>(
                "FormCheckbox",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FormCheckbox {
        static instance: ::protobuf::rt::LazyV2<FormCheckbox> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FormCheckbox::new)
    }
}

impl ::protobuf::Clear for FormCheckbox {
    fn clear(&mut self) {
        self.description.clear();
        self.checked = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormCheckbox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormCheckbox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LineItem {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub description: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::SingularPtrField<Offer>,
    pub amount: ::protobuf::SingularPtrField<Money>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LineItem {
    fn default() -> &'a LineItem {
        <LineItem as ::protobuf::Message>::default_instance()
    }
}

impl LineItem {
    pub fn new() -> LineItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string description = 2;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Offer offer = 3;


    pub fn get_offer(&self) -> &Offer {
        self.offer.as_ref().unwrap_or_else(|| <Offer as ::protobuf::Message>::default_instance())
    }

    // optional .Money amount = 4;


    pub fn get_amount(&self) -> &Money {
        self.amount.as_ref().unwrap_or_else(|| <Money as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LineItem {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.offer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.offer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LineItem {
        LineItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LineItem| { &m.name },
                |m: &mut LineItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &LineItem| { &m.description },
                |m: &mut LineItem| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &LineItem| { &m.offer },
                |m: &mut LineItem| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Money>>(
                "amount",
                |m: &LineItem| { &m.amount },
                |m: &mut LineItem| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LineItem>(
                "LineItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LineItem {
        static instance: ::protobuf::rt::LazyV2<LineItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LineItem::new)
    }
}

impl ::protobuf::Clear for LineItem {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.offer.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Money {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Money {
    fn default() -> &'a Money {
        <Money as ::protobuf::Message>::default_instance()
    }
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;


    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Money {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Money {
        Money::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &Money| { &m.micros },
                |m: &mut Money| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &Money| { &m.currencyCode },
                |m: &mut Money| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedAmount",
                |m: &Money| { &m.formattedAmount },
                |m: &mut Money| { &mut m.formattedAmount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Money>(
                "Money",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Money {
        static instance: ::protobuf::rt::LazyV2<Money> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Money::new)
    }
}

impl ::protobuf::Clear for Money {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseNotificationResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub debugInfo: ::protobuf::SingularPtrField<DebugInfo>,
    pub localizedErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub purchaseId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseNotificationResponse {
    fn default() -> &'a PurchaseNotificationResponse {
        <PurchaseNotificationResponse as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseNotificationResponse {
    pub fn new() -> PurchaseNotificationResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional .DebugInfo debugInfo = 2;


    pub fn get_debugInfo(&self) -> &DebugInfo {
        self.debugInfo.as_ref().unwrap_or_else(|| <DebugInfo as ::protobuf::Message>::default_instance())
    }

    // optional string localizedErrorMessage = 3;


    pub fn get_localizedErrorMessage(&self) -> &str {
        match self.localizedErrorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseId = 4;


    pub fn get_purchaseId(&self) -> &str {
        match self.purchaseId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PurchaseNotificationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.debugInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debugInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localizedErrorMessage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.debugInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.localizedErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.purchaseId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.debugInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.localizedErrorMessage.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.purchaseId.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseNotificationResponse {
        PurchaseNotificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &PurchaseNotificationResponse| { &m.status },
                |m: &mut PurchaseNotificationResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugInfo>>(
                "debugInfo",
                |m: &PurchaseNotificationResponse| { &m.debugInfo },
                |m: &mut PurchaseNotificationResponse| { &mut m.debugInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localizedErrorMessage",
                |m: &PurchaseNotificationResponse| { &m.localizedErrorMessage },
                |m: &mut PurchaseNotificationResponse| { &mut m.localizedErrorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseId",
                |m: &PurchaseNotificationResponse| { &m.purchaseId },
                |m: &mut PurchaseNotificationResponse| { &mut m.purchaseId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseNotificationResponse>(
                "PurchaseNotificationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseNotificationResponse {
        static instance: ::protobuf::rt::LazyV2<PurchaseNotificationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseNotificationResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseNotificationResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.debugInfo.clear();
        self.localizedErrorMessage.clear();
        self.purchaseId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseNotificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseNotificationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseStatusResponse {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub statusMsg: ::protobuf::SingularField<::std::string::String>,
    pub statusTitle: ::protobuf::SingularField<::std::string::String>,
    pub briefMessage: ::protobuf::SingularField<::std::string::String>,
    pub infoUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub rejectedInstrument: ::protobuf::SingularPtrField<Instrument>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseStatusResponse {
    fn default() -> &'a PurchaseStatusResponse {
        <PurchaseStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseStatusResponse {
    pub fn new() -> PurchaseStatusResponse {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional string statusMsg = 2;


    pub fn get_statusMsg(&self) -> &str {
        match self.statusMsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string statusTitle = 3;


    pub fn get_statusTitle(&self) -> &str {
        match self.statusTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string briefMessage = 4;


    pub fn get_briefMessage(&self) -> &str {
        match self.briefMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string infoUrl = 5;


    pub fn get_infoUrl(&self) -> &str {
        match self.infoUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .LibraryUpdate libraryUpdate = 6;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }

    // optional .Instrument rejectedInstrument = 7;


    pub fn get_rejectedInstrument(&self) -> &Instrument {
        self.rejectedInstrument.as_ref().unwrap_or_else(|| <Instrument as ::protobuf::Message>::default_instance())
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 8;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PurchaseStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rejectedInstrument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusMsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.statusTitle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.briefMessage)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.infoUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rejectedInstrument)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.statusMsg.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.statusTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.briefMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.infoUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rejectedInstrument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.statusMsg.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.statusTitle.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.briefMessage.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.infoUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rejectedInstrument.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseStatusResponse {
        PurchaseStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &PurchaseStatusResponse| { &m.status },
                |m: &mut PurchaseStatusResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statusMsg",
                |m: &PurchaseStatusResponse| { &m.statusMsg },
                |m: &mut PurchaseStatusResponse| { &mut m.statusMsg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statusTitle",
                |m: &PurchaseStatusResponse| { &m.statusTitle },
                |m: &mut PurchaseStatusResponse| { &mut m.statusTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "briefMessage",
                |m: &PurchaseStatusResponse| { &m.briefMessage },
                |m: &mut PurchaseStatusResponse| { &mut m.briefMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "infoUrl",
                |m: &PurchaseStatusResponse| { &m.infoUrl },
                |m: &mut PurchaseStatusResponse| { &mut m.infoUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &PurchaseStatusResponse| { &m.libraryUpdate },
                |m: &mut PurchaseStatusResponse| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instrument>>(
                "rejectedInstrument",
                |m: &PurchaseStatusResponse| { &m.rejectedInstrument },
                |m: &mut PurchaseStatusResponse| { &mut m.rejectedInstrument },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &PurchaseStatusResponse| { &m.appDeliveryData },
                |m: &mut PurchaseStatusResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseStatusResponse>(
                "PurchaseStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseStatusResponse {
        static instance: ::protobuf::rt::LazyV2<PurchaseStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseStatusResponse::new)
    }
}

impl ::protobuf::Clear for PurchaseStatusResponse {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.statusMsg.clear();
        self.statusTitle.clear();
        self.briefMessage.clear();
        self.infoUrl.clear();
        self.libraryUpdate.clear();
        self.rejectedInstrument.clear();
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeliveryResponse {
    // message fields
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeliveryResponse {
    fn default() -> &'a DeliveryResponse {
        <DeliveryResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeliveryResponse {
    pub fn new() -> DeliveryResponse {
        ::std::default::Default::default()
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 2;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for DeliveryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeliveryResponse {
        DeliveryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &DeliveryResponse| { &m.appDeliveryData },
                |m: &mut DeliveryResponse| { &mut m.appDeliveryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeliveryResponse>(
                "DeliveryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeliveryResponse {
        static instance: ::protobuf::rt::LazyV2<DeliveryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeliveryResponse::new)
    }
}

impl ::protobuf::Clear for DeliveryResponse {
    fn clear(&mut self) {
        self.appDeliveryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeliveryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeliveryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Docid {
    // message fields
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub backend: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Docid {
    fn default() -> &'a Docid {
        <Docid as ::protobuf::Message>::default_instance()
    }
}

impl Docid {
    pub fn new() -> Docid {
        ::std::default::Default::default()
    }

    // optional string backendDocid = 1;


    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional int32 backend = 3;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }
}

impl ::protobuf::Message for Docid {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backendDocid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.backend {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Docid {
        Docid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendDocid",
                |m: &Docid| { &m.backendDocid },
                |m: &mut Docid| { &mut m.backendDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &Docid| { &m.field_type },
                |m: &mut Docid| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &Docid| { &m.backend },
                |m: &mut Docid| { &mut m.backend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Docid>(
                "Docid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Docid {
        static instance: ::protobuf::rt::LazyV2<Docid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Docid::new)
    }
}

impl ::protobuf::Clear for Docid {
    fn clear(&mut self) {
        self.backendDocid.clear();
        self.field_type = ::std::option::Option::None;
        self.backend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Docid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Docid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Install {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub version: ::std::option::Option<i32>,
    pub bundled: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Install {
    fn default() -> &'a Install {
        <Install as ::protobuf::Message>::default_instance()
    }
}

impl Install {
    pub fn new() -> Install {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 1;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional bool bundled = 3;


    pub fn get_bundled(&self) -> bool {
        self.bundled.unwrap_or(false)
    }
}

impl ::protobuf::Message for Install {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bundled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bundled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bundled {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Install {
        Install::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &Install| { &m.androidId },
                |m: &mut Install| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &Install| { &m.version },
                |m: &mut Install| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bundled",
                |m: &Install| { &m.bundled },
                |m: &mut Install| { &mut m.bundled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Install>(
                "Install",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Install {
        static instance: ::protobuf::rt::LazyV2<Install> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Install::new)
    }
}

impl ::protobuf::Clear for Install {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.bundled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Install {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Install {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Offer {
    // message fields
    pub micros: ::std::option::Option<i64>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub formattedAmount: ::protobuf::SingularField<::std::string::String>,
    pub convertedPrice: ::protobuf::RepeatedField<Offer>,
    pub checkoutFlowRequired: ::std::option::Option<bool>,
    pub fullPriceMicros: ::std::option::Option<i64>,
    pub formattedFullAmount: ::protobuf::SingularField<::std::string::String>,
    pub offerType: ::std::option::Option<i32>,
    pub rentalTerms: ::protobuf::SingularPtrField<RentalTerms>,
    pub onSaleDate: ::std::option::Option<i64>,
    pub promotionLabel: ::protobuf::RepeatedField<::std::string::String>,
    pub subscriptionTerms: ::protobuf::SingularPtrField<SubscriptionTerms>,
    pub formattedName: ::protobuf::SingularField<::std::string::String>,
    pub formattedDescription: ::protobuf::SingularField<::std::string::String>,
    pub sale: ::std::option::Option<bool>,
    pub message: ::protobuf::SingularField<::std::string::String>,
    pub saleEndTimestamp: ::std::option::Option<i64>,
    pub saleMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Offer {
    fn default() -> &'a Offer {
        <Offer as ::protobuf::Message>::default_instance()
    }
}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    // optional int64 micros = 1;


    pub fn get_micros(&self) -> i64 {
        self.micros.unwrap_or(0)
    }

    // optional string currencyCode = 2;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedAmount = 3;


    pub fn get_formattedAmount(&self) -> &str {
        match self.formattedAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Offer convertedPrice = 4;


    pub fn get_convertedPrice(&self) -> &[Offer] {
        &self.convertedPrice
    }

    // optional bool checkoutFlowRequired = 5;


    pub fn get_checkoutFlowRequired(&self) -> bool {
        self.checkoutFlowRequired.unwrap_or(false)
    }

    // optional int64 fullPriceMicros = 6;


    pub fn get_fullPriceMicros(&self) -> i64 {
        self.fullPriceMicros.unwrap_or(0)
    }

    // optional string formattedFullAmount = 7;


    pub fn get_formattedFullAmount(&self) -> &str {
        match self.formattedFullAmount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 offerType = 8;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional .RentalTerms rentalTerms = 9;


    pub fn get_rentalTerms(&self) -> &RentalTerms {
        self.rentalTerms.as_ref().unwrap_or_else(|| <RentalTerms as ::protobuf::Message>::default_instance())
    }

    // optional int64 onSaleDate = 10;


    pub fn get_onSaleDate(&self) -> i64 {
        self.onSaleDate.unwrap_or(0)
    }

    // repeated string promotionLabel = 11;


    pub fn get_promotionLabel(&self) -> &[::std::string::String] {
        &self.promotionLabel
    }

    // optional .SubscriptionTerms subscriptionTerms = 12;


    pub fn get_subscriptionTerms(&self) -> &SubscriptionTerms {
        self.subscriptionTerms.as_ref().unwrap_or_else(|| <SubscriptionTerms as ::protobuf::Message>::default_instance())
    }

    // optional string formattedName = 13;


    pub fn get_formattedName(&self) -> &str {
        match self.formattedName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string formattedDescription = 14;


    pub fn get_formattedDescription(&self) -> &str {
        match self.formattedDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool sale = 22;


    pub fn get_sale(&self) -> bool {
        self.sale.unwrap_or(false)
    }

    // optional string message = 26;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 saleEndTimestamp = 30;


    pub fn get_saleEndTimestamp(&self) -> i64 {
        self.saleEndTimestamp.unwrap_or(0)
    }

    // optional string saleMessage = 31;


    pub fn get_saleMessage(&self) -> &str {
        match self.saleMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        for v in &self.convertedPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.micros = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedAmount)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.convertedPrice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checkoutFlowRequired = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fullPriceMicros = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedFullAmount)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rentalTerms)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.onSaleDate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.promotionLabel)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionTerms)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedName)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formattedDescription)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sale = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.saleEndTimestamp = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.saleMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.micros {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.convertedPrice {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.checkoutFlowRequired {
            my_size += 2;
        }
        if let Some(v) = self.fullPriceMicros {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.formattedFullAmount.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.onSaleDate {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.promotionLabel {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.subscriptionTerms.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.formattedName.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.formattedDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.sale {
            my_size += 3;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.saleEndTimestamp {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.saleMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.micros {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.formattedAmount.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.convertedPrice {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.checkoutFlowRequired {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.fullPriceMicros {
            os.write_int64(6, v)?;
        }
        if let Some(ref v) = self.formattedFullAmount.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.rentalTerms.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.onSaleDate {
            os.write_int64(10, v)?;
        }
        for v in &self.promotionLabel {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.subscriptionTerms.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.formattedName.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.formattedDescription.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.sale {
            os.write_bool(22, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(26, &v)?;
        }
        if let Some(v) = self.saleEndTimestamp {
            os.write_int64(30, v)?;
        }
        if let Some(ref v) = self.saleMessage.as_ref() {
            os.write_string(31, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "micros",
                |m: &Offer| { &m.micros },
                |m: &mut Offer| { &mut m.micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &Offer| { &m.currencyCode },
                |m: &mut Offer| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedAmount",
                |m: &Offer| { &m.formattedAmount },
                |m: &mut Offer| { &mut m.formattedAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "convertedPrice",
                |m: &Offer| { &m.convertedPrice },
                |m: &mut Offer| { &mut m.convertedPrice },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checkoutFlowRequired",
                |m: &Offer| { &m.checkoutFlowRequired },
                |m: &mut Offer| { &mut m.checkoutFlowRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fullPriceMicros",
                |m: &Offer| { &m.fullPriceMicros },
                |m: &mut Offer| { &mut m.fullPriceMicros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedFullAmount",
                |m: &Offer| { &m.formattedFullAmount },
                |m: &mut Offer| { &mut m.formattedFullAmount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &Offer| { &m.offerType },
                |m: &mut Offer| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RentalTerms>>(
                "rentalTerms",
                |m: &Offer| { &m.rentalTerms },
                |m: &mut Offer| { &mut m.rentalTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "onSaleDate",
                |m: &Offer| { &m.onSaleDate },
                |m: &mut Offer| { &mut m.onSaleDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "promotionLabel",
                |m: &Offer| { &m.promotionLabel },
                |m: &mut Offer| { &mut m.promotionLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionTerms>>(
                "subscriptionTerms",
                |m: &Offer| { &m.subscriptionTerms },
                |m: &mut Offer| { &mut m.subscriptionTerms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedName",
                |m: &Offer| { &m.formattedName },
                |m: &mut Offer| { &mut m.formattedName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formattedDescription",
                |m: &Offer| { &m.formattedDescription },
                |m: &mut Offer| { &mut m.formattedDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sale",
                |m: &Offer| { &m.sale },
                |m: &mut Offer| { &mut m.sale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Offer| { &m.message },
                |m: &mut Offer| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "saleEndTimestamp",
                |m: &Offer| { &m.saleEndTimestamp },
                |m: &mut Offer| { &mut m.saleEndTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saleMessage",
                |m: &Offer| { &m.saleMessage },
                |m: &mut Offer| { &mut m.saleMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Offer>(
                "Offer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Offer {
        static instance: ::protobuf::rt::LazyV2<Offer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Offer::new)
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.micros = ::std::option::Option::None;
        self.currencyCode.clear();
        self.formattedAmount.clear();
        self.convertedPrice.clear();
        self.checkoutFlowRequired = ::std::option::Option::None;
        self.fullPriceMicros = ::std::option::Option::None;
        self.formattedFullAmount.clear();
        self.offerType = ::std::option::Option::None;
        self.rentalTerms.clear();
        self.onSaleDate = ::std::option::Option::None;
        self.promotionLabel.clear();
        self.subscriptionTerms.clear();
        self.formattedName.clear();
        self.formattedDescription.clear();
        self.sale = ::std::option::Option::None;
        self.message.clear();
        self.saleEndTimestamp = ::std::option::Option::None;
        self.saleMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Offer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct OwnershipInfo {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OwnershipInfo {
    fn default() -> &'a OwnershipInfo {
        <OwnershipInfo as ::protobuf::Message>::default_instance()
    }
}

impl OwnershipInfo {
    pub fn new() -> OwnershipInfo {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;


    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 validUntilTimestampMsec = 2;


    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;


    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 refundTimeoutTimestampMsec = 4;


    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 5;


    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for OwnershipInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OwnershipInfo {
        OwnershipInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initiationTimestampMsec",
                |m: &OwnershipInfo| { &m.initiationTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.initiationTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "validUntilTimestampMsec",
                |m: &OwnershipInfo| { &m.validUntilTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.validUntilTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoRenewing",
                |m: &OwnershipInfo| { &m.autoRenewing },
                |m: &mut OwnershipInfo| { &mut m.autoRenewing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutTimestampMsec",
                |m: &OwnershipInfo| { &m.refundTimeoutTimestampMsec },
                |m: &mut OwnershipInfo| { &mut m.refundTimeoutTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postDeliveryRefundWindowMsec",
                |m: &OwnershipInfo| { &m.postDeliveryRefundWindowMsec },
                |m: &mut OwnershipInfo| { &mut m.postDeliveryRefundWindowMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OwnershipInfo>(
                "OwnershipInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OwnershipInfo {
        static instance: ::protobuf::rt::LazyV2<OwnershipInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OwnershipInfo::new)
    }
}

impl ::protobuf::Clear for OwnershipInfo {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OwnershipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnershipInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RentalTerms {
    // message fields
    pub grantPeriodSeconds: ::std::option::Option<i32>,
    pub activatePeriodSeconds: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RentalTerms {
    fn default() -> &'a RentalTerms {
        <RentalTerms as ::protobuf::Message>::default_instance()
    }
}

impl RentalTerms {
    pub fn new() -> RentalTerms {
        ::std::default::Default::default()
    }

    // optional int32 grantPeriodSeconds = 1;


    pub fn get_grantPeriodSeconds(&self) -> i32 {
        self.grantPeriodSeconds.unwrap_or(0)
    }

    // optional int32 activatePeriodSeconds = 2;


    pub fn get_activatePeriodSeconds(&self) -> i32 {
        self.activatePeriodSeconds.unwrap_or(0)
    }
}

impl ::protobuf::Message for RentalTerms {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.grantPeriodSeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activatePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.grantPeriodSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activatePeriodSeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.grantPeriodSeconds {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.activatePeriodSeconds {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RentalTerms {
        RentalTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "grantPeriodSeconds",
                |m: &RentalTerms| { &m.grantPeriodSeconds },
                |m: &mut RentalTerms| { &mut m.grantPeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "activatePeriodSeconds",
                |m: &RentalTerms| { &m.activatePeriodSeconds },
                |m: &mut RentalTerms| { &mut m.activatePeriodSeconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RentalTerms>(
                "RentalTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RentalTerms {
        static instance: ::protobuf::rt::LazyV2<RentalTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RentalTerms::new)
    }
}

impl ::protobuf::Clear for RentalTerms {
    fn clear(&mut self) {
        self.grantPeriodSeconds = ::std::option::Option::None;
        self.activatePeriodSeconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RentalTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RentalTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscriptionTerms {
    // message fields
    pub recurringPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    pub trialPeriod: ::protobuf::SingularPtrField<TimePeriod>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionTerms {
    fn default() -> &'a SubscriptionTerms {
        <SubscriptionTerms as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionTerms {
    pub fn new() -> SubscriptionTerms {
        ::std::default::Default::default()
    }

    // optional .TimePeriod recurringPeriod = 1;


    pub fn get_recurringPeriod(&self) -> &TimePeriod {
        self.recurringPeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }

    // optional .TimePeriod trialPeriod = 2;


    pub fn get_trialPeriod(&self) -> &TimePeriod {
        self.trialPeriod.as_ref().unwrap_or_else(|| <TimePeriod as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SubscriptionTerms {
    fn is_initialized(&self) -> bool {
        for v in &self.recurringPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trialPeriod {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recurringPeriod)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trialPeriod)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recurringPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trialPeriod.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recurringPeriod.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trialPeriod.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionTerms {
        SubscriptionTerms::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "recurringPeriod",
                |m: &SubscriptionTerms| { &m.recurringPeriod },
                |m: &mut SubscriptionTerms| { &mut m.recurringPeriod },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimePeriod>>(
                "trialPeriod",
                |m: &SubscriptionTerms| { &m.trialPeriod },
                |m: &mut SubscriptionTerms| { &mut m.trialPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscriptionTerms>(
                "SubscriptionTerms",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionTerms {
        static instance: ::protobuf::rt::LazyV2<SubscriptionTerms> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscriptionTerms::new)
    }
}

impl ::protobuf::Clear for SubscriptionTerms {
    fn clear(&mut self) {
        self.recurringPeriod.clear();
        self.trialPeriod.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionTerms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionTerms {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TimePeriod {
    // message fields
    pub unit: ::std::option::Option<i32>,
    pub count: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimePeriod {
    fn default() -> &'a TimePeriod {
        <TimePeriod as ::protobuf::Message>::default_instance()
    }
}

impl TimePeriod {
    pub fn new() -> TimePeriod {
        ::std::default::Default::default()
    }

    // optional int32 unit = 1;


    pub fn get_unit(&self) -> i32 {
        self.unit.unwrap_or(0)
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
}

impl ::protobuf::Message for TimePeriod {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimePeriod {
        TimePeriod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unit",
                |m: &TimePeriod| { &m.unit },
                |m: &mut TimePeriod| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &TimePeriod| { &m.count },
                |m: &mut TimePeriod| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimePeriod>(
                "TimePeriod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimePeriod {
        static instance: ::protobuf::rt::LazyV2<TimePeriod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimePeriod::new)
    }
}

impl ::protobuf::Clear for TimePeriod {
    fn clear(&mut self) {
        self.unit = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimePeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimePeriod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingAddressSpec {
    // message fields
    pub billingAddressType: ::std::option::Option<i32>,
    pub requiredField: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingAddressSpec {
    fn default() -> &'a BillingAddressSpec {
        <BillingAddressSpec as ::protobuf::Message>::default_instance()
    }
}

impl BillingAddressSpec {
    pub fn new() -> BillingAddressSpec {
        ::std::default::Default::default()
    }

    // optional int32 billingAddressType = 1;


    pub fn get_billingAddressType(&self) -> i32 {
        self.billingAddressType.unwrap_or(0)
    }

    // repeated int32 requiredField = 2;


    pub fn get_requiredField(&self) -> &[i32] {
        &self.requiredField
    }
}

impl ::protobuf::Message for BillingAddressSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.billingAddressType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.requiredField)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.billingAddressType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredField {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.billingAddressType {
            os.write_int32(1, v)?;
        }
        for v in &self.requiredField {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingAddressSpec {
        BillingAddressSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "billingAddressType",
                |m: &BillingAddressSpec| { &m.billingAddressType },
                |m: &mut BillingAddressSpec| { &mut m.billingAddressType },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "requiredField",
                |m: &BillingAddressSpec| { &m.requiredField },
                |m: &mut BillingAddressSpec| { &mut m.requiredField },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingAddressSpec>(
                "BillingAddressSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingAddressSpec {
        static instance: ::protobuf::rt::LazyV2<BillingAddressSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingAddressSpec::new)
    }
}

impl ::protobuf::Clear for BillingAddressSpec {
    fn clear(&mut self) {
        self.billingAddressType = ::std::option::Option::None;
        self.requiredField.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingAddressSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingAddressSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingCredentials {
    // message fields
    pub value: ::protobuf::SingularField<::std::string::String>,
    pub expiration: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingCredentials {
    fn default() -> &'a CarrierBillingCredentials {
        <CarrierBillingCredentials as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingCredentials {
    pub fn new() -> CarrierBillingCredentials {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 expiration = 2;


    pub fn get_expiration(&self) -> i64 {
        self.expiration.unwrap_or(0)
    }
}

impl ::protobuf::Message for CarrierBillingCredentials {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingCredentials {
        CarrierBillingCredentials::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CarrierBillingCredentials| { &m.value },
                |m: &mut CarrierBillingCredentials| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiration",
                |m: &CarrierBillingCredentials| { &m.expiration },
                |m: &mut CarrierBillingCredentials| { &mut m.expiration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingCredentials>(
                "CarrierBillingCredentials",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingCredentials {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingCredentials> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingCredentials::new)
    }
}

impl ::protobuf::Clear for CarrierBillingCredentials {
    fn clear(&mut self) {
        self.value.clear();
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingCredentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingCredentials {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingInstrument {
    // message fields
    pub instrumentKey: ::protobuf::SingularField<::std::string::String>,
    pub accountType: ::protobuf::SingularField<::std::string::String>,
    pub currencyCode: ::protobuf::SingularField<::std::string::String>,
    pub transactionLimit: ::std::option::Option<i64>,
    pub subscriberIdentifier: ::protobuf::SingularField<::std::string::String>,
    pub encryptedSubscriberInfo: ::protobuf::SingularPtrField<EncryptedSubscriberInfo>,
    pub credentials: ::protobuf::SingularPtrField<CarrierBillingCredentials>,
    pub acceptedCarrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingInstrument {
    fn default() -> &'a CarrierBillingInstrument {
        <CarrierBillingInstrument as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingInstrument {
    pub fn new() -> CarrierBillingInstrument {
        ::std::default::Default::default()
    }

    // optional string instrumentKey = 1;


    pub fn get_instrumentKey(&self) -> &str {
        match self.instrumentKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string accountType = 2;


    pub fn get_accountType(&self) -> &str {
        match self.accountType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string currencyCode = 3;


    pub fn get_currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 transactionLimit = 4;


    pub fn get_transactionLimit(&self) -> i64 {
        self.transactionLimit.unwrap_or(0)
    }

    // optional string subscriberIdentifier = 5;


    pub fn get_subscriberIdentifier(&self) -> &str {
        match self.subscriberIdentifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .EncryptedSubscriberInfo encryptedSubscriberInfo = 6;


    pub fn get_encryptedSubscriberInfo(&self) -> &EncryptedSubscriberInfo {
        self.encryptedSubscriberInfo.as_ref().unwrap_or_else(|| <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierBillingCredentials credentials = 7;


    pub fn get_credentials(&self) -> &CarrierBillingCredentials {
        self.credentials.as_ref().unwrap_or_else(|| <CarrierBillingCredentials as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierTos acceptedCarrierTos = 8;


    pub fn get_acceptedCarrierTos(&self) -> &CarrierTos {
        self.acceptedCarrierTos.as_ref().unwrap_or_else(|| <CarrierTos as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for CarrierBillingInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedSubscriberInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptedCarrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.currencyCode)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transactionLimit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscriberIdentifier)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryptedSubscriberInfo)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.credentials)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acceptedCarrierTos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.accountType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.transactionLimit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acceptedCarrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentKey.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.accountType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.currencyCode.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.transactionLimit {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.subscriberIdentifier.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.encryptedSubscriberInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.credentials.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acceptedCarrierTos.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrument {
        CarrierBillingInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentKey",
                |m: &CarrierBillingInstrument| { &m.instrumentKey },
                |m: &mut CarrierBillingInstrument| { &mut m.instrumentKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountType",
                |m: &CarrierBillingInstrument| { &m.accountType },
                |m: &mut CarrierBillingInstrument| { &mut m.accountType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currencyCode",
                |m: &CarrierBillingInstrument| { &m.currencyCode },
                |m: &mut CarrierBillingInstrument| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "transactionLimit",
                |m: &CarrierBillingInstrument| { &m.transactionLimit },
                |m: &mut CarrierBillingInstrument| { &mut m.transactionLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriberIdentifier",
                |m: &CarrierBillingInstrument| { &m.subscriberIdentifier },
                |m: &mut CarrierBillingInstrument| { &mut m.subscriberIdentifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedSubscriberInfo>>(
                "encryptedSubscriberInfo",
                |m: &CarrierBillingInstrument| { &m.encryptedSubscriberInfo },
                |m: &mut CarrierBillingInstrument| { &mut m.encryptedSubscriberInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingCredentials>>(
                "credentials",
                |m: &CarrierBillingInstrument| { &m.credentials },
                |m: &mut CarrierBillingInstrument| { &mut m.credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>>(
                "acceptedCarrierTos",
                |m: &CarrierBillingInstrument| { &m.acceptedCarrierTos },
                |m: &mut CarrierBillingInstrument| { &mut m.acceptedCarrierTos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingInstrument>(
                "CarrierBillingInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrument {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingInstrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingInstrument::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrument {
    fn clear(&mut self) {
        self.instrumentKey.clear();
        self.accountType.clear();
        self.currencyCode.clear();
        self.transactionLimit = ::std::option::Option::None;
        self.subscriberIdentifier.clear();
        self.encryptedSubscriberInfo.clear();
        self.credentials.clear();
        self.acceptedCarrierTos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingInstrumentStatus {
    // message fields
    pub carrierTos: ::protobuf::SingularPtrField<CarrierTos>,
    pub associationRequired: ::std::option::Option<bool>,
    pub passwordRequired: ::std::option::Option<bool>,
    pub carrierPasswordPrompt: ::protobuf::SingularPtrField<PasswordPrompt>,
    pub apiVersion: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingInstrumentStatus {
    fn default() -> &'a CarrierBillingInstrumentStatus {
        <CarrierBillingInstrumentStatus as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingInstrumentStatus {
    pub fn new() -> CarrierBillingInstrumentStatus {
        ::std::default::Default::default()
    }

    // optional .CarrierTos carrierTos = 1;


    pub fn get_carrierTos(&self) -> &CarrierTos {
        self.carrierTos.as_ref().unwrap_or_else(|| <CarrierTos as ::protobuf::Message>::default_instance())
    }

    // optional bool associationRequired = 2;


    pub fn get_associationRequired(&self) -> bool {
        self.associationRequired.unwrap_or(false)
    }

    // optional bool passwordRequired = 3;


    pub fn get_passwordRequired(&self) -> bool {
        self.passwordRequired.unwrap_or(false)
    }

    // optional .PasswordPrompt carrierPasswordPrompt = 4;


    pub fn get_carrierPasswordPrompt(&self) -> &PasswordPrompt {
        self.carrierPasswordPrompt.as_ref().unwrap_or_else(|| <PasswordPrompt as ::protobuf::Message>::default_instance())
    }

    // optional int32 apiVersion = 5;


    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string name = 6;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierBillingInstrumentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierPasswordPrompt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierTos)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.associationRequired = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passwordRequired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierPasswordPrompt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.carrierTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.associationRequired {
            my_size += 2;
        }
        if let Some(v) = self.passwordRequired {
            my_size += 2;
        }
        if let Some(ref v) = self.carrierPasswordPrompt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.carrierTos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.associationRequired {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.passwordRequired {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.carrierPasswordPrompt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingInstrumentStatus {
        CarrierBillingInstrumentStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTos>>(
                "carrierTos",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierTos },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "associationRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.associationRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.associationRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passwordRequired",
                |m: &CarrierBillingInstrumentStatus| { &m.passwordRequired },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.passwordRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PasswordPrompt>>(
                "carrierPasswordPrompt",
                |m: &CarrierBillingInstrumentStatus| { &m.carrierPasswordPrompt },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.carrierPasswordPrompt },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "apiVersion",
                |m: &CarrierBillingInstrumentStatus| { &m.apiVersion },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CarrierBillingInstrumentStatus| { &m.name },
                |m: &mut CarrierBillingInstrumentStatus| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingInstrumentStatus>(
                "CarrierBillingInstrumentStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingInstrumentStatus {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingInstrumentStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingInstrumentStatus::new)
    }
}

impl ::protobuf::Clear for CarrierBillingInstrumentStatus {
    fn clear(&mut self) {
        self.carrierTos.clear();
        self.associationRequired = ::std::option::Option::None;
        self.passwordRequired = ::std::option::Option::None;
        self.carrierPasswordPrompt.clear();
        self.apiVersion = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingInstrumentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingInstrumentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierTos {
    // message fields
    pub dcbTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub piiTos: ::protobuf::SingularPtrField<CarrierTosEntry>,
    pub needsDcbTosAcceptance: ::std::option::Option<bool>,
    pub needsPiiTosAcceptance: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierTos {
    fn default() -> &'a CarrierTos {
        <CarrierTos as ::protobuf::Message>::default_instance()
    }
}

impl CarrierTos {
    pub fn new() -> CarrierTos {
        ::std::default::Default::default()
    }

    // optional .CarrierTosEntry dcbTos = 1;


    pub fn get_dcbTos(&self) -> &CarrierTosEntry {
        self.dcbTos.as_ref().unwrap_or_else(|| <CarrierTosEntry as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierTosEntry piiTos = 2;


    pub fn get_piiTos(&self) -> &CarrierTosEntry {
        self.piiTos.as_ref().unwrap_or_else(|| <CarrierTosEntry as ::protobuf::Message>::default_instance())
    }

    // optional bool needsDcbTosAcceptance = 3;


    pub fn get_needsDcbTosAcceptance(&self) -> bool {
        self.needsDcbTosAcceptance.unwrap_or(false)
    }

    // optional bool needsPiiTosAcceptance = 4;


    pub fn get_needsPiiTosAcceptance(&self) -> bool {
        self.needsPiiTosAcceptance.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierTos {
    fn is_initialized(&self) -> bool {
        for v in &self.dcbTos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.piiTos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dcbTos)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.piiTos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsDcbTosAcceptance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needsPiiTosAcceptance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dcbTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.piiTos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            my_size += 2;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dcbTos.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.piiTos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.needsDcbTosAcceptance {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.needsPiiTosAcceptance {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTos {
        CarrierTos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>>(
                "dcbTos",
                |m: &CarrierTos| { &m.dcbTos },
                |m: &mut CarrierTos| { &mut m.dcbTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierTosEntry>>(
                "piiTos",
                |m: &CarrierTos| { &m.piiTos },
                |m: &mut CarrierTos| { &mut m.piiTos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needsDcbTosAcceptance",
                |m: &CarrierTos| { &m.needsDcbTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsDcbTosAcceptance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needsPiiTosAcceptance",
                |m: &CarrierTos| { &m.needsPiiTosAcceptance },
                |m: &mut CarrierTos| { &mut m.needsPiiTosAcceptance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierTos>(
                "CarrierTos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTos {
        static instance: ::protobuf::rt::LazyV2<CarrierTos> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierTos::new)
    }
}

impl ::protobuf::Clear for CarrierTos {
    fn clear(&mut self) {
        self.dcbTos.clear();
        self.piiTos.clear();
        self.needsDcbTosAcceptance = ::std::option::Option::None;
        self.needsPiiTosAcceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTos {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierTosEntry {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierTosEntry {
    fn default() -> &'a CarrierTosEntry {
        <CarrierTosEntry as ::protobuf::Message>::default_instance()
    }
}

impl CarrierTosEntry {
    pub fn new() -> CarrierTosEntry {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CarrierTosEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierTosEntry {
        CarrierTosEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CarrierTosEntry| { &m.url },
                |m: &mut CarrierTosEntry| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &CarrierTosEntry| { &m.version },
                |m: &mut CarrierTosEntry| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierTosEntry>(
                "CarrierTosEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierTosEntry {
        static instance: ::protobuf::rt::LazyV2<CarrierTosEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierTosEntry::new)
    }
}

impl ::protobuf::Clear for CarrierTosEntry {
    fn clear(&mut self) {
        self.url.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierTosEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierTosEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CreditCardInstrument {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub escrowHandle: ::protobuf::SingularField<::std::string::String>,
    pub lastDigits: ::protobuf::SingularField<::std::string::String>,
    pub expirationMonth: ::std::option::Option<i32>,
    pub expirationYear: ::std::option::Option<i32>,
    pub escrowEfeParam: ::protobuf::RepeatedField<EfeParam>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreditCardInstrument {
    fn default() -> &'a CreditCardInstrument {
        <CreditCardInstrument as ::protobuf::Message>::default_instance()
    }
}

impl CreditCardInstrument {
    pub fn new() -> CreditCardInstrument {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string escrowHandle = 2;


    pub fn get_escrowHandle(&self) -> &str {
        match self.escrowHandle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string lastDigits = 3;


    pub fn get_lastDigits(&self) -> &str {
        match self.lastDigits.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 expirationMonth = 4;


    pub fn get_expirationMonth(&self) -> i32 {
        self.expirationMonth.unwrap_or(0)
    }

    // optional int32 expirationYear = 5;


    pub fn get_expirationYear(&self) -> i32 {
        self.expirationYear.unwrap_or(0)
    }

    // repeated .EfeParam escrowEfeParam = 6;


    pub fn get_escrowEfeParam(&self) -> &[EfeParam] {
        &self.escrowEfeParam
    }
}

impl ::protobuf::Message for CreditCardInstrument {
    fn is_initialized(&self) -> bool {
        for v in &self.escrowEfeParam {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.escrowHandle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastDigits)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationMonth = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expirationYear = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.escrowEfeParam)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.escrowHandle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expirationMonth {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expirationYear {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.escrowEfeParam {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.escrowHandle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastDigits.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.expirationMonth {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.expirationYear {
            os.write_int32(5, v)?;
        }
        for v in &self.escrowEfeParam {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreditCardInstrument {
        CreditCardInstrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CreditCardInstrument| { &m.field_type },
                |m: &mut CreditCardInstrument| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "escrowHandle",
                |m: &CreditCardInstrument| { &m.escrowHandle },
                |m: &mut CreditCardInstrument| { &mut m.escrowHandle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastDigits",
                |m: &CreditCardInstrument| { &m.lastDigits },
                |m: &mut CreditCardInstrument| { &mut m.lastDigits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expirationMonth",
                |m: &CreditCardInstrument| { &m.expirationMonth },
                |m: &mut CreditCardInstrument| { &mut m.expirationMonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expirationYear",
                |m: &CreditCardInstrument| { &m.expirationYear },
                |m: &mut CreditCardInstrument| { &mut m.expirationYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EfeParam>>(
                "escrowEfeParam",
                |m: &CreditCardInstrument| { &m.escrowEfeParam },
                |m: &mut CreditCardInstrument| { &mut m.escrowEfeParam },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreditCardInstrument>(
                "CreditCardInstrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreditCardInstrument {
        static instance: ::protobuf::rt::LazyV2<CreditCardInstrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreditCardInstrument::new)
    }
}

impl ::protobuf::Clear for CreditCardInstrument {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.escrowHandle.clear();
        self.lastDigits.clear();
        self.expirationMonth = ::std::option::Option::None;
        self.expirationYear = ::std::option::Option::None;
        self.escrowEfeParam.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreditCardInstrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreditCardInstrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EfeParam {
    // message fields
    pub key: ::std::option::Option<i32>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EfeParam {
    fn default() -> &'a EfeParam {
        <EfeParam as ::protobuf::Message>::default_instance()
    }
}

impl EfeParam {
    pub fn new() -> EfeParam {
        ::std::default::Default::default()
    }

    // optional int32 key = 1;


    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EfeParam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EfeParam {
        EfeParam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key",
                |m: &EfeParam| { &m.key },
                |m: &mut EfeParam| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &EfeParam| { &m.value },
                |m: &mut EfeParam| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EfeParam>(
                "EfeParam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EfeParam {
        static instance: ::protobuf::rt::LazyV2<EfeParam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EfeParam::new)
    }
}

impl ::protobuf::Clear for EfeParam {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EfeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EfeParam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InputValidationError {
    // message fields
    pub inputField: ::std::option::Option<i32>,
    pub errorMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InputValidationError {
    fn default() -> &'a InputValidationError {
        <InputValidationError as ::protobuf::Message>::default_instance()
    }
}

impl InputValidationError {
    pub fn new() -> InputValidationError {
        ::std::default::Default::default()
    }

    // optional int32 inputField = 1;


    pub fn get_inputField(&self) -> i32 {
        self.inputField.unwrap_or(0)
    }

    // optional string errorMessage = 2;


    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InputValidationError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inputField = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inputField {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inputField {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.errorMessage.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputValidationError {
        InputValidationError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "inputField",
                |m: &InputValidationError| { &m.inputField },
                |m: &mut InputValidationError| { &mut m.inputField },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMessage",
                |m: &InputValidationError| { &m.errorMessage },
                |m: &mut InputValidationError| { &mut m.errorMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InputValidationError>(
                "InputValidationError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InputValidationError {
        static instance: ::protobuf::rt::LazyV2<InputValidationError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InputValidationError::new)
    }
}

impl ::protobuf::Clear for InputValidationError {
    fn clear(&mut self) {
        self.inputField = ::std::option::Option::None;
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputValidationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputValidationError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Instrument {
    // message fields
    pub instrumentId: ::protobuf::SingularField<::std::string::String>,
    pub billingAddress: ::protobuf::SingularPtrField<Address>,
    pub creditCard: ::protobuf::SingularPtrField<CreditCardInstrument>,
    pub carrierBilling: ::protobuf::SingularPtrField<CarrierBillingInstrument>,
    pub billingAddressSpec: ::protobuf::SingularPtrField<BillingAddressSpec>,
    pub instrumentFamily: ::std::option::Option<i32>,
    pub carrierBillingStatus: ::protobuf::SingularPtrField<CarrierBillingInstrumentStatus>,
    pub displayTitle: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Instrument {
    fn default() -> &'a Instrument {
        <Instrument as ::protobuf::Message>::default_instance()
    }
}

impl Instrument {
    pub fn new() -> Instrument {
        ::std::default::Default::default()
    }

    // optional string instrumentId = 1;


    pub fn get_instrumentId(&self) -> &str {
        match self.instrumentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Address billingAddress = 2;


    pub fn get_billingAddress(&self) -> &Address {
        self.billingAddress.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }

    // optional .CreditCardInstrument creditCard = 3;


    pub fn get_creditCard(&self) -> &CreditCardInstrument {
        self.creditCard.as_ref().unwrap_or_else(|| <CreditCardInstrument as ::protobuf::Message>::default_instance())
    }

    // optional .CarrierBillingInstrument carrierBilling = 4;


    pub fn get_carrierBilling(&self) -> &CarrierBillingInstrument {
        self.carrierBilling.as_ref().unwrap_or_else(|| <CarrierBillingInstrument as ::protobuf::Message>::default_instance())
    }

    // optional .BillingAddressSpec billingAddressSpec = 5;


    pub fn get_billingAddressSpec(&self) -> &BillingAddressSpec {
        self.billingAddressSpec.as_ref().unwrap_or_else(|| <BillingAddressSpec as ::protobuf::Message>::default_instance())
    }

    // optional int32 instrumentFamily = 6;


    pub fn get_instrumentFamily(&self) -> i32 {
        self.instrumentFamily.unwrap_or(0)
    }

    // optional .CarrierBillingInstrumentStatus carrierBillingStatus = 7;


    pub fn get_carrierBillingStatus(&self) -> &CarrierBillingInstrumentStatus {
        self.carrierBillingStatus.as_ref().unwrap_or_else(|| <CarrierBillingInstrumentStatus as ::protobuf::Message>::default_instance())
    }

    // optional string displayTitle = 8;


    pub fn get_displayTitle(&self) -> &str {
        match self.displayTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Instrument {
    fn is_initialized(&self) -> bool {
        for v in &self.billingAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creditCard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBilling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingAddressSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.carrierBillingStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instrumentId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creditCard)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBilling)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingAddressSpec)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instrumentFamily = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingStatus)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayTitle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.instrumentId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.carrierBilling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billingAddressSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.instrumentFamily {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.carrierBillingStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.instrumentId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.billingAddress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creditCard.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.carrierBilling.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billingAddressSpec.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.instrumentFamily {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.carrierBillingStatus.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.displayTitle.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instrument {
        Instrument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instrumentId",
                |m: &Instrument| { &m.instrumentId },
                |m: &mut Instrument| { &mut m.instrumentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "billingAddress",
                |m: &Instrument| { &m.billingAddress },
                |m: &mut Instrument| { &mut m.billingAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreditCardInstrument>>(
                "creditCard",
                |m: &Instrument| { &m.creditCard },
                |m: &mut Instrument| { &mut m.creditCard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrument>>(
                "carrierBilling",
                |m: &Instrument| { &m.carrierBilling },
                |m: &mut Instrument| { &mut m.carrierBilling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingAddressSpec>>(
                "billingAddressSpec",
                |m: &Instrument| { &m.billingAddressSpec },
                |m: &mut Instrument| { &mut m.billingAddressSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instrumentFamily",
                |m: &Instrument| { &m.instrumentFamily },
                |m: &mut Instrument| { &mut m.instrumentFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingInstrumentStatus>>(
                "carrierBillingStatus",
                |m: &Instrument| { &m.carrierBillingStatus },
                |m: &mut Instrument| { &mut m.carrierBillingStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayTitle",
                |m: &Instrument| { &m.displayTitle },
                |m: &mut Instrument| { &mut m.displayTitle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Instrument>(
                "Instrument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Instrument {
        static instance: ::protobuf::rt::LazyV2<Instrument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Instrument::new)
    }
}

impl ::protobuf::Clear for Instrument {
    fn clear(&mut self) {
        self.instrumentId.clear();
        self.billingAddress.clear();
        self.creditCard.clear();
        self.carrierBilling.clear();
        self.billingAddressSpec.clear();
        self.instrumentFamily = ::std::option::Option::None;
        self.carrierBillingStatus.clear();
        self.displayTitle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instrument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instrument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PasswordPrompt {
    // message fields
    pub prompt: ::protobuf::SingularField<::std::string::String>,
    pub forgotPasswordUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PasswordPrompt {
    fn default() -> &'a PasswordPrompt {
        <PasswordPrompt as ::protobuf::Message>::default_instance()
    }
}

impl PasswordPrompt {
    pub fn new() -> PasswordPrompt {
        ::std::default::Default::default()
    }

    // optional string prompt = 1;


    pub fn get_prompt(&self) -> &str {
        match self.prompt.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string forgotPasswordUrl = 2;


    pub fn get_forgotPasswordUrl(&self) -> &str {
        match self.forgotPasswordUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PasswordPrompt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prompt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.forgotPasswordUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prompt.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.forgotPasswordUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prompt.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.forgotPasswordUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PasswordPrompt {
        PasswordPrompt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prompt",
                |m: &PasswordPrompt| { &m.prompt },
                |m: &mut PasswordPrompt| { &mut m.prompt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forgotPasswordUrl",
                |m: &PasswordPrompt| { &m.forgotPasswordUrl },
                |m: &mut PasswordPrompt| { &mut m.forgotPasswordUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PasswordPrompt>(
                "PasswordPrompt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PasswordPrompt {
        static instance: ::protobuf::rt::LazyV2<PasswordPrompt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PasswordPrompt::new)
    }
}

impl ::protobuf::Clear for PasswordPrompt {
    fn clear(&mut self) {
        self.prompt.clear();
        self.forgotPasswordUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PasswordPrompt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PasswordPrompt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ContainerMetadata {
    // message fields
    pub browseUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerMetadata {
    fn default() -> &'a ContainerMetadata {
        <ContainerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ContainerMetadata {
    pub fn new() -> ContainerMetadata {
        ::std::default::Default::default()
    }

    // optional string browseUrl = 1;


    pub fn get_browseUrl(&self) -> &str {
        match self.browseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string nextPageUrl = 2;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double relevance = 3;


    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 4;


    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 5;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ordered = 6;


    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }
}

impl ::protobuf::Message for ContainerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.browseUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.browseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.browseUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerMetadata {
        ContainerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "browseUrl",
                |m: &ContainerMetadata| { &m.browseUrl },
                |m: &mut ContainerMetadata| { &mut m.browseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &ContainerMetadata| { &m.nextPageUrl },
                |m: &mut ContainerMetadata| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "relevance",
                |m: &ContainerMetadata| { &m.relevance },
                |m: &mut ContainerMetadata| { &mut m.relevance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "estimatedResults",
                |m: &ContainerMetadata| { &m.estimatedResults },
                |m: &mut ContainerMetadata| { &mut m.estimatedResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &ContainerMetadata| { &m.analyticsCookie },
                |m: &mut ContainerMetadata| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ordered",
                |m: &ContainerMetadata| { &m.ordered },
                |m: &mut ContainerMetadata| { &mut m.ordered },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerMetadata>(
                "ContainerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerMetadata {
        static instance: ::protobuf::rt::LazyV2<ContainerMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerMetadata::new)
    }
}

impl ::protobuf::Clear for ContainerMetadata {
    fn clear(&mut self) {
        self.browseUrl.clear();
        self.nextPageUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.ordered = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugInfo {
    // message fields
    pub message: ::protobuf::RepeatedField<::std::string::String>,
    // timing: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugInfo {
    fn default() -> &'a DebugInfo {
        <DebugInfo as ::protobuf::Message>::default_instance()
    }
}

impl DebugInfo {
    pub fn new() -> DebugInfo {
        ::std::default::Default::default()
    }

    // repeated string message = 1;


    pub fn get_message(&self) -> &[::std::string::String] {
        &self.message
    }
}

impl ::protobuf::Message for DebugInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo {
        DebugInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &DebugInfo| { &m.message },
                |m: &mut DebugInfo| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugInfo>(
                "DebugInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo {
        static instance: ::protobuf::rt::LazyV2<DebugInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugInfo::new)
    }
}

impl ::protobuf::Clear for DebugInfo {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DebugInfo_Timing {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub timeInMs: ::std::option::Option<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugInfo_Timing {
    fn default() -> &'a DebugInfo_Timing {
        <DebugInfo_Timing as ::protobuf::Message>::default_instance()
    }
}

impl DebugInfo_Timing {
    pub fn new() -> DebugInfo_Timing {
        ::std::default::Default::default()
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double timeInMs = 4;


    pub fn get_timeInMs(&self) -> f64 {
        self.timeInMs.unwrap_or(0.)
    }
}

impl ::protobuf::Message for DebugInfo_Timing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.timeInMs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.timeInMs {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.timeInMs {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugInfo_Timing {
        DebugInfo_Timing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DebugInfo_Timing| { &m.name },
                |m: &mut DebugInfo_Timing| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "timeInMs",
                |m: &DebugInfo_Timing| { &m.timeInMs },
                |m: &mut DebugInfo_Timing| { &mut m.timeInMs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugInfo_Timing>(
                "DebugInfo.Timing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugInfo_Timing {
        static instance: ::protobuf::rt::LazyV2<DebugInfo_Timing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugInfo_Timing::new)
    }
}

impl ::protobuf::Clear for DebugInfo_Timing {
    fn clear(&mut self) {
        self.name.clear();
        self.timeInMs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugInfo_Timing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugInfo_Timing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsEntry {
    // message fields
    pub doc: ::protobuf::SingularPtrField<DocV2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsEntry {
    fn default() -> &'a BulkDetailsEntry {
        <BulkDetailsEntry as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsEntry {
    pub fn new() -> BulkDetailsEntry {
        ::std::default::Default::default()
    }

    // optional .DocV2 doc = 1;


    pub fn get_doc(&self) -> &DocV2 {
        self.doc.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BulkDetailsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.doc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.doc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsEntry {
        BulkDetailsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &BulkDetailsEntry| { &m.doc },
                |m: &mut BulkDetailsEntry| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsEntry>(
                "BulkDetailsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsEntry {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsEntry::new)
    }
}

impl ::protobuf::Clear for BulkDetailsEntry {
    fn clear(&mut self) {
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsRequest {
    // message fields
    pub docid: ::protobuf::RepeatedField<::std::string::String>,
    pub includeChildDocs: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsRequest {
    fn default() -> &'a BulkDetailsRequest {
        <BulkDetailsRequest as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsRequest {
    pub fn new() -> BulkDetailsRequest {
        ::std::default::Default::default()
    }

    // repeated string docid = 1;


    pub fn get_docid(&self) -> &[::std::string::String] {
        &self.docid
    }

    // optional bool includeChildDocs = 2;


    pub fn get_includeChildDocs(&self) -> bool {
        self.includeChildDocs.unwrap_or(false)
    }
}

impl ::protobuf::Message for BulkDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeChildDocs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.docid {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.includeChildDocs {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.docid {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.includeChildDocs {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsRequest {
        BulkDetailsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &BulkDetailsRequest| { &m.docid },
                |m: &mut BulkDetailsRequest| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "includeChildDocs",
                |m: &BulkDetailsRequest| { &m.includeChildDocs },
                |m: &mut BulkDetailsRequest| { &mut m.includeChildDocs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsRequest>(
                "BulkDetailsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsRequest {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsRequest::new)
    }
}

impl ::protobuf::Clear for BulkDetailsRequest {
    fn clear(&mut self) {
        self.docid.clear();
        self.includeChildDocs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BulkDetailsResponse {
    // message fields
    pub entry: ::protobuf::RepeatedField<BulkDetailsEntry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDetailsResponse {
    fn default() -> &'a BulkDetailsResponse {
        <BulkDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BulkDetailsResponse {
    pub fn new() -> BulkDetailsResponse {
        ::std::default::Default::default()
    }

    // repeated .BulkDetailsEntry entry = 1;


    pub fn get_entry(&self) -> &[BulkDetailsEntry] {
        &self.entry
    }
}

impl ::protobuf::Message for BulkDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDetailsResponse {
        BulkDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsEntry>>(
                "entry",
                |m: &BulkDetailsResponse| { &m.entry },
                |m: &mut BulkDetailsResponse| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BulkDetailsResponse>(
                "BulkDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BulkDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<BulkDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BulkDetailsResponse::new)
    }
}

impl ::protobuf::Clear for BulkDetailsResponse {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DetailsResponse {
    // message fields
    pub docV1: ::protobuf::SingularPtrField<DocV1>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub userReview: ::protobuf::SingularPtrField<Review>,
    pub docV2: ::protobuf::SingularPtrField<DocV2>,
    pub footerHtml: ::protobuf::SingularField<::std::string::String>,
    pub badge: ::protobuf::RepeatedField<Badge>,
    pub features: ::protobuf::SingularPtrField<Features>,
    pub detailsStreamUrl: ::protobuf::SingularField<::std::string::String>,
    pub userReviewUrl: ::protobuf::SingularField<::std::string::String>,
    pub postAcquireDetailsStreamUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DetailsResponse {
    fn default() -> &'a DetailsResponse {
        <DetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DetailsResponse {
    pub fn new() -> DetailsResponse {
        ::std::default::Default::default()
    }

    // optional .DocV1 docV1 = 1;


    pub fn get_docV1(&self) -> &DocV1 {
        self.docV1.as_ref().unwrap_or_else(|| <DocV1 as ::protobuf::Message>::default_instance())
    }

    // optional string analyticsCookie = 2;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Review userReview = 3;


    pub fn get_userReview(&self) -> &Review {
        self.userReview.as_ref().unwrap_or_else(|| <Review as ::protobuf::Message>::default_instance())
    }

    // optional .DocV2 docV2 = 4;


    pub fn get_docV2(&self) -> &DocV2 {
        self.docV2.as_ref().unwrap_or_else(|| <DocV2 as ::protobuf::Message>::default_instance())
    }

    // optional string footerHtml = 5;


    pub fn get_footerHtml(&self) -> &str {
        match self.footerHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Badge badge = 7;


    pub fn get_badge(&self) -> &[Badge] {
        &self.badge
    }

    // optional .Features features = 12;


    pub fn get_features(&self) -> &Features {
        self.features.as_ref().unwrap_or_else(|| <Features as ::protobuf::Message>::default_instance())
    }

    // optional string detailsStreamUrl = 13;


    pub fn get_detailsStreamUrl(&self) -> &str {
        match self.detailsStreamUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userReviewUrl = 14;


    pub fn get_userReviewUrl(&self) -> &str {
        match self.userReviewUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string postAcquireDetailsStreamUrl = 17;


    pub fn get_postAcquireDetailsStreamUrl(&self) -> &str {
        match self.postAcquireDetailsStreamUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.docV1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.docV2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docV1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userReview)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docV2)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.footerHtml)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badge)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.features)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsStreamUrl)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userReviewUrl)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postAcquireDetailsStreamUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docV1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.userReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docV2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.footerHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.badge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.features.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detailsStreamUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.userReviewUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.postAcquireDetailsStreamUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docV1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.userReview.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docV2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.footerHtml.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.badge {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.features.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detailsStreamUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.userReviewUrl.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.postAcquireDetailsStreamUrl.as_ref() {
            os.write_string(17, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetailsResponse {
        DetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>>(
                "docV1",
                |m: &DetailsResponse| { &m.docV1 },
                |m: &mut DetailsResponse| { &mut m.docV1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &DetailsResponse| { &m.analyticsCookie },
                |m: &mut DetailsResponse| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "userReview",
                |m: &DetailsResponse| { &m.userReview },
                |m: &mut DetailsResponse| { &mut m.userReview },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "docV2",
                |m: &DetailsResponse| { &m.docV2 },
                |m: &mut DetailsResponse| { &mut m.docV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "footerHtml",
                |m: &DetailsResponse| { &m.footerHtml },
                |m: &mut DetailsResponse| { &mut m.footerHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Badge>>(
                "badge",
                |m: &DetailsResponse| { &m.badge },
                |m: &mut DetailsResponse| { &mut m.badge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Features>>(
                "features",
                |m: &DetailsResponse| { &m.features },
                |m: &mut DetailsResponse| { &mut m.features },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsStreamUrl",
                |m: &DetailsResponse| { &m.detailsStreamUrl },
                |m: &mut DetailsResponse| { &mut m.detailsStreamUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userReviewUrl",
                |m: &DetailsResponse| { &m.userReviewUrl },
                |m: &mut DetailsResponse| { &mut m.userReviewUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "postAcquireDetailsStreamUrl",
                |m: &DetailsResponse| { &m.postAcquireDetailsStreamUrl },
                |m: &mut DetailsResponse| { &mut m.postAcquireDetailsStreamUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DetailsResponse>(
                "DetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DetailsResponse {
        static instance: ::protobuf::rt::LazyV2<DetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DetailsResponse::new)
    }
}

impl ::protobuf::Clear for DetailsResponse {
    fn clear(&mut self) {
        self.docV1.clear();
        self.analyticsCookie.clear();
        self.userReview.clear();
        self.docV2.clear();
        self.footerHtml.clear();
        self.badge.clear();
        self.features.clear();
        self.detailsStreamUrl.clear();
        self.userReviewUrl.clear();
        self.postAcquireDetailsStreamUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Badge {
    // message fields
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub badgeContainer1: ::protobuf::SingularPtrField<BadgeContainer1>,
    pub message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Badge {
    fn default() -> &'a Badge {
        <Badge as ::protobuf::Message>::default_instance()
    }
}

impl Badge {
    pub fn new() -> Badge {
        ::std::default::Default::default()
    }

    // optional string label = 1;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 2;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional .BadgeContainer1 badgeContainer1 = 4;


    pub fn get_badgeContainer1(&self) -> &BadgeContainer1 {
        self.badgeContainer1.as_ref().unwrap_or_else(|| <BadgeContainer1 as ::protobuf::Message>::default_instance())
    }

    // optional string message = 11;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Badge {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.badgeContainer1 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.badgeContainer1)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.badgeContainer1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.badgeContainer1.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Badge {
        Badge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Badge| { &m.label },
                |m: &mut Badge| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Badge| { &m.image },
                |m: &mut Badge| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BadgeContainer1>>(
                "badgeContainer1",
                |m: &Badge| { &m.badgeContainer1 },
                |m: &mut Badge| { &mut m.badgeContainer1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Badge| { &m.message },
                |m: &mut Badge| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Badge>(
                "Badge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Badge {
        static instance: ::protobuf::rt::LazyV2<Badge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Badge::new)
    }
}

impl ::protobuf::Clear for Badge {
    fn clear(&mut self) {
        self.label.clear();
        self.image.clear();
        self.badgeContainer1.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Badge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Badge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BadgeContainer1 {
    // message fields
    pub badgeContainer2: ::protobuf::SingularPtrField<BadgeContainer2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BadgeContainer1 {
    fn default() -> &'a BadgeContainer1 {
        <BadgeContainer1 as ::protobuf::Message>::default_instance()
    }
}

impl BadgeContainer1 {
    pub fn new() -> BadgeContainer1 {
        ::std::default::Default::default()
    }

    // optional .BadgeContainer2 badgeContainer2 = 1;


    pub fn get_badgeContainer2(&self) -> &BadgeContainer2 {
        self.badgeContainer2.as_ref().unwrap_or_else(|| <BadgeContainer2 as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BadgeContainer1 {
    fn is_initialized(&self) -> bool {
        for v in &self.badgeContainer2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.badgeContainer2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.badgeContainer2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.badgeContainer2.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BadgeContainer1 {
        BadgeContainer1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BadgeContainer2>>(
                "badgeContainer2",
                |m: &BadgeContainer1| { &m.badgeContainer2 },
                |m: &mut BadgeContainer1| { &mut m.badgeContainer2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BadgeContainer1>(
                "BadgeContainer1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BadgeContainer1 {
        static instance: ::protobuf::rt::LazyV2<BadgeContainer1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BadgeContainer1::new)
    }
}

impl ::protobuf::Clear for BadgeContainer1 {
    fn clear(&mut self) {
        self.badgeContainer2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BadgeContainer1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeContainer1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BadgeContainer2 {
    // message fields
    pub badgeLinkContainer: ::protobuf::SingularPtrField<BadgeLinkContainer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BadgeContainer2 {
    fn default() -> &'a BadgeContainer2 {
        <BadgeContainer2 as ::protobuf::Message>::default_instance()
    }
}

impl BadgeContainer2 {
    pub fn new() -> BadgeContainer2 {
        ::std::default::Default::default()
    }

    // optional .BadgeLinkContainer badgeLinkContainer = 2;


    pub fn get_badgeLinkContainer(&self) -> &BadgeLinkContainer {
        self.badgeLinkContainer.as_ref().unwrap_or_else(|| <BadgeLinkContainer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for BadgeContainer2 {
    fn is_initialized(&self) -> bool {
        for v in &self.badgeLinkContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.badgeLinkContainer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.badgeLinkContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.badgeLinkContainer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BadgeContainer2 {
        BadgeContainer2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BadgeLinkContainer>>(
                "badgeLinkContainer",
                |m: &BadgeContainer2| { &m.badgeLinkContainer },
                |m: &mut BadgeContainer2| { &mut m.badgeLinkContainer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BadgeContainer2>(
                "BadgeContainer2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BadgeContainer2 {
        static instance: ::protobuf::rt::LazyV2<BadgeContainer2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BadgeContainer2::new)
    }
}

impl ::protobuf::Clear for BadgeContainer2 {
    fn clear(&mut self) {
        self.badgeLinkContainer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BadgeContainer2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeContainer2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BadgeLinkContainer {
    // message fields
    pub link: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BadgeLinkContainer {
    fn default() -> &'a BadgeLinkContainer {
        <BadgeLinkContainer as ::protobuf::Message>::default_instance()
    }
}

impl BadgeLinkContainer {
    pub fn new() -> BadgeLinkContainer {
        ::std::default::Default::default()
    }

    // optional string link = 2;


    pub fn get_link(&self) -> &str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for BadgeLinkContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.link)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.link.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BadgeLinkContainer {
        BadgeLinkContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link",
                |m: &BadgeLinkContainer| { &m.link },
                |m: &mut BadgeLinkContainer| { &mut m.link },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BadgeLinkContainer>(
                "BadgeLinkContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BadgeLinkContainer {
        static instance: ::protobuf::rt::LazyV2<BadgeLinkContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BadgeLinkContainer::new)
    }
}

impl ::protobuf::Clear for BadgeLinkContainer {
    fn clear(&mut self) {
        self.link.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BadgeLinkContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BadgeLinkContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Features {
    // message fields
    pub featurePresence: ::protobuf::RepeatedField<Feature>,
    pub featureRating: ::protobuf::RepeatedField<Feature>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Features {
    fn default() -> &'a Features {
        <Features as ::protobuf::Message>::default_instance()
    }
}

impl Features {
    pub fn new() -> Features {
        ::std::default::Default::default()
    }

    // repeated .Feature featurePresence = 1;


    pub fn get_featurePresence(&self) -> &[Feature] {
        &self.featurePresence
    }

    // repeated .Feature featureRating = 2;


    pub fn get_featureRating(&self) -> &[Feature] {
        &self.featureRating
    }
}

impl ::protobuf::Message for Features {
    fn is_initialized(&self) -> bool {
        for v in &self.featurePresence {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.featureRating {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.featurePresence)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.featureRating)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.featurePresence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.featureRating {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.featurePresence {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.featureRating {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Features {
        Features::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "featurePresence",
                |m: &Features| { &m.featurePresence },
                |m: &mut Features| { &mut m.featurePresence },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Feature>>(
                "featureRating",
                |m: &Features| { &m.featureRating },
                |m: &mut Features| { &mut m.featureRating },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Features>(
                "Features",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Features {
        static instance: ::protobuf::rt::LazyV2<Features> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Features::new)
    }
}

impl ::protobuf::Clear for Features {
    fn clear(&mut self) {
        self.featurePresence.clear();
        self.featureRating.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Features {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Feature {
    // message fields
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Feature {
    fn default() -> &'a Feature {
        <Feature as ::protobuf::Message>::default_instance()
    }
}

impl Feature {
    pub fn new() -> Feature {
        ::std::default::Default::default()
    }

    // optional string label = 1;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 3;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Feature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Feature {
        Feature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Feature| { &m.label },
                |m: &mut Feature| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Feature| { &m.value },
                |m: &mut Feature| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Feature>(
                "Feature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Feature {
        static instance: ::protobuf::rt::LazyV2<Feature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Feature::new)
    }
}

impl ::protobuf::Clear for Feature {
    fn clear(&mut self) {
        self.label.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Feature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Feature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeviceConfigurationProto {
    // message fields
    pub touchScreen: ::std::option::Option<i32>,
    pub keyboard: ::std::option::Option<i32>,
    pub navigation: ::std::option::Option<i32>,
    pub screenLayout: ::std::option::Option<i32>,
    pub hasHardKeyboard: ::std::option::Option<bool>,
    pub hasFiveWayNavigation: ::std::option::Option<bool>,
    pub screenDensity: ::std::option::Option<i32>,
    pub glEsVersion: ::std::option::Option<i32>,
    pub systemSharedLibrary: ::protobuf::RepeatedField<::std::string::String>,
    pub systemAvailableFeature: ::protobuf::RepeatedField<::std::string::String>,
    pub nativePlatform: ::protobuf::RepeatedField<::std::string::String>,
    pub screenWidth: ::std::option::Option<i32>,
    pub screenHeight: ::std::option::Option<i32>,
    pub systemSupportedLocale: ::protobuf::RepeatedField<::std::string::String>,
    pub glExtension: ::protobuf::RepeatedField<::std::string::String>,
    pub deviceClass: ::std::option::Option<i32>,
    pub maxApkDownloadSizeMb: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceConfigurationProto {
    fn default() -> &'a DeviceConfigurationProto {
        <DeviceConfigurationProto as ::protobuf::Message>::default_instance()
    }
}

impl DeviceConfigurationProto {
    pub fn new() -> DeviceConfigurationProto {
        ::std::default::Default::default()
    }

    // optional int32 touchScreen = 1;


    pub fn get_touchScreen(&self) -> i32 {
        self.touchScreen.unwrap_or(0)
    }

    // optional int32 keyboard = 2;


    pub fn get_keyboard(&self) -> i32 {
        self.keyboard.unwrap_or(0)
    }

    // optional int32 navigation = 3;


    pub fn get_navigation(&self) -> i32 {
        self.navigation.unwrap_or(0)
    }

    // optional int32 screenLayout = 4;


    pub fn get_screenLayout(&self) -> i32 {
        self.screenLayout.unwrap_or(0)
    }

    // optional bool hasHardKeyboard = 5;


    pub fn get_hasHardKeyboard(&self) -> bool {
        self.hasHardKeyboard.unwrap_or(false)
    }

    // optional bool hasFiveWayNavigation = 6;


    pub fn get_hasFiveWayNavigation(&self) -> bool {
        self.hasFiveWayNavigation.unwrap_or(false)
    }

    // optional int32 screenDensity = 7;


    pub fn get_screenDensity(&self) -> i32 {
        self.screenDensity.unwrap_or(0)
    }

    // optional int32 glEsVersion = 8;


    pub fn get_glEsVersion(&self) -> i32 {
        self.glEsVersion.unwrap_or(0)
    }

    // repeated string systemSharedLibrary = 9;


    pub fn get_systemSharedLibrary(&self) -> &[::std::string::String] {
        &self.systemSharedLibrary
    }

    // repeated string systemAvailableFeature = 10;


    pub fn get_systemAvailableFeature(&self) -> &[::std::string::String] {
        &self.systemAvailableFeature
    }

    // repeated string nativePlatform = 11;


    pub fn get_nativePlatform(&self) -> &[::std::string::String] {
        &self.nativePlatform
    }

    // optional int32 screenWidth = 12;


    pub fn get_screenWidth(&self) -> i32 {
        self.screenWidth.unwrap_or(0)
    }

    // optional int32 screenHeight = 13;


    pub fn get_screenHeight(&self) -> i32 {
        self.screenHeight.unwrap_or(0)
    }

    // repeated string systemSupportedLocale = 14;


    pub fn get_systemSupportedLocale(&self) -> &[::std::string::String] {
        &self.systemSupportedLocale
    }

    // repeated string glExtension = 15;


    pub fn get_glExtension(&self) -> &[::std::string::String] {
        &self.glExtension
    }

    // optional int32 deviceClass = 16;


    pub fn get_deviceClass(&self) -> i32 {
        self.deviceClass.unwrap_or(0)
    }

    // optional int32 maxApkDownloadSizeMb = 17;


    pub fn get_maxApkDownloadSizeMb(&self) -> i32 {
        self.maxApkDownloadSizeMb.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeviceConfigurationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.touchScreen = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.keyboard = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.navigation = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenLayout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasHardKeyboard = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasFiveWayNavigation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenDensity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.glEsVersion = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSharedLibrary)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemAvailableFeature)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nativePlatform)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenWidth = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenHeight = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.systemSupportedLocale)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.glExtension)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceClass = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxApkDownloadSizeMb = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.touchScreen {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyboard {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.navigation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenLayout {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasHardKeyboard {
            my_size += 2;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            my_size += 2;
        }
        if let Some(v) = self.screenDensity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.glEsVersion {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSharedLibrary {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.systemAvailableFeature {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.nativePlatform {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(v) = self.screenWidth {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenHeight {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.systemSupportedLocale {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.glExtension {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.deviceClass {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.touchScreen {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.keyboard {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.navigation {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.screenLayout {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hasHardKeyboard {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.hasFiveWayNavigation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.screenDensity {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.glEsVersion {
            os.write_int32(8, v)?;
        }
        for v in &self.systemSharedLibrary {
            os.write_string(9, &v)?;
        };
        for v in &self.systemAvailableFeature {
            os.write_string(10, &v)?;
        };
        for v in &self.nativePlatform {
            os.write_string(11, &v)?;
        };
        if let Some(v) = self.screenWidth {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.screenHeight {
            os.write_int32(13, v)?;
        }
        for v in &self.systemSupportedLocale {
            os.write_string(14, &v)?;
        };
        for v in &self.glExtension {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.deviceClass {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.maxApkDownloadSizeMb {
            os.write_int32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceConfigurationProto {
        DeviceConfigurationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "touchScreen",
                |m: &DeviceConfigurationProto| { &m.touchScreen },
                |m: &mut DeviceConfigurationProto| { &mut m.touchScreen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "keyboard",
                |m: &DeviceConfigurationProto| { &m.keyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.keyboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "navigation",
                |m: &DeviceConfigurationProto| { &m.navigation },
                |m: &mut DeviceConfigurationProto| { &mut m.navigation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenLayout",
                |m: &DeviceConfigurationProto| { &m.screenLayout },
                |m: &mut DeviceConfigurationProto| { &mut m.screenLayout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasHardKeyboard",
                |m: &DeviceConfigurationProto| { &m.hasHardKeyboard },
                |m: &mut DeviceConfigurationProto| { &mut m.hasHardKeyboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasFiveWayNavigation",
                |m: &DeviceConfigurationProto| { &m.hasFiveWayNavigation },
                |m: &mut DeviceConfigurationProto| { &mut m.hasFiveWayNavigation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenDensity",
                |m: &DeviceConfigurationProto| { &m.screenDensity },
                |m: &mut DeviceConfigurationProto| { &mut m.screenDensity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "glEsVersion",
                |m: &DeviceConfigurationProto| { &m.glEsVersion },
                |m: &mut DeviceConfigurationProto| { &mut m.glEsVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSharedLibrary",
                |m: &DeviceConfigurationProto| { &m.systemSharedLibrary },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSharedLibrary },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemAvailableFeature",
                |m: &DeviceConfigurationProto| { &m.systemAvailableFeature },
                |m: &mut DeviceConfigurationProto| { &mut m.systemAvailableFeature },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nativePlatform",
                |m: &DeviceConfigurationProto| { &m.nativePlatform },
                |m: &mut DeviceConfigurationProto| { &mut m.nativePlatform },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenWidth",
                |m: &DeviceConfigurationProto| { &m.screenWidth },
                |m: &mut DeviceConfigurationProto| { &mut m.screenWidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenHeight",
                |m: &DeviceConfigurationProto| { &m.screenHeight },
                |m: &mut DeviceConfigurationProto| { &mut m.screenHeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemSupportedLocale",
                |m: &DeviceConfigurationProto| { &m.systemSupportedLocale },
                |m: &mut DeviceConfigurationProto| { &mut m.systemSupportedLocale },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "glExtension",
                |m: &DeviceConfigurationProto| { &m.glExtension },
                |m: &mut DeviceConfigurationProto| { &mut m.glExtension },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceClass",
                |m: &DeviceConfigurationProto| { &m.deviceClass },
                |m: &mut DeviceConfigurationProto| { &mut m.deviceClass },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxApkDownloadSizeMb",
                |m: &DeviceConfigurationProto| { &m.maxApkDownloadSizeMb },
                |m: &mut DeviceConfigurationProto| { &mut m.maxApkDownloadSizeMb },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceConfigurationProto>(
                "DeviceConfigurationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceConfigurationProto {
        static instance: ::protobuf::rt::LazyV2<DeviceConfigurationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceConfigurationProto::new)
    }
}

impl ::protobuf::Clear for DeviceConfigurationProto {
    fn clear(&mut self) {
        self.touchScreen = ::std::option::Option::None;
        self.keyboard = ::std::option::Option::None;
        self.navigation = ::std::option::Option::None;
        self.screenLayout = ::std::option::Option::None;
        self.hasHardKeyboard = ::std::option::Option::None;
        self.hasFiveWayNavigation = ::std::option::Option::None;
        self.screenDensity = ::std::option::Option::None;
        self.glEsVersion = ::std::option::Option::None;
        self.systemSharedLibrary.clear();
        self.systemAvailableFeature.clear();
        self.nativePlatform.clear();
        self.screenWidth = ::std::option::Option::None;
        self.screenHeight = ::std::option::Option::None;
        self.systemSupportedLocale.clear();
        self.glExtension.clear();
        self.deviceClass = ::std::option::Option::None;
        self.maxApkDownloadSizeMb = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceConfigurationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceConfigurationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Document {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub fetchDocid: ::protobuf::SingularPtrField<Docid>,
    pub sampleDocid: ::protobuf::SingularPtrField<Docid>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub priceDeprecated: ::protobuf::SingularPtrField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub translatedSnippet: ::protobuf::RepeatedField<TranslatedText>,
    pub documentVariant: ::protobuf::RepeatedField<DocumentVariant>,
    pub categoryId: ::protobuf::RepeatedField<::std::string::String>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    pub parent: ::protobuf::RepeatedField<Document>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Document {
    fn default() -> &'a Document {
        <Document as ::protobuf::Message>::default_instance()
    }
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // optional .Docid docid = 1;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional .Docid fetchDocid = 2;


    pub fn get_fetchDocid(&self) -> &Docid {
        self.fetchDocid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional .Docid sampleDocid = 3;


    pub fn get_sampleDocid(&self) -> &Docid {
        self.sampleDocid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional string title = 4;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 5;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string snippet = 6;


    pub fn get_snippet(&self) -> &[::std::string::String] {
        &self.snippet
    }

    // optional .Offer priceDeprecated = 7;


    pub fn get_priceDeprecated(&self) -> &Offer {
        self.priceDeprecated.as_ref().unwrap_or_else(|| <Offer as ::protobuf::Message>::default_instance())
    }

    // optional .Availability availability = 9;


    pub fn get_availability(&self) -> &Availability {
        self.availability.as_ref().unwrap_or_else(|| <Availability as ::protobuf::Message>::default_instance())
    }

    // repeated .Image image = 10;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated .Document child = 11;


    pub fn get_child(&self) -> &[Document] {
        &self.child
    }

    // optional .AggregateRating aggregateRating = 13;


    pub fn get_aggregateRating(&self) -> &AggregateRating {
        self.aggregateRating.as_ref().unwrap_or_else(|| <AggregateRating as ::protobuf::Message>::default_instance())
    }

    // repeated .Offer offer = 14;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // repeated .TranslatedText translatedSnippet = 15;


    pub fn get_translatedSnippet(&self) -> &[TranslatedText] {
        &self.translatedSnippet
    }

    // repeated .DocumentVariant documentVariant = 16;


    pub fn get_documentVariant(&self) -> &[DocumentVariant] {
        &self.documentVariant
    }

    // repeated string categoryId = 17;


    pub fn get_categoryId(&self) -> &[::std::string::String] {
        &self.categoryId
    }

    // repeated .Document decoration = 18;


    pub fn get_decoration(&self) -> &[Document] {
        &self.decoration
    }

    // repeated .Document parent = 19;


    pub fn get_parent(&self) -> &[Document] {
        &self.parent
    }

    // optional string privacyPolicyUrl = 20;


    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fetchDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sampleDocid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.priceDeprecated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translatedSnippet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.documentVariant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fetchDocid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sampleDocid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.priceDeprecated)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregateRating)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.translatedSnippet)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documentVariant)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categoryId)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decoration)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parent)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fetchDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sampleDocid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.priceDeprecated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.translatedSnippet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.documentVariant {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.categoryId {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.parent {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fetchDocid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sampleDocid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.snippet {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.priceDeprecated.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.availability.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.image {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.child {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.aggregateRating.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.offer {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.translatedSnippet {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.documentVariant {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.categoryId {
            os.write_string(17, &v)?;
        };
        for v in &self.decoration {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.parent {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(20, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &Document| { &m.docid },
                |m: &mut Document| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "fetchDocid",
                |m: &Document| { &m.fetchDocid },
                |m: &mut Document| { &mut m.fetchDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "sampleDocid",
                |m: &Document| { &m.sampleDocid },
                |m: &mut Document| { &mut m.sampleDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Document| { &m.title },
                |m: &mut Document| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Document| { &m.url },
                |m: &mut Document| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &Document| { &m.snippet },
                |m: &mut Document| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "priceDeprecated",
                |m: &Document| { &m.priceDeprecated },
                |m: &mut Document| { &mut m.priceDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                "availability",
                |m: &Document| { &m.availability },
                |m: &mut Document| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Document| { &m.image },
                |m: &mut Document| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &Document| { &m.child },
                |m: &mut Document| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>>(
                "aggregateRating",
                |m: &Document| { &m.aggregateRating },
                |m: &mut Document| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &Document| { &m.offer },
                |m: &mut Document| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "translatedSnippet",
                |m: &Document| { &m.translatedSnippet },
                |m: &mut Document| { &mut m.translatedSnippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentVariant>>(
                "documentVariant",
                |m: &Document| { &m.documentVariant },
                |m: &mut Document| { &mut m.documentVariant },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categoryId",
                |m: &Document| { &m.categoryId },
                |m: &mut Document| { &mut m.categoryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &Document| { &m.decoration },
                |m: &mut Document| { &mut m.decoration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "parent",
                |m: &Document| { &m.parent },
                |m: &mut Document| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privacyPolicyUrl",
                |m: &Document| { &m.privacyPolicyUrl },
                |m: &mut Document| { &mut m.privacyPolicyUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Document>(
                "Document",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Document {
        static instance: ::protobuf::rt::LazyV2<Document> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Document::new)
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.docid.clear();
        self.fetchDocid.clear();
        self.sampleDocid.clear();
        self.title.clear();
        self.url.clear();
        self.snippet.clear();
        self.priceDeprecated.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.aggregateRating.clear();
        self.offer.clear();
        self.translatedSnippet.clear();
        self.documentVariant.clear();
        self.categoryId.clear();
        self.decoration.clear();
        self.parent.clear();
        self.privacyPolicyUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocumentVariant {
    // message fields
    pub variationType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub snippet: ::protobuf::RepeatedField<::std::string::String>,
    pub recentChanges: ::protobuf::SingularField<::std::string::String>,
    pub autoTranslation: ::protobuf::RepeatedField<TranslatedText>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub channelId: ::std::option::Option<i64>,
    pub child: ::protobuf::RepeatedField<Document>,
    pub decoration: ::protobuf::RepeatedField<Document>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentVariant {
    fn default() -> &'a DocumentVariant {
        <DocumentVariant as ::protobuf::Message>::default_instance()
    }
}

impl DocumentVariant {
    pub fn new() -> DocumentVariant {
        ::std::default::Default::default()
    }

    // optional int32 variationType = 1;


    pub fn get_variationType(&self) -> i32 {
        self.variationType.unwrap_or(0)
    }

    // optional .Rule rule = 2;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string snippet = 4;


    pub fn get_snippet(&self) -> &[::std::string::String] {
        &self.snippet
    }

    // optional string recentChanges = 5;


    pub fn get_recentChanges(&self) -> &str {
        match self.recentChanges.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .TranslatedText autoTranslation = 6;


    pub fn get_autoTranslation(&self) -> &[TranslatedText] {
        &self.autoTranslation
    }

    // repeated .Offer offer = 7;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // optional int64 channelId = 9;


    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }

    // repeated .Document child = 10;


    pub fn get_child(&self) -> &[Document] {
        &self.child
    }

    // repeated .Document decoration = 11;


    pub fn get_decoration(&self) -> &[Document] {
        &self.decoration
    }
}

impl ::protobuf::Message for DocumentVariant {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoTranslation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.variationType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snippet)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChanges)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.autoTranslation)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.decoration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.variationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.snippet {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.recentChanges.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.autoTranslation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.decoration {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.variationType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.snippet {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.recentChanges.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.autoTranslation {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.offer {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.channelId {
            os.write_int64(9, v)?;
        }
        for v in &self.child {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.decoration {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentVariant {
        DocumentVariant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "variationType",
                |m: &DocumentVariant| { &m.variationType },
                |m: &mut DocumentVariant| { &mut m.variationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &DocumentVariant| { &m.rule },
                |m: &mut DocumentVariant| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocumentVariant| { &m.title },
                |m: &mut DocumentVariant| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &DocumentVariant| { &m.snippet },
                |m: &mut DocumentVariant| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recentChanges",
                |m: &DocumentVariant| { &m.recentChanges },
                |m: &mut DocumentVariant| { &mut m.recentChanges },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TranslatedText>>(
                "autoTranslation",
                |m: &DocumentVariant| { &m.autoTranslation },
                |m: &mut DocumentVariant| { &mut m.autoTranslation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocumentVariant| { &m.offer },
                |m: &mut DocumentVariant| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "channelId",
                |m: &DocumentVariant| { &m.channelId },
                |m: &mut DocumentVariant| { &mut m.channelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "child",
                |m: &DocumentVariant| { &m.child },
                |m: &mut DocumentVariant| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "decoration",
                |m: &DocumentVariant| { &m.decoration },
                |m: &mut DocumentVariant| { &mut m.decoration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentVariant>(
                "DocumentVariant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentVariant {
        static instance: ::protobuf::rt::LazyV2<DocumentVariant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentVariant::new)
    }
}

impl ::protobuf::Clear for DocumentVariant {
    fn clear(&mut self) {
        self.variationType = ::std::option::Option::None;
        self.rule.clear();
        self.title.clear();
        self.snippet.clear();
        self.recentChanges.clear();
        self.autoTranslation.clear();
        self.offer.clear();
        self.channelId = ::std::option::Option::None;
        self.child.clear();
        self.decoration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentVariant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentVariant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image {
    // message fields
    pub imageType: ::std::option::Option<i32>,
    // dimension: <group>
    pub imageUrl: ::protobuf::SingularField<::std::string::String>,
    pub altTextLocalized: ::protobuf::SingularField<::std::string::String>,
    pub secureUrl: ::protobuf::SingularField<::std::string::String>,
    pub positionInSequence: ::std::option::Option<i32>,
    pub supportsFifeUrlOptions: ::std::option::Option<bool>,
    // citation: <group>
    pub color: ::protobuf::SingularField<::std::string::String>,
    pub screenshotSetNumber: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    // optional int32 imageType = 1;


    pub fn get_imageType(&self) -> i32 {
        self.imageType.unwrap_or(0)
    }

    // optional string imageUrl = 5;


    pub fn get_imageUrl(&self) -> &str {
        match self.imageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string altTextLocalized = 6;


    pub fn get_altTextLocalized(&self) -> &str {
        match self.altTextLocalized.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string secureUrl = 7;


    pub fn get_secureUrl(&self) -> &str {
        match self.secureUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 positionInSequence = 8;


    pub fn get_positionInSequence(&self) -> i32 {
        self.positionInSequence.unwrap_or(0)
    }

    // optional bool supportsFifeUrlOptions = 9;


    pub fn get_supportsFifeUrlOptions(&self) -> bool {
        self.supportsFifeUrlOptions.unwrap_or(false)
    }

    // optional string color = 15;


    pub fn get_color(&self) -> &str {
        match self.color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 screenshotSetNumber = 21;


    pub fn get_screenshotSetNumber(&self) -> i32 {
        self.screenshotSetNumber.unwrap_or(0)
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.imageType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.altTextLocalized)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secureUrl)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.positionInSequence = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsFifeUrlOptions = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.color)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.screenshotSetNumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.imageType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.imageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.altTextLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.secureUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.positionInSequence {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            my_size += 2;
        }
        if let Some(ref v) = self.color.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.screenshotSetNumber {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.imageType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.imageUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.altTextLocalized.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.secureUrl.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.positionInSequence {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.supportsFifeUrlOptions {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.color.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.screenshotSetNumber {
            os.write_int32(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "imageType",
                |m: &Image| { &m.imageType },
                |m: &mut Image| { &mut m.imageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imageUrl",
                |m: &Image| { &m.imageUrl },
                |m: &mut Image| { &mut m.imageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "altTextLocalized",
                |m: &Image| { &m.altTextLocalized },
                |m: &mut Image| { &mut m.altTextLocalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secureUrl",
                |m: &Image| { &m.secureUrl },
                |m: &mut Image| { &mut m.secureUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "positionInSequence",
                |m: &Image| { &m.positionInSequence },
                |m: &mut Image| { &mut m.positionInSequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supportsFifeUrlOptions",
                |m: &Image| { &m.supportsFifeUrlOptions },
                |m: &mut Image| { &mut m.supportsFifeUrlOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "color",
                |m: &Image| { &m.color },
                |m: &mut Image| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "screenshotSetNumber",
                |m: &Image| { &m.screenshotSetNumber },
                |m: &mut Image| { &mut m.screenshotSetNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image>(
                "Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image {
        static instance: ::protobuf::rt::LazyV2<Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image::new)
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.imageType = ::std::option::Option::None;
        self.imageUrl.clear();
        self.altTextLocalized.clear();
        self.secureUrl.clear();
        self.positionInSequence = ::std::option::Option::None;
        self.supportsFifeUrlOptions = ::std::option::Option::None;
        self.color.clear();
        self.screenshotSetNumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image_Dimension {
    // message fields
    pub width: ::std::option::Option<i32>,
    pub height: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image_Dimension {
    fn default() -> &'a Image_Dimension {
        <Image_Dimension as ::protobuf::Message>::default_instance()
    }
}

impl Image_Dimension {
    pub fn new() -> Image_Dimension {
        ::std::default::Default::default()
    }

    // optional int32 width = 3;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    // optional int32 height = 4;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
}

impl ::protobuf::Message for Image_Dimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Dimension {
        Image_Dimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &Image_Dimension| { &m.width },
                |m: &mut Image_Dimension| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &Image_Dimension| { &m.height },
                |m: &mut Image_Dimension| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image_Dimension>(
                "Image.Dimension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Dimension {
        static instance: ::protobuf::rt::LazyV2<Image_Dimension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image_Dimension::new)
    }
}

impl ::protobuf::Clear for Image_Dimension {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Dimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Dimension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Image_Citation {
    // message fields
    pub titleLocalized: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Image_Citation {
    fn default() -> &'a Image_Citation {
        <Image_Citation as ::protobuf::Message>::default_instance()
    }
}

impl Image_Citation {
    pub fn new() -> Image_Citation {
        ::std::default::Default::default()
    }

    // optional string titleLocalized = 11;


    pub fn get_titleLocalized(&self) -> &str {
        match self.titleLocalized.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 12;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Image_Citation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.titleLocalized)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.titleLocalized.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.titleLocalized.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Image_Citation {
        Image_Citation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "titleLocalized",
                |m: &Image_Citation| { &m.titleLocalized },
                |m: &mut Image_Citation| { &mut m.titleLocalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Image_Citation| { &m.url },
                |m: &mut Image_Citation| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Image_Citation>(
                "Image.Citation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Image_Citation {
        static instance: ::protobuf::rt::LazyV2<Image_Citation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Image_Citation::new)
    }
}

impl ::protobuf::Clear for Image_Citation {
    fn clear(&mut self) {
        self.titleLocalized.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Image_Citation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Image_Citation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TranslatedText {
    // message fields
    pub text: ::protobuf::SingularField<::std::string::String>,
    pub sourceLocale: ::protobuf::SingularField<::std::string::String>,
    pub targetLocale: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TranslatedText {
    fn default() -> &'a TranslatedText {
        <TranslatedText as ::protobuf::Message>::default_instance()
    }
}

impl TranslatedText {
    pub fn new() -> TranslatedText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string sourceLocale = 2;


    pub fn get_sourceLocale(&self) -> &str {
        match self.sourceLocale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string targetLocale = 3;


    pub fn get_targetLocale(&self) -> &str {
        match self.targetLocale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TranslatedText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sourceLocale)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetLocale)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sourceLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.targetLocale.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sourceLocale.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.targetLocale.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TranslatedText {
        TranslatedText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &TranslatedText| { &m.text },
                |m: &mut TranslatedText| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sourceLocale",
                |m: &TranslatedText| { &m.sourceLocale },
                |m: &mut TranslatedText| { &mut m.sourceLocale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetLocale",
                |m: &TranslatedText| { &m.targetLocale },
                |m: &mut TranslatedText| { &mut m.targetLocale },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TranslatedText>(
                "TranslatedText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TranslatedText {
        static instance: ::protobuf::rt::LazyV2<TranslatedText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TranslatedText::new)
    }
}

impl ::protobuf::Clear for TranslatedText {
    fn clear(&mut self) {
        self.text.clear();
        self.sourceLocale.clear();
        self.targetLocale.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TranslatedText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TranslatedText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusOneData {
    // message fields
    pub setByUser: ::std::option::Option<bool>,
    pub total: ::std::option::Option<i64>,
    pub circlesTotal: ::std::option::Option<i64>,
    pub circlesPeople: ::protobuf::RepeatedField<PlusPerson>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusOneData {
    fn default() -> &'a PlusOneData {
        <PlusOneData as ::protobuf::Message>::default_instance()
    }
}

impl PlusOneData {
    pub fn new() -> PlusOneData {
        ::std::default::Default::default()
    }

    // optional bool setByUser = 1;


    pub fn get_setByUser(&self) -> bool {
        self.setByUser.unwrap_or(false)
    }

    // optional int64 total = 2;


    pub fn get_total(&self) -> i64 {
        self.total.unwrap_or(0)
    }

    // optional int64 circlesTotal = 3;


    pub fn get_circlesTotal(&self) -> i64 {
        self.circlesTotal.unwrap_or(0)
    }

    // repeated .PlusPerson circlesPeople = 4;


    pub fn get_circlesPeople(&self) -> &[PlusPerson] {
        &self.circlesPeople
    }
}

impl ::protobuf::Message for PlusOneData {
    fn is_initialized(&self) -> bool {
        for v in &self.circlesPeople {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.setByUser = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.circlesTotal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.circlesPeople)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.setByUser {
            my_size += 2;
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.circlesTotal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.circlesPeople {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.setByUser {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.circlesTotal {
            os.write_int64(3, v)?;
        }
        for v in &self.circlesPeople {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusOneData {
        PlusOneData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "setByUser",
                |m: &PlusOneData| { &m.setByUser },
                |m: &mut PlusOneData| { &mut m.setByUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total",
                |m: &PlusOneData| { &m.total },
                |m: &mut PlusOneData| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "circlesTotal",
                |m: &PlusOneData| { &m.circlesTotal },
                |m: &mut PlusOneData| { &mut m.circlesTotal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusPerson>>(
                "circlesPeople",
                |m: &PlusOneData| { &m.circlesPeople },
                |m: &mut PlusOneData| { &mut m.circlesPeople },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusOneData>(
                "PlusOneData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusOneData {
        static instance: ::protobuf::rt::LazyV2<PlusOneData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusOneData::new)
    }
}

impl ::protobuf::Clear for PlusOneData {
    fn clear(&mut self) {
        self.setByUser = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.circlesTotal = ::std::option::Option::None;
        self.circlesPeople.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusOneData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusOneData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PlusPerson {
    // message fields
    pub displayName: ::protobuf::SingularField<::std::string::String>,
    pub profileImageUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlusPerson {
    fn default() -> &'a PlusPerson {
        <PlusPerson as ::protobuf::Message>::default_instance()
    }
}

impl PlusPerson {
    pub fn new() -> PlusPerson {
        ::std::default::Default::default()
    }

    // optional string displayName = 2;


    pub fn get_displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string profileImageUrl = 4;


    pub fn get_profileImageUrl(&self) -> &str {
        match self.profileImageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PlusPerson {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profileImageUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.profileImageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.displayName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.profileImageUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlusPerson {
        PlusPerson::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayName",
                |m: &PlusPerson| { &m.displayName },
                |m: &mut PlusPerson| { &mut m.displayName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "profileImageUrl",
                |m: &PlusPerson| { &m.profileImageUrl },
                |m: &mut PlusPerson| { &mut m.profileImageUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlusPerson>(
                "PlusPerson",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlusPerson {
        static instance: ::protobuf::rt::LazyV2<PlusPerson> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlusPerson::new)
    }
}

impl ::protobuf::Clear for PlusPerson {
    fn clear(&mut self) {
        self.displayName.clear();
        self.profileImageUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlusPerson {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlusPerson {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AlbumDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlbumDetails {
    fn default() -> &'a AlbumDetails {
        <AlbumDetails as ::protobuf::Message>::default_instance()
    }
}

impl AlbumDetails {
    pub fn new() -> AlbumDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .MusicDetails details = 2;


    pub fn get_details(&self) -> &MusicDetails {
        self.details.as_ref().unwrap_or_else(|| <MusicDetails as ::protobuf::Message>::default_instance())
    }

    // optional .ArtistDetails displayArtist = 3;


    pub fn get_displayArtist(&self) -> &ArtistDetails {
        self.displayArtist.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AlbumDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.displayArtist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlbumDetails {
        AlbumDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AlbumDetails| { &m.name },
                |m: &mut AlbumDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>>(
                "details",
                |m: &AlbumDetails| { &m.details },
                |m: &mut AlbumDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "displayArtist",
                |m: &AlbumDetails| { &m.displayArtist },
                |m: &mut AlbumDetails| { &mut m.displayArtist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlbumDetails>(
                "AlbumDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlbumDetails {
        static instance: ::protobuf::rt::LazyV2<AlbumDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlbumDetails::new)
    }
}

impl ::protobuf::Clear for AlbumDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.displayArtist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlbumDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlbumDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppDetails {
    // message fields
    pub developerName: ::protobuf::SingularField<::std::string::String>,
    pub majorVersionNumber: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub versionString: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub appCategory: ::protobuf::RepeatedField<::std::string::String>,
    pub contentRating: ::std::option::Option<i32>,
    pub installationSize: ::std::option::Option<i64>,
    pub permission: ::protobuf::RepeatedField<::std::string::String>,
    pub developerEmail: ::protobuf::SingularField<::std::string::String>,
    pub developerWebsite: ::protobuf::SingularField<::std::string::String>,
    pub numDownloads: ::protobuf::SingularField<::std::string::String>,
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub recentChangesHtml: ::protobuf::SingularField<::std::string::String>,
    pub uploadDate: ::protobuf::SingularField<::std::string::String>,
    pub file: ::protobuf::RepeatedField<FileMetadata>,
    pub appType: ::protobuf::SingularField<::std::string::String>,
    pub unstable: ::std::option::Option<bool>,
    pub hasInstantLink: ::std::option::Option<bool>,
    pub containsAds: ::protobuf::SingularField<::std::string::String>,
    pub dependencies: ::protobuf::SingularPtrField<Dependencies>,
    pub testingProgramInfo: ::protobuf::SingularPtrField<TestingProgramInfo>,
    pub earlyAccessInfo: ::protobuf::SingularPtrField<EarlyAccessInfo>,
    pub instantLink: ::protobuf::SingularField<::std::string::String>,
    pub developerAddress: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDetails {
    fn default() -> &'a AppDetails {
        <AppDetails as ::protobuf::Message>::default_instance()
    }
}

impl AppDetails {
    pub fn new() -> AppDetails {
        ::std::default::Default::default()
    }

    // optional string developerName = 1;


    pub fn get_developerName(&self) -> &str {
        match self.developerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 majorVersionNumber = 2;


    pub fn get_majorVersionNumber(&self) -> i32 {
        self.majorVersionNumber.unwrap_or(0)
    }

    // optional int32 versionCode = 3;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string versionString = 4;


    pub fn get_versionString(&self) -> &str {
        match self.versionString.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string appCategory = 7;


    pub fn get_appCategory(&self) -> &[::std::string::String] {
        &self.appCategory
    }

    // optional int32 contentRating = 8;


    pub fn get_contentRating(&self) -> i32 {
        self.contentRating.unwrap_or(0)
    }

    // optional int64 installationSize = 9;


    pub fn get_installationSize(&self) -> i64 {
        self.installationSize.unwrap_or(0)
    }

    // repeated string permission = 10;


    pub fn get_permission(&self) -> &[::std::string::String] {
        &self.permission
    }

    // optional string developerEmail = 11;


    pub fn get_developerEmail(&self) -> &str {
        match self.developerEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string developerWebsite = 12;


    pub fn get_developerWebsite(&self) -> &str {
        match self.developerWebsite.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string numDownloads = 13;


    pub fn get_numDownloads(&self) -> &str {
        match self.numDownloads.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string packageName = 14;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string recentChangesHtml = 15;


    pub fn get_recentChangesHtml(&self) -> &str {
        match self.recentChangesHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string uploadDate = 16;


    pub fn get_uploadDate(&self) -> &str {
        match self.uploadDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .FileMetadata file = 17;


    pub fn get_file(&self) -> &[FileMetadata] {
        &self.file
    }

    // optional string appType = 18;


    pub fn get_appType(&self) -> &str {
        match self.appType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool unstable = 21;


    pub fn get_unstable(&self) -> bool {
        self.unstable.unwrap_or(false)
    }

    // optional bool hasInstantLink = 24;


    pub fn get_hasInstantLink(&self) -> bool {
        self.hasInstantLink.unwrap_or(false)
    }

    // optional string containsAds = 30;


    pub fn get_containsAds(&self) -> &str {
        match self.containsAds.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Dependencies dependencies = 34;


    pub fn get_dependencies(&self) -> &Dependencies {
        self.dependencies.as_ref().unwrap_or_else(|| <Dependencies as ::protobuf::Message>::default_instance())
    }

    // optional .TestingProgramInfo testingProgramInfo = 35;


    pub fn get_testingProgramInfo(&self) -> &TestingProgramInfo {
        self.testingProgramInfo.as_ref().unwrap_or_else(|| <TestingProgramInfo as ::protobuf::Message>::default_instance())
    }

    // optional .EarlyAccessInfo earlyAccessInfo = 36;


    pub fn get_earlyAccessInfo(&self) -> &EarlyAccessInfo {
        self.earlyAccessInfo.as_ref().unwrap_or_else(|| <EarlyAccessInfo as ::protobuf::Message>::default_instance())
    }

    // optional string instantLink = 43;


    pub fn get_instantLink(&self) -> &str {
        match self.instantLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string developerAddress = 45;


    pub fn get_developerAddress(&self) -> &str {
        match self.developerAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AppDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dependencies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.testingProgramInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.earlyAccessInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.majorVersionNumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.versionString)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.appCategory)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.contentRating = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.installationSize = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.permission)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerEmail)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerWebsite)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.numDownloads)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recentChangesHtml)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDate)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appType)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unstable = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasInstantLink = ::std::option::Option::Some(tmp);
                },
                30 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containsAds)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dependencies)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.testingProgramInfo)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.earlyAccessInfo)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instantLink)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.developerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.majorVersionNumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.versionString.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.appCategory {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.contentRating {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.installationSize {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.permission {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.developerEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.developerWebsite.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.numDownloads.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.recentChangesHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.uploadDate.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.appType.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.unstable {
            my_size += 3;
        }
        if let Some(v) = self.hasInstantLink {
            my_size += 3;
        }
        if let Some(ref v) = self.containsAds.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(ref v) = self.dependencies.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.testingProgramInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.earlyAccessInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instantLink.as_ref() {
            my_size += ::protobuf::rt::string_size(43, &v);
        }
        if let Some(ref v) = self.developerAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.developerName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.majorVersionNumber {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.versionString.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.appCategory {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.contentRating {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.installationSize {
            os.write_int64(9, v)?;
        }
        for v in &self.permission {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.developerEmail.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.developerWebsite.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.numDownloads.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.recentChangesHtml.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.uploadDate.as_ref() {
            os.write_string(16, &v)?;
        }
        for v in &self.file {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.appType.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.unstable {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.hasInstantLink {
            os.write_bool(24, v)?;
        }
        if let Some(ref v) = self.containsAds.as_ref() {
            os.write_string(30, &v)?;
        }
        if let Some(ref v) = self.dependencies.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.testingProgramInfo.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.earlyAccessInfo.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instantLink.as_ref() {
            os.write_string(43, &v)?;
        }
        if let Some(ref v) = self.developerAddress.as_ref() {
            os.write_string(45, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDetails {
        AppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerName",
                |m: &AppDetails| { &m.developerName },
                |m: &mut AppDetails| { &mut m.developerName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "majorVersionNumber",
                |m: &AppDetails| { &m.majorVersionNumber },
                |m: &mut AppDetails| { &mut m.majorVersionNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AppDetails| { &m.versionCode },
                |m: &mut AppDetails| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "versionString",
                |m: &AppDetails| { &m.versionString },
                |m: &mut AppDetails| { &mut m.versionString },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &AppDetails| { &m.title },
                |m: &mut AppDetails| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appCategory",
                |m: &AppDetails| { &m.appCategory },
                |m: &mut AppDetails| { &mut m.appCategory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "contentRating",
                |m: &AppDetails| { &m.contentRating },
                |m: &mut AppDetails| { &mut m.contentRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "installationSize",
                |m: &AppDetails| { &m.installationSize },
                |m: &mut AppDetails| { &mut m.installationSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permission",
                |m: &AppDetails| { &m.permission },
                |m: &mut AppDetails| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerEmail",
                |m: &AppDetails| { &m.developerEmail },
                |m: &mut AppDetails| { &mut m.developerEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerWebsite",
                |m: &AppDetails| { &m.developerWebsite },
                |m: &mut AppDetails| { &mut m.developerWebsite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "numDownloads",
                |m: &AppDetails| { &m.numDownloads },
                |m: &mut AppDetails| { &mut m.numDownloads },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &AppDetails| { &m.packageName },
                |m: &mut AppDetails| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recentChangesHtml",
                |m: &AppDetails| { &m.recentChangesHtml },
                |m: &mut AppDetails| { &mut m.recentChangesHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uploadDate",
                |m: &AppDetails| { &m.uploadDate },
                |m: &mut AppDetails| { &mut m.uploadDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileMetadata>>(
                "file",
                |m: &AppDetails| { &m.file },
                |m: &mut AppDetails| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appType",
                |m: &AppDetails| { &m.appType },
                |m: &mut AppDetails| { &mut m.appType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unstable",
                |m: &AppDetails| { &m.unstable },
                |m: &mut AppDetails| { &mut m.unstable },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasInstantLink",
                |m: &AppDetails| { &m.hasInstantLink },
                |m: &mut AppDetails| { &mut m.hasInstantLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "containsAds",
                |m: &AppDetails| { &m.containsAds },
                |m: &mut AppDetails| { &mut m.containsAds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependencies>>(
                "dependencies",
                |m: &AppDetails| { &m.dependencies },
                |m: &mut AppDetails| { &mut m.dependencies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestingProgramInfo>>(
                "testingProgramInfo",
                |m: &AppDetails| { &m.testingProgramInfo },
                |m: &mut AppDetails| { &mut m.testingProgramInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EarlyAccessInfo>>(
                "earlyAccessInfo",
                |m: &AppDetails| { &m.earlyAccessInfo },
                |m: &mut AppDetails| { &mut m.earlyAccessInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instantLink",
                |m: &AppDetails| { &m.instantLink },
                |m: &mut AppDetails| { &mut m.instantLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerAddress",
                |m: &AppDetails| { &m.developerAddress },
                |m: &mut AppDetails| { &mut m.developerAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppDetails>(
                "AppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppDetails {
        static instance: ::protobuf::rt::LazyV2<AppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppDetails::new)
    }
}

impl ::protobuf::Clear for AppDetails {
    fn clear(&mut self) {
        self.developerName.clear();
        self.majorVersionNumber = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.versionString.clear();
        self.title.clear();
        self.appCategory.clear();
        self.contentRating = ::std::option::Option::None;
        self.installationSize = ::std::option::Option::None;
        self.permission.clear();
        self.developerEmail.clear();
        self.developerWebsite.clear();
        self.numDownloads.clear();
        self.packageName.clear();
        self.recentChangesHtml.clear();
        self.uploadDate.clear();
        self.file.clear();
        self.appType.clear();
        self.unstable = ::std::option::Option::None;
        self.hasInstantLink = ::std::option::Option::None;
        self.containsAds.clear();
        self.dependencies.clear();
        self.testingProgramInfo.clear();
        self.earlyAccessInfo.clear();
        self.instantLink.clear();
        self.developerAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Dependencies {
    // message fields
    pub unknown1: ::std::option::Option<i32>,
    pub unknown2: ::std::option::Option<i64>,
    pub dependency: ::protobuf::RepeatedField<Dependency>,
    pub unknown3: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dependencies {
    fn default() -> &'a Dependencies {
        <Dependencies as ::protobuf::Message>::default_instance()
    }
}

impl Dependencies {
    pub fn new() -> Dependencies {
        ::std::default::Default::default()
    }

    // optional int32 unknown1 = 1;


    pub fn get_unknown1(&self) -> i32 {
        self.unknown1.unwrap_or(0)
    }

    // optional int64 unknown2 = 2;


    pub fn get_unknown2(&self) -> i64 {
        self.unknown2.unwrap_or(0)
    }

    // repeated .Dependency dependency = 3;


    pub fn get_dependency(&self) -> &[Dependency] {
        &self.dependency
    }

    // optional int32 unknown3 = 4;


    pub fn get_unknown3(&self) -> i32 {
        self.unknown3.unwrap_or(0)
    }
}

impl ::protobuf::Message for Dependencies {
    fn is_initialized(&self) -> bool {
        for v in &self.dependency {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown1 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unknown2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dependency)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown3 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.unknown1 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unknown2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dependency {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.unknown3 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unknown1 {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.unknown2 {
            os.write_int64(2, v)?;
        }
        for v in &self.dependency {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.unknown3 {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dependencies {
        Dependencies::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown1",
                |m: &Dependencies| { &m.unknown1 },
                |m: &mut Dependencies| { &mut m.unknown1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unknown2",
                |m: &Dependencies| { &m.unknown2 },
                |m: &mut Dependencies| { &mut m.unknown2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dependency>>(
                "dependency",
                |m: &Dependencies| { &m.dependency },
                |m: &mut Dependencies| { &mut m.dependency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown3",
                |m: &Dependencies| { &m.unknown3 },
                |m: &mut Dependencies| { &mut m.unknown3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dependencies>(
                "Dependencies",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dependencies {
        static instance: ::protobuf::rt::LazyV2<Dependencies> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dependencies::new)
    }
}

impl ::protobuf::Clear for Dependencies {
    fn clear(&mut self) {
        self.unknown1 = ::std::option::Option::None;
        self.unknown2 = ::std::option::Option::None;
        self.dependency.clear();
        self.unknown3 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dependencies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dependencies {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Dependency {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub version: ::std::option::Option<i32>,
    pub unknown4: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dependency {
    fn default() -> &'a Dependency {
        <Dependency as ::protobuf::Message>::default_instance()
    }
}

impl Dependency {
    pub fn new() -> Dependency {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional int32 unknown4 = 4;


    pub fn get_unknown4(&self) -> i32 {
        self.unknown4.unwrap_or(0)
    }
}

impl ::protobuf::Message for Dependency {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown4 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unknown4 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.unknown4 {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dependency {
        Dependency::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &Dependency| { &m.packageName },
                |m: &mut Dependency| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &Dependency| { &m.version },
                |m: &mut Dependency| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown4",
                |m: &Dependency| { &m.unknown4 },
                |m: &mut Dependency| { &mut m.unknown4 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dependency>(
                "Dependency",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dependency {
        static instance: ::protobuf::rt::LazyV2<Dependency> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dependency::new)
    }
}

impl ::protobuf::Clear for Dependency {
    fn clear(&mut self) {
        self.packageName.clear();
        self.version = ::std::option::Option::None;
        self.unknown4 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dependency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dependency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TestingProgramInfo {
    // message fields
    pub subscribed: ::std::option::Option<bool>,
    pub subscribed1: ::std::option::Option<bool>,
    pub testingProgramEmail: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestingProgramInfo {
    fn default() -> &'a TestingProgramInfo {
        <TestingProgramInfo as ::protobuf::Message>::default_instance()
    }
}

impl TestingProgramInfo {
    pub fn new() -> TestingProgramInfo {
        ::std::default::Default::default()
    }

    // optional bool subscribed = 2;


    pub fn get_subscribed(&self) -> bool {
        self.subscribed.unwrap_or(false)
    }

    // optional bool subscribed1 = 3;


    pub fn get_subscribed1(&self) -> bool {
        self.subscribed1.unwrap_or(false)
    }

    // optional string testingProgramEmail = 5;


    pub fn get_testingProgramEmail(&self) -> &str {
        match self.testingProgramEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TestingProgramInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subscribed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subscribed1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.testingProgramEmail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscribed {
            my_size += 2;
        }
        if let Some(v) = self.subscribed1 {
            my_size += 2;
        }
        if let Some(ref v) = self.testingProgramEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscribed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.subscribed1 {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.testingProgramEmail.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestingProgramInfo {
        TestingProgramInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "subscribed",
                |m: &TestingProgramInfo| { &m.subscribed },
                |m: &mut TestingProgramInfo| { &mut m.subscribed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "subscribed1",
                |m: &TestingProgramInfo| { &m.subscribed1 },
                |m: &mut TestingProgramInfo| { &mut m.subscribed1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "testingProgramEmail",
                |m: &TestingProgramInfo| { &m.testingProgramEmail },
                |m: &mut TestingProgramInfo| { &mut m.testingProgramEmail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestingProgramInfo>(
                "TestingProgramInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestingProgramInfo {
        static instance: ::protobuf::rt::LazyV2<TestingProgramInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestingProgramInfo::new)
    }
}

impl ::protobuf::Clear for TestingProgramInfo {
    fn clear(&mut self) {
        self.subscribed = ::std::option::Option::None;
        self.subscribed1 = ::std::option::Option::None;
        self.testingProgramEmail.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestingProgramInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingProgramInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EarlyAccessInfo {
    // message fields
    pub email: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EarlyAccessInfo {
    fn default() -> &'a EarlyAccessInfo {
        <EarlyAccessInfo as ::protobuf::Message>::default_instance()
    }
}

impl EarlyAccessInfo {
    pub fn new() -> EarlyAccessInfo {
        ::std::default::Default::default()
    }

    // optional string email = 3;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for EarlyAccessInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EarlyAccessInfo {
        EarlyAccessInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &EarlyAccessInfo| { &m.email },
                |m: &mut EarlyAccessInfo| { &mut m.email },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EarlyAccessInfo>(
                "EarlyAccessInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EarlyAccessInfo {
        static instance: ::protobuf::rt::LazyV2<EarlyAccessInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EarlyAccessInfo::new)
    }
}

impl ::protobuf::Clear for EarlyAccessInfo {
    fn clear(&mut self) {
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EarlyAccessInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EarlyAccessInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ArtistDetails {
    // message fields
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub externalLinks: ::protobuf::SingularPtrField<ArtistExternalLinks>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtistDetails {
    fn default() -> &'a ArtistDetails {
        <ArtistDetails as ::protobuf::Message>::default_instance()
    }
}

impl ArtistDetails {
    pub fn new() -> ArtistDetails {
        ::std::default::Default::default()
    }

    // optional string detailsUrl = 1;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ArtistExternalLinks externalLinks = 3;


    pub fn get_externalLinks(&self) -> &ArtistExternalLinks {
        self.externalLinks.as_ref().unwrap_or_else(|| <ArtistExternalLinks as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ArtistDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.externalLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.externalLinks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.externalLinks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.externalLinks.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistDetails {
        ArtistDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &ArtistDetails| { &m.detailsUrl },
                |m: &mut ArtistDetails| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ArtistDetails| { &m.name },
                |m: &mut ArtistDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistExternalLinks>>(
                "externalLinks",
                |m: &ArtistDetails| { &m.externalLinks },
                |m: &mut ArtistDetails| { &mut m.externalLinks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtistDetails>(
                "ArtistDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistDetails {
        static instance: ::protobuf::rt::LazyV2<ArtistDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtistDetails::new)
    }
}

impl ::protobuf::Clear for ArtistDetails {
    fn clear(&mut self) {
        self.detailsUrl.clear();
        self.name.clear();
        self.externalLinks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ArtistExternalLinks {
    // message fields
    pub websiteUrl: ::protobuf::RepeatedField<::std::string::String>,
    pub googlePlusProfileUrl: ::protobuf::SingularField<::std::string::String>,
    pub youtubeChannelUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArtistExternalLinks {
    fn default() -> &'a ArtistExternalLinks {
        <ArtistExternalLinks as ::protobuf::Message>::default_instance()
    }
}

impl ArtistExternalLinks {
    pub fn new() -> ArtistExternalLinks {
        ::std::default::Default::default()
    }

    // repeated string websiteUrl = 1;


    pub fn get_websiteUrl(&self) -> &[::std::string::String] {
        &self.websiteUrl
    }

    // optional string googlePlusProfileUrl = 2;


    pub fn get_googlePlusProfileUrl(&self) -> &str {
        match self.googlePlusProfileUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string youtubeChannelUrl = 3;


    pub fn get_youtubeChannelUrl(&self) -> &str {
        match self.youtubeChannelUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ArtistExternalLinks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.websiteUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.googlePlusProfileUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubeChannelUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.websiteUrl {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.googlePlusProfileUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.youtubeChannelUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.websiteUrl {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.googlePlusProfileUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.youtubeChannelUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArtistExternalLinks {
        ArtistExternalLinks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "websiteUrl",
                |m: &ArtistExternalLinks| { &m.websiteUrl },
                |m: &mut ArtistExternalLinks| { &mut m.websiteUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "googlePlusProfileUrl",
                |m: &ArtistExternalLinks| { &m.googlePlusProfileUrl },
                |m: &mut ArtistExternalLinks| { &mut m.googlePlusProfileUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtubeChannelUrl",
                |m: &ArtistExternalLinks| { &m.youtubeChannelUrl },
                |m: &mut ArtistExternalLinks| { &mut m.youtubeChannelUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ArtistExternalLinks>(
                "ArtistExternalLinks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ArtistExternalLinks {
        static instance: ::protobuf::rt::LazyV2<ArtistExternalLinks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ArtistExternalLinks::new)
    }
}

impl ::protobuf::Clear for ArtistExternalLinks {
    fn clear(&mut self) {
        self.websiteUrl.clear();
        self.googlePlusProfileUrl.clear();
        self.youtubeChannelUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArtistExternalLinks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtistExternalLinks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocumentDetails {
    // message fields
    pub appDetails: ::protobuf::SingularPtrField<AppDetails>,
    pub albumDetails: ::protobuf::SingularPtrField<AlbumDetails>,
    pub artistDetails: ::protobuf::SingularPtrField<ArtistDetails>,
    pub songDetails: ::protobuf::SingularPtrField<SongDetails>,
    pub bookDetails: ::protobuf::SingularPtrField<BookDetails>,
    pub videoDetails: ::protobuf::SingularPtrField<VideoDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<SubscriptionDetails>,
    pub magazineDetails: ::protobuf::SingularPtrField<MagazineDetails>,
    pub tvShowDetails: ::protobuf::SingularPtrField<TvShowDetails>,
    pub tvSeasonDetails: ::protobuf::SingularPtrField<TvSeasonDetails>,
    pub tvEpisodeDetails: ::protobuf::SingularPtrField<TvEpisodeDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDetails {
    fn default() -> &'a DocumentDetails {
        <DocumentDetails as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDetails {
    pub fn new() -> DocumentDetails {
        ::std::default::Default::default()
    }

    // optional .AppDetails appDetails = 1;


    pub fn get_appDetails(&self) -> &AppDetails {
        self.appDetails.as_ref().unwrap_or_else(|| <AppDetails as ::protobuf::Message>::default_instance())
    }

    // optional .AlbumDetails albumDetails = 2;


    pub fn get_albumDetails(&self) -> &AlbumDetails {
        self.albumDetails.as_ref().unwrap_or_else(|| <AlbumDetails as ::protobuf::Message>::default_instance())
    }

    // optional .ArtistDetails artistDetails = 3;


    pub fn get_artistDetails(&self) -> &ArtistDetails {
        self.artistDetails.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }

    // optional .SongDetails songDetails = 4;


    pub fn get_songDetails(&self) -> &SongDetails {
        self.songDetails.as_ref().unwrap_or_else(|| <SongDetails as ::protobuf::Message>::default_instance())
    }

    // optional .BookDetails bookDetails = 5;


    pub fn get_bookDetails(&self) -> &BookDetails {
        self.bookDetails.as_ref().unwrap_or_else(|| <BookDetails as ::protobuf::Message>::default_instance())
    }

    // optional .VideoDetails videoDetails = 6;


    pub fn get_videoDetails(&self) -> &VideoDetails {
        self.videoDetails.as_ref().unwrap_or_else(|| <VideoDetails as ::protobuf::Message>::default_instance())
    }

    // optional .SubscriptionDetails subscriptionDetails = 7;


    pub fn get_subscriptionDetails(&self) -> &SubscriptionDetails {
        self.subscriptionDetails.as_ref().unwrap_or_else(|| <SubscriptionDetails as ::protobuf::Message>::default_instance())
    }

    // optional .MagazineDetails magazineDetails = 8;


    pub fn get_magazineDetails(&self) -> &MagazineDetails {
        self.magazineDetails.as_ref().unwrap_or_else(|| <MagazineDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvShowDetails tvShowDetails = 9;


    pub fn get_tvShowDetails(&self) -> &TvShowDetails {
        self.tvShowDetails.as_ref().unwrap_or_else(|| <TvShowDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvSeasonDetails tvSeasonDetails = 10;


    pub fn get_tvSeasonDetails(&self) -> &TvSeasonDetails {
        self.tvSeasonDetails.as_ref().unwrap_or_else(|| <TvSeasonDetails as ::protobuf::Message>::default_instance())
    }

    // optional .TvEpisodeDetails tvEpisodeDetails = 11;


    pub fn get_tvEpisodeDetails(&self) -> &TvEpisodeDetails {
        self.tvEpisodeDetails.as_ref().unwrap_or_else(|| <TvEpisodeDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for DocumentDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.albumDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.artistDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.songDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bookDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.videoDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.magazineDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvShowDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvSeasonDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tvEpisodeDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDetails)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.albumDetails)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.artistDetails)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.songDetails)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bookDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.videoDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionDetails)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.magazineDetails)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvShowDetails)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvSeasonDetails)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tvEpisodeDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.albumDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.artistDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.songDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bookDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.videoDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.magazineDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvShowDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvSeasonDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tvEpisodeDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.appDetails.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.albumDetails.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.artistDetails.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.songDetails.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bookDetails.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.videoDetails.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.magazineDetails.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvShowDetails.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvSeasonDetails.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tvEpisodeDetails.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDetails {
        DocumentDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDetails>>(
                "appDetails",
                |m: &DocumentDetails| { &m.appDetails },
                |m: &mut DocumentDetails| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlbumDetails>>(
                "albumDetails",
                |m: &DocumentDetails| { &m.albumDetails },
                |m: &mut DocumentDetails| { &mut m.albumDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "artistDetails",
                |m: &DocumentDetails| { &m.artistDetails },
                |m: &mut DocumentDetails| { &mut m.artistDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SongDetails>>(
                "songDetails",
                |m: &DocumentDetails| { &m.songDetails },
                |m: &mut DocumentDetails| { &mut m.songDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BookDetails>>(
                "bookDetails",
                |m: &DocumentDetails| { &m.bookDetails },
                |m: &mut DocumentDetails| { &mut m.bookDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoDetails>>(
                "videoDetails",
                |m: &DocumentDetails| { &m.videoDetails },
                |m: &mut DocumentDetails| { &mut m.videoDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubscriptionDetails>>(
                "subscriptionDetails",
                |m: &DocumentDetails| { &m.subscriptionDetails },
                |m: &mut DocumentDetails| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MagazineDetails>>(
                "magazineDetails",
                |m: &DocumentDetails| { &m.magazineDetails },
                |m: &mut DocumentDetails| { &mut m.magazineDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvShowDetails>>(
                "tvShowDetails",
                |m: &DocumentDetails| { &m.tvShowDetails },
                |m: &mut DocumentDetails| { &mut m.tvShowDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvSeasonDetails>>(
                "tvSeasonDetails",
                |m: &DocumentDetails| { &m.tvSeasonDetails },
                |m: &mut DocumentDetails| { &mut m.tvSeasonDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TvEpisodeDetails>>(
                "tvEpisodeDetails",
                |m: &DocumentDetails| { &m.tvEpisodeDetails },
                |m: &mut DocumentDetails| { &mut m.tvEpisodeDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDetails>(
                "DocumentDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentDetails {
        static instance: ::protobuf::rt::LazyV2<DocumentDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentDetails::new)
    }
}

impl ::protobuf::Clear for DocumentDetails {
    fn clear(&mut self) {
        self.appDetails.clear();
        self.albumDetails.clear();
        self.artistDetails.clear();
        self.songDetails.clear();
        self.bookDetails.clear();
        self.videoDetails.clear();
        self.subscriptionDetails.clear();
        self.magazineDetails.clear();
        self.tvShowDetails.clear();
        self.tvSeasonDetails.clear();
        self.tvEpisodeDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FileMetadata {
    // message fields
    pub fileType: ::std::option::Option<i32>,
    pub versionCode: ::std::option::Option<i32>,
    pub size: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileMetadata {
    fn default() -> &'a FileMetadata {
        <FileMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FileMetadata {
    pub fn new() -> FileMetadata {
        ::std::default::Default::default()
    }

    // optional int32 fileType = 1;


    pub fn get_fileType(&self) -> i32 {
        self.fileType.unwrap_or(0)
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for FileMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fileType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileMetadata {
        FileMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fileType",
                |m: &FileMetadata| { &m.fileType },
                |m: &mut FileMetadata| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &FileMetadata| { &m.versionCode },
                |m: &mut FileMetadata| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &FileMetadata| { &m.size },
                |m: &mut FileMetadata| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileMetadata>(
                "FileMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileMetadata {
        static instance: ::protobuf::rt::LazyV2<FileMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileMetadata::new)
    }
}

impl ::protobuf::Clear for FileMetadata {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.versionCode = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MagazineDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub deviceAvailabilityDescriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub psvDescription: ::protobuf::SingularField<::std::string::String>,
    pub deliveryFrequencyDescription: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MagazineDetails {
    fn default() -> &'a MagazineDetails {
        <MagazineDetails as ::protobuf::Message>::default_instance()
    }
}

impl MagazineDetails {
    pub fn new() -> MagazineDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deviceAvailabilityDescriptionHtml = 2;


    pub fn get_deviceAvailabilityDescriptionHtml(&self) -> &str {
        match self.deviceAvailabilityDescriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string psvDescription = 3;


    pub fn get_psvDescription(&self) -> &str {
        match self.psvDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deliveryFrequencyDescription = 4;


    pub fn get_deliveryFrequencyDescription(&self) -> &str {
        match self.deliveryFrequencyDescription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MagazineDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceAvailabilityDescriptionHtml)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.psvDescription)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deliveryFrequencyDescription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.deliveryFrequencyDescription.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.deviceAvailabilityDescriptionHtml.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.psvDescription.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.deliveryFrequencyDescription.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MagazineDetails {
        MagazineDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &MagazineDetails| { &m.parentDetailsUrl },
                |m: &mut MagazineDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceAvailabilityDescriptionHtml",
                |m: &MagazineDetails| { &m.deviceAvailabilityDescriptionHtml },
                |m: &mut MagazineDetails| { &mut m.deviceAvailabilityDescriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "psvDescription",
                |m: &MagazineDetails| { &m.psvDescription },
                |m: &mut MagazineDetails| { &mut m.psvDescription },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deliveryFrequencyDescription",
                |m: &MagazineDetails| { &m.deliveryFrequencyDescription },
                |m: &mut MagazineDetails| { &mut m.deliveryFrequencyDescription },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MagazineDetails>(
                "MagazineDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MagazineDetails {
        static instance: ::protobuf::rt::LazyV2<MagazineDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MagazineDetails::new)
    }
}

impl ::protobuf::Clear for MagazineDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.deviceAvailabilityDescriptionHtml.clear();
        self.psvDescription.clear();
        self.deliveryFrequencyDescription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MagazineDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MagazineDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct MusicDetails {
    // message fields
    pub censoring: ::std::option::Option<i32>,
    pub durationSec: ::std::option::Option<i32>,
    pub originalReleaseDate: ::protobuf::SingularField<::std::string::String>,
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub artist: ::protobuf::RepeatedField<ArtistDetails>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub releaseType: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MusicDetails {
    fn default() -> &'a MusicDetails {
        <MusicDetails as ::protobuf::Message>::default_instance()
    }
}

impl MusicDetails {
    pub fn new() -> MusicDetails {
        ::std::default::Default::default()
    }

    // optional int32 censoring = 1;


    pub fn get_censoring(&self) -> i32 {
        self.censoring.unwrap_or(0)
    }

    // optional int32 durationSec = 2;


    pub fn get_durationSec(&self) -> i32 {
        self.durationSec.unwrap_or(0)
    }

    // optional string originalReleaseDate = 3;


    pub fn get_originalReleaseDate(&self) -> &str {
        match self.originalReleaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string label = 4;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .ArtistDetails artist = 5;


    pub fn get_artist(&self) -> &[ArtistDetails] {
        &self.artist
    }

    // repeated string genre = 6;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }

    // optional string releaseDate = 7;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated int32 releaseType = 8;


    pub fn get_releaseType(&self) -> &[i32] {
        &self.releaseType
    }
}

impl ::protobuf::Message for MusicDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.artist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.censoring = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.durationSec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalReleaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.artist)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.releaseType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.censoring {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.durationSec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.originalReleaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.artist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.releaseType {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.censoring {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.durationSec {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.originalReleaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.artist {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.genre {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.releaseType {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MusicDetails {
        MusicDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "censoring",
                |m: &MusicDetails| { &m.censoring },
                |m: &mut MusicDetails| { &mut m.censoring },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "durationSec",
                |m: &MusicDetails| { &m.durationSec },
                |m: &mut MusicDetails| { &mut m.durationSec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originalReleaseDate",
                |m: &MusicDetails| { &m.originalReleaseDate },
                |m: &mut MusicDetails| { &mut m.originalReleaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &MusicDetails| { &m.label },
                |m: &mut MusicDetails| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "artist",
                |m: &MusicDetails| { &m.artist },
                |m: &mut MusicDetails| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &MusicDetails| { &m.genre },
                |m: &mut MusicDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &MusicDetails| { &m.releaseDate },
                |m: &mut MusicDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "releaseType",
                |m: &MusicDetails| { &m.releaseType },
                |m: &mut MusicDetails| { &mut m.releaseType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MusicDetails>(
                "MusicDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MusicDetails {
        static instance: ::protobuf::rt::LazyV2<MusicDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MusicDetails::new)
    }
}

impl ::protobuf::Clear for MusicDetails {
    fn clear(&mut self) {
        self.censoring = ::std::option::Option::None;
        self.durationSec = ::std::option::Option::None;
        self.originalReleaseDate.clear();
        self.label.clear();
        self.artist.clear();
        self.genre.clear();
        self.releaseDate.clear();
        self.releaseType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MusicDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MusicDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SongDetails {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<MusicDetails>,
    pub albumName: ::protobuf::SingularField<::std::string::String>,
    pub trackNumber: ::std::option::Option<i32>,
    pub previewUrl: ::protobuf::SingularField<::std::string::String>,
    pub displayArtist: ::protobuf::SingularPtrField<ArtistDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SongDetails {
    fn default() -> &'a SongDetails {
        <SongDetails as ::protobuf::Message>::default_instance()
    }
}

impl SongDetails {
    pub fn new() -> SongDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .MusicDetails details = 2;


    pub fn get_details(&self) -> &MusicDetails {
        self.details.as_ref().unwrap_or_else(|| <MusicDetails as ::protobuf::Message>::default_instance())
    }

    // optional string albumName = 3;


    pub fn get_albumName(&self) -> &str {
        match self.albumName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 trackNumber = 4;


    pub fn get_trackNumber(&self) -> i32 {
        self.trackNumber.unwrap_or(0)
    }

    // optional string previewUrl = 5;


    pub fn get_previewUrl(&self) -> &str {
        match self.previewUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ArtistDetails displayArtist = 6;


    pub fn get_displayArtist(&self) -> &ArtistDetails {
        self.displayArtist.as_ref().unwrap_or_else(|| <ArtistDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SongDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.displayArtist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.albumName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trackNumber = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.previewUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.displayArtist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.albumName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.trackNumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.previewUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.albumName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.trackNumber {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.previewUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.displayArtist.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SongDetails {
        SongDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SongDetails| { &m.name },
                |m: &mut SongDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MusicDetails>>(
                "details",
                |m: &SongDetails| { &m.details },
                |m: &mut SongDetails| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "albumName",
                |m: &SongDetails| { &m.albumName },
                |m: &mut SongDetails| { &mut m.albumName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trackNumber",
                |m: &SongDetails| { &m.trackNumber },
                |m: &mut SongDetails| { &mut m.trackNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "previewUrl",
                |m: &SongDetails| { &m.previewUrl },
                |m: &mut SongDetails| { &mut m.previewUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ArtistDetails>>(
                "displayArtist",
                |m: &SongDetails| { &m.displayArtist },
                |m: &mut SongDetails| { &mut m.displayArtist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SongDetails>(
                "SongDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SongDetails {
        static instance: ::protobuf::rt::LazyV2<SongDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SongDetails::new)
    }
}

impl ::protobuf::Clear for SongDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.details.clear();
        self.albumName.clear();
        self.trackNumber = ::std::option::Option::None;
        self.previewUrl.clear();
        self.displayArtist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SongDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SongDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SubscriptionDetails {
    // message fields
    pub subscriptionPeriod: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscriptionDetails {
    fn default() -> &'a SubscriptionDetails {
        <SubscriptionDetails as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionDetails {
    pub fn new() -> SubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int32 subscriptionPeriod = 1;


    pub fn get_subscriptionPeriod(&self) -> i32 {
        self.subscriptionPeriod.unwrap_or(0)
    }
}

impl ::protobuf::Message for SubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.subscriptionPeriod = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscriptionPeriod {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscriptionPeriod {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionDetails {
        SubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "subscriptionPeriod",
                |m: &SubscriptionDetails| { &m.subscriptionPeriod },
                |m: &mut SubscriptionDetails| { &mut m.subscriptionPeriod },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscriptionDetails>(
                "SubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscriptionDetails {
        static instance: ::protobuf::rt::LazyV2<SubscriptionDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for SubscriptionDetails {
    fn clear(&mut self) {
        self.subscriptionPeriod = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Trailer {
    // message fields
    pub trailerId: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub thumbnailUrl: ::protobuf::SingularField<::std::string::String>,
    pub watchUrl: ::protobuf::SingularField<::std::string::String>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Trailer {
    fn default() -> &'a Trailer {
        <Trailer as ::protobuf::Message>::default_instance()
    }
}

impl Trailer {
    pub fn new() -> Trailer {
        ::std::default::Default::default()
    }

    // optional string trailerId = 1;


    pub fn get_trailerId(&self) -> &str {
        match self.trailerId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string thumbnailUrl = 3;


    pub fn get_thumbnailUrl(&self) -> &str {
        match self.thumbnailUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string watchUrl = 4;


    pub fn get_watchUrl(&self) -> &str {
        match self.watchUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string duration = 5;


    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Trailer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trailerId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbnailUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.watchUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trailerId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbnailUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.watchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trailerId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbnailUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.watchUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trailer {
        Trailer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trailerId",
                |m: &Trailer| { &m.trailerId },
                |m: &mut Trailer| { &mut m.trailerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Trailer| { &m.title },
                |m: &mut Trailer| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbnailUrl",
                |m: &Trailer| { &m.thumbnailUrl },
                |m: &mut Trailer| { &mut m.thumbnailUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "watchUrl",
                |m: &Trailer| { &m.watchUrl },
                |m: &mut Trailer| { &mut m.watchUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &Trailer| { &m.duration },
                |m: &mut Trailer| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Trailer>(
                "Trailer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Trailer {
        static instance: ::protobuf::rt::LazyV2<Trailer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Trailer::new)
    }
}

impl ::protobuf::Clear for Trailer {
    fn clear(&mut self) {
        self.trailerId.clear();
        self.title.clear();
        self.thumbnailUrl.clear();
        self.watchUrl.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trailer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trailer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvEpisodeDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub episodeIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvEpisodeDetails {
    fn default() -> &'a TvEpisodeDetails {
        <TvEpisodeDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvEpisodeDetails {
    pub fn new() -> TvEpisodeDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 episodeIndex = 2;


    pub fn get_episodeIndex(&self) -> i32 {
        self.episodeIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvEpisodeDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.episodeIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.episodeIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.episodeIndex {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvEpisodeDetails {
        TvEpisodeDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &TvEpisodeDetails| { &m.parentDetailsUrl },
                |m: &mut TvEpisodeDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "episodeIndex",
                |m: &TvEpisodeDetails| { &m.episodeIndex },
                |m: &mut TvEpisodeDetails| { &mut m.episodeIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &TvEpisodeDetails| { &m.releaseDate },
                |m: &mut TvEpisodeDetails| { &mut m.releaseDate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvEpisodeDetails>(
                "TvEpisodeDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvEpisodeDetails {
        static instance: ::protobuf::rt::LazyV2<TvEpisodeDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvEpisodeDetails::new)
    }
}

impl ::protobuf::Clear for TvEpisodeDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.episodeIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvEpisodeDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvEpisodeDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvSeasonDetails {
    // message fields
    pub parentDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub seasonIndex: ::std::option::Option<i32>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvSeasonDetails {
    fn default() -> &'a TvSeasonDetails {
        <TvSeasonDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvSeasonDetails {
    pub fn new() -> TvSeasonDetails {
        ::std::default::Default::default()
    }

    // optional string parentDetailsUrl = 1;


    pub fn get_parentDetailsUrl(&self) -> &str {
        match self.parentDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 seasonIndex = 2;


    pub fn get_seasonIndex(&self) -> i32 {
        self.seasonIndex.unwrap_or(0)
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string broadcaster = 4;


    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvSeasonDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parentDetailsUrl)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seasonIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parentDetailsUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.seasonIndex {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvSeasonDetails {
        TvSeasonDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentDetailsUrl",
                |m: &TvSeasonDetails| { &m.parentDetailsUrl },
                |m: &mut TvSeasonDetails| { &mut m.parentDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seasonIndex",
                |m: &TvSeasonDetails| { &m.seasonIndex },
                |m: &mut TvSeasonDetails| { &mut m.seasonIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &TvSeasonDetails| { &m.releaseDate },
                |m: &mut TvSeasonDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcaster",
                |m: &TvSeasonDetails| { &m.broadcaster },
                |m: &mut TvSeasonDetails| { &mut m.broadcaster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvSeasonDetails>(
                "TvSeasonDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvSeasonDetails {
        static instance: ::protobuf::rt::LazyV2<TvSeasonDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvSeasonDetails::new)
    }
}

impl ::protobuf::Clear for TvSeasonDetails {
    fn clear(&mut self) {
        self.parentDetailsUrl.clear();
        self.seasonIndex = ::std::option::Option::None;
        self.releaseDate.clear();
        self.broadcaster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvSeasonDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvSeasonDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TvShowDetails {
    // message fields
    pub seasonCount: ::std::option::Option<i32>,
    pub startYear: ::std::option::Option<i32>,
    pub endYear: ::std::option::Option<i32>,
    pub broadcaster: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TvShowDetails {
    fn default() -> &'a TvShowDetails {
        <TvShowDetails as ::protobuf::Message>::default_instance()
    }
}

impl TvShowDetails {
    pub fn new() -> TvShowDetails {
        ::std::default::Default::default()
    }

    // optional int32 seasonCount = 1;


    pub fn get_seasonCount(&self) -> i32 {
        self.seasonCount.unwrap_or(0)
    }

    // optional int32 startYear = 2;


    pub fn get_startYear(&self) -> i32 {
        self.startYear.unwrap_or(0)
    }

    // optional int32 endYear = 3;


    pub fn get_endYear(&self) -> i32 {
        self.endYear.unwrap_or(0)
    }

    // optional string broadcaster = 4;


    pub fn get_broadcaster(&self) -> &str {
        match self.broadcaster.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TvShowDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seasonCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.startYear = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.endYear = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.broadcaster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seasonCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startYear {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endYear {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seasonCount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.startYear {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.endYear {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.broadcaster.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TvShowDetails {
        TvShowDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seasonCount",
                |m: &TvShowDetails| { &m.seasonCount },
                |m: &mut TvShowDetails| { &mut m.seasonCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "startYear",
                |m: &TvShowDetails| { &m.startYear },
                |m: &mut TvShowDetails| { &mut m.startYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "endYear",
                |m: &TvShowDetails| { &m.endYear },
                |m: &mut TvShowDetails| { &mut m.endYear },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "broadcaster",
                |m: &TvShowDetails| { &m.broadcaster },
                |m: &mut TvShowDetails| { &mut m.broadcaster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TvShowDetails>(
                "TvShowDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TvShowDetails {
        static instance: ::protobuf::rt::LazyV2<TvShowDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TvShowDetails::new)
    }
}

impl ::protobuf::Clear for TvShowDetails {
    fn clear(&mut self) {
        self.seasonCount = ::std::option::Option::None;
        self.startYear = ::std::option::Option::None;
        self.endYear = ::std::option::Option::None;
        self.broadcaster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TvShowDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TvShowDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoCredit {
    // message fields
    pub creditType: ::std::option::Option<i32>,
    pub credit: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoCredit {
    fn default() -> &'a VideoCredit {
        <VideoCredit as ::protobuf::Message>::default_instance()
    }
}

impl VideoCredit {
    pub fn new() -> VideoCredit {
        ::std::default::Default::default()
    }

    // optional int32 creditType = 1;


    pub fn get_creditType(&self) -> i32 {
        self.creditType.unwrap_or(0)
    }

    // optional string credit = 2;


    pub fn get_credit(&self) -> &str {
        match self.credit.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string name = 3;


    pub fn get_name(&self) -> &[::std::string::String] {
        &self.name
    }
}

impl ::protobuf::Message for VideoCredit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.creditType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credit)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.creditType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.credit.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.name {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.creditType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.credit.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.name {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoCredit {
        VideoCredit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "creditType",
                |m: &VideoCredit| { &m.creditType },
                |m: &mut VideoCredit| { &mut m.creditType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credit",
                |m: &VideoCredit| { &m.credit },
                |m: &mut VideoCredit| { &mut m.credit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VideoCredit| { &m.name },
                |m: &mut VideoCredit| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoCredit>(
                "VideoCredit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoCredit {
        static instance: ::protobuf::rt::LazyV2<VideoCredit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoCredit::new)
    }
}

impl ::protobuf::Clear for VideoCredit {
    fn clear(&mut self) {
        self.creditType = ::std::option::Option::None;
        self.credit.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoCredit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoCredit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoDetails {
    // message fields
    pub credit: ::protobuf::RepeatedField<VideoCredit>,
    pub duration: ::protobuf::SingularField<::std::string::String>,
    pub releaseDate: ::protobuf::SingularField<::std::string::String>,
    pub contentRating: ::protobuf::SingularField<::std::string::String>,
    pub likes: ::std::option::Option<i64>,
    pub dislikes: ::std::option::Option<i64>,
    pub genre: ::protobuf::RepeatedField<::std::string::String>,
    pub trailer: ::protobuf::RepeatedField<Trailer>,
    pub rentalTerm: ::protobuf::RepeatedField<VideoRentalTerm>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoDetails {
    fn default() -> &'a VideoDetails {
        <VideoDetails as ::protobuf::Message>::default_instance()
    }
}

impl VideoDetails {
    pub fn new() -> VideoDetails {
        ::std::default::Default::default()
    }

    // repeated .VideoCredit credit = 1;


    pub fn get_credit(&self) -> &[VideoCredit] {
        &self.credit
    }

    // optional string duration = 2;


    pub fn get_duration(&self) -> &str {
        match self.duration.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string releaseDate = 3;


    pub fn get_releaseDate(&self) -> &str {
        match self.releaseDate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string contentRating = 4;


    pub fn get_contentRating(&self) -> &str {
        match self.contentRating.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 likes = 5;


    pub fn get_likes(&self) -> i64 {
        self.likes.unwrap_or(0)
    }

    // optional int64 dislikes = 6;


    pub fn get_dislikes(&self) -> i64 {
        self.dislikes.unwrap_or(0)
    }

    // repeated string genre = 7;


    pub fn get_genre(&self) -> &[::std::string::String] {
        &self.genre
    }

    // repeated .Trailer trailer = 8;


    pub fn get_trailer(&self) -> &[Trailer] {
        &self.trailer
    }

    // repeated .VideoRentalTerm rentalTerm = 9;


    pub fn get_rentalTerm(&self) -> &[VideoRentalTerm] {
        &self.rentalTerm
    }
}

impl ::protobuf::Message for VideoDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.credit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trailer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rentalTerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.credit)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.duration)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.releaseDate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.contentRating)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.likes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dislikes = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.genre)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trailer)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rentalTerm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.credit {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.duration.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.contentRating.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.likes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dislikes {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.genre {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.trailer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rentalTerm {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.credit {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.duration.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.releaseDate.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.contentRating.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.likes {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dislikes {
            os.write_int64(6, v)?;
        }
        for v in &self.genre {
            os.write_string(7, &v)?;
        };
        for v in &self.trailer {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rentalTerm {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoDetails {
        VideoDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoCredit>>(
                "credit",
                |m: &VideoDetails| { &m.credit },
                |m: &mut VideoDetails| { &mut m.credit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &VideoDetails| { &m.duration },
                |m: &mut VideoDetails| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "releaseDate",
                |m: &VideoDetails| { &m.releaseDate },
                |m: &mut VideoDetails| { &mut m.releaseDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contentRating",
                |m: &VideoDetails| { &m.contentRating },
                |m: &mut VideoDetails| { &mut m.contentRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "likes",
                |m: &VideoDetails| { &m.likes },
                |m: &mut VideoDetails| { &mut m.likes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dislikes",
                |m: &VideoDetails| { &m.dislikes },
                |m: &mut VideoDetails| { &mut m.dislikes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "genre",
                |m: &VideoDetails| { &m.genre },
                |m: &mut VideoDetails| { &mut m.genre },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Trailer>>(
                "trailer",
                |m: &VideoDetails| { &m.trailer },
                |m: &mut VideoDetails| { &mut m.trailer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoRentalTerm>>(
                "rentalTerm",
                |m: &VideoDetails| { &m.rentalTerm },
                |m: &mut VideoDetails| { &mut m.rentalTerm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoDetails>(
                "VideoDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoDetails {
        static instance: ::protobuf::rt::LazyV2<VideoDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoDetails::new)
    }
}

impl ::protobuf::Clear for VideoDetails {
    fn clear(&mut self) {
        self.credit.clear();
        self.duration.clear();
        self.releaseDate.clear();
        self.contentRating.clear();
        self.likes = ::std::option::Option::None;
        self.dislikes = ::std::option::Option::None;
        self.genre.clear();
        self.trailer.clear();
        self.rentalTerm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoRentalTerm {
    // message fields
    pub offerType: ::std::option::Option<i32>,
    pub offerAbbreviation: ::protobuf::SingularField<::std::string::String>,
    pub rentalHeader: ::protobuf::SingularField<::std::string::String>,
    // term: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoRentalTerm {
    fn default() -> &'a VideoRentalTerm {
        <VideoRentalTerm as ::protobuf::Message>::default_instance()
    }
}

impl VideoRentalTerm {
    pub fn new() -> VideoRentalTerm {
        ::std::default::Default::default()
    }

    // optional int32 offerType = 1;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional string offerAbbreviation = 2;


    pub fn get_offerAbbreviation(&self) -> &str {
        match self.offerAbbreviation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string rentalHeader = 3;


    pub fn get_rentalHeader(&self) -> &str {
        match self.rentalHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.offerAbbreviation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rentalHeader)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.offerAbbreviation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.rentalHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offerType {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.offerAbbreviation.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.rentalHeader.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm {
        VideoRentalTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &VideoRentalTerm| { &m.offerType },
                |m: &mut VideoRentalTerm| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "offerAbbreviation",
                |m: &VideoRentalTerm| { &m.offerAbbreviation },
                |m: &mut VideoRentalTerm| { &mut m.offerAbbreviation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rentalHeader",
                |m: &VideoRentalTerm| { &m.rentalHeader },
                |m: &mut VideoRentalTerm| { &mut m.rentalHeader },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoRentalTerm>(
                "VideoRentalTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm {
        static instance: ::protobuf::rt::LazyV2<VideoRentalTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoRentalTerm::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm {
    fn clear(&mut self) {
        self.offerType = ::std::option::Option::None;
        self.offerAbbreviation.clear();
        self.rentalHeader.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VideoRentalTerm_Term {
    // message fields
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub body: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoRentalTerm_Term {
    fn default() -> &'a VideoRentalTerm_Term {
        <VideoRentalTerm_Term as ::protobuf::Message>::default_instance()
    }
}

impl VideoRentalTerm_Term {
    pub fn new() -> VideoRentalTerm_Term {
        ::std::default::Default::default()
    }

    // optional string header = 5;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string body = 6;


    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for VideoRentalTerm_Term {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoRentalTerm_Term {
        VideoRentalTerm_Term::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &VideoRentalTerm_Term| { &m.header },
                |m: &mut VideoRentalTerm_Term| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &VideoRentalTerm_Term| { &m.body },
                |m: &mut VideoRentalTerm_Term| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VideoRentalTerm_Term>(
                "VideoRentalTerm.Term",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VideoRentalTerm_Term {
        static instance: ::protobuf::rt::LazyV2<VideoRentalTerm_Term> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VideoRentalTerm_Term::new)
    }
}

impl ::protobuf::Clear for VideoRentalTerm_Term {
    fn clear(&mut self) {
        self.header.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoRentalTerm_Term {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoRentalTerm_Term {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Bucket {
    // message fields
    pub document: ::protobuf::RepeatedField<DocV1>,
    pub multiCorpus: ::std::option::Option<bool>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub iconUrl: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relevance: ::std::option::Option<f64>,
    pub estimatedResults: ::std::option::Option<i64>,
    pub analyticsCookie: ::protobuf::SingularField<::std::string::String>,
    pub fullContentsListUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub ordered: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket {
    fn default() -> &'a Bucket {
        <Bucket as ::protobuf::Message>::default_instance()
    }
}

impl Bucket {
    pub fn new() -> Bucket {
        ::std::default::Default::default()
    }

    // repeated .DocV1 document = 1;


    pub fn get_document(&self) -> &[DocV1] {
        &self.document
    }

    // optional bool multiCorpus = 2;


    pub fn get_multiCorpus(&self) -> bool {
        self.multiCorpus.unwrap_or(false)
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string iconUrl = 4;


    pub fn get_iconUrl(&self) -> &str {
        match self.iconUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string fullContentsUrl = 5;


    pub fn get_fullContentsUrl(&self) -> &str {
        match self.fullContentsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double relevance = 6;


    pub fn get_relevance(&self) -> f64 {
        self.relevance.unwrap_or(0.)
    }

    // optional int64 estimatedResults = 7;


    pub fn get_estimatedResults(&self) -> i64 {
        self.estimatedResults.unwrap_or(0)
    }

    // optional string analyticsCookie = 8;


    pub fn get_analyticsCookie(&self) -> &str {
        match self.analyticsCookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string fullContentsListUrl = 9;


    pub fn get_fullContentsListUrl(&self) -> &str {
        match self.fullContentsListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string nextPageUrl = 10;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ordered = 11;


    pub fn get_ordered(&self) -> bool {
        self.ordered.unwrap_or(false)
    }
}

impl ::protobuf::Message for Bucket {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiCorpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.relevance = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.estimatedResults = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.analyticsCookie)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fullContentsListUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ordered = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.document {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.multiCorpus {
            my_size += 2;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.iconUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.fullContentsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.relevance {
            my_size += 9;
        }
        if let Some(v) = self.estimatedResults {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.fullContentsListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.ordered {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.document {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.multiCorpus {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.iconUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.fullContentsUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.relevance {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.estimatedResults {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.analyticsCookie.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.fullContentsListUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.ordered {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket {
        Bucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV1>>(
                "document",
                |m: &Bucket| { &m.document },
                |m: &mut Bucket| { &mut m.document },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "multiCorpus",
                |m: &Bucket| { &m.multiCorpus },
                |m: &mut Bucket| { &mut m.multiCorpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Bucket| { &m.title },
                |m: &mut Bucket| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iconUrl",
                |m: &Bucket| { &m.iconUrl },
                |m: &mut Bucket| { &mut m.iconUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullContentsUrl",
                |m: &Bucket| { &m.fullContentsUrl },
                |m: &mut Bucket| { &mut m.fullContentsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "relevance",
                |m: &Bucket| { &m.relevance },
                |m: &mut Bucket| { &mut m.relevance },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "estimatedResults",
                |m: &Bucket| { &m.estimatedResults },
                |m: &mut Bucket| { &mut m.estimatedResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "analyticsCookie",
                |m: &Bucket| { &m.analyticsCookie },
                |m: &mut Bucket| { &mut m.analyticsCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fullContentsListUrl",
                |m: &Bucket| { &m.fullContentsListUrl },
                |m: &mut Bucket| { &mut m.fullContentsListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &Bucket| { &m.nextPageUrl },
                |m: &mut Bucket| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ordered",
                |m: &Bucket| { &m.ordered },
                |m: &mut Bucket| { &mut m.ordered },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket>(
                "Bucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket {
        static instance: ::protobuf::rt::LazyV2<Bucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket::new)
    }
}

impl ::protobuf::Clear for Bucket {
    fn clear(&mut self) {
        self.document.clear();
        self.multiCorpus = ::std::option::Option::None;
        self.title.clear();
        self.iconUrl.clear();
        self.fullContentsUrl.clear();
        self.relevance = ::std::option::Option::None;
        self.estimatedResults = ::std::option::Option::None;
        self.analyticsCookie.clear();
        self.fullContentsListUrl.clear();
        self.nextPageUrl.clear();
        self.ordered = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ListResponse {
    // message fields
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // repeated .Bucket bucket = 1;


    pub fn get_bucket(&self) -> &[Bucket] {
        &self.bucket
    }

    // repeated .DocV2 doc = 2;


    pub fn get_doc(&self) -> &[DocV2] {
        &self.doc
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bucket {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.doc {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &ListResponse| { &m.bucket },
                |m: &mut ListResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &ListResponse| { &m.doc },
                |m: &mut ListResponse| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListResponse>(
                "ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ::protobuf::rt::LazyV2<ListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListResponse::new)
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.bucket.clear();
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocV1 {
    // message fields
    pub finskyDoc: ::protobuf::SingularPtrField<Document>,
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedListUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByListUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub relatedBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub moreByBrowseUrl: ::protobuf::SingularField<::std::string::String>,
    pub relatedHeader: ::protobuf::SingularField<::std::string::String>,
    pub moreByHeader: ::protobuf::SingularField<::std::string::String>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub plusOneData: ::protobuf::SingularPtrField<PlusOneData>,
    pub warningMessage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocV1 {
    fn default() -> &'a DocV1 {
        <DocV1 as ::protobuf::Message>::default_instance()
    }
}

impl DocV1 {
    pub fn new() -> DocV1 {
        ::std::default::Default::default()
    }

    // optional .Document finskyDoc = 1;


    pub fn get_finskyDoc(&self) -> &Document {
        self.finskyDoc.as_ref().unwrap_or_else(|| <Document as ::protobuf::Message>::default_instance())
    }

    // optional string docid = 2;


    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string detailsUrl = 3;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewsUrl = 4;


    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedListUrl = 5;


    pub fn get_relatedListUrl(&self) -> &str {
        match self.relatedListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByListUrl = 6;


    pub fn get_moreByListUrl(&self) -> &str {
        match self.moreByListUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string shareUrl = 7;


    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string creator = 8;


    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DocumentDetails details = 9;


    pub fn get_details(&self) -> &DocumentDetails {
        self.details.as_ref().unwrap_or_else(|| <DocumentDetails as ::protobuf::Message>::default_instance())
    }

    // optional string descriptionHtml = 10;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedBrowseUrl = 11;


    pub fn get_relatedBrowseUrl(&self) -> &str {
        match self.relatedBrowseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByBrowseUrl = 12;


    pub fn get_moreByBrowseUrl(&self) -> &str {
        match self.moreByBrowseUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string relatedHeader = 13;


    pub fn get_relatedHeader(&self) -> &str {
        match self.relatedHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string moreByHeader = 14;


    pub fn get_moreByHeader(&self) -> &str {
        match self.moreByHeader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string title = 15;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .PlusOneData plusOneData = 16;


    pub fn get_plusOneData(&self) -> &PlusOneData {
        self.plusOneData.as_ref().unwrap_or_else(|| <PlusOneData as ::protobuf::Message>::default_instance())
    }

    // optional string warningMessage = 17;


    pub fn get_warningMessage(&self) -> &str {
        match self.warningMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocV1 {
    fn is_initialized(&self) -> bool {
        for v in &self.finskyDoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plusOneData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finskyDoc)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedListUrl)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByListUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedBrowseUrl)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByBrowseUrl)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relatedHeader)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.moreByHeader)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plusOneData)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.warningMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.finskyDoc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.relatedListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.moreByListUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.relatedBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.moreByBrowseUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.relatedHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.moreByHeader.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.finskyDoc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.relatedListUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.moreByListUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.creator.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.relatedBrowseUrl.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.moreByBrowseUrl.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.relatedHeader.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.moreByHeader.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.plusOneData.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.warningMessage.as_ref() {
            os.write_string(17, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV1 {
        DocV1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "finskyDoc",
                |m: &DocV1| { &m.finskyDoc },
                |m: &mut DocV1| { &mut m.finskyDoc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &DocV1| { &m.docid },
                |m: &mut DocV1| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &DocV1| { &m.detailsUrl },
                |m: &mut DocV1| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewsUrl",
                |m: &DocV1| { &m.reviewsUrl },
                |m: &mut DocV1| { &mut m.reviewsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedListUrl",
                |m: &DocV1| { &m.relatedListUrl },
                |m: &mut DocV1| { &mut m.relatedListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByListUrl",
                |m: &DocV1| { &m.moreByListUrl },
                |m: &mut DocV1| { &mut m.moreByListUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareUrl",
                |m: &DocV1| { &m.shareUrl },
                |m: &mut DocV1| { &mut m.shareUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creator",
                |m: &DocV1| { &m.creator },
                |m: &mut DocV1| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>>(
                "details",
                |m: &DocV1| { &m.details },
                |m: &mut DocV1| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &DocV1| { &m.descriptionHtml },
                |m: &mut DocV1| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedBrowseUrl",
                |m: &DocV1| { &m.relatedBrowseUrl },
                |m: &mut DocV1| { &mut m.relatedBrowseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByBrowseUrl",
                |m: &DocV1| { &m.moreByBrowseUrl },
                |m: &mut DocV1| { &mut m.moreByBrowseUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relatedHeader",
                |m: &DocV1| { &m.relatedHeader },
                |m: &mut DocV1| { &mut m.relatedHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moreByHeader",
                |m: &DocV1| { &m.moreByHeader },
                |m: &mut DocV1| { &mut m.moreByHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocV1| { &m.title },
                |m: &mut DocV1| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlusOneData>>(
                "plusOneData",
                |m: &DocV1| { &m.plusOneData },
                |m: &mut DocV1| { &mut m.plusOneData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "warningMessage",
                |m: &DocV1| { &m.warningMessage },
                |m: &mut DocV1| { &mut m.warningMessage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocV1>(
                "DocV1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV1 {
        static instance: ::protobuf::rt::LazyV2<DocV1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocV1::new)
    }
}

impl ::protobuf::Clear for DocV1 {
    fn clear(&mut self) {
        self.finskyDoc.clear();
        self.docid.clear();
        self.detailsUrl.clear();
        self.reviewsUrl.clear();
        self.relatedListUrl.clear();
        self.moreByListUrl.clear();
        self.shareUrl.clear();
        self.creator.clear();
        self.details.clear();
        self.descriptionHtml.clear();
        self.relatedBrowseUrl.clear();
        self.moreByBrowseUrl.clear();
        self.relatedHeader.clear();
        self.moreByHeader.clear();
        self.title.clear();
        self.plusOneData.clear();
        self.warningMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DocV2 {
    // message fields
    pub docid: ::protobuf::SingularField<::std::string::String>,
    pub backendDocid: ::protobuf::SingularField<::std::string::String>,
    pub docType: ::std::option::Option<i32>,
    pub backendId: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub creator: ::protobuf::SingularField<::std::string::String>,
    pub descriptionHtml: ::protobuf::SingularField<::std::string::String>,
    pub offer: ::protobuf::RepeatedField<Offer>,
    pub availability: ::protobuf::SingularPtrField<Availability>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub child: ::protobuf::RepeatedField<DocV2>,
    pub containerMetadata: ::protobuf::SingularPtrField<ContainerMetadata>,
    pub details: ::protobuf::SingularPtrField<DocumentDetails>,
    pub aggregateRating: ::protobuf::SingularPtrField<AggregateRating>,
    pub relatedLinks: ::protobuf::SingularPtrField<RelatedLinks>,
    pub detailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub shareUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewsUrl: ::protobuf::SingularField<::std::string::String>,
    pub backendUrl: ::protobuf::SingularField<::std::string::String>,
    pub purchaseDetailsUrl: ::protobuf::SingularField<::std::string::String>,
    pub detailsReusable: ::std::option::Option<bool>,
    pub subtitle: ::protobuf::SingularField<::std::string::String>,
    pub unknownCategoryContainer: ::protobuf::SingularPtrField<UnknownCategoryContainer>,
    pub unknown25: ::protobuf::SingularPtrField<Unknown25>,
    pub descriptionShort: ::protobuf::SingularField<::std::string::String>,
    pub reviewSnippetsUrl: ::protobuf::SingularField<::std::string::String>,
    pub reviewQuestionsUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocV2 {
    fn default() -> &'a DocV2 {
        <DocV2 as ::protobuf::Message>::default_instance()
    }
}

impl DocV2 {
    pub fn new() -> DocV2 {
        ::std::default::Default::default()
    }

    // optional string docid = 1;


    pub fn get_docid(&self) -> &str {
        match self.docid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string backendDocid = 2;


    pub fn get_backendDocid(&self) -> &str {
        match self.backendDocid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 docType = 3;


    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional int32 backendId = 4;


    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string creator = 6;


    pub fn get_creator(&self) -> &str {
        match self.creator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string descriptionHtml = 7;


    pub fn get_descriptionHtml(&self) -> &str {
        match self.descriptionHtml.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Offer offer = 8;


    pub fn get_offer(&self) -> &[Offer] {
        &self.offer
    }

    // optional .Availability availability = 9;


    pub fn get_availability(&self) -> &Availability {
        self.availability.as_ref().unwrap_or_else(|| <Availability as ::protobuf::Message>::default_instance())
    }

    // repeated .Image image = 10;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // repeated .DocV2 child = 11;


    pub fn get_child(&self) -> &[DocV2] {
        &self.child
    }

    // optional .ContainerMetadata containerMetadata = 12;


    pub fn get_containerMetadata(&self) -> &ContainerMetadata {
        self.containerMetadata.as_ref().unwrap_or_else(|| <ContainerMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .DocumentDetails details = 13;


    pub fn get_details(&self) -> &DocumentDetails {
        self.details.as_ref().unwrap_or_else(|| <DocumentDetails as ::protobuf::Message>::default_instance())
    }

    // optional .AggregateRating aggregateRating = 14;


    pub fn get_aggregateRating(&self) -> &AggregateRating {
        self.aggregateRating.as_ref().unwrap_or_else(|| <AggregateRating as ::protobuf::Message>::default_instance())
    }

    // optional .RelatedLinks relatedLinks = 15;


    pub fn get_relatedLinks(&self) -> &RelatedLinks {
        self.relatedLinks.as_ref().unwrap_or_else(|| <RelatedLinks as ::protobuf::Message>::default_instance())
    }

    // optional string detailsUrl = 16;


    pub fn get_detailsUrl(&self) -> &str {
        match self.detailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string shareUrl = 17;


    pub fn get_shareUrl(&self) -> &str {
        match self.shareUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewsUrl = 18;


    pub fn get_reviewsUrl(&self) -> &str {
        match self.reviewsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string backendUrl = 19;


    pub fn get_backendUrl(&self) -> &str {
        match self.backendUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string purchaseDetailsUrl = 20;


    pub fn get_purchaseDetailsUrl(&self) -> &str {
        match self.purchaseDetailsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool detailsReusable = 21;


    pub fn get_detailsReusable(&self) -> bool {
        self.detailsReusable.unwrap_or(false)
    }

    // optional string subtitle = 22;


    pub fn get_subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .UnknownCategoryContainer unknownCategoryContainer = 24;


    pub fn get_unknownCategoryContainer(&self) -> &UnknownCategoryContainer {
        self.unknownCategoryContainer.as_ref().unwrap_or_else(|| <UnknownCategoryContainer as ::protobuf::Message>::default_instance())
    }

    // optional .Unknown25 unknown25 = 25;


    pub fn get_unknown25(&self) -> &Unknown25 {
        self.unknown25.as_ref().unwrap_or_else(|| <Unknown25 as ::protobuf::Message>::default_instance())
    }

    // optional string descriptionShort = 27;


    pub fn get_descriptionShort(&self) -> &str {
        match self.descriptionShort.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewSnippetsUrl = 31;


    pub fn get_reviewSnippetsUrl(&self) -> &str {
        match self.reviewSnippetsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reviewQuestionsUrl = 34;


    pub fn get_reviewQuestionsUrl(&self) -> &str {
        match self.reviewQuestionsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for DocV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.offer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.availability {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregateRating {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unknownCategoryContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unknown25 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendDocid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.creator)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionHtml)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offer)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.availability)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.containerMetadata)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregateRating)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relatedLinks)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.detailsUrl)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareUrl)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewsUrl)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backendUrl)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchaseDetailsUrl)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detailsReusable = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subtitle)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknownCategoryContainer)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknown25)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.descriptionShort)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewSnippetsUrl)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reviewQuestionsUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.backendDocid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.creator.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.offer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.availability.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.containerMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.aggregateRating.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.relatedLinks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.backendUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.purchaseDetailsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.detailsReusable {
            my_size += 3;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(ref v) = self.unknownCategoryContainer.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unknown25.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.descriptionShort.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(ref v) = self.reviewSnippetsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(ref v) = self.reviewQuestionsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.backendDocid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.creator.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.descriptionHtml.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.offer {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.availability.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.image {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.child {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.containerMetadata.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.aggregateRating.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.relatedLinks.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detailsUrl.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.shareUrl.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.reviewsUrl.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.backendUrl.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.purchaseDetailsUrl.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.detailsReusable {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.subtitle.as_ref() {
            os.write_string(22, &v)?;
        }
        if let Some(ref v) = self.unknownCategoryContainer.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unknown25.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.descriptionShort.as_ref() {
            os.write_string(27, &v)?;
        }
        if let Some(ref v) = self.reviewSnippetsUrl.as_ref() {
            os.write_string(31, &v)?;
        }
        if let Some(ref v) = self.reviewQuestionsUrl.as_ref() {
            os.write_string(34, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocV2 {
        DocV2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docid",
                |m: &DocV2| { &m.docid },
                |m: &mut DocV2| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendDocid",
                |m: &DocV2| { &m.backendDocid },
                |m: &mut DocV2| { &mut m.backendDocid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "docType",
                |m: &DocV2| { &m.docType },
                |m: &mut DocV2| { &mut m.docType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backendId",
                |m: &DocV2| { &m.backendId },
                |m: &mut DocV2| { &mut m.backendId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &DocV2| { &m.title },
                |m: &mut DocV2| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "creator",
                |m: &DocV2| { &m.creator },
                |m: &mut DocV2| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionHtml",
                |m: &DocV2| { &m.descriptionHtml },
                |m: &mut DocV2| { &mut m.descriptionHtml },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Offer>>(
                "offer",
                |m: &DocV2| { &m.offer },
                |m: &mut DocV2| { &mut m.offer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Availability>>(
                "availability",
                |m: &DocV2| { &m.availability },
                |m: &mut DocV2| { &mut m.availability },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &DocV2| { &m.image },
                |m: &mut DocV2| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "child",
                |m: &DocV2| { &m.child },
                |m: &mut DocV2| { &mut m.child },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerMetadata>>(
                "containerMetadata",
                |m: &DocV2| { &m.containerMetadata },
                |m: &mut DocV2| { &mut m.containerMetadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocumentDetails>>(
                "details",
                |m: &DocV2| { &m.details },
                |m: &mut DocV2| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AggregateRating>>(
                "aggregateRating",
                |m: &DocV2| { &m.aggregateRating },
                |m: &mut DocV2| { &mut m.aggregateRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedLinks>>(
                "relatedLinks",
                |m: &DocV2| { &m.relatedLinks },
                |m: &mut DocV2| { &mut m.relatedLinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detailsUrl",
                |m: &DocV2| { &m.detailsUrl },
                |m: &mut DocV2| { &mut m.detailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareUrl",
                |m: &DocV2| { &m.shareUrl },
                |m: &mut DocV2| { &mut m.shareUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewsUrl",
                |m: &DocV2| { &m.reviewsUrl },
                |m: &mut DocV2| { &mut m.reviewsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backendUrl",
                |m: &DocV2| { &m.backendUrl },
                |m: &mut DocV2| { &mut m.backendUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "purchaseDetailsUrl",
                |m: &DocV2| { &m.purchaseDetailsUrl },
                |m: &mut DocV2| { &mut m.purchaseDetailsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detailsReusable",
                |m: &DocV2| { &m.detailsReusable },
                |m: &mut DocV2| { &mut m.detailsReusable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subtitle",
                |m: &DocV2| { &m.subtitle },
                |m: &mut DocV2| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnknownCategoryContainer>>(
                "unknownCategoryContainer",
                |m: &DocV2| { &m.unknownCategoryContainer },
                |m: &mut DocV2| { &mut m.unknownCategoryContainer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unknown25>>(
                "unknown25",
                |m: &DocV2| { &m.unknown25 },
                |m: &mut DocV2| { &mut m.unknown25 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptionShort",
                |m: &DocV2| { &m.descriptionShort },
                |m: &mut DocV2| { &mut m.descriptionShort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewSnippetsUrl",
                |m: &DocV2| { &m.reviewSnippetsUrl },
                |m: &mut DocV2| { &mut m.reviewSnippetsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reviewQuestionsUrl",
                |m: &DocV2| { &m.reviewQuestionsUrl },
                |m: &mut DocV2| { &mut m.reviewQuestionsUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocV2>(
                "DocV2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocV2 {
        static instance: ::protobuf::rt::LazyV2<DocV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocV2::new)
    }
}

impl ::protobuf::Clear for DocV2 {
    fn clear(&mut self) {
        self.docid.clear();
        self.backendDocid.clear();
        self.docType = ::std::option::Option::None;
        self.backendId = ::std::option::Option::None;
        self.title.clear();
        self.creator.clear();
        self.descriptionHtml.clear();
        self.offer.clear();
        self.availability.clear();
        self.image.clear();
        self.child.clear();
        self.containerMetadata.clear();
        self.details.clear();
        self.aggregateRating.clear();
        self.relatedLinks.clear();
        self.detailsUrl.clear();
        self.shareUrl.clear();
        self.reviewsUrl.clear();
        self.backendUrl.clear();
        self.purchaseDetailsUrl.clear();
        self.detailsReusable = ::std::option::Option::None;
        self.subtitle.clear();
        self.unknownCategoryContainer.clear();
        self.unknown25.clear();
        self.descriptionShort.clear();
        self.reviewSnippetsUrl.clear();
        self.reviewQuestionsUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Unknown25 {
    // message fields
    pub item: ::protobuf::RepeatedField<Unknown25Item>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Unknown25 {
    fn default() -> &'a Unknown25 {
        <Unknown25 as ::protobuf::Message>::default_instance()
    }
}

impl Unknown25 {
    pub fn new() -> Unknown25 {
        ::std::default::Default::default()
    }

    // repeated .Unknown25Item item = 2;


    pub fn get_item(&self) -> &[Unknown25Item] {
        &self.item
    }
}

impl ::protobuf::Message for Unknown25 {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unknown25 {
        Unknown25::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unknown25Item>>(
                "item",
                |m: &Unknown25| { &m.item },
                |m: &mut Unknown25| { &mut m.item },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Unknown25>(
                "Unknown25",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Unknown25 {
        static instance: ::protobuf::rt::LazyV2<Unknown25> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Unknown25::new)
    }
}

impl ::protobuf::Clear for Unknown25 {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unknown25 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unknown25 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Unknown25Item {
    // message fields
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub container: ::protobuf::SingularPtrField<Unknown25Container>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Unknown25Item {
    fn default() -> &'a Unknown25Item {
        <Unknown25Item as ::protobuf::Message>::default_instance()
    }
}

impl Unknown25Item {
    pub fn new() -> Unknown25Item {
        ::std::default::Default::default()
    }

    // optional string label = 1;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Unknown25Container container = 3;


    pub fn get_container(&self) -> &Unknown25Container {
        self.container.as_ref().unwrap_or_else(|| <Unknown25Container as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Unknown25Item {
    fn is_initialized(&self) -> bool {
        for v in &self.container {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.container.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unknown25Item {
        Unknown25Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Unknown25Item| { &m.label },
                |m: &mut Unknown25Item| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Unknown25Container>>(
                "container",
                |m: &Unknown25Item| { &m.container },
                |m: &mut Unknown25Item| { &mut m.container },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Unknown25Item>(
                "Unknown25Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Unknown25Item {
        static instance: ::protobuf::rt::LazyV2<Unknown25Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Unknown25Item::new)
    }
}

impl ::protobuf::Clear for Unknown25Item {
    fn clear(&mut self) {
        self.label.clear();
        self.container.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unknown25Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unknown25Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Unknown25Container {
    // message fields
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Unknown25Container {
    fn default() -> &'a Unknown25Container {
        <Unknown25Container as ::protobuf::Message>::default_instance()
    }
}

impl Unknown25Container {
    pub fn new() -> Unknown25Container {
        ::std::default::Default::default()
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Unknown25Container {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Unknown25Container {
        Unknown25Container::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Unknown25Container| { &m.value },
                |m: &mut Unknown25Container| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Unknown25Container>(
                "Unknown25Container",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Unknown25Container {
        static instance: ::protobuf::rt::LazyV2<Unknown25Container> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Unknown25Container::new)
    }
}

impl ::protobuf::Clear for Unknown25Container {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Unknown25Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unknown25Container {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedLinks {
    // message fields
    pub unknown1: ::protobuf::SingularPtrField<RelatedLinksUnknown1>,
    pub privacyPolicyUrl: ::protobuf::SingularField<::std::string::String>,
    pub youMightAlsoLike: ::protobuf::SingularPtrField<RelatedLink>,
    pub rated: ::protobuf::SingularPtrField<Rated>,
    pub relatedLinks: ::protobuf::RepeatedField<RelatedLink>,
    pub categoryInfo: ::protobuf::SingularPtrField<CategoryInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedLinks {
    fn default() -> &'a RelatedLinks {
        <RelatedLinks as ::protobuf::Message>::default_instance()
    }
}

impl RelatedLinks {
    pub fn new() -> RelatedLinks {
        ::std::default::Default::default()
    }

    // optional .RelatedLinksUnknown1 unknown1 = 10;


    pub fn get_unknown1(&self) -> &RelatedLinksUnknown1 {
        self.unknown1.as_ref().unwrap_or_else(|| <RelatedLinksUnknown1 as ::protobuf::Message>::default_instance())
    }

    // optional string privacyPolicyUrl = 18;


    pub fn get_privacyPolicyUrl(&self) -> &str {
        match self.privacyPolicyUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .RelatedLink youMightAlsoLike = 24;


    pub fn get_youMightAlsoLike(&self) -> &RelatedLink {
        self.youMightAlsoLike.as_ref().unwrap_or_else(|| <RelatedLink as ::protobuf::Message>::default_instance())
    }

    // optional .Rated rated = 29;


    pub fn get_rated(&self) -> &Rated {
        self.rated.as_ref().unwrap_or_else(|| <Rated as ::protobuf::Message>::default_instance())
    }

    // repeated .RelatedLink relatedLinks = 34;


    pub fn get_relatedLinks(&self) -> &[RelatedLink] {
        &self.relatedLinks
    }

    // optional .CategoryInfo categoryInfo = 53;


    pub fn get_categoryInfo(&self) -> &CategoryInfo {
        self.categoryInfo.as_ref().unwrap_or_else(|| <CategoryInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RelatedLinks {
    fn is_initialized(&self) -> bool {
        for v in &self.unknown1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.youMightAlsoLike {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedLinks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.categoryInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknown1)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privacyPolicyUrl)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.youMightAlsoLike)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rated)?;
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relatedLinks)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.categoryInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unknown1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.youMightAlsoLike.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rated.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.relatedLinks {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.categoryInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unknown1.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.privacyPolicyUrl.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.youMightAlsoLike.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rated.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.relatedLinks {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.categoryInfo.as_ref() {
            os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedLinks {
        RelatedLinks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedLinksUnknown1>>(
                "unknown1",
                |m: &RelatedLinks| { &m.unknown1 },
                |m: &mut RelatedLinks| { &mut m.unknown1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privacyPolicyUrl",
                |m: &RelatedLinks| { &m.privacyPolicyUrl },
                |m: &mut RelatedLinks| { &mut m.privacyPolicyUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedLink>>(
                "youMightAlsoLike",
                |m: &RelatedLinks| { &m.youMightAlsoLike },
                |m: &mut RelatedLinks| { &mut m.youMightAlsoLike },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rated>>(
                "rated",
                |m: &RelatedLinks| { &m.rated },
                |m: &mut RelatedLinks| { &mut m.rated },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedLink>>(
                "relatedLinks",
                |m: &RelatedLinks| { &m.relatedLinks },
                |m: &mut RelatedLinks| { &mut m.relatedLinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CategoryInfo>>(
                "categoryInfo",
                |m: &RelatedLinks| { &m.categoryInfo },
                |m: &mut RelatedLinks| { &mut m.categoryInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedLinks>(
                "RelatedLinks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedLinks {
        static instance: ::protobuf::rt::LazyV2<RelatedLinks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedLinks::new)
    }
}

impl ::protobuf::Clear for RelatedLinks {
    fn clear(&mut self) {
        self.unknown1.clear();
        self.privacyPolicyUrl.clear();
        self.youMightAlsoLike.clear();
        self.rated.clear();
        self.relatedLinks.clear();
        self.categoryInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedLinks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedLinks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedLinksUnknown1 {
    // message fields
    pub unknown2: ::protobuf::SingularPtrField<RelatedLinksUnknown2>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedLinksUnknown1 {
    fn default() -> &'a RelatedLinksUnknown1 {
        <RelatedLinksUnknown1 as ::protobuf::Message>::default_instance()
    }
}

impl RelatedLinksUnknown1 {
    pub fn new() -> RelatedLinksUnknown1 {
        ::std::default::Default::default()
    }

    // optional .RelatedLinksUnknown2 unknown2 = 2;


    pub fn get_unknown2(&self) -> &RelatedLinksUnknown2 {
        self.unknown2.as_ref().unwrap_or_else(|| <RelatedLinksUnknown2 as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for RelatedLinksUnknown1 {
    fn is_initialized(&self) -> bool {
        for v in &self.unknown2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknown2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.unknown2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.unknown2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedLinksUnknown1 {
        RelatedLinksUnknown1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedLinksUnknown2>>(
                "unknown2",
                |m: &RelatedLinksUnknown1| { &m.unknown2 },
                |m: &mut RelatedLinksUnknown1| { &mut m.unknown2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedLinksUnknown1>(
                "RelatedLinksUnknown1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedLinksUnknown1 {
        static instance: ::protobuf::rt::LazyV2<RelatedLinksUnknown1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedLinksUnknown1::new)
    }
}

impl ::protobuf::Clear for RelatedLinksUnknown1 {
    fn clear(&mut self) {
        self.unknown2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedLinksUnknown1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedLinksUnknown1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedLinksUnknown2 {
    // message fields
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedLinksUnknown2 {
    fn default() -> &'a RelatedLinksUnknown2 {
        <RelatedLinksUnknown2 as ::protobuf::Message>::default_instance()
    }
}

impl RelatedLinksUnknown2 {
    pub fn new() -> RelatedLinksUnknown2 {
        ::std::default::Default::default()
    }

    // optional string homeUrl = 2;


    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string nextPageUrl = 3;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RelatedLinksUnknown2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.homeUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedLinksUnknown2 {
        RelatedLinksUnknown2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "homeUrl",
                |m: &RelatedLinksUnknown2| { &m.homeUrl },
                |m: &mut RelatedLinksUnknown2| { &mut m.homeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &RelatedLinksUnknown2| { &m.nextPageUrl },
                |m: &mut RelatedLinksUnknown2| { &mut m.nextPageUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedLinksUnknown2>(
                "RelatedLinksUnknown2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedLinksUnknown2 {
        static instance: ::protobuf::rt::LazyV2<RelatedLinksUnknown2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedLinksUnknown2::new)
    }
}

impl ::protobuf::Clear for RelatedLinksUnknown2 {
    fn clear(&mut self) {
        self.homeUrl.clear();
        self.nextPageUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedLinksUnknown2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedLinksUnknown2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Rated {
    // message fields
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::SingularPtrField<Image>,
    pub learnMoreHtmlLink: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rated {
    fn default() -> &'a Rated {
        <Rated as ::protobuf::Message>::default_instance()
    }
}

impl Rated {
    pub fn new() -> Rated {
        ::std::default::Default::default()
    }

    // optional string label = 1;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image image = 2;


    pub fn get_image(&self) -> &Image {
        self.image.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }

    // optional string learnMoreHtmlLink = 4;


    pub fn get_learnMoreHtmlLink(&self) -> &str {
        match self.learnMoreHtmlLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Rated {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.learnMoreHtmlLink)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.learnMoreHtmlLink.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.learnMoreHtmlLink.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rated {
        Rated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &Rated| { &m.label },
                |m: &mut Rated| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &Rated| { &m.image },
                |m: &mut Rated| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "learnMoreHtmlLink",
                |m: &Rated| { &m.learnMoreHtmlLink },
                |m: &mut Rated| { &mut m.learnMoreHtmlLink },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rated>(
                "Rated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rated {
        static instance: ::protobuf::rt::LazyV2<Rated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rated::new)
    }
}

impl ::protobuf::Clear for Rated {
    fn clear(&mut self) {
        self.label.clear();
        self.image.clear();
        self.learnMoreHtmlLink.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedLink {
    // message fields
    pub label: ::protobuf::SingularField<::std::string::String>,
    pub url1: ::protobuf::SingularField<::std::string::String>,
    pub url2: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedLink {
    fn default() -> &'a RelatedLink {
        <RelatedLink as ::protobuf::Message>::default_instance()
    }
}

impl RelatedLink {
    pub fn new() -> RelatedLink {
        ::std::default::Default::default()
    }

    // optional string label = 1;


    pub fn get_label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url1 = 2;


    pub fn get_url1(&self) -> &str {
        match self.url1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url2 = 3;


    pub fn get_url2(&self) -> &str {
        match self.url2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for RelatedLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.url1.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.url2.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.label.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.url1.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.url2.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedLink {
        RelatedLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label",
                |m: &RelatedLink| { &m.label },
                |m: &mut RelatedLink| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url1",
                |m: &RelatedLink| { &m.url1 },
                |m: &mut RelatedLink| { &mut m.url1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url2",
                |m: &RelatedLink| { &m.url2 },
                |m: &mut RelatedLink| { &mut m.url2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedLink>(
                "RelatedLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedLink {
        static instance: ::protobuf::rt::LazyV2<RelatedLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedLink::new)
    }
}

impl ::protobuf::Clear for RelatedLink {
    fn clear(&mut self) {
        self.label.clear();
        self.url1.clear();
        self.url2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CategoryInfo {
    // message fields
    pub appType: ::protobuf::SingularField<::std::string::String>,
    pub appCategory: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CategoryInfo {
    fn default() -> &'a CategoryInfo {
        <CategoryInfo as ::protobuf::Message>::default_instance()
    }
}

impl CategoryInfo {
    pub fn new() -> CategoryInfo {
        ::std::default::Default::default()
    }

    // optional string appType = 1;


    pub fn get_appType(&self) -> &str {
        match self.appType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string appCategory = 2;


    pub fn get_appCategory(&self) -> &str {
        match self.appCategory.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CategoryInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appCategory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.appType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.appCategory.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.appType.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.appCategory.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoryInfo {
        CategoryInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appType",
                |m: &CategoryInfo| { &m.appType },
                |m: &mut CategoryInfo| { &mut m.appType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appCategory",
                |m: &CategoryInfo| { &m.appCategory },
                |m: &mut CategoryInfo| { &mut m.appCategory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CategoryInfo>(
                "CategoryInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoryInfo {
        static instance: ::protobuf::rt::LazyV2<CategoryInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CategoryInfo::new)
    }
}

impl ::protobuf::Clear for CategoryInfo {
    fn clear(&mut self) {
        self.appType.clear();
        self.appCategory.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct EncryptedSubscriberInfo {
    // message fields
    pub data: ::protobuf::SingularField<::std::string::String>,
    pub encryptedKey: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    pub initVector: ::protobuf::SingularField<::std::string::String>,
    pub googleKeyVersion: ::std::option::Option<i32>,
    pub carrierKeyVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptedSubscriberInfo {
    fn default() -> &'a EncryptedSubscriberInfo {
        <EncryptedSubscriberInfo as ::protobuf::Message>::default_instance()
    }
}

impl EncryptedSubscriberInfo {
    pub fn new() -> EncryptedSubscriberInfo {
        ::std::default::Default::default()
    }

    // optional string data = 1;


    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string encryptedKey = 2;


    pub fn get_encryptedKey(&self) -> &str {
        match self.encryptedKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 3;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string initVector = 4;


    pub fn get_initVector(&self) -> &str {
        match self.initVector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 googleKeyVersion = 5;


    pub fn get_googleKeyVersion(&self) -> i32 {
        self.googleKeyVersion.unwrap_or(0)
    }

    // optional int32 carrierKeyVersion = 6;


    pub fn get_carrierKeyVersion(&self) -> i32 {
        self.carrierKeyVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for EncryptedSubscriberInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptedKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initVector)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.googleKeyVersion = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.carrierKeyVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.initVector.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.googleKeyVersion {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.carrierKeyVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.encryptedKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.initVector.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.googleKeyVersion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.carrierKeyVersion {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedSubscriberInfo {
        EncryptedSubscriberInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &EncryptedSubscriberInfo| { &m.data },
                |m: &mut EncryptedSubscriberInfo| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryptedKey",
                |m: &EncryptedSubscriberInfo| { &m.encryptedKey },
                |m: &mut EncryptedSubscriberInfo| { &mut m.encryptedKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &EncryptedSubscriberInfo| { &m.signature },
                |m: &mut EncryptedSubscriberInfo| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initVector",
                |m: &EncryptedSubscriberInfo| { &m.initVector },
                |m: &mut EncryptedSubscriberInfo| { &mut m.initVector },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "googleKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.googleKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.googleKeyVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "carrierKeyVersion",
                |m: &EncryptedSubscriberInfo| { &m.carrierKeyVersion },
                |m: &mut EncryptedSubscriberInfo| { &mut m.carrierKeyVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptedSubscriberInfo>(
                "EncryptedSubscriberInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptedSubscriberInfo {
        static instance: ::protobuf::rt::LazyV2<EncryptedSubscriberInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptedSubscriberInfo::new)
    }
}

impl ::protobuf::Clear for EncryptedSubscriberInfo {
    fn clear(&mut self) {
        self.data.clear();
        self.encryptedKey.clear();
        self.signature.clear();
        self.initVector.clear();
        self.googleKeyVersion = ::std::option::Option::None;
        self.carrierKeyVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedSubscriberInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedSubscriberInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Availability {
    // message fields
    pub restriction: ::std::option::Option<i32>,
    pub offerType: ::std::option::Option<i32>,
    pub rule: ::protobuf::SingularPtrField<Rule>,
    // perdeviceavailabilityrestriction: <group>
    pub availableIfOwned: ::std::option::Option<bool>,
    pub install: ::protobuf::RepeatedField<Install>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    pub ownershipInfo: ::protobuf::SingularPtrField<OwnershipInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability {
    fn default() -> &'a Availability {
        <Availability as ::protobuf::Message>::default_instance()
    }
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    // optional int32 restriction = 5;


    pub fn get_restriction(&self) -> i32 {
        self.restriction.unwrap_or(0)
    }

    // optional int32 offerType = 6;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional .Rule rule = 7;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // optional bool availableIfOwned = 13;


    pub fn get_availableIfOwned(&self) -> bool {
        self.availableIfOwned.unwrap_or(false)
    }

    // repeated .Install install = 14;


    pub fn get_install(&self) -> &[Install] {
        &self.install
    }

    // optional .FilterEvaluationInfo filterInfo = 16;


    pub fn get_filterInfo(&self) -> &FilterEvaluationInfo {
        self.filterInfo.as_ref().unwrap_or_else(|| <FilterEvaluationInfo as ::protobuf::Message>::default_instance())
    }

    // optional .OwnershipInfo ownershipInfo = 17;


    pub fn get_ownershipInfo(&self) -> &OwnershipInfo {
        self.ownershipInfo.as_ref().unwrap_or_else(|| <OwnershipInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Availability {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.install {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownershipInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restriction = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.availableIfOwned = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.install)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filterInfo)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ownershipInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.restriction {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.availableIfOwned {
            my_size += 2;
        }
        for value in &self.install {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ownershipInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.restriction {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.availableIfOwned {
            os.write_bool(13, v)?;
        }
        for v in &self.install {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.filterInfo.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ownershipInfo.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "restriction",
                |m: &Availability| { &m.restriction },
                |m: &mut Availability| { &mut m.restriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &Availability| { &m.offerType },
                |m: &mut Availability| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &Availability| { &m.rule },
                |m: &mut Availability| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "availableIfOwned",
                |m: &Availability| { &m.availableIfOwned },
                |m: &mut Availability| { &mut m.availableIfOwned },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Install>>(
                "install",
                |m: &Availability| { &m.install },
                |m: &mut Availability| { &mut m.install },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>>(
                "filterInfo",
                |m: &Availability| { &m.filterInfo },
                |m: &mut Availability| { &mut m.filterInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OwnershipInfo>>(
                "ownershipInfo",
                |m: &Availability| { &m.ownershipInfo },
                |m: &mut Availability| { &mut m.ownershipInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Availability>(
                "Availability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability {
        static instance: ::protobuf::rt::LazyV2<Availability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Availability::new)
    }
}

impl ::protobuf::Clear for Availability {
    fn clear(&mut self) {
        self.restriction = ::std::option::Option::None;
        self.offerType = ::std::option::Option::None;
        self.rule.clear();
        self.availableIfOwned = ::std::option::Option::None;
        self.install.clear();
        self.filterInfo.clear();
        self.ownershipInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Availability_PerDeviceAvailabilityRestriction {
    // message fields
    pub androidId: ::std::option::Option<u64>,
    pub deviceRestriction: ::std::option::Option<i32>,
    pub channelId: ::std::option::Option<i64>,
    pub filterInfo: ::protobuf::SingularPtrField<FilterEvaluationInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability_PerDeviceAvailabilityRestriction {
    fn default() -> &'a Availability_PerDeviceAvailabilityRestriction {
        <Availability_PerDeviceAvailabilityRestriction as ::protobuf::Message>::default_instance()
    }
}

impl Availability_PerDeviceAvailabilityRestriction {
    pub fn new() -> Availability_PerDeviceAvailabilityRestriction {
        ::std::default::Default::default()
    }

    // optional fixed64 androidId = 10;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional int32 deviceRestriction = 11;


    pub fn get_deviceRestriction(&self) -> i32 {
        self.deviceRestriction.unwrap_or(0)
    }

    // optional int64 channelId = 12;


    pub fn get_channelId(&self) -> i64 {
        self.channelId.unwrap_or(0)
    }

    // optional .FilterEvaluationInfo filterInfo = 15;


    pub fn get_filterInfo(&self) -> &FilterEvaluationInfo {
        self.filterInfo.as_ref().unwrap_or_else(|| <FilterEvaluationInfo as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Availability_PerDeviceAvailabilityRestriction {
    fn is_initialized(&self) -> bool {
        for v in &self.filterInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deviceRestriction = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channelId = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filterInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.deviceRestriction {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channelId {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filterInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.deviceRestriction {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.channelId {
            os.write_int64(12, v)?;
        }
        if let Some(ref v) = self.filterInfo.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability_PerDeviceAvailabilityRestriction {
        Availability_PerDeviceAvailabilityRestriction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.androidId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deviceRestriction",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.deviceRestriction },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.deviceRestriction },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "channelId",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.channelId },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.channelId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterEvaluationInfo>>(
                "filterInfo",
                |m: &Availability_PerDeviceAvailabilityRestriction| { &m.filterInfo },
                |m: &mut Availability_PerDeviceAvailabilityRestriction| { &mut m.filterInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Availability_PerDeviceAvailabilityRestriction>(
                "Availability.PerDeviceAvailabilityRestriction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Availability_PerDeviceAvailabilityRestriction {
        static instance: ::protobuf::rt::LazyV2<Availability_PerDeviceAvailabilityRestriction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Availability_PerDeviceAvailabilityRestriction::new)
    }
}

impl ::protobuf::Clear for Availability_PerDeviceAvailabilityRestriction {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.deviceRestriction = ::std::option::Option::None;
        self.channelId = ::std::option::Option::None;
        self.filterInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability_PerDeviceAvailabilityRestriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability_PerDeviceAvailabilityRestriction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FilterEvaluationInfo {
    // message fields
    pub ruleEvaluation: ::protobuf::RepeatedField<RuleEvaluation>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterEvaluationInfo {
    fn default() -> &'a FilterEvaluationInfo {
        <FilterEvaluationInfo as ::protobuf::Message>::default_instance()
    }
}

impl FilterEvaluationInfo {
    pub fn new() -> FilterEvaluationInfo {
        ::std::default::Default::default()
    }

    // repeated .RuleEvaluation ruleEvaluation = 1;


    pub fn get_ruleEvaluation(&self) -> &[RuleEvaluation] {
        &self.ruleEvaluation
    }
}

impl ::protobuf::Message for FilterEvaluationInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.ruleEvaluation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ruleEvaluation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ruleEvaluation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ruleEvaluation {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterEvaluationInfo {
        FilterEvaluationInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuleEvaluation>>(
                "ruleEvaluation",
                |m: &FilterEvaluationInfo| { &m.ruleEvaluation },
                |m: &mut FilterEvaluationInfo| { &mut m.ruleEvaluation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterEvaluationInfo>(
                "FilterEvaluationInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterEvaluationInfo {
        static instance: ::protobuf::rt::LazyV2<FilterEvaluationInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterEvaluationInfo::new)
    }
}

impl ::protobuf::Clear for FilterEvaluationInfo {
    fn clear(&mut self) {
        self.ruleEvaluation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterEvaluationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterEvaluationInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Rule {
    // message fields
    pub negate: ::std::option::Option<bool>,
    pub operator: ::std::option::Option<i32>,
    pub key: ::std::option::Option<i32>,
    pub stringArg: ::protobuf::RepeatedField<::std::string::String>,
    pub longArg: ::std::vec::Vec<i64>,
    pub doubleArg: ::std::vec::Vec<f64>,
    pub subrule: ::protobuf::RepeatedField<Rule>,
    pub responseCode: ::std::option::Option<i32>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub stringArgHash: ::std::vec::Vec<u64>,
    pub constArg: ::std::vec::Vec<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rule {
    fn default() -> &'a Rule {
        <Rule as ::protobuf::Message>::default_instance()
    }
}

impl Rule {
    pub fn new() -> Rule {
        ::std::default::Default::default()
    }

    // optional bool negate = 1;


    pub fn get_negate(&self) -> bool {
        self.negate.unwrap_or(false)
    }

    // optional int32 operator = 2;


    pub fn get_operator(&self) -> i32 {
        self.operator.unwrap_or(0)
    }

    // optional int32 key = 3;


    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    // repeated string stringArg = 4;


    pub fn get_stringArg(&self) -> &[::std::string::String] {
        &self.stringArg
    }

    // repeated int64 longArg = 5;


    pub fn get_longArg(&self) -> &[i64] {
        &self.longArg
    }

    // repeated double doubleArg = 6;


    pub fn get_doubleArg(&self) -> &[f64] {
        &self.doubleArg
    }

    // repeated .Rule subrule = 7;


    pub fn get_subrule(&self) -> &[Rule] {
        &self.subrule
    }

    // optional int32 responseCode = 8;


    pub fn get_responseCode(&self) -> i32 {
        self.responseCode.unwrap_or(0)
    }

    // optional string comment = 9;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated fixed64 stringArgHash = 10;


    pub fn get_stringArgHash(&self) -> &[u64] {
        &self.stringArgHash
    }

    // repeated int32 constArg = 11;


    pub fn get_constArg(&self) -> &[i32] {
        &self.constArg
    }
}

impl ::protobuf::Message for Rule {
    fn is_initialized(&self) -> bool {
        for v in &self.subrule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.operator = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.stringArg)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.longArg)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.doubleArg)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subrule)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.responseCode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.stringArgHash)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.constArg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.negate {
            my_size += 2;
        }
        if let Some(v) = self.operator {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stringArg {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.longArg {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.doubleArg.len() as u32;
        for value in &self.subrule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.responseCode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += 9 * self.stringArgHash.len() as u32;
        for value in &self.constArg {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.negate {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.operator {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.key {
            os.write_int32(3, v)?;
        }
        for v in &self.stringArg {
            os.write_string(4, &v)?;
        };
        for v in &self.longArg {
            os.write_int64(5, *v)?;
        };
        for v in &self.doubleArg {
            os.write_double(6, *v)?;
        };
        for v in &self.subrule {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.responseCode {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.stringArgHash {
            os.write_fixed64(10, *v)?;
        };
        for v in &self.constArg {
            os.write_int32(11, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rule {
        Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "negate",
                |m: &Rule| { &m.negate },
                |m: &mut Rule| { &mut m.negate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "operator",
                |m: &Rule| { &m.operator },
                |m: &mut Rule| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "key",
                |m: &Rule| { &m.key },
                |m: &mut Rule| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stringArg",
                |m: &Rule| { &m.stringArg },
                |m: &mut Rule| { &mut m.stringArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "longArg",
                |m: &Rule| { &m.longArg },
                |m: &mut Rule| { &mut m.longArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "doubleArg",
                |m: &Rule| { &m.doubleArg },
                |m: &mut Rule| { &mut m.doubleArg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "subrule",
                |m: &Rule| { &m.subrule },
                |m: &mut Rule| { &mut m.subrule },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "responseCode",
                |m: &Rule| { &m.responseCode },
                |m: &mut Rule| { &mut m.responseCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &Rule| { &m.comment },
                |m: &mut Rule| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "stringArgHash",
                |m: &Rule| { &m.stringArgHash },
                |m: &mut Rule| { &mut m.stringArgHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "constArg",
                |m: &Rule| { &m.constArg },
                |m: &mut Rule| { &mut m.constArg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rule>(
                "Rule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rule {
        static instance: ::protobuf::rt::LazyV2<Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rule::new)
    }
}

impl ::protobuf::Clear for Rule {
    fn clear(&mut self) {
        self.negate = ::std::option::Option::None;
        self.operator = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.stringArg.clear();
        self.longArg.clear();
        self.doubleArg.clear();
        self.subrule.clear();
        self.responseCode = ::std::option::Option::None;
        self.comment.clear();
        self.stringArgHash.clear();
        self.constArg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuleEvaluation {
    // message fields
    pub rule: ::protobuf::SingularPtrField<Rule>,
    pub actualStringValue: ::protobuf::RepeatedField<::std::string::String>,
    pub actualLongValue: ::std::vec::Vec<i64>,
    pub actualBoolValue: ::std::vec::Vec<bool>,
    pub actualDoubleValue: ::std::vec::Vec<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuleEvaluation {
    fn default() -> &'a RuleEvaluation {
        <RuleEvaluation as ::protobuf::Message>::default_instance()
    }
}

impl RuleEvaluation {
    pub fn new() -> RuleEvaluation {
        ::std::default::Default::default()
    }

    // optional .Rule rule = 1;


    pub fn get_rule(&self) -> &Rule {
        self.rule.as_ref().unwrap_or_else(|| <Rule as ::protobuf::Message>::default_instance())
    }

    // repeated string actualStringValue = 2;


    pub fn get_actualStringValue(&self) -> &[::std::string::String] {
        &self.actualStringValue
    }

    // repeated int64 actualLongValue = 3;


    pub fn get_actualLongValue(&self) -> &[i64] {
        &self.actualLongValue
    }

    // repeated bool actualBoolValue = 4;


    pub fn get_actualBoolValue(&self) -> &[bool] {
        &self.actualBoolValue
    }

    // repeated double actualDoubleValue = 5;


    pub fn get_actualDoubleValue(&self) -> &[f64] {
        &self.actualDoubleValue
    }
}

impl ::protobuf::Message for RuleEvaluation {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rule)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actualStringValue)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.actualLongValue)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.actualBoolValue)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.actualDoubleValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.actualStringValue {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.actualLongValue {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 2 * self.actualBoolValue.len() as u32;
        my_size += 9 * self.actualDoubleValue.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rule.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.actualStringValue {
            os.write_string(2, &v)?;
        };
        for v in &self.actualLongValue {
            os.write_int64(3, *v)?;
        };
        for v in &self.actualBoolValue {
            os.write_bool(4, *v)?;
        };
        for v in &self.actualDoubleValue {
            os.write_double(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuleEvaluation {
        RuleEvaluation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rule>>(
                "rule",
                |m: &RuleEvaluation| { &m.rule },
                |m: &mut RuleEvaluation| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "actualStringValue",
                |m: &RuleEvaluation| { &m.actualStringValue },
                |m: &mut RuleEvaluation| { &mut m.actualStringValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "actualLongValue",
                |m: &RuleEvaluation| { &m.actualLongValue },
                |m: &mut RuleEvaluation| { &mut m.actualLongValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "actualBoolValue",
                |m: &RuleEvaluation| { &m.actualBoolValue },
                |m: &mut RuleEvaluation| { &mut m.actualBoolValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "actualDoubleValue",
                |m: &RuleEvaluation| { &m.actualDoubleValue },
                |m: &mut RuleEvaluation| { &mut m.actualDoubleValue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuleEvaluation>(
                "RuleEvaluation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuleEvaluation {
        static instance: ::protobuf::rt::LazyV2<RuleEvaluation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuleEvaluation::new)
    }
}

impl ::protobuf::Clear for RuleEvaluation {
    fn clear(&mut self) {
        self.rule.clear();
        self.actualStringValue.clear();
        self.actualLongValue.clear();
        self.actualBoolValue.clear();
        self.actualDoubleValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuleEvaluation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuleEvaluation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryAppDetails {
    // message fields
    pub certificateHash: ::protobuf::SingularField<::std::string::String>,
    pub refundTimeoutTimestampMsec: ::std::option::Option<i64>,
    pub postDeliveryRefundWindowMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryAppDetails {
    fn default() -> &'a LibraryAppDetails {
        <LibraryAppDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibraryAppDetails {
    pub fn new() -> LibraryAppDetails {
        ::std::default::Default::default()
    }

    // optional string certificateHash = 2;


    pub fn get_certificateHash(&self) -> &str {
        match self.certificateHash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 refundTimeoutTimestampMsec = 3;


    pub fn get_refundTimeoutTimestampMsec(&self) -> i64 {
        self.refundTimeoutTimestampMsec.unwrap_or(0)
    }

    // optional int64 postDeliveryRefundWindowMsec = 4;


    pub fn get_postDeliveryRefundWindowMsec(&self) -> i64 {
        self.postDeliveryRefundWindowMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.certificateHash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.refundTimeoutTimestampMsec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.postDeliveryRefundWindowMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.certificateHash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.certificateHash.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.refundTimeoutTimestampMsec {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.postDeliveryRefundWindowMsec {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryAppDetails {
        LibraryAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificateHash",
                |m: &LibraryAppDetails| { &m.certificateHash },
                |m: &mut LibraryAppDetails| { &mut m.certificateHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "refundTimeoutTimestampMsec",
                |m: &LibraryAppDetails| { &m.refundTimeoutTimestampMsec },
                |m: &mut LibraryAppDetails| { &mut m.refundTimeoutTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "postDeliveryRefundWindowMsec",
                |m: &LibraryAppDetails| { &m.postDeliveryRefundWindowMsec },
                |m: &mut LibraryAppDetails| { &mut m.postDeliveryRefundWindowMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryAppDetails>(
                "LibraryAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryAppDetails {
        static instance: ::protobuf::rt::LazyV2<LibraryAppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryAppDetails {
    fn clear(&mut self) {
        self.certificateHash.clear();
        self.refundTimeoutTimestampMsec = ::std::option::Option::None;
        self.postDeliveryRefundWindowMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryAppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryInAppDetails {
    // message fields
    pub signedPurchaseData: ::protobuf::SingularField<::std::string::String>,
    pub signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryInAppDetails {
    fn default() -> &'a LibraryInAppDetails {
        <LibraryInAppDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibraryInAppDetails {
    pub fn new() -> LibraryInAppDetails {
        ::std::default::Default::default()
    }

    // optional string signedPurchaseData = 1;


    pub fn get_signedPurchaseData(&self) -> &str {
        match self.signedPurchaseData.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string signature = 2;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryInAppDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signedPurchaseData)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signedPurchaseData.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryInAppDetails {
        LibraryInAppDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signedPurchaseData",
                |m: &LibraryInAppDetails| { &m.signedPurchaseData },
                |m: &mut LibraryInAppDetails| { &mut m.signedPurchaseData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &LibraryInAppDetails| { &m.signature },
                |m: &mut LibraryInAppDetails| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryInAppDetails>(
                "LibraryInAppDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryInAppDetails {
        static instance: ::protobuf::rt::LazyV2<LibraryInAppDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryInAppDetails::new)
    }
}

impl ::protobuf::Clear for LibraryInAppDetails {
    fn clear(&mut self) {
        self.signedPurchaseData.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryInAppDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryInAppDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryMutation {
    // message fields
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub offerType: ::std::option::Option<i32>,
    pub documentHash: ::std::option::Option<i64>,
    pub deleted: ::std::option::Option<bool>,
    pub appDetails: ::protobuf::SingularPtrField<LibraryAppDetails>,
    pub subscriptionDetails: ::protobuf::SingularPtrField<LibrarySubscriptionDetails>,
    pub inAppDetails: ::protobuf::SingularPtrField<LibraryInAppDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryMutation {
    fn default() -> &'a LibraryMutation {
        <LibraryMutation as ::protobuf::Message>::default_instance()
    }
}

impl LibraryMutation {
    pub fn new() -> LibraryMutation {
        ::std::default::Default::default()
    }

    // optional .Docid docid = 1;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional int32 offerType = 2;


    pub fn get_offerType(&self) -> i32 {
        self.offerType.unwrap_or(0)
    }

    // optional int64 documentHash = 3;


    pub fn get_documentHash(&self) -> i64 {
        self.documentHash.unwrap_or(0)
    }

    // optional bool deleted = 4;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    // optional .LibraryAppDetails appDetails = 5;


    pub fn get_appDetails(&self) -> &LibraryAppDetails {
        self.appDetails.as_ref().unwrap_or_else(|| <LibraryAppDetails as ::protobuf::Message>::default_instance())
    }

    // optional .LibrarySubscriptionDetails subscriptionDetails = 6;


    pub fn get_subscriptionDetails(&self) -> &LibrarySubscriptionDetails {
        self.subscriptionDetails.as_ref().unwrap_or_else(|| <LibrarySubscriptionDetails as ::protobuf::Message>::default_instance())
    }

    // optional .LibraryInAppDetails inAppDetails = 7;


    pub fn get_inAppDetails(&self) -> &LibraryInAppDetails {
        self.inAppDetails.as_ref().unwrap_or_else(|| <LibraryInAppDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for LibraryMutation {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscriptionDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offerType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.documentHash = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDetails)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscriptionDetails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offerType {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.documentHash {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(ref v) = self.appDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offerType {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.documentHash {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.appDetails.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscriptionDetails.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppDetails.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryMutation {
        LibraryMutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &LibraryMutation| { &m.docid },
                |m: &mut LibraryMutation| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offerType",
                |m: &LibraryMutation| { &m.offerType },
                |m: &mut LibraryMutation| { &mut m.offerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "documentHash",
                |m: &LibraryMutation| { &m.documentHash },
                |m: &mut LibraryMutation| { &mut m.documentHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &LibraryMutation| { &m.deleted },
                |m: &mut LibraryMutation| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryAppDetails>>(
                "appDetails",
                |m: &LibraryMutation| { &m.appDetails },
                |m: &mut LibraryMutation| { &mut m.appDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibrarySubscriptionDetails>>(
                "subscriptionDetails",
                |m: &LibraryMutation| { &m.subscriptionDetails },
                |m: &mut LibraryMutation| { &mut m.subscriptionDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryInAppDetails>>(
                "inAppDetails",
                |m: &LibraryMutation| { &m.inAppDetails },
                |m: &mut LibraryMutation| { &mut m.inAppDetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryMutation>(
                "LibraryMutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryMutation {
        static instance: ::protobuf::rt::LazyV2<LibraryMutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryMutation::new)
    }
}

impl ::protobuf::Clear for LibraryMutation {
    fn clear(&mut self) {
        self.docid.clear();
        self.offerType = ::std::option::Option::None;
        self.documentHash = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.appDetails.clear();
        self.subscriptionDetails.clear();
        self.inAppDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryMutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibrarySubscriptionDetails {
    // message fields
    pub initiationTimestampMsec: ::std::option::Option<i64>,
    pub validUntilTimestampMsec: ::std::option::Option<i64>,
    pub autoRenewing: ::std::option::Option<bool>,
    pub trialUntilTimestampMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibrarySubscriptionDetails {
    fn default() -> &'a LibrarySubscriptionDetails {
        <LibrarySubscriptionDetails as ::protobuf::Message>::default_instance()
    }
}

impl LibrarySubscriptionDetails {
    pub fn new() -> LibrarySubscriptionDetails {
        ::std::default::Default::default()
    }

    // optional int64 initiationTimestampMsec = 1;


    pub fn get_initiationTimestampMsec(&self) -> i64 {
        self.initiationTimestampMsec.unwrap_or(0)
    }

    // optional int64 validUntilTimestampMsec = 2;


    pub fn get_validUntilTimestampMsec(&self) -> i64 {
        self.validUntilTimestampMsec.unwrap_or(0)
    }

    // optional bool autoRenewing = 3;


    pub fn get_autoRenewing(&self) -> bool {
        self.autoRenewing.unwrap_or(false)
    }

    // optional int64 trialUntilTimestampMsec = 4;


    pub fn get_trialUntilTimestampMsec(&self) -> i64 {
        self.trialUntilTimestampMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibrarySubscriptionDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initiationTimestampMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.validUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoRenewing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.trialUntilTimestampMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiationTimestampMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.validUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autoRenewing {
            my_size += 2;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiationTimestampMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.validUntilTimestampMsec {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoRenewing {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.trialUntilTimestampMsec {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibrarySubscriptionDetails {
        LibrarySubscriptionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initiationTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.initiationTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.initiationTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "validUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.validUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.validUntilTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoRenewing",
                |m: &LibrarySubscriptionDetails| { &m.autoRenewing },
                |m: &mut LibrarySubscriptionDetails| { &mut m.autoRenewing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "trialUntilTimestampMsec",
                |m: &LibrarySubscriptionDetails| { &m.trialUntilTimestampMsec },
                |m: &mut LibrarySubscriptionDetails| { &mut m.trialUntilTimestampMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibrarySubscriptionDetails>(
                "LibrarySubscriptionDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibrarySubscriptionDetails {
        static instance: ::protobuf::rt::LazyV2<LibrarySubscriptionDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibrarySubscriptionDetails::new)
    }
}

impl ::protobuf::Clear for LibrarySubscriptionDetails {
    fn clear(&mut self) {
        self.initiationTimestampMsec = ::std::option::Option::None;
        self.validUntilTimestampMsec = ::std::option::Option::None;
        self.autoRenewing = ::std::option::Option::None;
        self.trialUntilTimestampMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibrarySubscriptionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibrarySubscriptionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryUpdate {
    // message fields
    pub status: ::std::option::Option<i32>,
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub mutation: ::protobuf::RepeatedField<LibraryMutation>,
    pub hasMore: ::std::option::Option<bool>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryUpdate {
    fn default() -> &'a LibraryUpdate {
        <LibraryUpdate as ::protobuf::Message>::default_instance()
    }
}

impl LibraryUpdate {
    pub fn new() -> LibraryUpdate {
        ::std::default::Default::default()
    }

    // optional int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0)
    }

    // optional int32 corpus = 2;


    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 3;


    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .LibraryMutation mutation = 4;


    pub fn get_mutation(&self) -> &[LibraryMutation] {
        &self.mutation
    }

    // optional bool hasMore = 5;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    // optional string libraryId = 6;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LibraryUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mutation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.mutation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.corpus {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.mutation {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryUpdate {
        LibraryUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &LibraryUpdate| { &m.status },
                |m: &mut LibraryUpdate| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "corpus",
                |m: &LibraryUpdate| { &m.corpus },
                |m: &mut LibraryUpdate| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverToken",
                |m: &LibraryUpdate| { &m.serverToken },
                |m: &mut LibraryUpdate| { &mut m.serverToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryMutation>>(
                "mutation",
                |m: &LibraryUpdate| { &m.mutation },
                |m: &mut LibraryUpdate| { &mut m.mutation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &LibraryUpdate| { &m.hasMore },
                |m: &mut LibraryUpdate| { &mut m.hasMore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &LibraryUpdate| { &m.libraryId },
                |m: &mut LibraryUpdate| { &mut m.libraryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryUpdate>(
                "LibraryUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryUpdate {
        static instance: ::protobuf::rt::LazyV2<LibraryUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryUpdate::new)
    }
}

impl ::protobuf::Clear for LibraryUpdate {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.mutation.clear();
        self.hasMore = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidAppNotificationData {
    // message fields
    pub versionCode: ::std::option::Option<i32>,
    pub assetId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidAppNotificationData {
    fn default() -> &'a AndroidAppNotificationData {
        <AndroidAppNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl AndroidAppNotificationData {
    pub fn new() -> AndroidAppNotificationData {
        ::std::default::Default::default()
    }

    // optional int32 versionCode = 1;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }

    // optional string assetId = 2;


    pub fn get_assetId(&self) -> &str {
        match self.assetId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.assetId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.assetId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.versionCode {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.assetId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidAppNotificationData {
        AndroidAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &AndroidAppNotificationData| { &m.versionCode },
                |m: &mut AndroidAppNotificationData| { &mut m.versionCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &AndroidAppNotificationData| { &m.assetId },
                |m: &mut AndroidAppNotificationData| { &mut m.assetId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidAppNotificationData>(
                "AndroidAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidAppNotificationData {
        static instance: ::protobuf::rt::LazyV2<AndroidAppNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidAppNotificationData::new)
    }
}

impl ::protobuf::Clear for AndroidAppNotificationData {
    fn clear(&mut self) {
        self.versionCode = ::std::option::Option::None;
        self.assetId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidAppNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InAppNotificationData {
    // message fields
    pub checkoutOrderId: ::protobuf::SingularField<::std::string::String>,
    pub inAppNotificationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAppNotificationData {
    fn default() -> &'a InAppNotificationData {
        <InAppNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl InAppNotificationData {
    pub fn new() -> InAppNotificationData {
        ::std::default::Default::default()
    }

    // optional string checkoutOrderId = 1;


    pub fn get_checkoutOrderId(&self) -> &str {
        match self.checkoutOrderId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string inAppNotificationId = 2;


    pub fn get_inAppNotificationId(&self) -> &str {
        match self.inAppNotificationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for InAppNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.checkoutOrderId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inAppNotificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checkoutOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.inAppNotificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checkoutOrderId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.inAppNotificationId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAppNotificationData {
        InAppNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "checkoutOrderId",
                |m: &InAppNotificationData| { &m.checkoutOrderId },
                |m: &mut InAppNotificationData| { &mut m.checkoutOrderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inAppNotificationId",
                |m: &InAppNotificationData| { &m.inAppNotificationId },
                |m: &mut InAppNotificationData| { &mut m.inAppNotificationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InAppNotificationData>(
                "InAppNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InAppNotificationData {
        static instance: ::protobuf::rt::LazyV2<InAppNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InAppNotificationData::new)
    }
}

impl ::protobuf::Clear for InAppNotificationData {
    fn clear(&mut self) {
        self.checkoutOrderId.clear();
        self.inAppNotificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAppNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAppNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LibraryDirtyData {
    // message fields
    pub backend: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LibraryDirtyData {
    fn default() -> &'a LibraryDirtyData {
        <LibraryDirtyData as ::protobuf::Message>::default_instance()
    }
}

impl LibraryDirtyData {
    pub fn new() -> LibraryDirtyData {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }
}

impl ::protobuf::Message for LibraryDirtyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryDirtyData {
        LibraryDirtyData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &LibraryDirtyData| { &m.backend },
                |m: &mut LibraryDirtyData| { &mut m.backend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LibraryDirtyData>(
                "LibraryDirtyData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LibraryDirtyData {
        static instance: ::protobuf::rt::LazyV2<LibraryDirtyData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LibraryDirtyData::new)
    }
}

impl ::protobuf::Clear for LibraryDirtyData {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryDirtyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryDirtyData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Notification {
    // message fields
    pub notificationType: ::std::option::Option<i32>,
    pub timestamp: ::std::option::Option<i64>,
    pub docid: ::protobuf::SingularPtrField<Docid>,
    pub docTitle: ::protobuf::SingularField<::std::string::String>,
    pub userEmail: ::protobuf::SingularField<::std::string::String>,
    pub appData: ::protobuf::SingularPtrField<AndroidAppNotificationData>,
    pub appDeliveryData: ::protobuf::SingularPtrField<AndroidAppDeliveryData>,
    pub purchaseRemovalData: ::protobuf::SingularPtrField<PurchaseRemovalData>,
    pub userNotificationData: ::protobuf::SingularPtrField<UserNotificationData>,
    pub inAppNotificationData: ::protobuf::SingularPtrField<InAppNotificationData>,
    pub purchaseDeclinedData: ::protobuf::SingularPtrField<PurchaseDeclinedData>,
    pub notificationId: ::protobuf::SingularField<::std::string::String>,
    pub libraryUpdate: ::protobuf::SingularPtrField<LibraryUpdate>,
    pub libraryDirtyData: ::protobuf::SingularPtrField<LibraryDirtyData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Notification {
    fn default() -> &'a Notification {
        <Notification as ::protobuf::Message>::default_instance()
    }
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    // optional int32 notificationType = 1;


    pub fn get_notificationType(&self) -> i32 {
        self.notificationType.unwrap_or(0)
    }

    // optional int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional .Docid docid = 4;


    pub fn get_docid(&self) -> &Docid {
        self.docid.as_ref().unwrap_or_else(|| <Docid as ::protobuf::Message>::default_instance())
    }

    // optional string docTitle = 5;


    pub fn get_docTitle(&self) -> &str {
        match self.docTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string userEmail = 6;


    pub fn get_userEmail(&self) -> &str {
        match self.userEmail.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AndroidAppNotificationData appData = 7;


    pub fn get_appData(&self) -> &AndroidAppNotificationData {
        self.appData.as_ref().unwrap_or_else(|| <AndroidAppNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .AndroidAppDeliveryData appDeliveryData = 8;


    pub fn get_appDeliveryData(&self) -> &AndroidAppDeliveryData {
        self.appDeliveryData.as_ref().unwrap_or_else(|| <AndroidAppDeliveryData as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseRemovalData purchaseRemovalData = 9;


    pub fn get_purchaseRemovalData(&self) -> &PurchaseRemovalData {
        self.purchaseRemovalData.as_ref().unwrap_or_else(|| <PurchaseRemovalData as ::protobuf::Message>::default_instance())
    }

    // optional .UserNotificationData userNotificationData = 10;


    pub fn get_userNotificationData(&self) -> &UserNotificationData {
        self.userNotificationData.as_ref().unwrap_or_else(|| <UserNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .InAppNotificationData inAppNotificationData = 11;


    pub fn get_inAppNotificationData(&self) -> &InAppNotificationData {
        self.inAppNotificationData.as_ref().unwrap_or_else(|| <InAppNotificationData as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseDeclinedData purchaseDeclinedData = 12;


    pub fn get_purchaseDeclinedData(&self) -> &PurchaseDeclinedData {
        self.purchaseDeclinedData.as_ref().unwrap_or_else(|| <PurchaseDeclinedData as ::protobuf::Message>::default_instance())
    }

    // optional string notificationId = 13;


    pub fn get_notificationId(&self) -> &str {
        match self.notificationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .LibraryUpdate libraryUpdate = 14;


    pub fn get_libraryUpdate(&self) -> &LibraryUpdate {
        self.libraryUpdate.as_ref().unwrap_or_else(|| <LibraryUpdate as ::protobuf::Message>::default_instance())
    }

    // optional .LibraryDirtyData libraryDirtyData = 15;


    pub fn get_libraryDirtyData(&self) -> &LibraryDirtyData {
        self.libraryDirtyData.as_ref().unwrap_or_else(|| <LibraryDirtyData as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.docid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDeliveryData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseRemovalData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inAppNotificationData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseDeclinedData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryUpdate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libraryDirtyData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.notificationType = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.docTitle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userEmail)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appData)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDeliveryData)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseRemovalData)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userNotificationData)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inAppNotificationData)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseDeclinedData)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationId)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryUpdate)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.libraryDirtyData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notificationType {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.docid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.docTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.userEmail.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.appData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseRemovalData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inAppNotificationData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseDeclinedData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.notificationId.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.libraryDirtyData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notificationType {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.docid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.docTitle.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.userEmail.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.appData.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appDeliveryData.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseRemovalData.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userNotificationData.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inAppNotificationData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseDeclinedData.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.notificationId.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.libraryUpdate.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.libraryDirtyData.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "notificationType",
                |m: &Notification| { &m.notificationType },
                |m: &mut Notification| { &mut m.notificationType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Notification| { &m.timestamp },
                |m: &mut Notification| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Docid>>(
                "docid",
                |m: &Notification| { &m.docid },
                |m: &mut Notification| { &mut m.docid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "docTitle",
                |m: &Notification| { &m.docTitle },
                |m: &mut Notification| { &mut m.docTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userEmail",
                |m: &Notification| { &m.userEmail },
                |m: &mut Notification| { &mut m.userEmail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppNotificationData>>(
                "appData",
                |m: &Notification| { &m.appData },
                |m: &mut Notification| { &mut m.appData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidAppDeliveryData>>(
                "appDeliveryData",
                |m: &Notification| { &m.appDeliveryData },
                |m: &mut Notification| { &mut m.appDeliveryData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseRemovalData>>(
                "purchaseRemovalData",
                |m: &Notification| { &m.purchaseRemovalData },
                |m: &mut Notification| { &mut m.purchaseRemovalData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserNotificationData>>(
                "userNotificationData",
                |m: &Notification| { &m.userNotificationData },
                |m: &mut Notification| { &mut m.userNotificationData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InAppNotificationData>>(
                "inAppNotificationData",
                |m: &Notification| { &m.inAppNotificationData },
                |m: &mut Notification| { &mut m.inAppNotificationData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseDeclinedData>>(
                "purchaseDeclinedData",
                |m: &Notification| { &m.purchaseDeclinedData },
                |m: &mut Notification| { &mut m.purchaseDeclinedData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationId",
                |m: &Notification| { &m.notificationId },
                |m: &mut Notification| { &mut m.notificationId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryUpdate>>(
                "libraryUpdate",
                |m: &Notification| { &m.libraryUpdate },
                |m: &mut Notification| { &mut m.libraryUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LibraryDirtyData>>(
                "libraryDirtyData",
                |m: &Notification| { &m.libraryDirtyData },
                |m: &mut Notification| { &mut m.libraryDirtyData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Notification>(
                "Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Notification {
        static instance: ::protobuf::rt::LazyV2<Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Notification::new)
    }
}

impl ::protobuf::Clear for Notification {
    fn clear(&mut self) {
        self.notificationType = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.docid.clear();
        self.docTitle.clear();
        self.userEmail.clear();
        self.appData.clear();
        self.appDeliveryData.clear();
        self.purchaseRemovalData.clear();
        self.userNotificationData.clear();
        self.inAppNotificationData.clear();
        self.purchaseDeclinedData.clear();
        self.notificationId.clear();
        self.libraryUpdate.clear();
        self.libraryDirtyData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseDeclinedData {
    // message fields
    pub reason: ::std::option::Option<i32>,
    pub showNotification: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseDeclinedData {
    fn default() -> &'a PurchaseDeclinedData {
        <PurchaseDeclinedData as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseDeclinedData {
    pub fn new() -> PurchaseDeclinedData {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    // optional bool showNotification = 2;


    pub fn get_showNotification(&self) -> bool {
        self.showNotification.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseDeclinedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.showNotification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.showNotification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.showNotification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseDeclinedData {
        PurchaseDeclinedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reason",
                |m: &PurchaseDeclinedData| { &m.reason },
                |m: &mut PurchaseDeclinedData| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "showNotification",
                |m: &PurchaseDeclinedData| { &m.showNotification },
                |m: &mut PurchaseDeclinedData| { &mut m.showNotification },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseDeclinedData>(
                "PurchaseDeclinedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseDeclinedData {
        static instance: ::protobuf::rt::LazyV2<PurchaseDeclinedData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseDeclinedData::new)
    }
}

impl ::protobuf::Clear for PurchaseDeclinedData {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.showNotification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseDeclinedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseDeclinedData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PurchaseRemovalData {
    // message fields
    pub malicious: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurchaseRemovalData {
    fn default() -> &'a PurchaseRemovalData {
        <PurchaseRemovalData as ::protobuf::Message>::default_instance()
    }
}

impl PurchaseRemovalData {
    pub fn new() -> PurchaseRemovalData {
        ::std::default::Default::default()
    }

    // optional bool malicious = 1;


    pub fn get_malicious(&self) -> bool {
        self.malicious.unwrap_or(false)
    }
}

impl ::protobuf::Message for PurchaseRemovalData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.malicious = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.malicious {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.malicious {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurchaseRemovalData {
        PurchaseRemovalData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "malicious",
                |m: &PurchaseRemovalData| { &m.malicious },
                |m: &mut PurchaseRemovalData| { &mut m.malicious },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurchaseRemovalData>(
                "PurchaseRemovalData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurchaseRemovalData {
        static instance: ::protobuf::rt::LazyV2<PurchaseRemovalData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurchaseRemovalData::new)
    }
}

impl ::protobuf::Clear for PurchaseRemovalData {
    fn clear(&mut self) {
        self.malicious = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurchaseRemovalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurchaseRemovalData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserNotificationData {
    // message fields
    pub notificationTitle: ::protobuf::SingularField<::std::string::String>,
    pub notificationText: ::protobuf::SingularField<::std::string::String>,
    pub tickerText: ::protobuf::SingularField<::std::string::String>,
    pub dialogTitle: ::protobuf::SingularField<::std::string::String>,
    pub dialogText: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserNotificationData {
    fn default() -> &'a UserNotificationData {
        <UserNotificationData as ::protobuf::Message>::default_instance()
    }
}

impl UserNotificationData {
    pub fn new() -> UserNotificationData {
        ::std::default::Default::default()
    }

    // optional string notificationTitle = 1;


    pub fn get_notificationTitle(&self) -> &str {
        match self.notificationTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string notificationText = 2;


    pub fn get_notificationText(&self) -> &str {
        match self.notificationText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tickerText = 3;


    pub fn get_tickerText(&self) -> &str {
        match self.tickerText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dialogTitle = 4;


    pub fn get_dialogTitle(&self) -> &str {
        match self.dialogTitle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dialogText = 5;


    pub fn get_dialogText(&self) -> &str {
        match self.dialogText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UserNotificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationTitle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notificationText)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tickerText)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogTitle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dialogText)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.notificationTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.notificationText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.tickerText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.dialogTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.dialogText.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.notificationTitle.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.notificationText.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.tickerText.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.dialogTitle.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.dialogText.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserNotificationData {
        UserNotificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationTitle",
                |m: &UserNotificationData| { &m.notificationTitle },
                |m: &mut UserNotificationData| { &mut m.notificationTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notificationText",
                |m: &UserNotificationData| { &m.notificationText },
                |m: &mut UserNotificationData| { &mut m.notificationText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tickerText",
                |m: &UserNotificationData| { &m.tickerText },
                |m: &mut UserNotificationData| { &mut m.tickerText },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dialogTitle",
                |m: &UserNotificationData| { &m.dialogTitle },
                |m: &mut UserNotificationData| { &mut m.dialogTitle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dialogText",
                |m: &UserNotificationData| { &m.dialogText },
                |m: &mut UserNotificationData| { &mut m.dialogText },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserNotificationData>(
                "UserNotificationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserNotificationData {
        static instance: ::protobuf::rt::LazyV2<UserNotificationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserNotificationData::new)
    }
}

impl ::protobuf::Clear for UserNotificationData {
    fn clear(&mut self) {
        self.notificationTitle.clear();
        self.notificationText.clear();
        self.tickerText.clear();
        self.dialogTitle.clear();
        self.dialogText.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserNotificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserNotificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AggregateRating {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub starRating: ::std::option::Option<f32>,
    pub ratingsCount: ::std::option::Option<u64>,
    pub oneStarRatings: ::std::option::Option<u64>,
    pub twoStarRatings: ::std::option::Option<u64>,
    pub threeStarRatings: ::std::option::Option<u64>,
    pub fourStarRatings: ::std::option::Option<u64>,
    pub fiveStarRatings: ::std::option::Option<u64>,
    pub thumbsUpCount: ::std::option::Option<u64>,
    pub thumbsDownCount: ::std::option::Option<u64>,
    pub commentCount: ::std::option::Option<u64>,
    pub bayesianMeanRating: ::std::option::Option<f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AggregateRating {
    fn default() -> &'a AggregateRating {
        <AggregateRating as ::protobuf::Message>::default_instance()
    }
}

impl AggregateRating {
    pub fn new() -> AggregateRating {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional float starRating = 2;


    pub fn get_starRating(&self) -> f32 {
        self.starRating.unwrap_or(0.)
    }

    // optional uint64 ratingsCount = 3;


    pub fn get_ratingsCount(&self) -> u64 {
        self.ratingsCount.unwrap_or(0)
    }

    // optional uint64 oneStarRatings = 4;


    pub fn get_oneStarRatings(&self) -> u64 {
        self.oneStarRatings.unwrap_or(0)
    }

    // optional uint64 twoStarRatings = 5;


    pub fn get_twoStarRatings(&self) -> u64 {
        self.twoStarRatings.unwrap_or(0)
    }

    // optional uint64 threeStarRatings = 6;


    pub fn get_threeStarRatings(&self) -> u64 {
        self.threeStarRatings.unwrap_or(0)
    }

    // optional uint64 fourStarRatings = 7;


    pub fn get_fourStarRatings(&self) -> u64 {
        self.fourStarRatings.unwrap_or(0)
    }

    // optional uint64 fiveStarRatings = 8;


    pub fn get_fiveStarRatings(&self) -> u64 {
        self.fiveStarRatings.unwrap_or(0)
    }

    // optional uint64 thumbsUpCount = 9;


    pub fn get_thumbsUpCount(&self) -> u64 {
        self.thumbsUpCount.unwrap_or(0)
    }

    // optional uint64 thumbsDownCount = 10;


    pub fn get_thumbsDownCount(&self) -> u64 {
        self.thumbsDownCount.unwrap_or(0)
    }

    // optional uint64 commentCount = 11;


    pub fn get_commentCount(&self) -> u64 {
        self.commentCount.unwrap_or(0)
    }

    // optional double bayesianMeanRating = 12;


    pub fn get_bayesianMeanRating(&self) -> f64 {
        self.bayesianMeanRating.unwrap_or(0.)
    }
}

impl ::protobuf::Message for AggregateRating {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ratingsCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.oneStarRatings = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.twoStarRatings = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.threeStarRatings = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fourStarRatings = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fiveStarRatings = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsUpCount = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thumbsDownCount = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commentCount = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bayesianMeanRating = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += 5;
        }
        if let Some(v) = self.ratingsCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.oneStarRatings {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twoStarRatings {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threeStarRatings {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fourStarRatings {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fiveStarRatings {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsUpCount {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thumbsDownCount {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commentCount {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bayesianMeanRating {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.ratingsCount {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.oneStarRatings {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.twoStarRatings {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.threeStarRatings {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.fourStarRatings {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.fiveStarRatings {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.thumbsUpCount {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.thumbsDownCount {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.commentCount {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.bayesianMeanRating {
            os.write_double(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregateRating {
        AggregateRating::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &AggregateRating| { &m.field_type },
                |m: &mut AggregateRating| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "starRating",
                |m: &AggregateRating| { &m.starRating },
                |m: &mut AggregateRating| { &mut m.starRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ratingsCount",
                |m: &AggregateRating| { &m.ratingsCount },
                |m: &mut AggregateRating| { &mut m.ratingsCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "oneStarRatings",
                |m: &AggregateRating| { &m.oneStarRatings },
                |m: &mut AggregateRating| { &mut m.oneStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "twoStarRatings",
                |m: &AggregateRating| { &m.twoStarRatings },
                |m: &mut AggregateRating| { &mut m.twoStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "threeStarRatings",
                |m: &AggregateRating| { &m.threeStarRatings },
                |m: &mut AggregateRating| { &mut m.threeStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fourStarRatings",
                |m: &AggregateRating| { &m.fourStarRatings },
                |m: &mut AggregateRating| { &mut m.fourStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fiveStarRatings",
                |m: &AggregateRating| { &m.fiveStarRatings },
                |m: &mut AggregateRating| { &mut m.fiveStarRatings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "thumbsUpCount",
                |m: &AggregateRating| { &m.thumbsUpCount },
                |m: &mut AggregateRating| { &mut m.thumbsUpCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "thumbsDownCount",
                |m: &AggregateRating| { &m.thumbsDownCount },
                |m: &mut AggregateRating| { &mut m.thumbsDownCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "commentCount",
                |m: &AggregateRating| { &m.commentCount },
                |m: &mut AggregateRating| { &mut m.commentCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bayesianMeanRating",
                |m: &AggregateRating| { &m.bayesianMeanRating },
                |m: &mut AggregateRating| { &mut m.bayesianMeanRating },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AggregateRating>(
                "AggregateRating",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AggregateRating {
        static instance: ::protobuf::rt::LazyV2<AggregateRating> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AggregateRating::new)
    }
}

impl ::protobuf::Clear for AggregateRating {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.ratingsCount = ::std::option::Option::None;
        self.oneStarRatings = ::std::option::Option::None;
        self.twoStarRatings = ::std::option::Option::None;
        self.threeStarRatings = ::std::option::Option::None;
        self.fourStarRatings = ::std::option::Option::None;
        self.fiveStarRatings = ::std::option::Option::None;
        self.thumbsUpCount = ::std::option::Option::None;
        self.thumbsDownCount = ::std::option::Option::None;
        self.commentCount = ::std::option::Option::None;
        self.bayesianMeanRating = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AggregateRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregateRating {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AcceptTosResponse {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceptTosResponse {
    fn default() -> &'a AcceptTosResponse {
        <AcceptTosResponse as ::protobuf::Message>::default_instance()
    }
}

impl AcceptTosResponse {
    pub fn new() -> AcceptTosResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AcceptTosResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceptTosResponse {
        AcceptTosResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceptTosResponse>(
                "AcceptTosResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceptTosResponse {
        static instance: ::protobuf::rt::LazyV2<AcceptTosResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceptTosResponse::new)
    }
}

impl ::protobuf::Clear for AcceptTosResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceptTosResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceptTosResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CarrierBillingConfig {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub apiVersion: ::std::option::Option<i32>,
    pub provisioningUrl: ::protobuf::SingularField<::std::string::String>,
    pub credentialsUrl: ::protobuf::SingularField<::std::string::String>,
    pub tosRequired: ::std::option::Option<bool>,
    pub perTransactionCredentialsRequired: ::std::option::Option<bool>,
    pub sendSubscriberIdWithCarrierBillingRequests: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CarrierBillingConfig {
    fn default() -> &'a CarrierBillingConfig {
        <CarrierBillingConfig as ::protobuf::Message>::default_instance()
    }
}

impl CarrierBillingConfig {
    pub fn new() -> CarrierBillingConfig {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 apiVersion = 3;


    pub fn get_apiVersion(&self) -> i32 {
        self.apiVersion.unwrap_or(0)
    }

    // optional string provisioningUrl = 4;


    pub fn get_provisioningUrl(&self) -> &str {
        match self.provisioningUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string credentialsUrl = 5;


    pub fn get_credentialsUrl(&self) -> &str {
        match self.credentialsUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool tosRequired = 6;


    pub fn get_tosRequired(&self) -> bool {
        self.tosRequired.unwrap_or(false)
    }

    // optional bool perTransactionCredentialsRequired = 7;


    pub fn get_perTransactionCredentialsRequired(&self) -> bool {
        self.perTransactionCredentialsRequired.unwrap_or(false)
    }

    // optional bool sendSubscriberIdWithCarrierBillingRequests = 8;


    pub fn get_sendSubscriberIdWithCarrierBillingRequests(&self) -> bool {
        self.sendSubscriberIdWithCarrierBillingRequests.unwrap_or(false)
    }
}

impl ::protobuf::Message for CarrierBillingConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.apiVersion = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.provisioningUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.credentialsUrl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tosRequired = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perTransactionCredentialsRequired = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.apiVersion {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.provisioningUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.credentialsUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tosRequired {
            my_size += 2;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            my_size += 2;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.apiVersion {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.provisioningUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.credentialsUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.tosRequired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.perTransactionCredentialsRequired {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sendSubscriberIdWithCarrierBillingRequests {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarrierBillingConfig {
        CarrierBillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CarrierBillingConfig| { &m.id },
                |m: &mut CarrierBillingConfig| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CarrierBillingConfig| { &m.name },
                |m: &mut CarrierBillingConfig| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "apiVersion",
                |m: &CarrierBillingConfig| { &m.apiVersion },
                |m: &mut CarrierBillingConfig| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "provisioningUrl",
                |m: &CarrierBillingConfig| { &m.provisioningUrl },
                |m: &mut CarrierBillingConfig| { &mut m.provisioningUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credentialsUrl",
                |m: &CarrierBillingConfig| { &m.credentialsUrl },
                |m: &mut CarrierBillingConfig| { &mut m.credentialsUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tosRequired",
                |m: &CarrierBillingConfig| { &m.tosRequired },
                |m: &mut CarrierBillingConfig| { &mut m.tosRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "perTransactionCredentialsRequired",
                |m: &CarrierBillingConfig| { &m.perTransactionCredentialsRequired },
                |m: &mut CarrierBillingConfig| { &mut m.perTransactionCredentialsRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sendSubscriberIdWithCarrierBillingRequests",
                |m: &CarrierBillingConfig| { &m.sendSubscriberIdWithCarrierBillingRequests },
                |m: &mut CarrierBillingConfig| { &mut m.sendSubscriberIdWithCarrierBillingRequests },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CarrierBillingConfig>(
                "CarrierBillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CarrierBillingConfig {
        static instance: ::protobuf::rt::LazyV2<CarrierBillingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CarrierBillingConfig::new)
    }
}

impl ::protobuf::Clear for CarrierBillingConfig {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.apiVersion = ::std::option::Option::None;
        self.provisioningUrl.clear();
        self.credentialsUrl.clear();
        self.tosRequired = ::std::option::Option::None;
        self.perTransactionCredentialsRequired = ::std::option::Option::None;
        self.sendSubscriberIdWithCarrierBillingRequests = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarrierBillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarrierBillingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BillingConfig {
    // message fields
    pub carrierBillingConfig: ::protobuf::SingularPtrField<CarrierBillingConfig>,
    pub maxIabApiVersion: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BillingConfig {
    fn default() -> &'a BillingConfig {
        <BillingConfig as ::protobuf::Message>::default_instance()
    }
}

impl BillingConfig {
    pub fn new() -> BillingConfig {
        ::std::default::Default::default()
    }

    // optional .CarrierBillingConfig carrierBillingConfig = 1;


    pub fn get_carrierBillingConfig(&self) -> &CarrierBillingConfig {
        self.carrierBillingConfig.as_ref().unwrap_or_else(|| <CarrierBillingConfig as ::protobuf::Message>::default_instance())
    }

    // optional int32 maxIabApiVersion = 2;


    pub fn get_maxIabApiVersion(&self) -> i32 {
        self.maxIabApiVersion.unwrap_or(0)
    }
}

impl ::protobuf::Message for BillingConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.carrierBillingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.carrierBillingConfig)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxIabApiVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.carrierBillingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.maxIabApiVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.carrierBillingConfig.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.maxIabApiVersion {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BillingConfig {
        BillingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CarrierBillingConfig>>(
                "carrierBillingConfig",
                |m: &BillingConfig| { &m.carrierBillingConfig },
                |m: &mut BillingConfig| { &mut m.carrierBillingConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxIabApiVersion",
                |m: &BillingConfig| { &m.maxIabApiVersion },
                |m: &mut BillingConfig| { &mut m.maxIabApiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BillingConfig>(
                "BillingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BillingConfig {
        static instance: ::protobuf::rt::LazyV2<BillingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BillingConfig::new)
    }
}

impl ::protobuf::Clear for BillingConfig {
    fn clear(&mut self) {
        self.carrierBillingConfig.clear();
        self.maxIabApiVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BillingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BillingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CorpusMetadata {
    // message fields
    pub backend: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub landingUrl: ::protobuf::SingularField<::std::string::String>,
    pub libraryName: ::protobuf::SingularField<::std::string::String>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    pub shopName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorpusMetadata {
    fn default() -> &'a CorpusMetadata {
        <CorpusMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CorpusMetadata {
    pub fn new() -> CorpusMetadata {
        ::std::default::Default::default()
    }

    // optional int32 backend = 1;


    pub fn get_backend(&self) -> i32 {
        self.backend.unwrap_or(0)
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string landingUrl = 3;


    pub fn get_landingUrl(&self) -> &str {
        match self.landingUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string libraryName = 4;


    pub fn get_libraryName(&self) -> &str {
        match self.libraryName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string recsWidgetUrl = 6;


    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string shopName = 7;


    pub fn get_shopName(&self) -> &str {
        match self.shopName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CorpusMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.landingUrl)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shopName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.backend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.landingUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.libraryName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.shopName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.backend {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.landingUrl.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.libraryName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.shopName.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorpusMetadata {
        CorpusMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backend",
                |m: &CorpusMetadata| { &m.backend },
                |m: &mut CorpusMetadata| { &mut m.backend },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CorpusMetadata| { &m.name },
                |m: &mut CorpusMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "landingUrl",
                |m: &CorpusMetadata| { &m.landingUrl },
                |m: &mut CorpusMetadata| { &mut m.landingUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryName",
                |m: &CorpusMetadata| { &m.libraryName },
                |m: &mut CorpusMetadata| { &mut m.libraryName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recsWidgetUrl",
                |m: &CorpusMetadata| { &m.recsWidgetUrl },
                |m: &mut CorpusMetadata| { &mut m.recsWidgetUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shopName",
                |m: &CorpusMetadata| { &m.shopName },
                |m: &mut CorpusMetadata| { &mut m.shopName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorpusMetadata>(
                "CorpusMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorpusMetadata {
        static instance: ::protobuf::rt::LazyV2<CorpusMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorpusMetadata::new)
    }
}

impl ::protobuf::Clear for CorpusMetadata {
    fn clear(&mut self) {
        self.backend = ::std::option::Option::None;
        self.name.clear();
        self.landingUrl.clear();
        self.libraryName.clear();
        self.recsWidgetUrl.clear();
        self.shopName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorpusMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorpusMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Experiments {
    // message fields
    pub experimentId: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Experiments {
    fn default() -> &'a Experiments {
        <Experiments as ::protobuf::Message>::default_instance()
    }
}

impl Experiments {
    pub fn new() -> Experiments {
        ::std::default::Default::default()
    }

    // repeated string experimentId = 1;


    pub fn get_experimentId(&self) -> &[::std::string::String] {
        &self.experimentId
    }
}

impl ::protobuf::Message for Experiments {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.experimentId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.experimentId {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.experimentId {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Experiments {
        Experiments::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "experimentId",
                |m: &Experiments| { &m.experimentId },
                |m: &mut Experiments| { &mut m.experimentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Experiments>(
                "Experiments",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Experiments {
        static instance: ::protobuf::rt::LazyV2<Experiments> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Experiments::new)
    }
}

impl ::protobuf::Clear for Experiments {
    fn clear(&mut self) {
        self.experimentId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Experiments {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Experiments {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SelfUpdateConfig {
    // message fields
    pub latestClientVersionCode: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelfUpdateConfig {
    fn default() -> &'a SelfUpdateConfig {
        <SelfUpdateConfig as ::protobuf::Message>::default_instance()
    }
}

impl SelfUpdateConfig {
    pub fn new() -> SelfUpdateConfig {
        ::std::default::Default::default()
    }

    // optional int32 latestClientVersionCode = 1;


    pub fn get_latestClientVersionCode(&self) -> i32 {
        self.latestClientVersionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for SelfUpdateConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latestClientVersionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latestClientVersionCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latestClientVersionCode {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelfUpdateConfig {
        SelfUpdateConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "latestClientVersionCode",
                |m: &SelfUpdateConfig| { &m.latestClientVersionCode },
                |m: &mut SelfUpdateConfig| { &mut m.latestClientVersionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelfUpdateConfig>(
                "SelfUpdateConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelfUpdateConfig {
        static instance: ::protobuf::rt::LazyV2<SelfUpdateConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelfUpdateConfig::new)
    }
}

impl ::protobuf::Clear for SelfUpdateConfig {
    fn clear(&mut self) {
        self.latestClientVersionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelfUpdateConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelfUpdateConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TocResponse {
    // message fields
    pub corpus: ::protobuf::RepeatedField<CorpusMetadata>,
    pub tosVersionDeprecated: ::std::option::Option<i32>,
    pub tosContent: ::protobuf::SingularField<::std::string::String>,
    pub homeUrl: ::protobuf::SingularField<::std::string::String>,
    pub experiments: ::protobuf::SingularPtrField<Experiments>,
    pub tosCheckboxTextMarketingEmails: ::protobuf::SingularField<::std::string::String>,
    pub tosToken: ::protobuf::SingularField<::std::string::String>,
    pub iconOverrideUrl: ::protobuf::SingularField<::std::string::String>,
    pub selfUpdateConfig: ::protobuf::SingularPtrField<SelfUpdateConfig>,
    pub requiresUploadDeviceConfig: ::std::option::Option<bool>,
    pub billingConfig: ::protobuf::SingularPtrField<BillingConfig>,
    pub recsWidgetUrl: ::protobuf::SingularField<::std::string::String>,
    pub socialHomeUrl: ::protobuf::SingularField<::std::string::String>,
    pub ageVerificationRequired: ::std::option::Option<bool>,
    pub gplusSignupEnabled: ::std::option::Option<bool>,
    pub redeemEnabled: ::std::option::Option<bool>,
    pub helpUrl: ::protobuf::SingularField<::std::string::String>,
    pub themeId: ::std::option::Option<i32>,
    pub entertainmentHomeUrl: ::protobuf::SingularField<::std::string::String>,
    pub cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TocResponse {
    fn default() -> &'a TocResponse {
        <TocResponse as ::protobuf::Message>::default_instance()
    }
}

impl TocResponse {
    pub fn new() -> TocResponse {
        ::std::default::Default::default()
    }

    // repeated .CorpusMetadata corpus = 1;


    pub fn get_corpus(&self) -> &[CorpusMetadata] {
        &self.corpus
    }

    // optional int32 tosVersionDeprecated = 2;


    pub fn get_tosVersionDeprecated(&self) -> i32 {
        self.tosVersionDeprecated.unwrap_or(0)
    }

    // optional string tosContent = 3;


    pub fn get_tosContent(&self) -> &str {
        match self.tosContent.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string homeUrl = 4;


    pub fn get_homeUrl(&self) -> &str {
        match self.homeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Experiments experiments = 5;


    pub fn get_experiments(&self) -> &Experiments {
        self.experiments.as_ref().unwrap_or_else(|| <Experiments as ::protobuf::Message>::default_instance())
    }

    // optional string tosCheckboxTextMarketingEmails = 6;


    pub fn get_tosCheckboxTextMarketingEmails(&self) -> &str {
        match self.tosCheckboxTextMarketingEmails.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string tosToken = 7;


    pub fn get_tosToken(&self) -> &str {
        match self.tosToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string iconOverrideUrl = 9;


    pub fn get_iconOverrideUrl(&self) -> &str {
        match self.iconOverrideUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SelfUpdateConfig selfUpdateConfig = 10;


    pub fn get_selfUpdateConfig(&self) -> &SelfUpdateConfig {
        self.selfUpdateConfig.as_ref().unwrap_or_else(|| <SelfUpdateConfig as ::protobuf::Message>::default_instance())
    }

    // optional bool requiresUploadDeviceConfig = 11;


    pub fn get_requiresUploadDeviceConfig(&self) -> bool {
        self.requiresUploadDeviceConfig.unwrap_or(false)
    }

    // optional .BillingConfig billingConfig = 12;


    pub fn get_billingConfig(&self) -> &BillingConfig {
        self.billingConfig.as_ref().unwrap_or_else(|| <BillingConfig as ::protobuf::Message>::default_instance())
    }

    // optional string recsWidgetUrl = 13;


    pub fn get_recsWidgetUrl(&self) -> &str {
        match self.recsWidgetUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string socialHomeUrl = 15;


    pub fn get_socialHomeUrl(&self) -> &str {
        match self.socialHomeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ageVerificationRequired = 16;


    pub fn get_ageVerificationRequired(&self) -> bool {
        self.ageVerificationRequired.unwrap_or(false)
    }

    // optional bool gplusSignupEnabled = 17;


    pub fn get_gplusSignupEnabled(&self) -> bool {
        self.gplusSignupEnabled.unwrap_or(false)
    }

    // optional bool redeemEnabled = 18;


    pub fn get_redeemEnabled(&self) -> bool {
        self.redeemEnabled.unwrap_or(false)
    }

    // optional string helpUrl = 19;


    pub fn get_helpUrl(&self) -> &str {
        match self.helpUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 themeId = 20;


    pub fn get_themeId(&self) -> i32 {
        self.themeId.unwrap_or(0)
    }

    // optional string entertainmentHomeUrl = 21;


    pub fn get_entertainmentHomeUrl(&self) -> &str {
        match self.entertainmentHomeUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string cookie = 22;


    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TocResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.corpus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.experiments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selfUpdateConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billingConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.corpus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tosVersionDeprecated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosContent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.homeUrl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.experiments)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosCheckboxTextMarketingEmails)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tosToken)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iconOverrideUrl)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selfUpdateConfig)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requiresUploadDeviceConfig = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billingConfig)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recsWidgetUrl)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.socialHomeUrl)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ageVerificationRequired = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.gplusSignupEnabled = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.redeemEnabled = ::std::option::Option::Some(tmp);
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.helpUrl)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.themeId = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.entertainmentHomeUrl)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.corpus {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tosVersionDeprecated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tosContent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.experiments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.tosToken.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.iconOverrideUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.selfUpdateConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            my_size += 2;
        }
        if let Some(ref v) = self.billingConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.socialHomeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.ageVerificationRequired {
            my_size += 3;
        }
        if let Some(v) = self.gplusSignupEnabled {
            my_size += 3;
        }
        if let Some(v) = self.redeemEnabled {
            my_size += 3;
        }
        if let Some(ref v) = self.helpUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.themeId {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.entertainmentHomeUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.corpus {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tosVersionDeprecated {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.tosContent.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.homeUrl.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.experiments.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tosCheckboxTextMarketingEmails.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.tosToken.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.iconOverrideUrl.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.selfUpdateConfig.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.requiresUploadDeviceConfig {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.billingConfig.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recsWidgetUrl.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.socialHomeUrl.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.ageVerificationRequired {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.gplusSignupEnabled {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.redeemEnabled {
            os.write_bool(18, v)?;
        }
        if let Some(ref v) = self.helpUrl.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(v) = self.themeId {
            os.write_int32(20, v)?;
        }
        if let Some(ref v) = self.entertainmentHomeUrl.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(22, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TocResponse {
        TocResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorpusMetadata>>(
                "corpus",
                |m: &TocResponse| { &m.corpus },
                |m: &mut TocResponse| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tosVersionDeprecated",
                |m: &TocResponse| { &m.tosVersionDeprecated },
                |m: &mut TocResponse| { &mut m.tosVersionDeprecated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosContent",
                |m: &TocResponse| { &m.tosContent },
                |m: &mut TocResponse| { &mut m.tosContent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "homeUrl",
                |m: &TocResponse| { &m.homeUrl },
                |m: &mut TocResponse| { &mut m.homeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Experiments>>(
                "experiments",
                |m: &TocResponse| { &m.experiments },
                |m: &mut TocResponse| { &mut m.experiments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosCheckboxTextMarketingEmails",
                |m: &TocResponse| { &m.tosCheckboxTextMarketingEmails },
                |m: &mut TocResponse| { &mut m.tosCheckboxTextMarketingEmails },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tosToken",
                |m: &TocResponse| { &m.tosToken },
                |m: &mut TocResponse| { &mut m.tosToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iconOverrideUrl",
                |m: &TocResponse| { &m.iconOverrideUrl },
                |m: &mut TocResponse| { &mut m.iconOverrideUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SelfUpdateConfig>>(
                "selfUpdateConfig",
                |m: &TocResponse| { &m.selfUpdateConfig },
                |m: &mut TocResponse| { &mut m.selfUpdateConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requiresUploadDeviceConfig",
                |m: &TocResponse| { &m.requiresUploadDeviceConfig },
                |m: &mut TocResponse| { &mut m.requiresUploadDeviceConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BillingConfig>>(
                "billingConfig",
                |m: &TocResponse| { &m.billingConfig },
                |m: &mut TocResponse| { &mut m.billingConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recsWidgetUrl",
                |m: &TocResponse| { &m.recsWidgetUrl },
                |m: &mut TocResponse| { &mut m.recsWidgetUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "socialHomeUrl",
                |m: &TocResponse| { &m.socialHomeUrl },
                |m: &mut TocResponse| { &mut m.socialHomeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ageVerificationRequired",
                |m: &TocResponse| { &m.ageVerificationRequired },
                |m: &mut TocResponse| { &mut m.ageVerificationRequired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "gplusSignupEnabled",
                |m: &TocResponse| { &m.gplusSignupEnabled },
                |m: &mut TocResponse| { &mut m.gplusSignupEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "redeemEnabled",
                |m: &TocResponse| { &m.redeemEnabled },
                |m: &mut TocResponse| { &mut m.redeemEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "helpUrl",
                |m: &TocResponse| { &m.helpUrl },
                |m: &mut TocResponse| { &mut m.helpUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "themeId",
                |m: &TocResponse| { &m.themeId },
                |m: &mut TocResponse| { &mut m.themeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entertainmentHomeUrl",
                |m: &TocResponse| { &m.entertainmentHomeUrl },
                |m: &mut TocResponse| { &mut m.entertainmentHomeUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cookie",
                |m: &TocResponse| { &m.cookie },
                |m: &mut TocResponse| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TocResponse>(
                "TocResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TocResponse {
        static instance: ::protobuf::rt::LazyV2<TocResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TocResponse::new)
    }
}

impl ::protobuf::Clear for TocResponse {
    fn clear(&mut self) {
        self.corpus.clear();
        self.tosVersionDeprecated = ::std::option::Option::None;
        self.tosContent.clear();
        self.homeUrl.clear();
        self.experiments.clear();
        self.tosCheckboxTextMarketingEmails.clear();
        self.tosToken.clear();
        self.iconOverrideUrl.clear();
        self.selfUpdateConfig.clear();
        self.requiresUploadDeviceConfig = ::std::option::Option::None;
        self.billingConfig.clear();
        self.recsWidgetUrl.clear();
        self.socialHomeUrl.clear();
        self.ageVerificationRequired = ::std::option::Option::None;
        self.gplusSignupEnabled = ::std::option::Option::None;
        self.redeemEnabled = ::std::option::Option::None;
        self.helpUrl.clear();
        self.themeId = ::std::option::Option::None;
        self.entertainmentHomeUrl.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TocResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TocResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Payload {
    // message fields
    pub listResponse: ::protobuf::SingularPtrField<ListResponse>,
    pub detailsResponse: ::protobuf::SingularPtrField<DetailsResponse>,
    pub reviewResponse: ::protobuf::SingularPtrField<ReviewResponse>,
    pub buyResponse: ::protobuf::SingularPtrField<BuyResponse>,
    pub searchResponse: ::protobuf::SingularPtrField<SearchResponse>,
    pub tocResponse: ::protobuf::SingularPtrField<TocResponse>,
    pub browseResponse: ::protobuf::SingularPtrField<BrowseResponse>,
    pub purchaseStatusResponse: ::protobuf::SingularPtrField<PurchaseStatusResponse>,
    pub logResponse: ::protobuf::SingularField<::std::string::String>,
    pub flagContentResponse: ::protobuf::SingularField<::std::string::String>,
    pub bulkDetailsResponse: ::protobuf::SingularPtrField<BulkDetailsResponse>,
    pub deliveryResponse: ::protobuf::SingularPtrField<DeliveryResponse>,
    pub acceptTosResponse: ::protobuf::SingularPtrField<AcceptTosResponse>,
    pub androidCheckinResponse: ::protobuf::SingularPtrField<AndroidCheckinResponse>,
    pub uploadDeviceConfigResponse: ::protobuf::SingularPtrField<UploadDeviceConfigResponse>,
    pub searchSuggestResponse: ::protobuf::SingularPtrField<SearchSuggestResponse>,
    pub testingProgramResponse: ::protobuf::SingularPtrField<TestingProgramResponse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payload {
    fn default() -> &'a Payload {
        <Payload as ::protobuf::Message>::default_instance()
    }
}

impl Payload {
    pub fn new() -> Payload {
        ::std::default::Default::default()
    }

    // optional .ListResponse listResponse = 1;


    pub fn get_listResponse(&self) -> &ListResponse {
        self.listResponse.as_ref().unwrap_or_else(|| <ListResponse as ::protobuf::Message>::default_instance())
    }

    // optional .DetailsResponse detailsResponse = 2;


    pub fn get_detailsResponse(&self) -> &DetailsResponse {
        self.detailsResponse.as_ref().unwrap_or_else(|| <DetailsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .ReviewResponse reviewResponse = 3;


    pub fn get_reviewResponse(&self) -> &ReviewResponse {
        self.reviewResponse.as_ref().unwrap_or_else(|| <ReviewResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BuyResponse buyResponse = 4;


    pub fn get_buyResponse(&self) -> &BuyResponse {
        self.buyResponse.as_ref().unwrap_or_else(|| <BuyResponse as ::protobuf::Message>::default_instance())
    }

    // optional .SearchResponse searchResponse = 5;


    pub fn get_searchResponse(&self) -> &SearchResponse {
        self.searchResponse.as_ref().unwrap_or_else(|| <SearchResponse as ::protobuf::Message>::default_instance())
    }

    // optional .TocResponse tocResponse = 6;


    pub fn get_tocResponse(&self) -> &TocResponse {
        self.tocResponse.as_ref().unwrap_or_else(|| <TocResponse as ::protobuf::Message>::default_instance())
    }

    // optional .BrowseResponse browseResponse = 7;


    pub fn get_browseResponse(&self) -> &BrowseResponse {
        self.browseResponse.as_ref().unwrap_or_else(|| <BrowseResponse as ::protobuf::Message>::default_instance())
    }

    // optional .PurchaseStatusResponse purchaseStatusResponse = 8;


    pub fn get_purchaseStatusResponse(&self) -> &PurchaseStatusResponse {
        self.purchaseStatusResponse.as_ref().unwrap_or_else(|| <PurchaseStatusResponse as ::protobuf::Message>::default_instance())
    }

    // optional string logResponse = 10;


    pub fn get_logResponse(&self) -> &str {
        match self.logResponse.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string flagContentResponse = 13;


    pub fn get_flagContentResponse(&self) -> &str {
        match self.flagContentResponse.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .BulkDetailsResponse bulkDetailsResponse = 19;


    pub fn get_bulkDetailsResponse(&self) -> &BulkDetailsResponse {
        self.bulkDetailsResponse.as_ref().unwrap_or_else(|| <BulkDetailsResponse as ::protobuf::Message>::default_instance())
    }

    // optional .DeliveryResponse deliveryResponse = 21;


    pub fn get_deliveryResponse(&self) -> &DeliveryResponse {
        self.deliveryResponse.as_ref().unwrap_or_else(|| <DeliveryResponse as ::protobuf::Message>::default_instance())
    }

    // optional .AcceptTosResponse acceptTosResponse = 22;


    pub fn get_acceptTosResponse(&self) -> &AcceptTosResponse {
        self.acceptTosResponse.as_ref().unwrap_or_else(|| <AcceptTosResponse as ::protobuf::Message>::default_instance())
    }

    // optional .AndroidCheckinResponse androidCheckinResponse = 26;


    pub fn get_androidCheckinResponse(&self) -> &AndroidCheckinResponse {
        self.androidCheckinResponse.as_ref().unwrap_or_else(|| <AndroidCheckinResponse as ::protobuf::Message>::default_instance())
    }

    // optional .UploadDeviceConfigResponse uploadDeviceConfigResponse = 28;


    pub fn get_uploadDeviceConfigResponse(&self) -> &UploadDeviceConfigResponse {
        self.uploadDeviceConfigResponse.as_ref().unwrap_or_else(|| <UploadDeviceConfigResponse as ::protobuf::Message>::default_instance())
    }

    // optional .SearchSuggestResponse searchSuggestResponse = 40;


    pub fn get_searchSuggestResponse(&self) -> &SearchSuggestResponse {
        self.searchSuggestResponse.as_ref().unwrap_or_else(|| <SearchSuggestResponse as ::protobuf::Message>::default_instance())
    }

    // optional .TestingProgramResponse testingProgramResponse = 80;


    pub fn get_testingProgramResponse(&self) -> &TestingProgramResponse {
        self.testingProgramResponse.as_ref().unwrap_or_else(|| <TestingProgramResponse as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Payload {
    fn is_initialized(&self) -> bool {
        for v in &self.listResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reviewResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buyResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tocResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.browseResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.purchaseStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bulkDetailsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deliveryResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceptTosResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.androidCheckinResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uploadDeviceConfigResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.searchSuggestResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.testingProgramResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.listResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.detailsResponse)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reviewResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buyResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.searchResponse)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tocResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.browseResponse)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.purchaseStatusResponse)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.flagContentResponse)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bulkDetailsResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deliveryResponse)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acceptTosResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.androidCheckinResponse)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uploadDeviceConfigResponse)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.searchSuggestResponse)?;
                },
                80 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.testingProgramResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.listResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reviewResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buyResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.searchResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tocResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.browseResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.logResponse.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.flagContentResponse.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.bulkDetailsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deliveryResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acceptTosResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.androidCheckinResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.uploadDeviceConfigResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.searchSuggestResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.testingProgramResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.listResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detailsResponse.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reviewResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buyResponse.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.searchResponse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tocResponse.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.browseResponse.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.purchaseStatusResponse.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.logResponse.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.flagContentResponse.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.bulkDetailsResponse.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deliveryResponse.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acceptTosResponse.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.androidCheckinResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.uploadDeviceConfigResponse.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.searchSuggestResponse.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.testingProgramResponse.as_ref() {
            os.write_tag(80, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payload {
        Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListResponse>>(
                "listResponse",
                |m: &Payload| { &m.listResponse },
                |m: &mut Payload| { &mut m.listResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DetailsResponse>>(
                "detailsResponse",
                |m: &Payload| { &m.detailsResponse },
                |m: &mut Payload| { &mut m.detailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewResponse>>(
                "reviewResponse",
                |m: &Payload| { &m.reviewResponse },
                |m: &mut Payload| { &mut m.reviewResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuyResponse>>(
                "buyResponse",
                |m: &Payload| { &m.buyResponse },
                |m: &mut Payload| { &mut m.buyResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchResponse>>(
                "searchResponse",
                |m: &Payload| { &m.searchResponse },
                |m: &mut Payload| { &mut m.searchResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TocResponse>>(
                "tocResponse",
                |m: &Payload| { &m.tocResponse },
                |m: &mut Payload| { &mut m.tocResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BrowseResponse>>(
                "browseResponse",
                |m: &Payload| { &m.browseResponse },
                |m: &mut Payload| { &mut m.browseResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurchaseStatusResponse>>(
                "purchaseStatusResponse",
                |m: &Payload| { &m.purchaseStatusResponse },
                |m: &mut Payload| { &mut m.purchaseStatusResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logResponse",
                |m: &Payload| { &m.logResponse },
                |m: &mut Payload| { &mut m.logResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flagContentResponse",
                |m: &Payload| { &m.flagContentResponse },
                |m: &mut Payload| { &mut m.flagContentResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulkDetailsResponse>>(
                "bulkDetailsResponse",
                |m: &Payload| { &m.bulkDetailsResponse },
                |m: &mut Payload| { &mut m.bulkDetailsResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeliveryResponse>>(
                "deliveryResponse",
                |m: &Payload| { &m.deliveryResponse },
                |m: &mut Payload| { &mut m.deliveryResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AcceptTosResponse>>(
                "acceptTosResponse",
                |m: &Payload| { &m.acceptTosResponse },
                |m: &mut Payload| { &mut m.acceptTosResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidCheckinResponse>>(
                "androidCheckinResponse",
                |m: &Payload| { &m.androidCheckinResponse },
                |m: &mut Payload| { &mut m.androidCheckinResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UploadDeviceConfigResponse>>(
                "uploadDeviceConfigResponse",
                |m: &Payload| { &m.uploadDeviceConfigResponse },
                |m: &mut Payload| { &mut m.uploadDeviceConfigResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchSuggestResponse>>(
                "searchSuggestResponse",
                |m: &Payload| { &m.searchSuggestResponse },
                |m: &mut Payload| { &mut m.searchSuggestResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestingProgramResponse>>(
                "testingProgramResponse",
                |m: &Payload| { &m.testingProgramResponse },
                |m: &mut Payload| { &mut m.testingProgramResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Payload>(
                "Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Payload {
        static instance: ::protobuf::rt::LazyV2<Payload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payload::new)
    }
}

impl ::protobuf::Clear for Payload {
    fn clear(&mut self) {
        self.listResponse.clear();
        self.detailsResponse.clear();
        self.reviewResponse.clear();
        self.buyResponse.clear();
        self.searchResponse.clear();
        self.tocResponse.clear();
        self.browseResponse.clear();
        self.purchaseStatusResponse.clear();
        self.logResponse.clear();
        self.flagContentResponse.clear();
        self.bulkDetailsResponse.clear();
        self.deliveryResponse.clear();
        self.acceptTosResponse.clear();
        self.androidCheckinResponse.clear();
        self.uploadDeviceConfigResponse.clear();
        self.searchSuggestResponse.clear();
        self.testingProgramResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PreFetch {
    // message fields
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub response: ::protobuf::SingularPtrField<ResponseWrapper>,
    pub etag: ::protobuf::SingularField<::std::string::String>,
    pub ttl: ::std::option::Option<i64>,
    pub softTtl: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreFetch {
    fn default() -> &'a PreFetch {
        <PreFetch as ::protobuf::Message>::default_instance()
    }
}

impl PreFetch {
    pub fn new() -> PreFetch {
        ::std::default::Default::default()
    }

    // optional string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .ResponseWrapper response = 2;


    pub fn get_response(&self) -> &ResponseWrapper {
        self.response.as_ref().unwrap_or_else(|| <ResponseWrapper as ::protobuf::Message>::default_instance())
    }

    // optional string etag = 3;


    pub fn get_etag(&self) -> &str {
        match self.etag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 ttl = 4;


    pub fn get_ttl(&self) -> i64 {
        self.ttl.unwrap_or(0)
    }

    // optional int64 softTtl = 5;


    pub fn get_softTtl(&self) -> i64 {
        self.softTtl.unwrap_or(0)
    }
}

impl ::protobuf::Message for PreFetch {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.etag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ttl = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.softTtl = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.etag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ttl {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.softTtl {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.etag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ttl {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.softTtl {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreFetch {
        PreFetch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &PreFetch| { &m.url },
                |m: &mut PreFetch| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseWrapper>>(
                "response",
                |m: &PreFetch| { &m.response },
                |m: &mut PreFetch| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &PreFetch| { &m.etag },
                |m: &mut PreFetch| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ttl",
                |m: &PreFetch| { &m.ttl },
                |m: &mut PreFetch| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "softTtl",
                |m: &PreFetch| { &m.softTtl },
                |m: &mut PreFetch| { &mut m.softTtl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreFetch>(
                "PreFetch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreFetch {
        static instance: ::protobuf::rt::LazyV2<PreFetch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreFetch::new)
    }
}

impl ::protobuf::Clear for PreFetch {
    fn clear(&mut self) {
        self.url.clear();
        self.response.clear();
        self.etag.clear();
        self.ttl = ::std::option::Option::None;
        self.softTtl = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreFetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreFetch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerMetadata {
    // message fields
    pub latencyMillis: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerMetadata {
    fn default() -> &'a ServerMetadata {
        <ServerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ServerMetadata {
    pub fn new() -> ServerMetadata {
        ::std::default::Default::default()
    }

    // optional int64 latencyMillis = 1;


    pub fn get_latencyMillis(&self) -> i64 {
        self.latencyMillis.unwrap_or(0)
    }
}

impl ::protobuf::Message for ServerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latencyMillis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.latencyMillis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.latencyMillis {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMetadata {
        ServerMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latencyMillis",
                |m: &ServerMetadata| { &m.latencyMillis },
                |m: &mut ServerMetadata| { &mut m.latencyMillis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerMetadata>(
                "ServerMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerMetadata {
        static instance: ::protobuf::rt::LazyV2<ServerMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerMetadata::new)
    }
}

impl ::protobuf::Clear for ServerMetadata {
    fn clear(&mut self) {
        self.latencyMillis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Targets {
    // message fields
    pub targetId: ::std::vec::Vec<i64>,
    pub signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Targets {
    fn default() -> &'a Targets {
        <Targets as ::protobuf::Message>::default_instance()
    }
}

impl Targets {
    pub fn new() -> Targets {
        ::std::default::Default::default()
    }

    // repeated int64 targetId = 1;


    pub fn get_targetId(&self) -> &[i64] {
        &self.targetId
    }

    // optional bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for Targets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.targetId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.targetId {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.targetId {
            os.write_int64(1, *v)?;
        };
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Targets {
        Targets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "targetId",
                |m: &Targets| { &m.targetId },
                |m: &mut Targets| { &mut m.targetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &Targets| { &m.signature },
                |m: &mut Targets| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Targets>(
                "Targets",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Targets {
        static instance: ::protobuf::rt::LazyV2<Targets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Targets::new)
    }
}

impl ::protobuf::Clear for Targets {
    fn clear(&mut self) {
        self.targetId.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Targets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Targets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerCookie {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerCookie {
    fn default() -> &'a ServerCookie {
        <ServerCookie as ::protobuf::Message>::default_instance()
    }
}

impl ServerCookie {
    pub fn new() -> ServerCookie {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional bytes token = 2;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ServerCookie {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerCookie {
        ServerCookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &ServerCookie| { &m.field_type },
                |m: &mut ServerCookie| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &ServerCookie| { &m.token },
                |m: &mut ServerCookie| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerCookie>(
                "ServerCookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerCookie {
        static instance: ::protobuf::rt::LazyV2<ServerCookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerCookie::new)
    }
}

impl ::protobuf::Clear for ServerCookie {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerCookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerCookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerCookies {
    // message fields
    pub serverCookie: ::protobuf::RepeatedField<ServerCookie>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerCookies {
    fn default() -> &'a ServerCookies {
        <ServerCookies as ::protobuf::Message>::default_instance()
    }
}

impl ServerCookies {
    pub fn new() -> ServerCookies {
        ::std::default::Default::default()
    }

    // repeated .ServerCookie serverCookie = 1;


    pub fn get_serverCookie(&self) -> &[ServerCookie] {
        &self.serverCookie
    }
}

impl ::protobuf::Message for ServerCookies {
    fn is_initialized(&self) -> bool {
        for v in &self.serverCookie {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.serverCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.serverCookie {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.serverCookie {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerCookies {
        ServerCookies::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerCookie>>(
                "serverCookie",
                |m: &ServerCookies| { &m.serverCookie },
                |m: &mut ServerCookies| { &mut m.serverCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerCookies>(
                "ServerCookies",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerCookies {
        static instance: ::protobuf::rt::LazyV2<ServerCookies> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerCookies::new)
    }
}

impl ::protobuf::Clear for ServerCookies {
    fn clear(&mut self) {
        self.serverCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerCookies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerCookies {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponseWrapper {
    // message fields
    pub payload: ::protobuf::SingularPtrField<Payload>,
    pub commands: ::protobuf::SingularPtrField<ServerCommands>,
    pub preFetch: ::protobuf::RepeatedField<PreFetch>,
    pub notification: ::protobuf::RepeatedField<Notification>,
    pub serverMetadata: ::protobuf::SingularPtrField<ServerMetadata>,
    pub targets: ::protobuf::SingularPtrField<Targets>,
    pub serverCookies: ::protobuf::SingularPtrField<ServerCookies>,
    pub serverLogsCookie: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseWrapper {
    fn default() -> &'a ResponseWrapper {
        <ResponseWrapper as ::protobuf::Message>::default_instance()
    }
}

impl ResponseWrapper {
    pub fn new() -> ResponseWrapper {
        ::std::default::Default::default()
    }

    // optional .Payload payload = 1;


    pub fn get_payload(&self) -> &Payload {
        self.payload.as_ref().unwrap_or_else(|| <Payload as ::protobuf::Message>::default_instance())
    }

    // optional .ServerCommands commands = 2;


    pub fn get_commands(&self) -> &ServerCommands {
        self.commands.as_ref().unwrap_or_else(|| <ServerCommands as ::protobuf::Message>::default_instance())
    }

    // repeated .PreFetch preFetch = 3;


    pub fn get_preFetch(&self) -> &[PreFetch] {
        &self.preFetch
    }

    // repeated .Notification notification = 4;


    pub fn get_notification(&self) -> &[Notification] {
        &self.notification
    }

    // optional .ServerMetadata serverMetadata = 5;


    pub fn get_serverMetadata(&self) -> &ServerMetadata {
        self.serverMetadata.as_ref().unwrap_or_else(|| <ServerMetadata as ::protobuf::Message>::default_instance())
    }

    // optional .Targets targets = 6;


    pub fn get_targets(&self) -> &Targets {
        self.targets.as_ref().unwrap_or_else(|| <Targets as ::protobuf::Message>::default_instance())
    }

    // optional .ServerCookies serverCookies = 7;


    pub fn get_serverCookies(&self) -> &ServerCookies {
        self.serverCookies.as_ref().unwrap_or_else(|| <ServerCookies as ::protobuf::Message>::default_instance())
    }

    // optional bytes serverLogsCookie = 9;


    pub fn get_serverLogsCookie(&self) -> &[u8] {
        match self.serverLogsCookie.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for ResponseWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commands {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preFetch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverCookies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commands)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preFetch)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notification)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverMetadata)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targets)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverCookies)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverLogsCookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commands.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.preFetch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notification {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.serverMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.targets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverCookies.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commands.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.preFetch {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notification {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.serverMetadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.targets.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverCookies.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverLogsCookie.as_ref() {
            os.write_bytes(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseWrapper {
        ResponseWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payload>>(
                "payload",
                |m: &ResponseWrapper| { &m.payload },
                |m: &mut ResponseWrapper| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerCommands>>(
                "commands",
                |m: &ResponseWrapper| { &m.commands },
                |m: &mut ResponseWrapper| { &mut m.commands },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreFetch>>(
                "preFetch",
                |m: &ResponseWrapper| { &m.preFetch },
                |m: &mut ResponseWrapper| { &mut m.preFetch },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Notification>>(
                "notification",
                |m: &ResponseWrapper| { &m.notification },
                |m: &mut ResponseWrapper| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMetadata>>(
                "serverMetadata",
                |m: &ResponseWrapper| { &m.serverMetadata },
                |m: &mut ResponseWrapper| { &mut m.serverMetadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Targets>>(
                "targets",
                |m: &ResponseWrapper| { &m.targets },
                |m: &mut ResponseWrapper| { &mut m.targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerCookies>>(
                "serverCookies",
                |m: &ResponseWrapper| { &m.serverCookies },
                |m: &mut ResponseWrapper| { &mut m.serverCookies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverLogsCookie",
                |m: &ResponseWrapper| { &m.serverLogsCookie },
                |m: &mut ResponseWrapper| { &mut m.serverLogsCookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseWrapper>(
                "ResponseWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseWrapper {
        static instance: ::protobuf::rt::LazyV2<ResponseWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseWrapper::new)
    }
}

impl ::protobuf::Clear for ResponseWrapper {
    fn clear(&mut self) {
        self.payload.clear();
        self.commands.clear();
        self.preFetch.clear();
        self.notification.clear();
        self.serverMetadata.clear();
        self.targets.clear();
        self.serverCookies.clear();
        self.serverLogsCookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ResponseWrapperApi {
    // message fields
    pub payload: ::protobuf::SingularPtrField<PayloadApi>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseWrapperApi {
    fn default() -> &'a ResponseWrapperApi {
        <ResponseWrapperApi as ::protobuf::Message>::default_instance()
    }
}

impl ResponseWrapperApi {
    pub fn new() -> ResponseWrapperApi {
        ::std::default::Default::default()
    }

    // optional .PayloadApi payload = 1;


    pub fn get_payload(&self) -> &PayloadApi {
        self.payload.as_ref().unwrap_or_else(|| <PayloadApi as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ResponseWrapperApi {
    fn is_initialized(&self) -> bool {
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseWrapperApi {
        ResponseWrapperApi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PayloadApi>>(
                "payload",
                |m: &ResponseWrapperApi| { &m.payload },
                |m: &mut ResponseWrapperApi| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseWrapperApi>(
                "ResponseWrapperApi",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseWrapperApi {
        static instance: ::protobuf::rt::LazyV2<ResponseWrapperApi> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseWrapperApi::new)
    }
}

impl ::protobuf::Clear for ResponseWrapperApi {
    fn clear(&mut self) {
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseWrapperApi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseWrapperApi {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PayloadApi {
    // message fields
    pub userProfileResponse: ::protobuf::SingularPtrField<UserProfileResponse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayloadApi {
    fn default() -> &'a PayloadApi {
        <PayloadApi as ::protobuf::Message>::default_instance()
    }
}

impl PayloadApi {
    pub fn new() -> PayloadApi {
        ::std::default::Default::default()
    }

    // optional .UserProfileResponse userProfileResponse = 5;


    pub fn get_userProfileResponse(&self) -> &UserProfileResponse {
        self.userProfileResponse.as_ref().unwrap_or_else(|| <UserProfileResponse as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for PayloadApi {
    fn is_initialized(&self) -> bool {
        for v in &self.userProfileResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userProfileResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.userProfileResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.userProfileResponse.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayloadApi {
        PayloadApi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserProfileResponse>>(
                "userProfileResponse",
                |m: &PayloadApi| { &m.userProfileResponse },
                |m: &mut PayloadApi| { &mut m.userProfileResponse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PayloadApi>(
                "PayloadApi",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PayloadApi {
        static instance: ::protobuf::rt::LazyV2<PayloadApi> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PayloadApi::new)
    }
}

impl ::protobuf::Clear for PayloadApi {
    fn clear(&mut self) {
        self.userProfileResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayloadApi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayloadApi {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserProfileResponse {
    // message fields
    pub userProfile: ::protobuf::SingularPtrField<UserProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserProfileResponse {
    fn default() -> &'a UserProfileResponse {
        <UserProfileResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserProfileResponse {
    pub fn new() -> UserProfileResponse {
        ::std::default::Default::default()
    }

    // optional .UserProfile userProfile = 1;


    pub fn get_userProfile(&self) -> &UserProfile {
        self.userProfile.as_ref().unwrap_or_else(|| <UserProfile as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for UserProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.userProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.userProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.userProfile.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserProfileResponse {
        UserProfileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserProfile>>(
                "userProfile",
                |m: &UserProfileResponse| { &m.userProfile },
                |m: &mut UserProfileResponse| { &mut m.userProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserProfileResponse>(
                "UserProfileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserProfileResponse {
        static instance: ::protobuf::rt::LazyV2<UserProfileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserProfileResponse::new)
    }
}

impl ::protobuf::Clear for UserProfileResponse {
    fn clear(&mut self) {
        self.userProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserProfileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ServerCommands {
    // message fields
    pub clearCache: ::std::option::Option<bool>,
    pub displayErrorMessage: ::protobuf::SingularField<::std::string::String>,
    pub logErrorStacktrace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerCommands {
    fn default() -> &'a ServerCommands {
        <ServerCommands as ::protobuf::Message>::default_instance()
    }
}

impl ServerCommands {
    pub fn new() -> ServerCommands {
        ::std::default::Default::default()
    }

    // optional bool clearCache = 1;


    pub fn get_clearCache(&self) -> bool {
        self.clearCache.unwrap_or(false)
    }

    // optional string displayErrorMessage = 2;


    pub fn get_displayErrorMessage(&self) -> &str {
        match self.displayErrorMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string logErrorStacktrace = 3;


    pub fn get_logErrorStacktrace(&self) -> &str {
        match self.logErrorStacktrace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ServerCommands {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clearCache = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.displayErrorMessage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logErrorStacktrace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clearCache {
            my_size += 2;
        }
        if let Some(ref v) = self.displayErrorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.logErrorStacktrace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clearCache {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.displayErrorMessage.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.logErrorStacktrace.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerCommands {
        ServerCommands::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clearCache",
                |m: &ServerCommands| { &m.clearCache },
                |m: &mut ServerCommands| { &mut m.clearCache },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "displayErrorMessage",
                |m: &ServerCommands| { &m.displayErrorMessage },
                |m: &mut ServerCommands| { &mut m.displayErrorMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logErrorStacktrace",
                |m: &ServerCommands| { &m.logErrorStacktrace },
                |m: &mut ServerCommands| { &mut m.logErrorStacktrace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerCommands>(
                "ServerCommands",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerCommands {
        static instance: ::protobuf::rt::LazyV2<ServerCommands> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerCommands::new)
    }
}

impl ::protobuf::Clear for ServerCommands {
    fn clear(&mut self) {
        self.clearCache = ::std::option::Option::None;
        self.displayErrorMessage.clear();
        self.logErrorStacktrace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerCommands {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerCommands {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GetReviewsResponse {
    // message fields
    pub review: ::protobuf::RepeatedField<Review>,
    pub matchingCount: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetReviewsResponse {
    fn default() -> &'a GetReviewsResponse {
        <GetReviewsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetReviewsResponse {
    pub fn new() -> GetReviewsResponse {
        ::std::default::Default::default()
    }

    // repeated .Review review = 1;


    pub fn get_review(&self) -> &[Review] {
        &self.review
    }

    // optional int64 matchingCount = 2;


    pub fn get_matchingCount(&self) -> i64 {
        self.matchingCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for GetReviewsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.review {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.review)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.matchingCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.review {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.matchingCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.review {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.matchingCount {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReviewsResponse {
        GetReviewsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "review",
                |m: &GetReviewsResponse| { &m.review },
                |m: &mut GetReviewsResponse| { &mut m.review },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "matchingCount",
                |m: &GetReviewsResponse| { &m.matchingCount },
                |m: &mut GetReviewsResponse| { &mut m.matchingCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetReviewsResponse>(
                "GetReviewsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetReviewsResponse {
        static instance: ::protobuf::rt::LazyV2<GetReviewsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetReviewsResponse::new)
    }
}

impl ::protobuf::Clear for GetReviewsResponse {
    fn clear(&mut self) {
        self.review.clear();
        self.matchingCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReviewsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReviewsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Review {
    // message fields
    pub authorName: ::protobuf::SingularField<::std::string::String>,
    pub url: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularField<::std::string::String>,
    pub documentVersion: ::protobuf::SingularField<::std::string::String>,
    pub timestampMsec: ::std::option::Option<i64>,
    pub starRating: ::std::option::Option<i32>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub comment: ::protobuf::SingularField<::std::string::String>,
    pub commentId: ::protobuf::SingularField<::std::string::String>,
    pub deviceName: ::protobuf::SingularField<::std::string::String>,
    pub replyText: ::protobuf::SingularField<::std::string::String>,
    pub replyTimestampMsec: ::std::option::Option<i64>,
    pub author: ::protobuf::SingularPtrField<ReviewAuthor>,
    pub userProfile: ::protobuf::SingularPtrField<UserProfile>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Review {
    fn default() -> &'a Review {
        <Review as ::protobuf::Message>::default_instance()
    }
}

impl Review {
    pub fn new() -> Review {
        ::std::default::Default::default()
    }

    // optional string authorName = 1;


    pub fn get_authorName(&self) -> &str {
        match self.authorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string url = 2;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string source = 3;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string documentVersion = 4;


    pub fn get_documentVersion(&self) -> &str {
        match self.documentVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 timestampMsec = 5;


    pub fn get_timestampMsec(&self) -> i64 {
        self.timestampMsec.unwrap_or(0)
    }

    // optional int32 starRating = 6;


    pub fn get_starRating(&self) -> i32 {
        self.starRating.unwrap_or(0)
    }

    // optional string title = 7;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string comment = 8;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string commentId = 9;


    pub fn get_commentId(&self) -> &str {
        match self.commentId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string deviceName = 19;


    pub fn get_deviceName(&self) -> &str {
        match self.deviceName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string replyText = 29;


    pub fn get_replyText(&self) -> &str {
        match self.replyText.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 replyTimestampMsec = 30;


    pub fn get_replyTimestampMsec(&self) -> i64 {
        self.replyTimestampMsec.unwrap_or(0)
    }

    // optional .ReviewAuthor author = 31;


    pub fn get_author(&self) -> &ReviewAuthor {
        self.author.as_ref().unwrap_or_else(|| <ReviewAuthor as ::protobuf::Message>::default_instance())
    }

    // optional .UserProfile userProfile = 33;


    pub fn get_userProfile(&self) -> &UserProfile {
        self.userProfile.as_ref().unwrap_or_else(|| <UserProfile as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Review {
    fn is_initialized(&self) -> bool {
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.authorName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.documentVersion)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestampMsec = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.starRating = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.commentId)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceName)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replyText)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replyTimestampMsec = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.author)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authorName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.documentVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestampMsec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.starRating {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.commentId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.deviceName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.replyText.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.replyTimestampMsec {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.author.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.userProfile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authorName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.documentVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.timestampMsec {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.starRating {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.commentId.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.deviceName.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.replyText.as_ref() {
            os.write_string(29, &v)?;
        }
        if let Some(v) = self.replyTimestampMsec {
            os.write_int64(30, v)?;
        }
        if let Some(ref v) = self.author.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.userProfile.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Review {
        Review::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authorName",
                |m: &Review| { &m.authorName },
                |m: &mut Review| { &mut m.authorName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Review| { &m.url },
                |m: &mut Review| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &Review| { &m.source },
                |m: &mut Review| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "documentVersion",
                |m: &Review| { &m.documentVersion },
                |m: &mut Review| { &mut m.documentVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestampMsec",
                |m: &Review| { &m.timestampMsec },
                |m: &mut Review| { &mut m.timestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "starRating",
                |m: &Review| { &m.starRating },
                |m: &mut Review| { &mut m.starRating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Review| { &m.title },
                |m: &mut Review| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &Review| { &m.comment },
                |m: &mut Review| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "commentId",
                |m: &Review| { &m.commentId },
                |m: &mut Review| { &mut m.commentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceName",
                |m: &Review| { &m.deviceName },
                |m: &mut Review| { &mut m.deviceName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "replyText",
                |m: &Review| { &m.replyText },
                |m: &mut Review| { &mut m.replyText },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replyTimestampMsec",
                |m: &Review| { &m.replyTimestampMsec },
                |m: &mut Review| { &mut m.replyTimestampMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReviewAuthor>>(
                "author",
                |m: &Review| { &m.author },
                |m: &mut Review| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UserProfile>>(
                "userProfile",
                |m: &Review| { &m.userProfile },
                |m: &mut Review| { &mut m.userProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Review>(
                "Review",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Review {
        static instance: ::protobuf::rt::LazyV2<Review> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Review::new)
    }
}

impl ::protobuf::Clear for Review {
    fn clear(&mut self) {
        self.authorName.clear();
        self.url.clear();
        self.source.clear();
        self.documentVersion.clear();
        self.timestampMsec = ::std::option::Option::None;
        self.starRating = ::std::option::Option::None;
        self.title.clear();
        self.comment.clear();
        self.commentId.clear();
        self.deviceName.clear();
        self.replyText.clear();
        self.replyTimestampMsec = ::std::option::Option::None;
        self.author.clear();
        self.userProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Review {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Review {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReviewAuthor {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub avatar: ::protobuf::SingularPtrField<Image>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReviewAuthor {
    fn default() -> &'a ReviewAuthor {
        <ReviewAuthor as ::protobuf::Message>::default_instance()
    }
}

impl ReviewAuthor {
    pub fn new() -> ReviewAuthor {
        ::std::default::Default::default()
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Image avatar = 5;


    pub fn get_avatar(&self) -> &Image {
        self.avatar.as_ref().unwrap_or_else(|| <Image as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ReviewAuthor {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewAuthor {
        ReviewAuthor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ReviewAuthor| { &m.name },
                |m: &mut ReviewAuthor| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "avatar",
                |m: &ReviewAuthor| { &m.avatar },
                |m: &mut ReviewAuthor| { &mut m.avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReviewAuthor>(
                "ReviewAuthor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewAuthor {
        static instance: ::protobuf::rt::LazyV2<ReviewAuthor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReviewAuthor::new)
    }
}

impl ::protobuf::Clear for ReviewAuthor {
    fn clear(&mut self) {
        self.name.clear();
        self.avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewAuthor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewAuthor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UserProfile {
    // message fields
    pub personIdString: ::protobuf::SingularField<::std::string::String>,
    pub personId: ::protobuf::SingularField<::std::string::String>,
    pub unknown1: ::std::option::Option<i32>,
    pub unknown2: ::std::option::Option<i32>,
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub image: ::protobuf::RepeatedField<Image>,
    pub googlePlusUrl: ::protobuf::SingularField<::std::string::String>,
    pub googlePlusTagline: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserProfile {
    fn default() -> &'a UserProfile {
        <UserProfile as ::protobuf::Message>::default_instance()
    }
}

impl UserProfile {
    pub fn new() -> UserProfile {
        ::std::default::Default::default()
    }

    // optional string personIdString = 1;


    pub fn get_personIdString(&self) -> &str {
        match self.personIdString.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string personId = 2;


    pub fn get_personId(&self) -> &str {
        match self.personId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 unknown1 = 3;


    pub fn get_unknown1(&self) -> i32 {
        self.unknown1.unwrap_or(0)
    }

    // optional int32 unknown2 = 4;


    pub fn get_unknown2(&self) -> i32 {
        self.unknown2.unwrap_or(0)
    }

    // optional string name = 5;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .Image image = 10;


    pub fn get_image(&self) -> &[Image] {
        &self.image
    }

    // optional string googlePlusUrl = 19;


    pub fn get_googlePlusUrl(&self) -> &str {
        match self.googlePlusUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string googlePlusTagline = 22;


    pub fn get_googlePlusTagline(&self) -> &str {
        match self.googlePlusTagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UserProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.personIdString)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.personId)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknown2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.image)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.googlePlusUrl)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.googlePlusTagline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.personIdString.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.personId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.unknown1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unknown2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.image {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.googlePlusUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.googlePlusTagline.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.personIdString.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.personId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.unknown1 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.unknown2 {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.image {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.googlePlusUrl.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.googlePlusTagline.as_ref() {
            os.write_string(22, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserProfile {
        UserProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "personIdString",
                |m: &UserProfile| { &m.personIdString },
                |m: &mut UserProfile| { &mut m.personIdString },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "personId",
                |m: &UserProfile| { &m.personId },
                |m: &mut UserProfile| { &mut m.personId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown1",
                |m: &UserProfile| { &m.unknown1 },
                |m: &mut UserProfile| { &mut m.unknown1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown2",
                |m: &UserProfile| { &m.unknown2 },
                |m: &mut UserProfile| { &mut m.unknown2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserProfile| { &m.name },
                |m: &mut UserProfile| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Image>>(
                "image",
                |m: &UserProfile| { &m.image },
                |m: &mut UserProfile| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "googlePlusUrl",
                |m: &UserProfile| { &m.googlePlusUrl },
                |m: &mut UserProfile| { &mut m.googlePlusUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "googlePlusTagline",
                |m: &UserProfile| { &m.googlePlusTagline },
                |m: &mut UserProfile| { &mut m.googlePlusTagline },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserProfile>(
                "UserProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserProfile {
        static instance: ::protobuf::rt::LazyV2<UserProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserProfile::new)
    }
}

impl ::protobuf::Clear for UserProfile {
    fn clear(&mut self) {
        self.personIdString.clear();
        self.personId.clear();
        self.unknown1 = ::std::option::Option::None;
        self.unknown2 = ::std::option::Option::None;
        self.name.clear();
        self.image.clear();
        self.googlePlusUrl.clear();
        self.googlePlusTagline.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ReviewResponse {
    // message fields
    pub getResponse: ::protobuf::SingularPtrField<GetReviewsResponse>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    pub userReview: ::protobuf::SingularPtrField<Review>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReviewResponse {
    fn default() -> &'a ReviewResponse {
        <ReviewResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReviewResponse {
    pub fn new() -> ReviewResponse {
        ::std::default::Default::default()
    }

    // optional .GetReviewsResponse getResponse = 1;


    pub fn get_getResponse(&self) -> &GetReviewsResponse {
        self.getResponse.as_ref().unwrap_or_else(|| <GetReviewsResponse as ::protobuf::Message>::default_instance())
    }

    // optional string nextPageUrl = 2;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .Review userReview = 3;


    pub fn get_userReview(&self) -> &Review {
        self.userReview.as_ref().unwrap_or_else(|| <Review as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for ReviewResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.getResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReview {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getResponse)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.userReview)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.getResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.userReview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.getResponse.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.userReview.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReviewResponse {
        ReviewResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetReviewsResponse>>(
                "getResponse",
                |m: &ReviewResponse| { &m.getResponse },
                |m: &mut ReviewResponse| { &mut m.getResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &ReviewResponse| { &m.nextPageUrl },
                |m: &mut ReviewResponse| { &mut m.nextPageUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Review>>(
                "userReview",
                |m: &ReviewResponse| { &m.userReview },
                |m: &mut ReviewResponse| { &mut m.userReview },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReviewResponse>(
                "ReviewResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReviewResponse {
        static instance: ::protobuf::rt::LazyV2<ReviewResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReviewResponse::new)
    }
}

impl ::protobuf::Clear for ReviewResponse {
    fn clear(&mut self) {
        self.getResponse.clear();
        self.nextPageUrl.clear();
        self.userReview.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReviewResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReviewResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RelatedSearch {
    // message fields
    pub searchUrl: ::protobuf::SingularField<::std::string::String>,
    pub header: ::protobuf::SingularField<::std::string::String>,
    pub backendId: ::std::option::Option<i32>,
    pub docType: ::std::option::Option<i32>,
    pub current: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelatedSearch {
    fn default() -> &'a RelatedSearch {
        <RelatedSearch as ::protobuf::Message>::default_instance()
    }
}

impl RelatedSearch {
    pub fn new() -> RelatedSearch {
        ::std::default::Default::default()
    }

    // optional string searchUrl = 1;


    pub fn get_searchUrl(&self) -> &str {
        match self.searchUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string header = 2;


    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 backendId = 3;


    pub fn get_backendId(&self) -> i32 {
        self.backendId.unwrap_or(0)
    }

    // optional int32 docType = 4;


    pub fn get_docType(&self) -> i32 {
        self.docType.unwrap_or(0)
    }

    // optional bool current = 5;


    pub fn get_current(&self) -> bool {
        self.current.unwrap_or(false)
    }
}

impl ::protobuf::Message for RelatedSearch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.searchUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backendId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.docType = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.searchUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.backendId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.docType {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.searchUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.backendId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.docType {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.current {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedSearch {
        RelatedSearch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searchUrl",
                |m: &RelatedSearch| { &m.searchUrl },
                |m: &mut RelatedSearch| { &mut m.searchUrl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header",
                |m: &RelatedSearch| { &m.header },
                |m: &mut RelatedSearch| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backendId",
                |m: &RelatedSearch| { &m.backendId },
                |m: &mut RelatedSearch| { &mut m.backendId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "docType",
                |m: &RelatedSearch| { &m.docType },
                |m: &mut RelatedSearch| { &mut m.docType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "current",
                |m: &RelatedSearch| { &m.current },
                |m: &mut RelatedSearch| { &mut m.current },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelatedSearch>(
                "RelatedSearch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelatedSearch {
        static instance: ::protobuf::rt::LazyV2<RelatedSearch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelatedSearch::new)
    }
}

impl ::protobuf::Clear for RelatedSearch {
    fn clear(&mut self) {
        self.searchUrl.clear();
        self.header.clear();
        self.backendId = ::std::option::Option::None;
        self.docType = ::std::option::Option::None;
        self.current = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedSearch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedSearch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchResponse {
    // message fields
    pub originalQuery: ::protobuf::SingularField<::std::string::String>,
    pub suggestedQuery: ::protobuf::SingularField<::std::string::String>,
    pub aggregateQuery: ::std::option::Option<bool>,
    pub bucket: ::protobuf::RepeatedField<Bucket>,
    pub doc: ::protobuf::RepeatedField<DocV2>,
    pub relatedSearch: ::protobuf::RepeatedField<RelatedSearch>,
    pub nextPageUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchResponse {
    fn default() -> &'a SearchResponse {
        <SearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchResponse {
    pub fn new() -> SearchResponse {
        ::std::default::Default::default()
    }

    // optional string originalQuery = 1;


    pub fn get_originalQuery(&self) -> &str {
        match self.originalQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string suggestedQuery = 2;


    pub fn get_suggestedQuery(&self) -> &str {
        match self.suggestedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool aggregateQuery = 3;


    pub fn get_aggregateQuery(&self) -> bool {
        self.aggregateQuery.unwrap_or(false)
    }

    // repeated .Bucket bucket = 4;


    pub fn get_bucket(&self) -> &[Bucket] {
        &self.bucket
    }

    // repeated .DocV2 doc = 5;


    pub fn get_doc(&self) -> &[DocV2] {
        &self.doc
    }

    // repeated .RelatedSearch relatedSearch = 6;


    pub fn get_relatedSearch(&self) -> &[RelatedSearch] {
        &self.relatedSearch
    }

    // optional string nextPageUrl = 10;


    pub fn get_nextPageUrl(&self) -> &str {
        match self.nextPageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.doc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relatedSearch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.originalQuery)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suggestedQuery)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aggregateQuery = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bucket)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.doc)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relatedSearch)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nextPageUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.originalQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.aggregateQuery {
            my_size += 2;
        }
        for value in &self.bucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.doc {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relatedSearch {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.originalQuery.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.aggregateQuery {
            os.write_bool(3, v)?;
        }
        for v in &self.bucket {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.doc {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relatedSearch {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.nextPageUrl.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchResponse {
        SearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originalQuery",
                |m: &SearchResponse| { &m.originalQuery },
                |m: &mut SearchResponse| { &mut m.originalQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suggestedQuery",
                |m: &SearchResponse| { &m.suggestedQuery },
                |m: &mut SearchResponse| { &mut m.suggestedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "aggregateQuery",
                |m: &SearchResponse| { &m.aggregateQuery },
                |m: &mut SearchResponse| { &mut m.aggregateQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "bucket",
                |m: &SearchResponse| { &m.bucket },
                |m: &mut SearchResponse| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DocV2>>(
                "doc",
                |m: &SearchResponse| { &m.doc },
                |m: &mut SearchResponse| { &mut m.doc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelatedSearch>>(
                "relatedSearch",
                |m: &SearchResponse| { &m.relatedSearch },
                |m: &mut SearchResponse| { &mut m.relatedSearch },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nextPageUrl",
                |m: &SearchResponse| { &m.nextPageUrl },
                |m: &mut SearchResponse| { &mut m.nextPageUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchResponse>(
                "SearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchResponse {
        static instance: ::protobuf::rt::LazyV2<SearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchResponse::new)
    }
}

impl ::protobuf::Clear for SearchResponse {
    fn clear(&mut self) {
        self.originalQuery.clear();
        self.suggestedQuery.clear();
        self.aggregateQuery = ::std::option::Option::None;
        self.bucket.clear();
        self.doc.clear();
        self.relatedSearch.clear();
        self.nextPageUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchSuggestResponse {
    // message fields
    pub entry: ::protobuf::RepeatedField<SearchSuggestEntry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchSuggestResponse {
    fn default() -> &'a SearchSuggestResponse {
        <SearchSuggestResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchSuggestResponse {
    pub fn new() -> SearchSuggestResponse {
        ::std::default::Default::default()
    }

    // repeated .SearchSuggestEntry entry = 1;


    pub fn get_entry(&self) -> &[SearchSuggestEntry] {
        &self.entry
    }
}

impl ::protobuf::Message for SearchSuggestResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchSuggestResponse {
        SearchSuggestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchSuggestEntry>>(
                "entry",
                |m: &SearchSuggestResponse| { &m.entry },
                |m: &mut SearchSuggestResponse| { &mut m.entry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchSuggestResponse>(
                "SearchSuggestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchSuggestResponse {
        static instance: ::protobuf::rt::LazyV2<SearchSuggestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchSuggestResponse::new)
    }
}

impl ::protobuf::Clear for SearchSuggestResponse {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchSuggestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchSuggestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchSuggestEntry {
    // message fields
    pub field_type: ::std::option::Option<i32>,
    pub suggestedQuery: ::protobuf::SingularField<::std::string::String>,
    pub imageContainer: ::protobuf::SingularPtrField<SearchSuggestEntry_ImageContainer>,
    pub title: ::protobuf::SingularField<::std::string::String>,
    pub packageNameContainer: ::protobuf::SingularPtrField<SearchSuggestEntry_PackageNameContainer>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchSuggestEntry {
    fn default() -> &'a SearchSuggestEntry {
        <SearchSuggestEntry as ::protobuf::Message>::default_instance()
    }
}

impl SearchSuggestEntry {
    pub fn new() -> SearchSuggestEntry {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // optional string suggestedQuery = 2;


    pub fn get_suggestedQuery(&self) -> &str {
        match self.suggestedQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SearchSuggestEntry.ImageContainer imageContainer = 5;


    pub fn get_imageContainer(&self) -> &SearchSuggestEntry_ImageContainer {
        self.imageContainer.as_ref().unwrap_or_else(|| <SearchSuggestEntry_ImageContainer as ::protobuf::Message>::default_instance())
    }

    // optional string title = 6;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .SearchSuggestEntry.PackageNameContainer packageNameContainer = 8;


    pub fn get_packageNameContainer(&self) -> &SearchSuggestEntry_PackageNameContainer {
        self.packageNameContainer.as_ref().unwrap_or_else(|| <SearchSuggestEntry_PackageNameContainer as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for SearchSuggestEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.imageContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.packageNameContainer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suggestedQuery)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.imageContainer)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packageNameContainer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.imageContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.packageNameContainer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.suggestedQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.imageContainer.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.packageNameContainer.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchSuggestEntry {
        SearchSuggestEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &SearchSuggestEntry| { &m.field_type },
                |m: &mut SearchSuggestEntry| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "suggestedQuery",
                |m: &SearchSuggestEntry| { &m.suggestedQuery },
                |m: &mut SearchSuggestEntry| { &mut m.suggestedQuery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchSuggestEntry_ImageContainer>>(
                "imageContainer",
                |m: &SearchSuggestEntry| { &m.imageContainer },
                |m: &mut SearchSuggestEntry| { &mut m.imageContainer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &SearchSuggestEntry| { &m.title },
                |m: &mut SearchSuggestEntry| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchSuggestEntry_PackageNameContainer>>(
                "packageNameContainer",
                |m: &SearchSuggestEntry| { &m.packageNameContainer },
                |m: &mut SearchSuggestEntry| { &mut m.packageNameContainer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchSuggestEntry>(
                "SearchSuggestEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchSuggestEntry {
        static instance: ::protobuf::rt::LazyV2<SearchSuggestEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchSuggestEntry::new)
    }
}

impl ::protobuf::Clear for SearchSuggestEntry {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.suggestedQuery.clear();
        self.imageContainer.clear();
        self.title.clear();
        self.packageNameContainer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchSuggestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchSuggestEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchSuggestEntry_ImageContainer {
    // message fields
    pub imageUrl: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchSuggestEntry_ImageContainer {
    fn default() -> &'a SearchSuggestEntry_ImageContainer {
        <SearchSuggestEntry_ImageContainer as ::protobuf::Message>::default_instance()
    }
}

impl SearchSuggestEntry_ImageContainer {
    pub fn new() -> SearchSuggestEntry_ImageContainer {
        ::std::default::Default::default()
    }

    // optional string imageUrl = 5;


    pub fn get_imageUrl(&self) -> &str {
        match self.imageUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SearchSuggestEntry_ImageContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.imageUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.imageUrl.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchSuggestEntry_ImageContainer {
        SearchSuggestEntry_ImageContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imageUrl",
                |m: &SearchSuggestEntry_ImageContainer| { &m.imageUrl },
                |m: &mut SearchSuggestEntry_ImageContainer| { &mut m.imageUrl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchSuggestEntry_ImageContainer>(
                "SearchSuggestEntry.ImageContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchSuggestEntry_ImageContainer {
        static instance: ::protobuf::rt::LazyV2<SearchSuggestEntry_ImageContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchSuggestEntry_ImageContainer::new)
    }
}

impl ::protobuf::Clear for SearchSuggestEntry_ImageContainer {
    fn clear(&mut self) {
        self.imageUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchSuggestEntry_ImageContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchSuggestEntry_ImageContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct SearchSuggestEntry_PackageNameContainer {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchSuggestEntry_PackageNameContainer {
    fn default() -> &'a SearchSuggestEntry_PackageNameContainer {
        <SearchSuggestEntry_PackageNameContainer as ::protobuf::Message>::default_instance()
    }
}

impl SearchSuggestEntry_PackageNameContainer {
    pub fn new() -> SearchSuggestEntry_PackageNameContainer {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for SearchSuggestEntry_PackageNameContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchSuggestEntry_PackageNameContainer {
        SearchSuggestEntry_PackageNameContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &SearchSuggestEntry_PackageNameContainer| { &m.packageName },
                |m: &mut SearchSuggestEntry_PackageNameContainer| { &mut m.packageName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchSuggestEntry_PackageNameContainer>(
                "SearchSuggestEntry.PackageNameContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchSuggestEntry_PackageNameContainer {
        static instance: ::protobuf::rt::LazyV2<SearchSuggestEntry_PackageNameContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchSuggestEntry_PackageNameContainer::new)
    }
}

impl ::protobuf::Clear for SearchSuggestEntry_PackageNameContainer {
    fn clear(&mut self) {
        self.packageName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchSuggestEntry_PackageNameContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchSuggestEntry_PackageNameContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TestingProgramResponse {
    // message fields
    pub result: ::protobuf::SingularPtrField<TestingProgramResult>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestingProgramResponse {
    fn default() -> &'a TestingProgramResponse {
        <TestingProgramResponse as ::protobuf::Message>::default_instance()
    }
}

impl TestingProgramResponse {
    pub fn new() -> TestingProgramResponse {
        ::std::default::Default::default()
    }

    // optional .TestingProgramResult result = 2;


    pub fn get_result(&self) -> &TestingProgramResult {
        self.result.as_ref().unwrap_or_else(|| <TestingProgramResult as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for TestingProgramResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestingProgramResponse {
        TestingProgramResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestingProgramResult>>(
                "result",
                |m: &TestingProgramResponse| { &m.result },
                |m: &mut TestingProgramResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestingProgramResponse>(
                "TestingProgramResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestingProgramResponse {
        static instance: ::protobuf::rt::LazyV2<TestingProgramResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestingProgramResponse::new)
    }
}

impl ::protobuf::Clear for TestingProgramResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestingProgramResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingProgramResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TestingProgramResult {
    // message fields
    pub details: ::protobuf::SingularPtrField<TestingProgramDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestingProgramResult {
    fn default() -> &'a TestingProgramResult {
        <TestingProgramResult as ::protobuf::Message>::default_instance()
    }
}

impl TestingProgramResult {
    pub fn new() -> TestingProgramResult {
        ::std::default::Default::default()
    }

    // optional .TestingProgramDetails details = 4;


    pub fn get_details(&self) -> &TestingProgramDetails {
        self.details.as_ref().unwrap_or_else(|| <TestingProgramDetails as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for TestingProgramResult {
    fn is_initialized(&self) -> bool {
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestingProgramResult {
        TestingProgramResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TestingProgramDetails>>(
                "details",
                |m: &TestingProgramResult| { &m.details },
                |m: &mut TestingProgramResult| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestingProgramResult>(
                "TestingProgramResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestingProgramResult {
        static instance: ::protobuf::rt::LazyV2<TestingProgramResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestingProgramResult::new)
    }
}

impl ::protobuf::Clear for TestingProgramResult {
    fn clear(&mut self) {
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestingProgramResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingProgramResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TestingProgramDetails {
    // message fields
    pub flag1: ::std::option::Option<bool>,
    pub id: ::std::option::Option<i64>,
    pub unsubscribed: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestingProgramDetails {
    fn default() -> &'a TestingProgramDetails {
        <TestingProgramDetails as ::protobuf::Message>::default_instance()
    }
}

impl TestingProgramDetails {
    pub fn new() -> TestingProgramDetails {
        ::std::default::Default::default()
    }

    // optional bool flag1 = 2;


    pub fn get_flag1(&self) -> bool {
        self.flag1.unwrap_or(false)
    }

    // optional int64 id = 3;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // optional bool unsubscribed = 4;


    pub fn get_unsubscribed(&self) -> bool {
        self.unsubscribed.unwrap_or(false)
    }
}

impl ::protobuf::Message for TestingProgramDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flag1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unsubscribed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flag1 {
            my_size += 2;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unsubscribed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flag1 {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.id {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.unsubscribed {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestingProgramDetails {
        TestingProgramDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flag1",
                |m: &TestingProgramDetails| { &m.flag1 },
                |m: &mut TestingProgramDetails| { &mut m.flag1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &TestingProgramDetails| { &m.id },
                |m: &mut TestingProgramDetails| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unsubscribed",
                |m: &TestingProgramDetails| { &m.unsubscribed },
                |m: &mut TestingProgramDetails| { &mut m.unsubscribed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestingProgramDetails>(
                "TestingProgramDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestingProgramDetails {
        static instance: ::protobuf::rt::LazyV2<TestingProgramDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestingProgramDetails::new)
    }
}

impl ::protobuf::Clear for TestingProgramDetails {
    fn clear(&mut self) {
        self.flag1 = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.unsubscribed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestingProgramDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingProgramDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct LogRequest {
    // message fields
    pub timestamp: ::std::option::Option<i64>,
    pub downloadConfirmationQuery: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogRequest {
    fn default() -> &'a LogRequest {
        <LogRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogRequest {
    pub fn new() -> LogRequest {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional string downloadConfirmationQuery = 2;


    pub fn get_downloadConfirmationQuery(&self) -> &str {
        match self.downloadConfirmationQuery.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for LogRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.downloadConfirmationQuery)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.downloadConfirmationQuery.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.downloadConfirmationQuery.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRequest {
        LogRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &LogRequest| { &m.timestamp },
                |m: &mut LogRequest| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "downloadConfirmationQuery",
                |m: &LogRequest| { &m.downloadConfirmationQuery },
                |m: &mut LogRequest| { &mut m.downloadConfirmationQuery },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogRequest>(
                "LogRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogRequest {
        static instance: ::protobuf::rt::LazyV2<LogRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogRequest::new)
    }
}

impl ::protobuf::Clear for LogRequest {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.downloadConfirmationQuery.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TestingProgramRequest {
    // message fields
    pub packageName: ::protobuf::SingularField<::std::string::String>,
    pub subscribe: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestingProgramRequest {
    fn default() -> &'a TestingProgramRequest {
        <TestingProgramRequest as ::protobuf::Message>::default_instance()
    }
}

impl TestingProgramRequest {
    pub fn new() -> TestingProgramRequest {
        ::std::default::Default::default()
    }

    // optional string packageName = 1;


    pub fn get_packageName(&self) -> &str {
        match self.packageName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool subscribe = 2;


    pub fn get_subscribe(&self) -> bool {
        self.subscribe.unwrap_or(false)
    }
}

impl ::protobuf::Message for TestingProgramRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.packageName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subscribe = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packageName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subscribe {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packageName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.subscribe {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestingProgramRequest {
        TestingProgramRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "packageName",
                |m: &TestingProgramRequest| { &m.packageName },
                |m: &mut TestingProgramRequest| { &mut m.packageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "subscribe",
                |m: &TestingProgramRequest| { &m.subscribe },
                |m: &mut TestingProgramRequest| { &mut m.subscribe },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestingProgramRequest>(
                "TestingProgramRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestingProgramRequest {
        static instance: ::protobuf::rt::LazyV2<TestingProgramRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestingProgramRequest::new)
    }
}

impl ::protobuf::Clear for TestingProgramRequest {
    fn clear(&mut self) {
        self.packageName.clear();
        self.subscribe = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestingProgramRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingProgramRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UploadDeviceConfigRequest {
    // message fields
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub manufacturer: ::protobuf::SingularField<::std::string::String>,
    pub gcmRegistrationId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadDeviceConfigRequest {
    fn default() -> &'a UploadDeviceConfigRequest {
        <UploadDeviceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadDeviceConfigRequest {
    pub fn new() -> UploadDeviceConfigRequest {
        ::std::default::Default::default()
    }

    // optional .DeviceConfigurationProto deviceConfiguration = 1;


    pub fn get_deviceConfiguration(&self) -> &DeviceConfigurationProto {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfigurationProto as ::protobuf::Message>::default_instance())
    }

    // optional string manufacturer = 2;


    pub fn get_manufacturer(&self) -> &str {
        match self.manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string gcmRegistrationId = 3;


    pub fn get_gcmRegistrationId(&self) -> &str {
        match self.gcmRegistrationId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceConfiguration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gcmRegistrationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.gcmRegistrationId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.gcmRegistrationId.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigRequest {
        UploadDeviceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>>(
                "deviceConfiguration",
                |m: &UploadDeviceConfigRequest| { &m.deviceConfiguration },
                |m: &mut UploadDeviceConfigRequest| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer",
                |m: &UploadDeviceConfigRequest| { &m.manufacturer },
                |m: &mut UploadDeviceConfigRequest| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gcmRegistrationId",
                |m: &UploadDeviceConfigRequest| { &m.gcmRegistrationId },
                |m: &mut UploadDeviceConfigRequest| { &mut m.gcmRegistrationId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadDeviceConfigRequest>(
                "UploadDeviceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<UploadDeviceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadDeviceConfigRequest::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigRequest {
    fn clear(&mut self) {
        self.deviceConfiguration.clear();
        self.manufacturer.clear();
        self.gcmRegistrationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UploadDeviceConfigResponse {
    // message fields
    pub uploadDeviceConfigToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadDeviceConfigResponse {
    fn default() -> &'a UploadDeviceConfigResponse {
        <UploadDeviceConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadDeviceConfigResponse {
    pub fn new() -> UploadDeviceConfigResponse {
        ::std::default::Default::default()
    }

    // optional string uploadDeviceConfigToken = 1;


    pub fn get_uploadDeviceConfigToken(&self) -> &str {
        match self.uploadDeviceConfigToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for UploadDeviceConfigResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uploadDeviceConfigToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uploadDeviceConfigToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uploadDeviceConfigToken.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadDeviceConfigResponse {
        UploadDeviceConfigResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uploadDeviceConfigToken",
                |m: &UploadDeviceConfigResponse| { &m.uploadDeviceConfigToken },
                |m: &mut UploadDeviceConfigResponse| { &mut m.uploadDeviceConfigToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UploadDeviceConfigResponse>(
                "UploadDeviceConfigResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UploadDeviceConfigResponse {
        static instance: ::protobuf::rt::LazyV2<UploadDeviceConfigResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UploadDeviceConfigResponse::new)
    }
}

impl ::protobuf::Clear for UploadDeviceConfigResponse {
    fn clear(&mut self) {
        self.uploadDeviceConfigToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadDeviceConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadDeviceConfigResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidCheckinRequest {
    // message fields
    pub imei: ::protobuf::SingularField<::std::string::String>,
    pub id: ::std::option::Option<i64>,
    pub digest: ::protobuf::SingularField<::std::string::String>,
    pub checkin: ::protobuf::SingularPtrField<AndroidCheckinProto>,
    pub desiredBuild: ::protobuf::SingularField<::std::string::String>,
    pub locale: ::protobuf::SingularField<::std::string::String>,
    pub loggingId: ::std::option::Option<i64>,
    pub marketCheckin: ::protobuf::SingularField<::std::string::String>,
    pub macAddr: ::protobuf::RepeatedField<::std::string::String>,
    pub meid: ::protobuf::SingularField<::std::string::String>,
    pub accountCookie: ::protobuf::RepeatedField<::std::string::String>,
    pub timeZone: ::protobuf::SingularField<::std::string::String>,
    pub securityToken: ::std::option::Option<u64>,
    pub version: ::std::option::Option<i32>,
    pub otaCert: ::protobuf::RepeatedField<::std::string::String>,
    pub serialNumber: ::protobuf::SingularField<::std::string::String>,
    pub esn: ::protobuf::SingularField<::std::string::String>,
    pub deviceConfiguration: ::protobuf::SingularPtrField<DeviceConfigurationProto>,
    pub macAddrType: ::protobuf::RepeatedField<::std::string::String>,
    pub fragment: ::std::option::Option<i32>,
    pub userName: ::protobuf::SingularField<::std::string::String>,
    pub userSerialNumber: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidCheckinRequest {
    fn default() -> &'a AndroidCheckinRequest {
        <AndroidCheckinRequest as ::protobuf::Message>::default_instance()
    }
}

impl AndroidCheckinRequest {
    pub fn new() -> AndroidCheckinRequest {
        ::std::default::Default::default()
    }

    // optional string imei = 1;


    pub fn get_imei(&self) -> &str {
        match self.imei.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 id = 2;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    // optional string digest = 3;


    pub fn get_digest(&self) -> &str {
        match self.digest.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .AndroidCheckinProto checkin = 4;


    pub fn get_checkin(&self) -> &AndroidCheckinProto {
        self.checkin.as_ref().unwrap_or_else(|| <AndroidCheckinProto as ::protobuf::Message>::default_instance())
    }

    // optional string desiredBuild = 5;


    pub fn get_desiredBuild(&self) -> &str {
        match self.desiredBuild.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string locale = 6;


    pub fn get_locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 loggingId = 7;


    pub fn get_loggingId(&self) -> i64 {
        self.loggingId.unwrap_or(0)
    }

    // optional string marketCheckin = 8;


    pub fn get_marketCheckin(&self) -> &str {
        match self.marketCheckin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string macAddr = 9;


    pub fn get_macAddr(&self) -> &[::std::string::String] {
        &self.macAddr
    }

    // optional string meid = 10;


    pub fn get_meid(&self) -> &str {
        match self.meid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string accountCookie = 11;


    pub fn get_accountCookie(&self) -> &[::std::string::String] {
        &self.accountCookie
    }

    // optional string timeZone = 12;


    pub fn get_timeZone(&self) -> &str {
        match self.timeZone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 securityToken = 13;


    pub fn get_securityToken(&self) -> u64 {
        self.securityToken.unwrap_or(0)
    }

    // optional int32 version = 14;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // repeated string otaCert = 15;


    pub fn get_otaCert(&self) -> &[::std::string::String] {
        &self.otaCert
    }

    // optional string serialNumber = 16;


    pub fn get_serialNumber(&self) -> &str {
        match self.serialNumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string esn = 17;


    pub fn get_esn(&self) -> &str {
        match self.esn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .DeviceConfigurationProto deviceConfiguration = 18;


    pub fn get_deviceConfiguration(&self) -> &DeviceConfigurationProto {
        self.deviceConfiguration.as_ref().unwrap_or_else(|| <DeviceConfigurationProto as ::protobuf::Message>::default_instance())
    }

    // repeated string macAddrType = 19;


    pub fn get_macAddrType(&self) -> &[::std::string::String] {
        &self.macAddrType
    }

    // optional int32 fragment = 20;


    pub fn get_fragment(&self) -> i32 {
        self.fragment.unwrap_or(0)
    }

    // optional string userName = 21;


    pub fn get_userName(&self) -> &str {
        match self.userName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 userSerialNumber = 22;


    pub fn get_userSerialNumber(&self) -> i32 {
        self.userSerialNumber.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidCheckinRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.checkin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deviceConfiguration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imei)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.digest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkin)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desiredBuild)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.locale)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.loggingId = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.marketCheckin)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.macAddr)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.meid)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accountCookie)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.timeZone)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.securityToken = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.otaCert)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serialNumber)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.esn)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deviceConfiguration)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.macAddrType)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fragment = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userName)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userSerialNumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.imei.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.checkin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desiredBuild.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.loggingId {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.marketCheckin.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.macAddr {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(ref v) = self.meid.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.accountCookie {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.timeZone.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.securityToken {
            my_size += 9;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.otaCert {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(ref v) = self.serialNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.esn.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.macAddrType {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(v) = self.fragment {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.userName.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.userSerialNumber {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.imei.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.id {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.digest.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.checkin.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desiredBuild.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.locale.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.loggingId {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.marketCheckin.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.macAddr {
            os.write_string(9, &v)?;
        };
        if let Some(ref v) = self.meid.as_ref() {
            os.write_string(10, &v)?;
        }
        for v in &self.accountCookie {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.timeZone.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.securityToken {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(14, v)?;
        }
        for v in &self.otaCert {
            os.write_string(15, &v)?;
        };
        if let Some(ref v) = self.serialNumber.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.esn.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.deviceConfiguration.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.macAddrType {
            os.write_string(19, &v)?;
        };
        if let Some(v) = self.fragment {
            os.write_int32(20, v)?;
        }
        if let Some(ref v) = self.userName.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.userSerialNumber {
            os.write_int32(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidCheckinRequest {
        AndroidCheckinRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imei",
                |m: &AndroidCheckinRequest| { &m.imei },
                |m: &mut AndroidCheckinRequest| { &mut m.imei },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &AndroidCheckinRequest| { &m.id },
                |m: &mut AndroidCheckinRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "digest",
                |m: &AndroidCheckinRequest| { &m.digest },
                |m: &mut AndroidCheckinRequest| { &mut m.digest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidCheckinProto>>(
                "checkin",
                |m: &AndroidCheckinRequest| { &m.checkin },
                |m: &mut AndroidCheckinRequest| { &mut m.checkin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desiredBuild",
                |m: &AndroidCheckinRequest| { &m.desiredBuild },
                |m: &mut AndroidCheckinRequest| { &mut m.desiredBuild },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locale",
                |m: &AndroidCheckinRequest| { &m.locale },
                |m: &mut AndroidCheckinRequest| { &mut m.locale },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "loggingId",
                |m: &AndroidCheckinRequest| { &m.loggingId },
                |m: &mut AndroidCheckinRequest| { &mut m.loggingId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "marketCheckin",
                |m: &AndroidCheckinRequest| { &m.marketCheckin },
                |m: &mut AndroidCheckinRequest| { &mut m.marketCheckin },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "macAddr",
                |m: &AndroidCheckinRequest| { &m.macAddr },
                |m: &mut AndroidCheckinRequest| { &mut m.macAddr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "meid",
                |m: &AndroidCheckinRequest| { &m.meid },
                |m: &mut AndroidCheckinRequest| { &mut m.meid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountCookie",
                |m: &AndroidCheckinRequest| { &m.accountCookie },
                |m: &mut AndroidCheckinRequest| { &mut m.accountCookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "timeZone",
                |m: &AndroidCheckinRequest| { &m.timeZone },
                |m: &mut AndroidCheckinRequest| { &mut m.timeZone },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "securityToken",
                |m: &AndroidCheckinRequest| { &m.securityToken },
                |m: &mut AndroidCheckinRequest| { &mut m.securityToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &AndroidCheckinRequest| { &m.version },
                |m: &mut AndroidCheckinRequest| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otaCert",
                |m: &AndroidCheckinRequest| { &m.otaCert },
                |m: &mut AndroidCheckinRequest| { &mut m.otaCert },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serialNumber",
                |m: &AndroidCheckinRequest| { &m.serialNumber },
                |m: &mut AndroidCheckinRequest| { &mut m.serialNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "esn",
                |m: &AndroidCheckinRequest| { &m.esn },
                |m: &mut AndroidCheckinRequest| { &mut m.esn },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceConfigurationProto>>(
                "deviceConfiguration",
                |m: &AndroidCheckinRequest| { &m.deviceConfiguration },
                |m: &mut AndroidCheckinRequest| { &mut m.deviceConfiguration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "macAddrType",
                |m: &AndroidCheckinRequest| { &m.macAddrType },
                |m: &mut AndroidCheckinRequest| { &mut m.macAddrType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fragment",
                |m: &AndroidCheckinRequest| { &m.fragment },
                |m: &mut AndroidCheckinRequest| { &mut m.fragment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userName",
                |m: &AndroidCheckinRequest| { &m.userName },
                |m: &mut AndroidCheckinRequest| { &mut m.userName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userSerialNumber",
                |m: &AndroidCheckinRequest| { &m.userSerialNumber },
                |m: &mut AndroidCheckinRequest| { &mut m.userSerialNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidCheckinRequest>(
                "AndroidCheckinRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidCheckinRequest {
        static instance: ::protobuf::rt::LazyV2<AndroidCheckinRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidCheckinRequest::new)
    }
}

impl ::protobuf::Clear for AndroidCheckinRequest {
    fn clear(&mut self) {
        self.imei.clear();
        self.id = ::std::option::Option::None;
        self.digest.clear();
        self.checkin.clear();
        self.desiredBuild.clear();
        self.locale.clear();
        self.loggingId = ::std::option::Option::None;
        self.marketCheckin.clear();
        self.macAddr.clear();
        self.meid.clear();
        self.accountCookie.clear();
        self.timeZone.clear();
        self.securityToken = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.otaCert.clear();
        self.serialNumber.clear();
        self.esn.clear();
        self.deviceConfiguration.clear();
        self.macAddrType.clear();
        self.fragment = ::std::option::Option::None;
        self.userName.clear();
        self.userSerialNumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidCheckinRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidCheckinRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidCheckinResponse {
    // message fields
    pub statsOk: ::std::option::Option<bool>,
    pub intent: ::protobuf::RepeatedField<AndroidIntentProto>,
    pub timeMsec: ::std::option::Option<i64>,
    pub digest: ::protobuf::SingularField<::std::string::String>,
    pub setting: ::protobuf::RepeatedField<GservicesSetting>,
    pub marketOk: ::std::option::Option<bool>,
    pub androidId: ::std::option::Option<u64>,
    pub securityToken: ::std::option::Option<u64>,
    pub settingsDiff: ::std::option::Option<bool>,
    pub deleteSetting: ::protobuf::RepeatedField<::std::string::String>,
    pub deviceCheckinConsistencyToken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidCheckinResponse {
    fn default() -> &'a AndroidCheckinResponse {
        <AndroidCheckinResponse as ::protobuf::Message>::default_instance()
    }
}

impl AndroidCheckinResponse {
    pub fn new() -> AndroidCheckinResponse {
        ::std::default::Default::default()
    }

    // optional bool statsOk = 1;


    pub fn get_statsOk(&self) -> bool {
        self.statsOk.unwrap_or(false)
    }

    // repeated .AndroidIntentProto intent = 2;


    pub fn get_intent(&self) -> &[AndroidIntentProto] {
        &self.intent
    }

    // optional int64 timeMsec = 3;


    pub fn get_timeMsec(&self) -> i64 {
        self.timeMsec.unwrap_or(0)
    }

    // optional string digest = 4;


    pub fn get_digest(&self) -> &str {
        match self.digest.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .GservicesSetting setting = 5;


    pub fn get_setting(&self) -> &[GservicesSetting] {
        &self.setting
    }

    // optional bool marketOk = 6;


    pub fn get_marketOk(&self) -> bool {
        self.marketOk.unwrap_or(false)
    }

    // optional fixed64 androidId = 7;


    pub fn get_androidId(&self) -> u64 {
        self.androidId.unwrap_or(0)
    }

    // optional fixed64 securityToken = 8;


    pub fn get_securityToken(&self) -> u64 {
        self.securityToken.unwrap_or(0)
    }

    // optional bool settingsDiff = 9;


    pub fn get_settingsDiff(&self) -> bool {
        self.settingsDiff.unwrap_or(false)
    }

    // repeated string deleteSetting = 10;


    pub fn get_deleteSetting(&self) -> &[::std::string::String] {
        &self.deleteSetting
    }

    // optional string deviceCheckinConsistencyToken = 12;


    pub fn get_deviceCheckinConsistencyToken(&self) -> &str {
        match self.deviceCheckinConsistencyToken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidCheckinResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.intent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.setting {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.statsOk = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.intent)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeMsec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.digest)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.setting)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.marketOk = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.securityToken = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.settingsDiff = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.deleteSetting)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deviceCheckinConsistencyToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.statsOk {
            my_size += 2;
        }
        for value in &self.intent {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.timeMsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.setting {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.marketOk {
            my_size += 2;
        }
        if let Some(v) = self.androidId {
            my_size += 9;
        }
        if let Some(v) = self.securityToken {
            my_size += 9;
        }
        if let Some(v) = self.settingsDiff {
            my_size += 2;
        }
        for value in &self.deleteSetting {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.deviceCheckinConsistencyToken.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.statsOk {
            os.write_bool(1, v)?;
        }
        for v in &self.intent {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.timeMsec {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.digest.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.setting {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.marketOk {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.androidId {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.securityToken {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.settingsDiff {
            os.write_bool(9, v)?;
        }
        for v in &self.deleteSetting {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.deviceCheckinConsistencyToken.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidCheckinResponse {
        AndroidCheckinResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "statsOk",
                |m: &AndroidCheckinResponse| { &m.statsOk },
                |m: &mut AndroidCheckinResponse| { &mut m.statsOk },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidIntentProto>>(
                "intent",
                |m: &AndroidCheckinResponse| { &m.intent },
                |m: &mut AndroidCheckinResponse| { &mut m.intent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeMsec",
                |m: &AndroidCheckinResponse| { &m.timeMsec },
                |m: &mut AndroidCheckinResponse| { &mut m.timeMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "digest",
                |m: &AndroidCheckinResponse| { &m.digest },
                |m: &mut AndroidCheckinResponse| { &mut m.digest },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GservicesSetting>>(
                "setting",
                |m: &AndroidCheckinResponse| { &m.setting },
                |m: &mut AndroidCheckinResponse| { &mut m.setting },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "marketOk",
                |m: &AndroidCheckinResponse| { &m.marketOk },
                |m: &mut AndroidCheckinResponse| { &mut m.marketOk },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "androidId",
                |m: &AndroidCheckinResponse| { &m.androidId },
                |m: &mut AndroidCheckinResponse| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "securityToken",
                |m: &AndroidCheckinResponse| { &m.securityToken },
                |m: &mut AndroidCheckinResponse| { &mut m.securityToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "settingsDiff",
                |m: &AndroidCheckinResponse| { &m.settingsDiff },
                |m: &mut AndroidCheckinResponse| { &mut m.settingsDiff },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deleteSetting",
                |m: &AndroidCheckinResponse| { &m.deleteSetting },
                |m: &mut AndroidCheckinResponse| { &mut m.deleteSetting },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deviceCheckinConsistencyToken",
                |m: &AndroidCheckinResponse| { &m.deviceCheckinConsistencyToken },
                |m: &mut AndroidCheckinResponse| { &mut m.deviceCheckinConsistencyToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidCheckinResponse>(
                "AndroidCheckinResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidCheckinResponse {
        static instance: ::protobuf::rt::LazyV2<AndroidCheckinResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidCheckinResponse::new)
    }
}

impl ::protobuf::Clear for AndroidCheckinResponse {
    fn clear(&mut self) {
        self.statsOk = ::std::option::Option::None;
        self.intent.clear();
        self.timeMsec = ::std::option::Option::None;
        self.digest.clear();
        self.setting.clear();
        self.marketOk = ::std::option::Option::None;
        self.androidId = ::std::option::Option::None;
        self.securityToken = ::std::option::Option::None;
        self.settingsDiff = ::std::option::Option::None;
        self.deleteSetting.clear();
        self.deviceCheckinConsistencyToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidCheckinResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidCheckinResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct GservicesSetting {
    // message fields
    pub name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GservicesSetting {
    fn default() -> &'a GservicesSetting {
        <GservicesSetting as ::protobuf::Message>::default_instance()
    }
}

impl GservicesSetting {
    pub fn new() -> GservicesSetting {
        ::std::default::Default::default()
    }

    // optional bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for GservicesSetting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GservicesSetting {
        GservicesSetting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &GservicesSetting| { &m.name },
                |m: &mut GservicesSetting| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &GservicesSetting| { &m.value },
                |m: &mut GservicesSetting| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GservicesSetting>(
                "GservicesSetting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GservicesSetting {
        static instance: ::protobuf::rt::LazyV2<GservicesSetting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GservicesSetting::new)
    }
}

impl ::protobuf::Clear for GservicesSetting {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GservicesSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GservicesSetting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidBuildProto {
    // message fields
    pub id: ::protobuf::SingularField<::std::string::String>,
    pub product: ::protobuf::SingularField<::std::string::String>,
    pub carrier: ::protobuf::SingularField<::std::string::String>,
    pub radio: ::protobuf::SingularField<::std::string::String>,
    pub bootloader: ::protobuf::SingularField<::std::string::String>,
    pub client: ::protobuf::SingularField<::std::string::String>,
    pub timestamp: ::std::option::Option<i64>,
    pub googleServices: ::std::option::Option<i32>,
    pub device: ::protobuf::SingularField<::std::string::String>,
    pub sdkVersion: ::std::option::Option<i32>,
    pub model: ::protobuf::SingularField<::std::string::String>,
    pub manufacturer: ::protobuf::SingularField<::std::string::String>,
    pub buildProduct: ::protobuf::SingularField<::std::string::String>,
    pub otaInstalled: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidBuildProto {
    fn default() -> &'a AndroidBuildProto {
        <AndroidBuildProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidBuildProto {
    pub fn new() -> AndroidBuildProto {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string product = 2;


    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string carrier = 3;


    pub fn get_carrier(&self) -> &str {
        match self.carrier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string radio = 4;


    pub fn get_radio(&self) -> &str {
        match self.radio.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string bootloader = 5;


    pub fn get_bootloader(&self) -> &str {
        match self.bootloader.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string client = 6;


    pub fn get_client(&self) -> &str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 timestamp = 7;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    // optional int32 googleServices = 8;


    pub fn get_googleServices(&self) -> i32 {
        self.googleServices.unwrap_or(0)
    }

    // optional string device = 9;


    pub fn get_device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 sdkVersion = 10;


    pub fn get_sdkVersion(&self) -> i32 {
        self.sdkVersion.unwrap_or(0)
    }

    // optional string model = 11;


    pub fn get_model(&self) -> &str {
        match self.model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string manufacturer = 12;


    pub fn get_manufacturer(&self) -> &str {
        match self.manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string buildProduct = 13;


    pub fn get_buildProduct(&self) -> &str {
        match self.buildProduct.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool otaInstalled = 14;


    pub fn get_otaInstalled(&self) -> bool {
        self.otaInstalled.unwrap_or(false)
    }
}

impl ::protobuf::Message for AndroidBuildProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.carrier)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.radio)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bootloader)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.googleServices = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdkVersion = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.model)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.manufacturer)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buildProduct)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.otaInstalled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.carrier.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.radio.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.bootloader.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.client.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.googleServices {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.sdkVersion {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.model.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.buildProduct.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.otaInstalled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.product.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.carrier.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.radio.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.bootloader.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.googleServices {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.device.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.sdkVersion {
            os.write_int32(10, v)?;
        }
        if let Some(ref v) = self.model.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.manufacturer.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.buildProduct.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.otaInstalled {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidBuildProto {
        AndroidBuildProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &AndroidBuildProto| { &m.id },
                |m: &mut AndroidBuildProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &AndroidBuildProto| { &m.product },
                |m: &mut AndroidBuildProto| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "carrier",
                |m: &AndroidBuildProto| { &m.carrier },
                |m: &mut AndroidBuildProto| { &mut m.carrier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "radio",
                |m: &AndroidBuildProto| { &m.radio },
                |m: &mut AndroidBuildProto| { &mut m.radio },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bootloader",
                |m: &AndroidBuildProto| { &m.bootloader },
                |m: &mut AndroidBuildProto| { &mut m.bootloader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client",
                |m: &AndroidBuildProto| { &m.client },
                |m: &mut AndroidBuildProto| { &mut m.client },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &AndroidBuildProto| { &m.timestamp },
                |m: &mut AndroidBuildProto| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "googleServices",
                |m: &AndroidBuildProto| { &m.googleServices },
                |m: &mut AndroidBuildProto| { &mut m.googleServices },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &AndroidBuildProto| { &m.device },
                |m: &mut AndroidBuildProto| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdkVersion",
                |m: &AndroidBuildProto| { &m.sdkVersion },
                |m: &mut AndroidBuildProto| { &mut m.sdkVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &AndroidBuildProto| { &m.model },
                |m: &mut AndroidBuildProto| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manufacturer",
                |m: &AndroidBuildProto| { &m.manufacturer },
                |m: &mut AndroidBuildProto| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "buildProduct",
                |m: &AndroidBuildProto| { &m.buildProduct },
                |m: &mut AndroidBuildProto| { &mut m.buildProduct },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "otaInstalled",
                |m: &AndroidBuildProto| { &m.otaInstalled },
                |m: &mut AndroidBuildProto| { &mut m.otaInstalled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidBuildProto>(
                "AndroidBuildProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidBuildProto {
        static instance: ::protobuf::rt::LazyV2<AndroidBuildProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidBuildProto::new)
    }
}

impl ::protobuf::Clear for AndroidBuildProto {
    fn clear(&mut self) {
        self.id.clear();
        self.product.clear();
        self.carrier.clear();
        self.radio.clear();
        self.bootloader.clear();
        self.client.clear();
        self.timestamp = ::std::option::Option::None;
        self.googleServices = ::std::option::Option::None;
        self.device.clear();
        self.sdkVersion = ::std::option::Option::None;
        self.model.clear();
        self.manufacturer.clear();
        self.buildProduct.clear();
        self.otaInstalled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidBuildProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidBuildProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidCheckinProto {
    // message fields
    pub build: ::protobuf::SingularPtrField<AndroidBuildProto>,
    pub lastCheckinMsec: ::std::option::Option<i64>,
    pub event: ::protobuf::RepeatedField<AndroidEventProto>,
    pub stat: ::protobuf::RepeatedField<AndroidStatisticProto>,
    pub requestedGroup: ::protobuf::RepeatedField<::std::string::String>,
    pub cellOperator: ::protobuf::SingularField<::std::string::String>,
    pub simOperator: ::protobuf::SingularField<::std::string::String>,
    pub roaming: ::protobuf::SingularField<::std::string::String>,
    pub userNumber: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidCheckinProto {
    fn default() -> &'a AndroidCheckinProto {
        <AndroidCheckinProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidCheckinProto {
    pub fn new() -> AndroidCheckinProto {
        ::std::default::Default::default()
    }

    // optional .AndroidBuildProto build = 1;


    pub fn get_build(&self) -> &AndroidBuildProto {
        self.build.as_ref().unwrap_or_else(|| <AndroidBuildProto as ::protobuf::Message>::default_instance())
    }

    // optional int64 lastCheckinMsec = 2;


    pub fn get_lastCheckinMsec(&self) -> i64 {
        self.lastCheckinMsec.unwrap_or(0)
    }

    // repeated .AndroidEventProto event = 3;


    pub fn get_event(&self) -> &[AndroidEventProto] {
        &self.event
    }

    // repeated .AndroidStatisticProto stat = 4;


    pub fn get_stat(&self) -> &[AndroidStatisticProto] {
        &self.stat
    }

    // repeated string requestedGroup = 5;


    pub fn get_requestedGroup(&self) -> &[::std::string::String] {
        &self.requestedGroup
    }

    // optional string cellOperator = 6;


    pub fn get_cellOperator(&self) -> &str {
        match self.cellOperator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string simOperator = 7;


    pub fn get_simOperator(&self) -> &str {
        match self.simOperator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string roaming = 8;


    pub fn get_roaming(&self) -> &str {
        match self.roaming.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 userNumber = 9;


    pub fn get_userNumber(&self) -> i32 {
        self.userNumber.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidCheckinProto {
    fn is_initialized(&self) -> bool {
        for v in &self.build {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.build)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastCheckinMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.requestedGroup)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cellOperator)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simOperator)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.roaming)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userNumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.build.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.lastCheckinMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.requestedGroup {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.cellOperator.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.simOperator.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.roaming.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.userNumber {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.build.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.lastCheckinMsec {
            os.write_int64(2, v)?;
        }
        for v in &self.event {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stat {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.requestedGroup {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.cellOperator.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.simOperator.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.roaming.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.userNumber {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidCheckinProto {
        AndroidCheckinProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidBuildProto>>(
                "build",
                |m: &AndroidCheckinProto| { &m.build },
                |m: &mut AndroidCheckinProto| { &mut m.build },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastCheckinMsec",
                |m: &AndroidCheckinProto| { &m.lastCheckinMsec },
                |m: &mut AndroidCheckinProto| { &mut m.lastCheckinMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidEventProto>>(
                "event",
                |m: &AndroidCheckinProto| { &m.event },
                |m: &mut AndroidCheckinProto| { &mut m.event },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidStatisticProto>>(
                "stat",
                |m: &AndroidCheckinProto| { &m.stat },
                |m: &mut AndroidCheckinProto| { &mut m.stat },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "requestedGroup",
                |m: &AndroidCheckinProto| { &m.requestedGroup },
                |m: &mut AndroidCheckinProto| { &mut m.requestedGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cellOperator",
                |m: &AndroidCheckinProto| { &m.cellOperator },
                |m: &mut AndroidCheckinProto| { &mut m.cellOperator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "simOperator",
                |m: &AndroidCheckinProto| { &m.simOperator },
                |m: &mut AndroidCheckinProto| { &mut m.simOperator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "roaming",
                |m: &AndroidCheckinProto| { &m.roaming },
                |m: &mut AndroidCheckinProto| { &mut m.roaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userNumber",
                |m: &AndroidCheckinProto| { &m.userNumber },
                |m: &mut AndroidCheckinProto| { &mut m.userNumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidCheckinProto>(
                "AndroidCheckinProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidCheckinProto {
        static instance: ::protobuf::rt::LazyV2<AndroidCheckinProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidCheckinProto::new)
    }
}

impl ::protobuf::Clear for AndroidCheckinProto {
    fn clear(&mut self) {
        self.build.clear();
        self.lastCheckinMsec = ::std::option::Option::None;
        self.event.clear();
        self.stat.clear();
        self.requestedGroup.clear();
        self.cellOperator.clear();
        self.simOperator.clear();
        self.roaming.clear();
        self.userNumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidCheckinProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidCheckinProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidEventProto {
    // message fields
    pub tag: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    pub timeMsec: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidEventProto {
    fn default() -> &'a AndroidEventProto {
        <AndroidEventProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidEventProto {
    pub fn new() -> AndroidEventProto {
        ::std::default::Default::default()
    }

    // optional string tag = 1;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 timeMsec = 3;


    pub fn get_timeMsec(&self) -> i64 {
        self.timeMsec.unwrap_or(0)
    }
}

impl ::protobuf::Message for AndroidEventProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeMsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timeMsec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.timeMsec {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidEventProto {
        AndroidEventProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &AndroidEventProto| { &m.tag },
                |m: &mut AndroidEventProto| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &AndroidEventProto| { &m.value },
                |m: &mut AndroidEventProto| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeMsec",
                |m: &AndroidEventProto| { &m.timeMsec },
                |m: &mut AndroidEventProto| { &mut m.timeMsec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidEventProto>(
                "AndroidEventProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidEventProto {
        static instance: ::protobuf::rt::LazyV2<AndroidEventProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidEventProto::new)
    }
}

impl ::protobuf::Clear for AndroidEventProto {
    fn clear(&mut self) {
        self.tag.clear();
        self.value.clear();
        self.timeMsec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidEventProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidEventProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidIntentProto {
    // message fields
    pub action: ::protobuf::SingularField<::std::string::String>,
    pub dataUri: ::protobuf::SingularField<::std::string::String>,
    pub mimeType: ::protobuf::SingularField<::std::string::String>,
    pub javaClass: ::protobuf::SingularField<::std::string::String>,
    // extra: <group>
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidIntentProto {
    fn default() -> &'a AndroidIntentProto {
        <AndroidIntentProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidIntentProto {
    pub fn new() -> AndroidIntentProto {
        ::std::default::Default::default()
    }

    // optional string action = 1;


    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string dataUri = 2;


    pub fn get_dataUri(&self) -> &str {
        match self.dataUri.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string mimeType = 3;


    pub fn get_mimeType(&self) -> &str {
        match self.mimeType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string javaClass = 4;


    pub fn get_javaClass(&self) -> &str {
        match self.javaClass.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidIntentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dataUri)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mimeType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.javaClass)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dataUri.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.mimeType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.javaClass.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dataUri.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.mimeType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.javaClass.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidIntentProto {
        AndroidIntentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &AndroidIntentProto| { &m.action },
                |m: &mut AndroidIntentProto| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataUri",
                |m: &AndroidIntentProto| { &m.dataUri },
                |m: &mut AndroidIntentProto| { &mut m.dataUri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mimeType",
                |m: &AndroidIntentProto| { &m.mimeType },
                |m: &mut AndroidIntentProto| { &mut m.mimeType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "javaClass",
                |m: &AndroidIntentProto| { &m.javaClass },
                |m: &mut AndroidIntentProto| { &mut m.javaClass },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidIntentProto>(
                "AndroidIntentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidIntentProto {
        static instance: ::protobuf::rt::LazyV2<AndroidIntentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidIntentProto::new)
    }
}

impl ::protobuf::Clear for AndroidIntentProto {
    fn clear(&mut self) {
        self.action.clear();
        self.dataUri.clear();
        self.mimeType.clear();
        self.javaClass.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidIntentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidIntentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidIntentProto_Extra {
    // message fields
    pub name: ::protobuf::SingularField<::std::string::String>,
    pub value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidIntentProto_Extra {
    fn default() -> &'a AndroidIntentProto_Extra {
        <AndroidIntentProto_Extra as ::protobuf::Message>::default_instance()
    }
}

impl AndroidIntentProto_Extra {
    pub fn new() -> AndroidIntentProto_Extra {
        ::std::default::Default::default()
    }

    // optional string name = 6;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 7;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AndroidIntentProto_Extra {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidIntentProto_Extra {
        AndroidIntentProto_Extra::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AndroidIntentProto_Extra| { &m.name },
                |m: &mut AndroidIntentProto_Extra| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &AndroidIntentProto_Extra| { &m.value },
                |m: &mut AndroidIntentProto_Extra| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidIntentProto_Extra>(
                "AndroidIntentProto.Extra",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidIntentProto_Extra {
        static instance: ::protobuf::rt::LazyV2<AndroidIntentProto_Extra> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidIntentProto_Extra::new)
    }
}

impl ::protobuf::Clear for AndroidIntentProto_Extra {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidIntentProto_Extra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidIntentProto_Extra {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidStatisticProto {
    // message fields
    pub tag: ::protobuf::SingularField<::std::string::String>,
    pub count: ::std::option::Option<i32>,
    pub sum: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidStatisticProto {
    fn default() -> &'a AndroidStatisticProto {
        <AndroidStatisticProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidStatisticProto {
    pub fn new() -> AndroidStatisticProto {
        ::std::default::Default::default()
    }

    // optional string tag = 1;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    // optional float sum = 3;


    pub fn get_sum(&self) -> f32 {
        self.sum.unwrap_or(0.)
    }
}

impl ::protobuf::Message for AndroidStatisticProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.sum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sum {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.sum {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidStatisticProto {
        AndroidStatisticProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &AndroidStatisticProto| { &m.tag },
                |m: &mut AndroidStatisticProto| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &AndroidStatisticProto| { &m.count },
                |m: &mut AndroidStatisticProto| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "sum",
                |m: &AndroidStatisticProto| { &m.sum },
                |m: &mut AndroidStatisticProto| { &mut m.sum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidStatisticProto>(
                "AndroidStatisticProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidStatisticProto {
        static instance: ::protobuf::rt::LazyV2<AndroidStatisticProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidStatisticProto::new)
    }
}

impl ::protobuf::Clear for AndroidStatisticProto {
    fn clear(&mut self) {
        self.tag.clear();
        self.count = ::std::option::Option::None;
        self.sum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidStatisticProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidStatisticProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ClientLibraryState {
    // message fields
    pub corpus: ::std::option::Option<i32>,
    pub serverToken: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub hashCodeSum: ::std::option::Option<i64>,
    pub librarySize: ::std::option::Option<i32>,
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientLibraryState {
    fn default() -> &'a ClientLibraryState {
        <ClientLibraryState as ::protobuf::Message>::default_instance()
    }
}

impl ClientLibraryState {
    pub fn new() -> ClientLibraryState {
        ::std::default::Default::default()
    }

    // optional int32 corpus = 1;


    pub fn get_corpus(&self) -> i32 {
        self.corpus.unwrap_or(0)
    }

    // optional bytes serverToken = 2;


    pub fn get_serverToken(&self) -> &[u8] {
        match self.serverToken.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int64 hashCodeSum = 3;


    pub fn get_hashCodeSum(&self) -> i64 {
        self.hashCodeSum.unwrap_or(0)
    }

    // optional int32 librarySize = 4;


    pub fn get_librarySize(&self) -> i32 {
        self.librarySize.unwrap_or(0)
    }

    // optional string libraryId = 5;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ClientLibraryState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.corpus = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serverToken)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.hashCodeSum = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.librarySize = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.corpus {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.hashCodeSum {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.librarySize {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.corpus {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.serverToken.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.hashCodeSum {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.librarySize {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientLibraryState {
        ClientLibraryState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "corpus",
                |m: &ClientLibraryState| { &m.corpus },
                |m: &mut ClientLibraryState| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serverToken",
                |m: &ClientLibraryState| { &m.serverToken },
                |m: &mut ClientLibraryState| { &mut m.serverToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "hashCodeSum",
                |m: &ClientLibraryState| { &m.hashCodeSum },
                |m: &mut ClientLibraryState| { &mut m.hashCodeSum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "librarySize",
                |m: &ClientLibraryState| { &m.librarySize },
                |m: &mut ClientLibraryState| { &mut m.librarySize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &ClientLibraryState| { &m.libraryId },
                |m: &mut ClientLibraryState| { &mut m.libraryId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientLibraryState>(
                "ClientLibraryState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientLibraryState {
        static instance: ::protobuf::rt::LazyV2<ClientLibraryState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientLibraryState::new)
    }
}

impl ::protobuf::Clear for ClientLibraryState {
    fn clear(&mut self) {
        self.corpus = ::std::option::Option::None;
        self.serverToken.clear();
        self.hashCodeSum = ::std::option::Option::None;
        self.librarySize = ::std::option::Option::None;
        self.libraryId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientLibraryState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientLibraryState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidDataUsageProto {
    // message fields
    pub version: ::std::option::Option<i32>,
    pub currentReportMsec: ::std::option::Option<i64>,
    pub keyToPackageNameMapping: ::protobuf::RepeatedField<KeyToPackageNameMapping>,
    pub payloadLevelAppStat: ::protobuf::RepeatedField<PayloadLevelAppStat>,
    pub ipLayerNetworkStat: ::protobuf::RepeatedField<IpLayerNetworkStat>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidDataUsageProto {
    fn default() -> &'a AndroidDataUsageProto {
        <AndroidDataUsageProto as ::protobuf::Message>::default_instance()
    }
}

impl AndroidDataUsageProto {
    pub fn new() -> AndroidDataUsageProto {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    // optional int64 currentReportMsec = 2;


    pub fn get_currentReportMsec(&self) -> i64 {
        self.currentReportMsec.unwrap_or(0)
    }

    // repeated .KeyToPackageNameMapping keyToPackageNameMapping = 3;


    pub fn get_keyToPackageNameMapping(&self) -> &[KeyToPackageNameMapping] {
        &self.keyToPackageNameMapping
    }

    // repeated .PayloadLevelAppStat payloadLevelAppStat = 4;


    pub fn get_payloadLevelAppStat(&self) -> &[PayloadLevelAppStat] {
        &self.payloadLevelAppStat
    }

    // repeated .IpLayerNetworkStat ipLayerNetworkStat = 5;


    pub fn get_ipLayerNetworkStat(&self) -> &[IpLayerNetworkStat] {
        &self.ipLayerNetworkStat
    }
}

impl ::protobuf::Message for AndroidDataUsageProto {
    fn is_initialized(&self) -> bool {
        for v in &self.keyToPackageNameMapping {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payloadLevelAppStat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ipLayerNetworkStat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.currentReportMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keyToPackageNameMapping)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payloadLevelAppStat)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ipLayerNetworkStat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currentReportMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keyToPackageNameMapping {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.payloadLevelAppStat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ipLayerNetworkStat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currentReportMsec {
            os.write_int64(2, v)?;
        }
        for v in &self.keyToPackageNameMapping {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.payloadLevelAppStat {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ipLayerNetworkStat {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidDataUsageProto {
        AndroidDataUsageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &AndroidDataUsageProto| { &m.version },
                |m: &mut AndroidDataUsageProto| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "currentReportMsec",
                |m: &AndroidDataUsageProto| { &m.currentReportMsec },
                |m: &mut AndroidDataUsageProto| { &mut m.currentReportMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPackageNameMapping>>(
                "keyToPackageNameMapping",
                |m: &AndroidDataUsageProto| { &m.keyToPackageNameMapping },
                |m: &mut AndroidDataUsageProto| { &mut m.keyToPackageNameMapping },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PayloadLevelAppStat>>(
                "payloadLevelAppStat",
                |m: &AndroidDataUsageProto| { &m.payloadLevelAppStat },
                |m: &mut AndroidDataUsageProto| { &mut m.payloadLevelAppStat },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpLayerNetworkStat>>(
                "ipLayerNetworkStat",
                |m: &AndroidDataUsageProto| { &m.ipLayerNetworkStat },
                |m: &mut AndroidDataUsageProto| { &mut m.ipLayerNetworkStat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidDataUsageProto>(
                "AndroidDataUsageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidDataUsageProto {
        static instance: ::protobuf::rt::LazyV2<AndroidDataUsageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidDataUsageProto::new)
    }
}

impl ::protobuf::Clear for AndroidDataUsageProto {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currentReportMsec = ::std::option::Option::None;
        self.keyToPackageNameMapping.clear();
        self.payloadLevelAppStat.clear();
        self.ipLayerNetworkStat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidDataUsageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidDataUsageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AndroidUsageStatsReport {
    // message fields
    pub androidId: ::std::option::Option<i64>,
    pub loggingId: ::std::option::Option<i64>,
    pub usageStats: ::protobuf::SingularPtrField<UsageStatsExtensionProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AndroidUsageStatsReport {
    fn default() -> &'a AndroidUsageStatsReport {
        <AndroidUsageStatsReport as ::protobuf::Message>::default_instance()
    }
}

impl AndroidUsageStatsReport {
    pub fn new() -> AndroidUsageStatsReport {
        ::std::default::Default::default()
    }

    // optional int64 androidId = 1;


    pub fn get_androidId(&self) -> i64 {
        self.androidId.unwrap_or(0)
    }

    // optional int64 loggingId = 2;


    pub fn get_loggingId(&self) -> i64 {
        self.loggingId.unwrap_or(0)
    }

    // optional .UsageStatsExtensionProto usageStats = 3;


    pub fn get_usageStats(&self) -> &UsageStatsExtensionProto {
        self.usageStats.as_ref().unwrap_or_else(|| <UsageStatsExtensionProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for AndroidUsageStatsReport {
    fn is_initialized(&self) -> bool {
        for v in &self.usageStats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.androidId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.loggingId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usageStats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.androidId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loggingId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.usageStats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.androidId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.loggingId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.usageStats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AndroidUsageStatsReport {
        AndroidUsageStatsReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "androidId",
                |m: &AndroidUsageStatsReport| { &m.androidId },
                |m: &mut AndroidUsageStatsReport| { &mut m.androidId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "loggingId",
                |m: &AndroidUsageStatsReport| { &m.loggingId },
                |m: &mut AndroidUsageStatsReport| { &mut m.loggingId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UsageStatsExtensionProto>>(
                "usageStats",
                |m: &AndroidUsageStatsReport| { &m.usageStats },
                |m: &mut AndroidUsageStatsReport| { &mut m.usageStats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AndroidUsageStatsReport>(
                "AndroidUsageStatsReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AndroidUsageStatsReport {
        static instance: ::protobuf::rt::LazyV2<AndroidUsageStatsReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AndroidUsageStatsReport::new)
    }
}

impl ::protobuf::Clear for AndroidUsageStatsReport {
    fn clear(&mut self) {
        self.androidId = ::std::option::Option::None;
        self.loggingId = ::std::option::Option::None;
        self.usageStats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AndroidUsageStatsReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidUsageStatsReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AppBucket {
    // message fields
    pub bucketStartMsec: ::std::option::Option<i64>,
    pub bucketDurationMsec: ::std::option::Option<i64>,
    pub statCounters: ::protobuf::RepeatedField<StatCounters>,
    pub operationCount: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppBucket {
    fn default() -> &'a AppBucket {
        <AppBucket as ::protobuf::Message>::default_instance()
    }
}

impl AppBucket {
    pub fn new() -> AppBucket {
        ::std::default::Default::default()
    }

    // optional int64 bucketStartMsec = 1;


    pub fn get_bucketStartMsec(&self) -> i64 {
        self.bucketStartMsec.unwrap_or(0)
    }

    // optional int64 bucketDurationMsec = 2;


    pub fn get_bucketDurationMsec(&self) -> i64 {
        self.bucketDurationMsec.unwrap_or(0)
    }

    // repeated .StatCounters statCounters = 3;


    pub fn get_statCounters(&self) -> &[StatCounters] {
        &self.statCounters
    }

    // optional int64 operationCount = 4;


    pub fn get_operationCount(&self) -> i64 {
        self.operationCount.unwrap_or(0)
    }
}

impl ::protobuf::Message for AppBucket {
    fn is_initialized(&self) -> bool {
        for v in &self.statCounters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucketStartMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucketDurationMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statCounters)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.operationCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bucketStartMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bucketDurationMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.statCounters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.operationCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bucketStartMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bucketDurationMsec {
            os.write_int64(2, v)?;
        }
        for v in &self.statCounters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.operationCount {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppBucket {
        AppBucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bucketStartMsec",
                |m: &AppBucket| { &m.bucketStartMsec },
                |m: &mut AppBucket| { &mut m.bucketStartMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bucketDurationMsec",
                |m: &AppBucket| { &m.bucketDurationMsec },
                |m: &mut AppBucket| { &mut m.bucketDurationMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatCounters>>(
                "statCounters",
                |m: &AppBucket| { &m.statCounters },
                |m: &mut AppBucket| { &mut m.statCounters },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "operationCount",
                |m: &AppBucket| { &m.operationCount },
                |m: &mut AppBucket| { &mut m.operationCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppBucket>(
                "AppBucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppBucket {
        static instance: ::protobuf::rt::LazyV2<AppBucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppBucket::new)
    }
}

impl ::protobuf::Clear for AppBucket {
    fn clear(&mut self) {
        self.bucketStartMsec = ::std::option::Option::None;
        self.bucketDurationMsec = ::std::option::Option::None;
        self.statCounters.clear();
        self.operationCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppBucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CounterData {
    // message fields
    pub bytes: ::std::option::Option<i64>,
    pub packets: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CounterData {
    fn default() -> &'a CounterData {
        <CounterData as ::protobuf::Message>::default_instance()
    }
}

impl CounterData {
    pub fn new() -> CounterData {
        ::std::default::Default::default()
    }

    // optional int64 bytes = 1;


    pub fn get_bytes(&self) -> i64 {
        self.bytes.unwrap_or(0)
    }

    // optional int64 packets = 2;


    pub fn get_packets(&self) -> i64 {
        self.packets.unwrap_or(0)
    }
}

impl ::protobuf::Message for CounterData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.packets = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packets {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytes {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.packets {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CounterData {
        CounterData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytes",
                |m: &CounterData| { &m.bytes },
                |m: &mut CounterData| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "packets",
                |m: &CounterData| { &m.packets },
                |m: &mut CounterData| { &mut m.packets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CounterData>(
                "CounterData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CounterData {
        static instance: ::protobuf::rt::LazyV2<CounterData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CounterData::new)
    }
}

impl ::protobuf::Clear for CounterData {
    fn clear(&mut self) {
        self.bytes = ::std::option::Option::None;
        self.packets = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CounterData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IpLayerAppStat {
    // message fields
    pub packageKey: ::std::option::Option<i32>,
    pub applicationTag: ::std::option::Option<i32>,
    pub ipLayerAppBucket: ::protobuf::RepeatedField<AppBucket>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IpLayerAppStat {
    fn default() -> &'a IpLayerAppStat {
        <IpLayerAppStat as ::protobuf::Message>::default_instance()
    }
}

impl IpLayerAppStat {
    pub fn new() -> IpLayerAppStat {
        ::std::default::Default::default()
    }

    // optional int32 packageKey = 1;


    pub fn get_packageKey(&self) -> i32 {
        self.packageKey.unwrap_or(0)
    }

    // optional int32 applicationTag = 2;


    pub fn get_applicationTag(&self) -> i32 {
        self.applicationTag.unwrap_or(0)
    }

    // repeated .AppBucket ipLayerAppBucket = 3;


    pub fn get_ipLayerAppBucket(&self) -> &[AppBucket] {
        &self.ipLayerAppBucket
    }
}

impl ::protobuf::Message for IpLayerAppStat {
    fn is_initialized(&self) -> bool {
        for v in &self.ipLayerAppBucket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packageKey = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.applicationTag = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ipLayerAppBucket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageKey {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.applicationTag {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ipLayerAppBucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageKey {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.applicationTag {
            os.write_int32(2, v)?;
        }
        for v in &self.ipLayerAppBucket {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IpLayerAppStat {
        IpLayerAppStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "packageKey",
                |m: &IpLayerAppStat| { &m.packageKey },
                |m: &mut IpLayerAppStat| { &mut m.packageKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "applicationTag",
                |m: &IpLayerAppStat| { &m.applicationTag },
                |m: &mut IpLayerAppStat| { &mut m.applicationTag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppBucket>>(
                "ipLayerAppBucket",
                |m: &IpLayerAppStat| { &m.ipLayerAppBucket },
                |m: &mut IpLayerAppStat| { &mut m.ipLayerAppBucket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IpLayerAppStat>(
                "IpLayerAppStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IpLayerAppStat {
        static instance: ::protobuf::rt::LazyV2<IpLayerAppStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IpLayerAppStat::new)
    }
}

impl ::protobuf::Clear for IpLayerAppStat {
    fn clear(&mut self) {
        self.packageKey = ::std::option::Option::None;
        self.applicationTag = ::std::option::Option::None;
        self.ipLayerAppBucket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpLayerAppStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpLayerAppStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IpLayerNetworkBucket {
    // message fields
    pub bucketStartMsec: ::std::option::Option<i64>,
    pub bucketDurationMsec: ::std::option::Option<i64>,
    pub statCounters: ::protobuf::RepeatedField<StatCounters>,
    pub networkActiveDuration: ::std::option::Option<i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IpLayerNetworkBucket {
    fn default() -> &'a IpLayerNetworkBucket {
        <IpLayerNetworkBucket as ::protobuf::Message>::default_instance()
    }
}

impl IpLayerNetworkBucket {
    pub fn new() -> IpLayerNetworkBucket {
        ::std::default::Default::default()
    }

    // optional int64 bucketStartMsec = 1;


    pub fn get_bucketStartMsec(&self) -> i64 {
        self.bucketStartMsec.unwrap_or(0)
    }

    // optional int64 bucketDurationMsec = 2;


    pub fn get_bucketDurationMsec(&self) -> i64 {
        self.bucketDurationMsec.unwrap_or(0)
    }

    // repeated .StatCounters statCounters = 3;


    pub fn get_statCounters(&self) -> &[StatCounters] {
        &self.statCounters
    }

    // optional int64 networkActiveDuration = 4;


    pub fn get_networkActiveDuration(&self) -> i64 {
        self.networkActiveDuration.unwrap_or(0)
    }
}

impl ::protobuf::Message for IpLayerNetworkBucket {
    fn is_initialized(&self) -> bool {
        for v in &self.statCounters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucketStartMsec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucketDurationMsec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statCounters)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.networkActiveDuration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bucketStartMsec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bucketDurationMsec {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.statCounters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.networkActiveDuration {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bucketStartMsec {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bucketDurationMsec {
            os.write_int64(2, v)?;
        }
        for v in &self.statCounters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.networkActiveDuration {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IpLayerNetworkBucket {
        IpLayerNetworkBucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bucketStartMsec",
                |m: &IpLayerNetworkBucket| { &m.bucketStartMsec },
                |m: &mut IpLayerNetworkBucket| { &mut m.bucketStartMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bucketDurationMsec",
                |m: &IpLayerNetworkBucket| { &m.bucketDurationMsec },
                |m: &mut IpLayerNetworkBucket| { &mut m.bucketDurationMsec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatCounters>>(
                "statCounters",
                |m: &IpLayerNetworkBucket| { &m.statCounters },
                |m: &mut IpLayerNetworkBucket| { &mut m.statCounters },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "networkActiveDuration",
                |m: &IpLayerNetworkBucket| { &m.networkActiveDuration },
                |m: &mut IpLayerNetworkBucket| { &mut m.networkActiveDuration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IpLayerNetworkBucket>(
                "IpLayerNetworkBucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IpLayerNetworkBucket {
        static instance: ::protobuf::rt::LazyV2<IpLayerNetworkBucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IpLayerNetworkBucket::new)
    }
}

impl ::protobuf::Clear for IpLayerNetworkBucket {
    fn clear(&mut self) {
        self.bucketStartMsec = ::std::option::Option::None;
        self.bucketDurationMsec = ::std::option::Option::None;
        self.statCounters.clear();
        self.networkActiveDuration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpLayerNetworkBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpLayerNetworkBucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct IpLayerNetworkStat {
    // message fields
    pub networkDetails: ::protobuf::SingularField<::std::string::String>,
    pub field_type: ::std::option::Option<i32>,
    pub ipLayerNetworkBucket: ::protobuf::RepeatedField<IpLayerNetworkBucket>,
    pub ipLayerAppStat: ::protobuf::RepeatedField<IpLayerAppStat>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IpLayerNetworkStat {
    fn default() -> &'a IpLayerNetworkStat {
        <IpLayerNetworkStat as ::protobuf::Message>::default_instance()
    }
}

impl IpLayerNetworkStat {
    pub fn new() -> IpLayerNetworkStat {
        ::std::default::Default::default()
    }

    // optional string networkDetails = 1;


    pub fn get_networkDetails(&self) -> &str {
        match self.networkDetails.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    // repeated .IpLayerNetworkBucket ipLayerNetworkBucket = 3;


    pub fn get_ipLayerNetworkBucket(&self) -> &[IpLayerNetworkBucket] {
        &self.ipLayerNetworkBucket
    }

    // repeated .IpLayerAppStat ipLayerAppStat = 4;


    pub fn get_ipLayerAppStat(&self) -> &[IpLayerAppStat] {
        &self.ipLayerAppStat
    }
}

impl ::protobuf::Message for IpLayerNetworkStat {
    fn is_initialized(&self) -> bool {
        for v in &self.ipLayerNetworkBucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ipLayerAppStat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.networkDetails)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ipLayerNetworkBucket)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ipLayerAppStat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.networkDetails.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ipLayerNetworkBucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ipLayerAppStat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.networkDetails.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(2, v)?;
        }
        for v in &self.ipLayerNetworkBucket {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ipLayerAppStat {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IpLayerNetworkStat {
        IpLayerNetworkStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "networkDetails",
                |m: &IpLayerNetworkStat| { &m.networkDetails },
                |m: &mut IpLayerNetworkStat| { &mut m.networkDetails },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &IpLayerNetworkStat| { &m.field_type },
                |m: &mut IpLayerNetworkStat| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpLayerNetworkBucket>>(
                "ipLayerNetworkBucket",
                |m: &IpLayerNetworkStat| { &m.ipLayerNetworkBucket },
                |m: &mut IpLayerNetworkStat| { &mut m.ipLayerNetworkBucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IpLayerAppStat>>(
                "ipLayerAppStat",
                |m: &IpLayerNetworkStat| { &m.ipLayerAppStat },
                |m: &mut IpLayerNetworkStat| { &mut m.ipLayerAppStat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IpLayerNetworkStat>(
                "IpLayerNetworkStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IpLayerNetworkStat {
        static instance: ::protobuf::rt::LazyV2<IpLayerNetworkStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IpLayerNetworkStat::new)
    }
}

impl ::protobuf::Clear for IpLayerNetworkStat {
    fn clear(&mut self) {
        self.networkDetails.clear();
        self.field_type = ::std::option::Option::None;
        self.ipLayerNetworkBucket.clear();
        self.ipLayerAppStat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IpLayerNetworkStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpLayerNetworkStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct KeyToPackageNameMapping {
    // message fields
    pub packageKey: ::std::option::Option<i32>,
    pub uidName: ::protobuf::SingularField<::std::string::String>,
    pub sharedPackageList: ::protobuf::RepeatedField<PackageInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyToPackageNameMapping {
    fn default() -> &'a KeyToPackageNameMapping {
        <KeyToPackageNameMapping as ::protobuf::Message>::default_instance()
    }
}

impl KeyToPackageNameMapping {
    pub fn new() -> KeyToPackageNameMapping {
        ::std::default::Default::default()
    }

    // optional int32 packageKey = 1;


    pub fn get_packageKey(&self) -> i32 {
        self.packageKey.unwrap_or(0)
    }

    // optional string uidName = 2;


    pub fn get_uidName(&self) -> &str {
        match self.uidName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .PackageInfo sharedPackageList = 3;


    pub fn get_sharedPackageList(&self) -> &[PackageInfo] {
        &self.sharedPackageList
    }
}

impl ::protobuf::Message for KeyToPackageNameMapping {
    fn is_initialized(&self) -> bool {
        for v in &self.sharedPackageList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packageKey = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uidName)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sharedPackageList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageKey {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.uidName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.sharedPackageList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageKey {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.uidName.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.sharedPackageList {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyToPackageNameMapping {
        KeyToPackageNameMapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "packageKey",
                |m: &KeyToPackageNameMapping| { &m.packageKey },
                |m: &mut KeyToPackageNameMapping| { &mut m.packageKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uidName",
                |m: &KeyToPackageNameMapping| { &m.uidName },
                |m: &mut KeyToPackageNameMapping| { &mut m.uidName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PackageInfo>>(
                "sharedPackageList",
                |m: &KeyToPackageNameMapping| { &m.sharedPackageList },
                |m: &mut KeyToPackageNameMapping| { &mut m.sharedPackageList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyToPackageNameMapping>(
                "KeyToPackageNameMapping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyToPackageNameMapping {
        static instance: ::protobuf::rt::LazyV2<KeyToPackageNameMapping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyToPackageNameMapping::new)
    }
}

impl ::protobuf::Clear for KeyToPackageNameMapping {
    fn clear(&mut self) {
        self.packageKey = ::std::option::Option::None;
        self.uidName.clear();
        self.sharedPackageList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyToPackageNameMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyToPackageNameMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PackageInfo {
    // message fields
    pub pkgName: ::protobuf::SingularField<::std::string::String>,
    pub versionCode: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PackageInfo {
    fn default() -> &'a PackageInfo {
        <PackageInfo as ::protobuf::Message>::default_instance()
    }
}

impl PackageInfo {
    pub fn new() -> PackageInfo {
        ::std::default::Default::default()
    }

    // optional string pkgName = 1;


    pub fn get_pkgName(&self) -> &str {
        match self.pkgName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 versionCode = 2;


    pub fn get_versionCode(&self) -> i32 {
        self.versionCode.unwrap_or(0)
    }
}

impl ::protobuf::Message for PackageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pkgName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.versionCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pkgName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.versionCode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pkgName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.versionCode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PackageInfo {
        PackageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pkgName",
                |m: &PackageInfo| { &m.pkgName },
                |m: &mut PackageInfo| { &mut m.pkgName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "versionCode",
                |m: &PackageInfo| { &m.versionCode },
                |m: &mut PackageInfo| { &mut m.versionCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PackageInfo>(
                "PackageInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PackageInfo {
        static instance: ::protobuf::rt::LazyV2<PackageInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PackageInfo::new)
    }
}

impl ::protobuf::Clear for PackageInfo {
    fn clear(&mut self) {
        self.pkgName.clear();
        self.versionCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PackageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct PayloadLevelAppStat {
    // message fields
    pub packageKey: ::std::option::Option<i32>,
    pub applicationTag: ::std::option::Option<i32>,
    pub payloadLevelAppBucket: ::protobuf::RepeatedField<AppBucket>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayloadLevelAppStat {
    fn default() -> &'a PayloadLevelAppStat {
        <PayloadLevelAppStat as ::protobuf::Message>::default_instance()
    }
}

impl PayloadLevelAppStat {
    pub fn new() -> PayloadLevelAppStat {
        ::std::default::Default::default()
    }

    // optional int32 packageKey = 1;


    pub fn get_packageKey(&self) -> i32 {
        self.packageKey.unwrap_or(0)
    }

    // optional int32 applicationTag = 2;


    pub fn get_applicationTag(&self) -> i32 {
        self.applicationTag.unwrap_or(0)
    }

    // repeated .AppBucket payloadLevelAppBucket = 3;


    pub fn get_payloadLevelAppBucket(&self) -> &[AppBucket] {
        &self.payloadLevelAppBucket
    }
}

impl ::protobuf::Message for PayloadLevelAppStat {
    fn is_initialized(&self) -> bool {
        for v in &self.payloadLevelAppBucket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.packageKey = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.applicationTag = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payloadLevelAppBucket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageKey {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.applicationTag {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.payloadLevelAppBucket {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageKey {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.applicationTag {
            os.write_int32(2, v)?;
        }
        for v in &self.payloadLevelAppBucket {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayloadLevelAppStat {
        PayloadLevelAppStat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "packageKey",
                |m: &PayloadLevelAppStat| { &m.packageKey },
                |m: &mut PayloadLevelAppStat| { &mut m.packageKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "applicationTag",
                |m: &PayloadLevelAppStat| { &m.applicationTag },
                |m: &mut PayloadLevelAppStat| { &mut m.applicationTag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppBucket>>(
                "payloadLevelAppBucket",
                |m: &PayloadLevelAppStat| { &m.payloadLevelAppBucket },
                |m: &mut PayloadLevelAppStat| { &mut m.payloadLevelAppBucket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PayloadLevelAppStat>(
                "PayloadLevelAppStat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PayloadLevelAppStat {
        static instance: ::protobuf::rt::LazyV2<PayloadLevelAppStat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PayloadLevelAppStat::new)
    }
}

impl ::protobuf::Clear for PayloadLevelAppStat {
    fn clear(&mut self) {
        self.packageKey = ::std::option::Option::None;
        self.applicationTag = ::std::option::Option::None;
        self.payloadLevelAppBucket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayloadLevelAppStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayloadLevelAppStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct StatCounters {
    // message fields
    pub networkProto: ::std::option::Option<i32>,
    pub direction: ::std::option::Option<i32>,
    pub counterData: ::protobuf::SingularPtrField<CounterData>,
    pub fgBg: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatCounters {
    fn default() -> &'a StatCounters {
        <StatCounters as ::protobuf::Message>::default_instance()
    }
}

impl StatCounters {
    pub fn new() -> StatCounters {
        ::std::default::Default::default()
    }

    // optional int32 networkProto = 1;


    pub fn get_networkProto(&self) -> i32 {
        self.networkProto.unwrap_or(0)
    }

    // optional int32 direction = 2;


    pub fn get_direction(&self) -> i32 {
        self.direction.unwrap_or(0)
    }

    // optional .CounterData counterData = 3;


    pub fn get_counterData(&self) -> &CounterData {
        self.counterData.as_ref().unwrap_or_else(|| <CounterData as ::protobuf::Message>::default_instance())
    }

    // optional int32 fgBg = 4;


    pub fn get_fgBg(&self) -> i32 {
        self.fgBg.unwrap_or(0)
    }
}

impl ::protobuf::Message for StatCounters {
    fn is_initialized(&self) -> bool {
        for v in &self.counterData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.networkProto = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.direction = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.counterData)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fgBg = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.networkProto {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.counterData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fgBg {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.networkProto {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.direction {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.counterData.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fgBg {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatCounters {
        StatCounters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "networkProto",
                |m: &StatCounters| { &m.networkProto },
                |m: &mut StatCounters| { &mut m.networkProto },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "direction",
                |m: &StatCounters| { &m.direction },
                |m: &mut StatCounters| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CounterData>>(
                "counterData",
                |m: &StatCounters| { &m.counterData },
                |m: &mut StatCounters| { &mut m.counterData },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fgBg",
                |m: &StatCounters| { &m.fgBg },
                |m: &mut StatCounters| { &mut m.fgBg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatCounters>(
                "StatCounters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatCounters {
        static instance: ::protobuf::rt::LazyV2<StatCounters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatCounters::new)
    }
}

impl ::protobuf::Clear for StatCounters {
    fn clear(&mut self) {
        self.networkProto = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.counterData.clear();
        self.fgBg = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatCounters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatCounters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UsageStatsExtensionProto {
    // message fields
    pub dataUsage: ::protobuf::SingularPtrField<AndroidDataUsageProto>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsageStatsExtensionProto {
    fn default() -> &'a UsageStatsExtensionProto {
        <UsageStatsExtensionProto as ::protobuf::Message>::default_instance()
    }
}

impl UsageStatsExtensionProto {
    pub fn new() -> UsageStatsExtensionProto {
        ::std::default::Default::default()
    }

    // optional .AndroidDataUsageProto dataUsage = 1;


    pub fn get_dataUsage(&self) -> &AndroidDataUsageProto {
        self.dataUsage.as_ref().unwrap_or_else(|| <AndroidDataUsageProto as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for UsageStatsExtensionProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dataUsage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataUsage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataUsage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataUsage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsageStatsExtensionProto {
        UsageStatsExtensionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AndroidDataUsageProto>>(
                "dataUsage",
                |m: &UsageStatsExtensionProto| { &m.dataUsage },
                |m: &mut UsageStatsExtensionProto| { &mut m.dataUsage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsageStatsExtensionProto>(
                "UsageStatsExtensionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsageStatsExtensionProto {
        static instance: ::protobuf::rt::LazyV2<UsageStatsExtensionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsageStatsExtensionProto::new)
    }
}

impl ::protobuf::Clear for UsageStatsExtensionProto {
    fn clear(&mut self) {
        self.dataUsage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsageStatsExtensionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsageStatsExtensionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ModifyLibraryRequest {
    // message fields
    pub libraryId: ::protobuf::SingularField<::std::string::String>,
    pub addPackageName: ::protobuf::RepeatedField<::std::string::String>,
    pub removePackageName: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyLibraryRequest {
    fn default() -> &'a ModifyLibraryRequest {
        <ModifyLibraryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyLibraryRequest {
    pub fn new() -> ModifyLibraryRequest {
        ::std::default::Default::default()
    }

    // optional string libraryId = 1;


    pub fn get_libraryId(&self) -> &str {
        match self.libraryId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string addPackageName = 2;


    pub fn get_addPackageName(&self) -> &[::std::string::String] {
        &self.addPackageName
    }

    // repeated string removePackageName = 3;


    pub fn get_removePackageName(&self) -> &[::std::string::String] {
        &self.removePackageName
    }
}

impl ::protobuf::Message for ModifyLibraryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.libraryId)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addPackageName)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.removePackageName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.libraryId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.addPackageName {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.removePackageName {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.libraryId.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.addPackageName {
            os.write_string(2, &v)?;
        };
        for v in &self.removePackageName {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyLibraryRequest {
        ModifyLibraryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "libraryId",
                |m: &ModifyLibraryRequest| { &m.libraryId },
                |m: &mut ModifyLibraryRequest| { &mut m.libraryId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addPackageName",
                |m: &ModifyLibraryRequest| { &m.addPackageName },
                |m: &mut ModifyLibraryRequest| { &mut m.addPackageName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "removePackageName",
                |m: &ModifyLibraryRequest| { &m.removePackageName },
                |m: &mut ModifyLibraryRequest| { &mut m.removePackageName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyLibraryRequest>(
                "ModifyLibraryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyLibraryRequest {
        static instance: ::protobuf::rt::LazyV2<ModifyLibraryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyLibraryRequest::new)
    }
}

impl ::protobuf::Clear for ModifyLibraryRequest {
    fn clear(&mut self) {
        self.libraryId.clear();
        self.addPackageName.clear();
        self.removePackageName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyLibraryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyLibraryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct UrlRequestWrapper {
    // message fields
    pub developerAppsRequest: ::protobuf::SingularPtrField<DeveloperAppsRequest>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UrlRequestWrapper {
    fn default() -> &'a UrlRequestWrapper {
        <UrlRequestWrapper as ::protobuf::Message>::default_instance()
    }
}

impl UrlRequestWrapper {
    pub fn new() -> UrlRequestWrapper {
        ::std::default::Default::default()
    }

    // optional .DeveloperAppsRequest developerAppsRequest = 49;


    pub fn get_developerAppsRequest(&self) -> &DeveloperAppsRequest {
        self.developerAppsRequest.as_ref().unwrap_or_else(|| <DeveloperAppsRequest as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for UrlRequestWrapper {
    fn is_initialized(&self) -> bool {
        for v in &self.developerAppsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.developerAppsRequest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.developerAppsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.developerAppsRequest.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UrlRequestWrapper {
        UrlRequestWrapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeveloperAppsRequest>>(
                "developerAppsRequest",
                |m: &UrlRequestWrapper| { &m.developerAppsRequest },
                |m: &mut UrlRequestWrapper| { &mut m.developerAppsRequest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UrlRequestWrapper>(
                "UrlRequestWrapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UrlRequestWrapper {
        static instance: ::protobuf::rt::LazyV2<UrlRequestWrapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UrlRequestWrapper::new)
    }
}

impl ::protobuf::Clear for UrlRequestWrapper {
    fn clear(&mut self) {
        self.developerAppsRequest.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UrlRequestWrapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UrlRequestWrapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeveloperAppsRequest {
    // message fields
    pub developerIdContainer1: ::protobuf::SingularPtrField<DeveloperIdContainer>,
    pub developerIdContainer2: ::protobuf::SingularPtrField<DeveloperIdContainer>,
    pub unknownInt3: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeveloperAppsRequest {
    fn default() -> &'a DeveloperAppsRequest {
        <DeveloperAppsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeveloperAppsRequest {
    pub fn new() -> DeveloperAppsRequest {
        ::std::default::Default::default()
    }

    // optional .DeveloperIdContainer developerIdContainer1 = 1;


    pub fn get_developerIdContainer1(&self) -> &DeveloperIdContainer {
        self.developerIdContainer1.as_ref().unwrap_or_else(|| <DeveloperIdContainer as ::protobuf::Message>::default_instance())
    }

    // optional .DeveloperIdContainer developerIdContainer2 = 2;


    pub fn get_developerIdContainer2(&self) -> &DeveloperIdContainer {
        self.developerIdContainer2.as_ref().unwrap_or_else(|| <DeveloperIdContainer as ::protobuf::Message>::default_instance())
    }

    // optional int32 unknownInt3 = 3;


    pub fn get_unknownInt3(&self) -> i32 {
        self.unknownInt3.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeveloperAppsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.developerIdContainer1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.developerIdContainer2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.developerIdContainer1)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.developerIdContainer2)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknownInt3 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.developerIdContainer1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.developerIdContainer2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.unknownInt3 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.developerIdContainer1.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.developerIdContainer2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.unknownInt3 {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeveloperAppsRequest {
        DeveloperAppsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeveloperIdContainer>>(
                "developerIdContainer1",
                |m: &DeveloperAppsRequest| { &m.developerIdContainer1 },
                |m: &mut DeveloperAppsRequest| { &mut m.developerIdContainer1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeveloperIdContainer>>(
                "developerIdContainer2",
                |m: &DeveloperAppsRequest| { &m.developerIdContainer2 },
                |m: &mut DeveloperAppsRequest| { &mut m.developerIdContainer2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknownInt3",
                |m: &DeveloperAppsRequest| { &m.unknownInt3 },
                |m: &mut DeveloperAppsRequest| { &mut m.unknownInt3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeveloperAppsRequest>(
                "DeveloperAppsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeveloperAppsRequest {
        static instance: ::protobuf::rt::LazyV2<DeveloperAppsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeveloperAppsRequest::new)
    }
}

impl ::protobuf::Clear for DeveloperAppsRequest {
    fn clear(&mut self) {
        self.developerIdContainer1.clear();
        self.developerIdContainer2.clear();
        self.unknownInt3 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeveloperAppsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeveloperAppsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DeveloperIdContainer {
    // message fields
    pub developerId: ::protobuf::SingularField<::std::string::String>,
    pub unknownInt2: ::std::option::Option<i32>,
    pub unknownInt3: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeveloperIdContainer {
    fn default() -> &'a DeveloperIdContainer {
        <DeveloperIdContainer as ::protobuf::Message>::default_instance()
    }
}

impl DeveloperIdContainer {
    pub fn new() -> DeveloperIdContainer {
        ::std::default::Default::default()
    }

    // optional string developerId = 1;


    pub fn get_developerId(&self) -> &str {
        match self.developerId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 unknownInt2 = 2;


    pub fn get_unknownInt2(&self) -> i32 {
        self.unknownInt2.unwrap_or(0)
    }

    // optional int32 unknownInt3 = 3;


    pub fn get_unknownInt3(&self) -> i32 {
        self.unknownInt3.unwrap_or(0)
    }
}

impl ::protobuf::Message for DeveloperIdContainer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.developerId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknownInt2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.unknownInt3 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.developerId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.unknownInt2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unknownInt3 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.developerId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.unknownInt2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.unknownInt3 {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeveloperIdContainer {
        DeveloperIdContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "developerId",
                |m: &DeveloperIdContainer| { &m.developerId },
                |m: &mut DeveloperIdContainer| { &mut m.developerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknownInt2",
                |m: &DeveloperIdContainer| { &m.unknownInt2 },
                |m: &mut DeveloperIdContainer| { &mut m.unknownInt2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknownInt3",
                |m: &DeveloperIdContainer| { &m.unknownInt3 },
                |m: &mut DeveloperIdContainer| { &mut m.unknownInt3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeveloperIdContainer>(
                "DeveloperIdContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeveloperIdContainer {
        static instance: ::protobuf::rt::LazyV2<DeveloperIdContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeveloperIdContainer::new)
    }
}

impl ::protobuf::Clear for DeveloperIdContainer {
    fn clear(&mut self) {
        self.developerId.clear();
        self.unknownInt2 = ::std::option::Option::None;
        self.unknownInt3 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeveloperIdContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeveloperIdContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10googleplay.proto\"\x86\x06\n\x16AndroidAppDeliveryData\x12$\n\x0cd\
    ownloadSize\x18\x01\x20\x01(\x03R\x0cdownloadSizeB\0\x12\x14\n\x04sha1\
    \x18\x02\x20\x01(\tR\x04sha1B\0\x12\"\n\x0bdownloadUrl\x18\x03\x20\x01(\
    \tR\x0bdownloadUrlB\0\x12:\n\x0eadditionalFile\x18\x04\x20\x03(\x0b2\x10\
    .AppFileMetadataR\x0eadditionalFileB\0\x12=\n\x12downloadAuthCookie\x18\
    \x05\x20\x03(\x0b2\x0b.HttpCookieR\x12downloadAuthCookieB\0\x12&\n\rforw\
    ardLocked\x18\x06\x20\x01(\x08R\rforwardLockedB\0\x12&\n\rrefundTimeout\
    \x18\x07\x20\x01(\x03R\rrefundTimeoutB\0\x12*\n\x0fserverInitiated\x18\
    \x08\x20\x01(\x08R\x0fserverInitiatedB\0\x12F\n\x1dpostInstallRefundWind\
    owMillis\x18\t\x20\x01(\x03R\x1dpostInstallRefundWindowMillisB\0\x124\n\
    \x14immediateStartNeeded\x18\n\x20\x01(\x08R\x14immediateStartNeededB\0\
    \x124\n\tpatchData\x18\x0b\x20\x01(\x0b2\x14.AndroidAppPatchDataR\tpatch\
    DataB\0\x12?\n\x10encryptionParams\x18\x0c\x20\x01(\x0b2\x11.EncryptionP\
    aramsR\x10encryptionParamsB\0\x120\n\x12downloadUrlGzipped\x18\r\x20\x01\
    (\tR\x12downloadUrlGzippedB\0\x122\n\x13downloadSizeGzipped\x18\x0e\x20\
    \x01(\x03R\x13downloadSizeGzippedB\0\x12\x1e\n\x05split\x18\x0f\x20\x03(\
    \x0b2\x06.SplitR\x05splitB\0\x12\x18\n\x06sha256\x18\x13\x20\x01(\tR\x06\
    sha256B\0:\0\"\xdf\x01\n\x05Split\x12\x14\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\0\x12\x14\n\x04size\x18\x02\x20\x01(\x03R\x04sizeB\0\x12\"\n\
    \x0bsizeGzipped\x18\x03\x20\x01(\x03R\x0bsizeGzippedB\0\x12\x14\n\x04sha\
    1\x18\x04\x20\x01(\tR\x04sha1B\0\x12\"\n\x0bdownloadUrl\x18\x05\x20\x01(\
    \tR\x0bdownloadUrlB\0\x120\n\x12downloadUrlGzipped\x18\x06\x20\x01(\tR\
    \x12downloadUrlGzippedB\0\x12\x18\n\x06sha256\x18\t\x20\x01(\tR\x06sha25\
    6B\0:\0\"\xcf\x01\n\x13AndroidAppPatchData\x12*\n\x0fbaseVersionCode\x18\
    \x01\x20\x01(\x05R\x0fbaseVersionCodeB\0\x12\x1c\n\x08baseSha1\x18\x02\
    \x20\x01(\tR\x08baseSha1B\0\x12\"\n\x0bdownloadUrl\x18\x03\x20\x01(\tR\
    \x0bdownloadUrlB\0\x12\"\n\x0bpatchFormat\x18\x04\x20\x01(\x05R\x0bpatch\
    FormatB\0\x12$\n\x0cmaxPatchSize\x18\x05\x20\x01(\x03R\x0cmaxPatchSizeB\
    \0:\0\"\xfb\x01\n\x0fAppFileMetadata\x12\x1c\n\x08fileType\x18\x01\x20\
    \x01(\x05R\x08fileTypeB\0\x12\"\n\x0bversionCode\x18\x02\x20\x01(\x05R\
    \x0bversionCodeB\0\x12\x14\n\x04size\x18\x03\x20\x01(\x03R\x04sizeB\0\
    \x12\"\n\x0bdownloadUrl\x18\x04\x20\x01(\tR\x0bdownloadUrlB\0\x12\"\n\
    \x0bsizeGzipped\x18\x06\x20\x01(\x03R\x0bsizeGzippedB\0\x120\n\x12downlo\
    adUrlGzipped\x18\x07\x20\x01(\tR\x12downloadUrlGzippedB\0\x12\x14\n\x04s\
    ha1\x18\x08\x20\x01(\tR\x04sha1B\0:\0\"t\n\x10EncryptionParams\x12\x1a\n\
    \x07version\x18\x01\x20\x01(\x05R\x07versionB\0\x12&\n\rencryptionKey\
    \x18\x02\x20\x01(\tR\rencryptionKeyB\0\x12\x1a\n\x07hmacKey\x18\x03\x20\
    \x01(\tR\x07hmacKeyB\0:\0\"<\n\nHttpCookie\x12\x14\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\0\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\0:\
    \0\"\xf9\x03\n\x07Address\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\
    \0\x12$\n\x0caddressLine1\x18\x02\x20\x01(\tR\x0caddressLine1B\0\x12$\n\
    \x0caddressLine2\x18\x03\x20\x01(\tR\x0caddressLine2B\0\x12\x14\n\x04cit\
    y\x18\x04\x20\x01(\tR\x04cityB\0\x12\x16\n\x05state\x18\x05\x20\x01(\tR\
    \x05stateB\0\x12\x20\n\npostalCode\x18\x06\x20\x01(\tR\npostalCodeB\0\
    \x12&\n\rpostalCountry\x18\x07\x20\x01(\tR\rpostalCountryB\0\x12.\n\x11d\
    ependentLocality\x18\x08\x20\x01(\tR\x11dependentLocalityB\0\x12\"\n\x0b\
    sortingCode\x18\t\x20\x01(\tR\x0bsortingCodeB\0\x12$\n\x0clanguageCode\
    \x18\n\x20\x01(\tR\x0clanguageCodeB\0\x12\"\n\x0bphoneNumber\x18\x0b\x20\
    \x01(\tR\x0bphoneNumberB\0\x12\x1e\n\tisReduced\x18\x0c\x20\x01(\x08R\ti\
    sReducedB\0\x12\x1e\n\tfirstName\x18\r\x20\x01(\tR\tfirstNameB\0\x12\x1c\
    \n\x08lastName\x18\x0e\x20\x01(\tR\x08lastNameB\0\x12\x16\n\x05email\x18\
    \x0f\x20\x01(\tR\x05emailB\0:\0\"p\n\nBookAuthor\x12\x14\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\0\x12*\n\x0fdeprecatedQuery\x18\x02\x20\x01(\t\
    R\x0fdeprecatedQueryB\0\x12\x1e\n\x05docid\x18\x03\x20\x01(\x0b2\x06.Doc\
    idR\x05docidB\0:\0\"\xcd\x05\n\x0bBookDetails\x12(\n\x07subject\x18\x03\
    \x20\x03(\x0b2\x0c.BookSubjectR\x07subjectB\0\x12\x1e\n\tpublisher\x18\
    \x04\x20\x01(\tR\tpublisherB\0\x12*\n\x0fpublicationDate\x18\x05\x20\x01\
    (\tR\x0fpublicationDateB\0\x12\x14\n\x04isbn\x18\x06\x20\x01(\tR\x04isbn\
    B\0\x12&\n\rnumberOfPages\x18\x07\x20\x01(\x05R\rnumberOfPagesB\0\x12\
    \x1c\n\x08subtitle\x18\x08\x20\x01(\tR\x08subtitleB\0\x12%\n\x06author\
    \x18\t\x20\x03(\x0b2\x0b.BookAuthorR\x06authorB\0\x12\x1e\n\treaderUrl\
    \x18\n\x20\x01(\tR\treaderUrlB\0\x12*\n\x0fdownloadEpubUrl\x18\x0b\x20\
    \x01(\tR\x0fdownloadEpubUrlB\0\x12(\n\x0edownloadPdfUrl\x18\x0c\x20\x01(\
    \tR\x0edownloadPdfUrlB\0\x12*\n\x0facsEpubTokenUrl\x18\r\x20\x01(\tR\x0f\
    acsEpubTokenUrlB\0\x12(\n\x0eacsPdfTokenUrl\x18\x0e\x20\x01(\tR\x0eacsPd\
    fTokenUrlB\0\x12&\n\repubAvailable\x18\x0f\x20\x01(\x08R\repubAvailableB\
    \0\x12$\n\x0cpdfAvailable\x18\x10\x20\x01(\x08R\x0cpdfAvailableB\0\x12(\
    \n\x0eaboutTheAuthor\x18\x11\x20\x01(\tR\x0eaboutTheAuthorB\0\x129\n\nid\
    entifier\x18\x12\x20\x03(\n2\x17.BookDetails.IdentifierR\nidentifierB\0\
    \x1aD\n\nIdentifier\x12\x14\n\x04type\x18\x13\x20\x01(\x05R\x04typeB\0\
    \x12\x20\n\nidentifier\x18\x14\x20\x01(\tR\nidentifierB\0:\0\"]\n\x0bBoo\
    kSubject\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12\x16\n\x05q\
    uery\x18\x02\x20\x01(\tR\x05queryB\0\x12\x1e\n\tsubjectId\x18\x03\x20\
    \x01(\tR\tsubjectIdB\0:\0\"\xb7\x01\n\nBrowseLink\x12\x14\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\0\x12\x1a\n\x07dataUrl\x18\x03\x20\x01(\tR\x07\
    dataUrlB\0\x12\x1c\n\x04icon\x18\x05\x20\x01(\x0b2\x06.ImageR\x04iconB\0\
    \x12W\n\x18unknownCategoryContainer\x18\x04\x20\x01(\x0b2\x19.UnknownCat\
    egoryContainerR\x18unknownCategoryContainerB\0:\0\"f\n\x18UnknownCategor\
    yContainer\x12H\n\x13categoryIdContainer\x18\x05\x20\x01(\x0b2\x14.Categ\
    oryIdContainerR\x13categoryIdContainerB\0:\0\"9\n\x13CategoryIdContainer\
    \x12\x20\n\ncategoryId\x18\x04\x20\x01(\tR\ncategoryIdB\0:\0\"\xf2\x01\n\
    \x0eBrowseResponse\x12\"\n\x0bcontentsUrl\x18\x01\x20\x01(\tR\x0bcontent\
    sUrlB\0\x12\x1c\n\x08promoUrl\x18\x02\x20\x01(\tR\x08promoUrlB\0\x12)\n\
    \x08category\x18\x03\x20\x03(\x0b2\x0b.BrowseLinkR\x08categoryB\0\x12-\n\
    \nbreadcrumb\x18\x04\x20\x03(\x0b2\x0b.BrowseLinkR\nbreadcrumbB\0\x12B\n\
    \x11categoryContainer\x18\t\x20\x01(\x0b2\x12.CategoryContainerR\x11cate\
    goryContainerB\0:\0\"@\n\x11CategoryContainer\x12)\n\x08category\x18\x04\
    \x20\x03(\x0b2\x0b.BrowseLinkR\x08categoryB\0:\0\"\xa8\x03\n\x10AddressC\
    hallenge\x124\n\x14responseAddressParam\x18\x01\x20\x01(\tR\x14responseA\
    ddressParamB\0\x12:\n\x17responseCheckboxesParam\x18\x02\x20\x01(\tR\x17\
    responseCheckboxesParamB\0\x12\x16\n\x05title\x18\x03\x20\x01(\tR\x05tit\
    leB\0\x12*\n\x0fdescriptionHtml\x18\x04\x20\x01(\tR\x0fdescriptionHtmlB\
    \0\x12+\n\x08checkbox\x18\x05\x20\x03(\x0b2\r.FormCheckboxR\x08checkboxB\
    \0\x12$\n\x07address\x18\x06\x20\x01(\x0b2\x08.AddressR\x07addressB\0\
    \x12A\n\x0ferrorInputField\x18\x07\x20\x03(\x0b2\x15.InputValidationErro\
    rR\x0ferrorInputFieldB\0\x12\x1e\n\terrorHtml\x18\x08\x20\x01(\tR\terror\
    HtmlB\0\x12&\n\rrequiredField\x18\t\x20\x03(\x05R\rrequiredFieldB\0:\0\"\
    \x9d\x03\n\x17AuthenticationChallenge\x120\n\x12authenticationType\x18\
    \x01\x20\x01(\x05R\x12authenticationTypeB\0\x12J\n\x1fresponseAuthentica\
    tionTypeParam\x18\x02\x20\x01(\tR\x1fresponseAuthenticationTypeParamB\0\
    \x12:\n\x17responseRetryCountParam\x18\x03\x20\x01(\tR\x17responseRetryC\
    ountParamB\0\x12&\n\rpinHeaderText\x18\x04\x20\x01(\tR\rpinHeaderTextB\0\
    \x128\n\x16pinDescriptionTextHtml\x18\x05\x20\x01(\tR\x16pinDescriptionT\
    extHtmlB\0\x12(\n\x0egaiaHeaderText\x18\x06\x20\x01(\tR\x0egaiaHeaderTex\
    tB\0\x12:\n\x17gaiaDescriptionTextHtml\x18\x07\x20\x01(\tR\x17gaiaDescri\
    ptionTextHtmlB\0:\0\"\x85\t\n\x0bBuyResponse\x12K\n\x10purchaseResponse\
    \x18\x01\x20\x01(\x0b2\x1d.PurchaseNotificationResponseR\x10purchaseResp\
    onseB\0\x12?\n\x0ccheckoutinfo\x18\x02\x20\x01(\n2\x19.BuyResponse.Check\
    outInfoR\x0ccheckoutinfoB\0\x12(\n\x0econtinueViaUrl\x18\x08\x20\x01(\tR\
    \x0econtinueViaUrlB\0\x12.\n\x11purchaseStatusUrl\x18\t\x20\x01(\tR\x11p\
    urchaseStatusUrlB\0\x12.\n\x11checkoutServiceId\x18\x0c\x20\x01(\tR\x11c\
    heckoutServiceIdB\0\x126\n\x15checkoutTokenRequired\x18\r\x20\x01(\x08R\
    \x15checkoutTokenRequiredB\0\x12*\n\x0fbaseCheckoutUrl\x18\x0e\x20\x01(\
    \tR\x0fbaseCheckoutUrlB\0\x12*\n\x0ftosCheckboxHtml\x18%\x20\x03(\tR\x0f\
    tosCheckboxHtmlB\0\x120\n\x12iabPermissionError\x18&\x20\x01(\x05R\x12ia\
    bPermissionErrorB\0\x12Q\n\x16purchaseStatusResponse\x18'\x20\x01(\x0b2\
    \x17.PurchaseStatusResponseR\x16purchaseStatusResponseB\0\x12(\n\x0epurc\
    haseCookie\x18.\x20\x01(\tR\x0epurchaseCookieB\0\x12*\n\tchallenge\x181\
    \x20\x01(\x0b2\n.ChallengeR\tchallengeB\0\x12&\n\rdownloadToken\x187\x20\
    \x01(\tR\rdownloadTokenB\0\x1a\xc8\x03\n\x0cCheckoutInfo\x12\x1f\n\x04it\
    em\x18\x03\x20\x01(\x0b2\t.LineItemR\x04itemB\0\x12%\n\x07subItem\x18\
    \x04\x20\x03(\x0b2\t.LineItemR\x07subItemB\0\x12E\n\x0echeckoutoption\
    \x18\x05\x20\x03(\n2\x1b.BuyResponse.CheckoutOptionR\x0echeckoutoptionB\
    \0\x126\n\x15deprecatedCheckoutUrl\x18\n\x20\x01(\tR\x15deprecatedChecko\
    utUrlB\0\x12,\n\x10addInstrumentUrl\x18\x0b\x20\x01(\tR\x10addInstrument\
    UrlB\0\x12\x20\n\nfooterHtml\x18\x14\x20\x03(\tR\nfooterHtmlB\0\x12<\n\
    \x18eligibleInstrumentFamily\x18\x1f\x20\x03(\x05R\x18eligibleInstrument\
    FamilyB\0\x12$\n\x0cfootnoteHtml\x18$\x20\x03(\tR\x0cfootnoteHtmlB\0\x12\
    =\n\x12eligibleInstrument\x18,\x20\x03(\x0b2\x0b.InstrumentR\x12eligible\
    InstrumentB\0:\0\"\xa4\x01\n\tChallenge\x12?\n\x10addressChallenge\x18\
    \x01\x20\x01(\x0b2\x11.AddressChallengeR\x10addressChallengeB\0\x12T\n\
    \x17authenticationChallenge\x18\x02\x20\x01(\x0b2\x18.AuthenticationChal\
    lengeR\x17authenticationChallengeB\0:\0\"n\n\x0cFormCheckbox\x12\"\n\x0b\
    description\x18\x01\x20\x01(\tR\x0bdescriptionB\0\x12\x1a\n\x07checked\
    \x18\x02\x20\x01(\x08R\x07checkedB\0\x12\x1c\n\x08required\x18\x03\x20\
    \x01(\x08R\x08requiredB\0:\0\"\x88\x01\n\x08LineItem\x12\x14\n\x04name\
    \x18\x01\x20\x01(\tR\x04nameB\0\x12\"\n\x0bdescription\x18\x02\x20\x01(\
    \tR\x0bdescriptionB\0\x12\x1e\n\x05offer\x18\x03\x20\x01(\x0b2\x06.Offer\
    R\x05offerB\0\x12\x20\n\x06amount\x18\x04\x20\x01(\x0b2\x06.MoneyR\x06am\
    ountB\0:\0\"u\n\x05Money\x12\x18\n\x06micros\x18\x01\x20\x01(\x03R\x06mi\
    crosB\0\x12$\n\x0ccurrencyCode\x18\x02\x20\x01(\tR\x0ccurrencyCodeB\0\
    \x12*\n\x0fformattedAmount\x18\x03\x20\x01(\tR\x0fformattedAmountB\0:\0\
    \"\xc0\x01\n\x1cPurchaseNotificationResponse\x12\x18\n\x06status\x18\x01\
    \x20\x01(\x05R\x06statusB\0\x12*\n\tdebugInfo\x18\x02\x20\x01(\x0b2\n.De\
    bugInfoR\tdebugInfoB\0\x126\n\x15localizedErrorMessage\x18\x03\x20\x01(\
    \tR\x15localizedErrorMessageB\0\x12\x20\n\npurchaseId\x18\x04\x20\x01(\t\
    R\npurchaseIdB\0:\0\"\xf6\x02\n\x16PurchaseStatusResponse\x12\x18\n\x06s\
    tatus\x18\x01\x20\x01(\x05R\x06statusB\0\x12\x1e\n\tstatusMsg\x18\x02\
    \x20\x01(\tR\tstatusMsgB\0\x12\"\n\x0bstatusTitle\x18\x03\x20\x01(\tR\
    \x0bstatusTitleB\0\x12$\n\x0cbriefMessage\x18\x04\x20\x01(\tR\x0cbriefMe\
    ssageB\0\x12\x1a\n\x07infoUrl\x18\x05\x20\x01(\tR\x07infoUrlB\0\x126\n\r\
    libraryUpdate\x18\x06\x20\x01(\x0b2\x0e.LibraryUpdateR\rlibraryUpdateB\0\
    \x12=\n\x12rejectedInstrument\x18\x07\x20\x01(\x0b2\x0b.InstrumentR\x12r\
    ejectedInstrumentB\0\x12C\n\x0fappDeliveryData\x18\x08\x20\x01(\x0b2\x17\
    .AndroidAppDeliveryDataR\x0fappDeliveryDataB\0:\0\"Y\n\x10DeliveryRespon\
    se\x12C\n\x0fappDeliveryData\x18\x02\x20\x01(\x0b2\x17.AndroidAppDeliver\
    yDataR\x0fappDeliveryDataB\0:\0\"a\n\x05Docid\x12$\n\x0cbackendDocid\x18\
    \x01\x20\x01(\tR\x0cbackendDocidB\0\x12\x14\n\x04type\x18\x02\x20\x01(\
    \x05R\x04typeB\0\x12\x1a\n\x07backend\x18\x03\x20\x01(\x05R\x07backendB\
    \0:\0\"c\n\x07Install\x12\x1e\n\tandroidId\x18\x01\x20\x01(\x06R\tandroi\
    dIdB\0\x12\x1a\n\x07version\x18\x02\x20\x01(\x05R\x07versionB\0\x12\x1a\
    \n\x07bundled\x18\x03\x20\x01(\x08R\x07bundledB\0:\0\"\x81\x06\n\x05Offe\
    r\x12\x18\n\x06micros\x18\x01\x20\x01(\x03R\x06microsB\0\x12$\n\x0ccurre\
    ncyCode\x18\x02\x20\x01(\tR\x0ccurrencyCodeB\0\x12*\n\x0fformattedAmount\
    \x18\x03\x20\x01(\tR\x0fformattedAmountB\0\x120\n\x0econvertedPrice\x18\
    \x04\x20\x03(\x0b2\x06.OfferR\x0econvertedPriceB\0\x124\n\x14checkoutFlo\
    wRequired\x18\x05\x20\x01(\x08R\x14checkoutFlowRequiredB\0\x12*\n\x0fful\
    lPriceMicros\x18\x06\x20\x01(\x03R\x0ffullPriceMicrosB\0\x122\n\x13forma\
    ttedFullAmount\x18\x07\x20\x01(\tR\x13formattedFullAmountB\0\x12\x1e\n\t\
    offerType\x18\x08\x20\x01(\x05R\tofferTypeB\0\x120\n\x0brentalTerms\x18\
    \t\x20\x01(\x0b2\x0c.RentalTermsR\x0brentalTermsB\0\x12\x20\n\nonSaleDat\
    e\x18\n\x20\x01(\x03R\nonSaleDateB\0\x12(\n\x0epromotionLabel\x18\x0b\
    \x20\x03(\tR\x0epromotionLabelB\0\x12B\n\x11subscriptionTerms\x18\x0c\
    \x20\x01(\x0b2\x12.SubscriptionTermsR\x11subscriptionTermsB\0\x12&\n\rfo\
    rmattedName\x18\r\x20\x01(\tR\rformattedNameB\0\x124\n\x14formattedDescr\
    iption\x18\x0e\x20\x01(\tR\x14formattedDescriptionB\0\x12\x14\n\x04sale\
    \x18\x16\x20\x01(\x08R\x04saleB\0\x12\x1a\n\x07message\x18\x1a\x20\x01(\
    \tR\x07messageB\0\x12,\n\x10saleEndTimestamp\x18\x1e\x20\x01(\x03R\x10sa\
    leEndTimestampB\0\x12\"\n\x0bsaleMessage\x18\x1f\x20\x01(\tR\x0bsaleMess\
    ageB\0:\0\"\xb7\x02\n\rOwnershipInfo\x12:\n\x17initiationTimestampMsec\
    \x18\x01\x20\x01(\x03R\x17initiationTimestampMsecB\0\x12:\n\x17validUnti\
    lTimestampMsec\x18\x02\x20\x01(\x03R\x17validUntilTimestampMsecB\0\x12$\
    \n\x0cautoRenewing\x18\x03\x20\x01(\x08R\x0cautoRenewingB\0\x12@\n\x1are\
    fundTimeoutTimestampMsec\x18\x04\x20\x01(\x03R\x1arefundTimeoutTimestamp\
    MsecB\0\x12D\n\x1cpostDeliveryRefundWindowMsec\x18\x05\x20\x01(\x03R\x1c\
    postDeliveryRefundWindowMsecB\0:\0\"y\n\x0bRentalTerms\x120\n\x12grantPe\
    riodSeconds\x18\x01\x20\x01(\x05R\x12grantPeriodSecondsB\0\x126\n\x15act\
    ivatePeriodSeconds\x18\x02\x20\x01(\x05R\x15activatePeriodSecondsB\0:\0\
    \"\x7f\n\x11SubscriptionTerms\x127\n\x0frecurringPeriod\x18\x01\x20\x01(\
    \x0b2\x0b.TimePeriodR\x0frecurringPeriodB\0\x12/\n\x0btrialPeriod\x18\
    \x02\x20\x01(\x0b2\x0b.TimePeriodR\x0btrialPeriodB\0:\0\"<\n\nTimePeriod\
    \x12\x14\n\x04unit\x18\x01\x20\x01(\x05R\x04unitB\0\x12\x16\n\x05count\
    \x18\x02\x20\x01(\x05R\x05countB\0:\0\"p\n\x12BillingAddressSpec\x120\n\
    \x12billingAddressType\x18\x01\x20\x01(\x05R\x12billingAddressTypeB\0\
    \x12&\n\rrequiredField\x18\x02\x20\x03(\x05R\rrequiredFieldB\0:\0\"W\n\
    \x19CarrierBillingCredentials\x12\x16\n\x05value\x18\x01\x20\x01(\tR\x05\
    valueB\0\x12\x20\n\nexpiration\x18\x02\x20\x01(\x03R\nexpirationB\0:\0\"\
    \xc7\x03\n\x18CarrierBillingInstrument\x12&\n\rinstrumentKey\x18\x01\x20\
    \x01(\tR\rinstrumentKeyB\0\x12\"\n\x0baccountType\x18\x02\x20\x01(\tR\
    \x0baccountTypeB\0\x12$\n\x0ccurrencyCode\x18\x03\x20\x01(\tR\x0ccurrenc\
    yCodeB\0\x12,\n\x10transactionLimit\x18\x04\x20\x01(\x03R\x10transaction\
    LimitB\0\x124\n\x14subscriberIdentifier\x18\x05\x20\x01(\tR\x14subscribe\
    rIdentifierB\0\x12T\n\x17encryptedSubscriberInfo\x18\x06\x20\x01(\x0b2\
    \x18.EncryptedSubscriberInfoR\x17encryptedSubscriberInfoB\0\x12>\n\x0bcr\
    edentials\x18\x07\x20\x01(\x0b2\x1a.CarrierBillingCredentialsR\x0bcreden\
    tialsB\0\x12=\n\x12acceptedCarrierTos\x18\x08\x20\x01(\x0b2\x0b.CarrierT\
    osR\x12acceptedCarrierTosB\0:\0\"\xb4\x02\n\x1eCarrierBillingInstrumentS\
    tatus\x12-\n\ncarrierTos\x18\x01\x20\x01(\x0b2\x0b.CarrierTosR\ncarrierT\
    osB\0\x122\n\x13associationRequired\x18\x02\x20\x01(\x08R\x13association\
    RequiredB\0\x12,\n\x10passwordRequired\x18\x03\x20\x01(\x08R\x10password\
    RequiredB\0\x12G\n\x15carrierPasswordPrompt\x18\x04\x20\x01(\x0b2\x0f.Pa\
    sswordPromptR\x15carrierPasswordPromptB\0\x12\x20\n\napiVersion\x18\x05\
    \x20\x01(\x05R\napiVersionB\0\x12\x14\n\x04name\x18\x06\x20\x01(\tR\x04n\
    ameB\0:\0\"\xd6\x01\n\nCarrierTos\x12*\n\x06dcbTos\x18\x01\x20\x01(\x0b2\
    \x10.CarrierTosEntryR\x06dcbTosB\0\x12*\n\x06piiTos\x18\x02\x20\x01(\x0b\
    2\x10.CarrierTosEntryR\x06piiTosB\0\x126\n\x15needsDcbTosAcceptance\x18\
    \x03\x20\x01(\x08R\x15needsDcbTosAcceptanceB\0\x126\n\x15needsPiiTosAcce\
    ptance\x18\x04\x20\x01(\x08R\x15needsPiiTosAcceptanceB\0:\0\"C\n\x0fCarr\
    ierTosEntry\x12\x12\n\x03url\x18\x01\x20\x01(\tR\x03urlB\0\x12\x1a\n\x07\
    version\x18\x02\x20\x01(\tR\x07versionB\0:\0\"\x81\x02\n\x14CreditCardIn\
    strument\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04typeB\0\x12$\n\x0ces\
    crowHandle\x18\x02\x20\x01(\tR\x0cescrowHandleB\0\x12\x20\n\nlastDigits\
    \x18\x03\x20\x01(\tR\nlastDigitsB\0\x12*\n\x0fexpirationMonth\x18\x04\
    \x20\x01(\x05R\x0fexpirationMonthB\0\x12(\n\x0eexpirationYear\x18\x05\
    \x20\x01(\x05R\x0eexpirationYearB\0\x123\n\x0eescrowEfeParam\x18\x06\x20\
    \x03(\x0b2\t.EfeParamR\x0eescrowEfeParamB\0:\0\"8\n\x08EfeParam\x12\x12\
    \n\x03key\x18\x01\x20\x01(\x05R\x03keyB\0\x12\x16\n\x05value\x18\x02\x20\
    \x01(\tR\x05valueB\0:\0\"`\n\x14InputValidationError\x12\x20\n\ninputFie\
    ld\x18\x01\x20\x01(\x05R\ninputFieldB\0\x12$\n\x0cerrorMessage\x18\x02\
    \x20\x01(\tR\x0cerrorMessageB\0:\0\"\xd8\x03\n\nInstrument\x12$\n\x0cins\
    trumentId\x18\x01\x20\x01(\tR\x0cinstrumentIdB\0\x122\n\x0ebillingAddres\
    s\x18\x02\x20\x01(\x0b2\x08.AddressR\x0ebillingAddressB\0\x127\n\ncredit\
    Card\x18\x03\x20\x01(\x0b2\x15.CreditCardInstrumentR\ncreditCardB\0\x12C\
    \n\x0ecarrierBilling\x18\x04\x20\x01(\x0b2\x19.CarrierBillingInstrumentR\
    \x0ecarrierBillingB\0\x12E\n\x12billingAddressSpec\x18\x05\x20\x01(\x0b2\
    \x13.BillingAddressSpecR\x12billingAddressSpecB\0\x12,\n\x10instrumentFa\
    mily\x18\x06\x20\x01(\x05R\x10instrumentFamilyB\0\x12U\n\x14carrierBilli\
    ngStatus\x18\x07\x20\x01(\x0b2\x1f.CarrierBillingInstrumentStatusR\x14ca\
    rrierBillingStatusB\0\x12$\n\x0cdisplayTitle\x18\x08\x20\x01(\tR\x0cdisp\
    layTitleB\0:\0\"\\\n\x0ePasswordPrompt\x12\x18\n\x06prompt\x18\x01\x20\
    \x01(\tR\x06promptB\0\x12.\n\x11forgotPasswordUrl\x18\x02\x20\x01(\tR\
    \x11forgotPasswordUrlB\0:\0\"\xef\x01\n\x11ContainerMetadata\x12\x1e\n\t\
    browseUrl\x18\x01\x20\x01(\tR\tbrowseUrlB\0\x12\"\n\x0bnextPageUrl\x18\
    \x02\x20\x01(\tR\x0bnextPageUrlB\0\x12\x1e\n\trelevance\x18\x03\x20\x01(\
    \x01R\trelevanceB\0\x12,\n\x10estimatedResults\x18\x04\x20\x01(\x03R\x10\
    estimatedResultsB\0\x12*\n\x0fanalyticsCookie\x18\x05\x20\x01(\tR\x0fana\
    lyticsCookieB\0\x12\x1a\n\x07ordered\x18\x06\x20\x01(\x08R\x07orderedB\0\
    :\0\"\x94\x01\n\tDebugInfo\x12\x1a\n\x07message\x18\x01\x20\x03(\tR\x07m\
    essageB\0\x12+\n\x06timing\x18\x02\x20\x03(\n2\x11.DebugInfo.TimingR\x06\
    timingB\0\x1a<\n\x06Timing\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04name\
    B\0\x12\x1c\n\x08timeInMs\x18\x04\x20\x01(\x01R\x08timeInMsB\0:\0\"0\n\
    \x10BulkDetailsEntry\x12\x1a\n\x03doc\x18\x01\x20\x01(\x0b2\x06.DocV2R\
    \x03docB\0:\0\"\\\n\x12BulkDetailsRequest\x12\x16\n\x05docid\x18\x01\x20\
    \x03(\tR\x05docidB\0\x12,\n\x10includeChildDocs\x18\x02\x20\x01(\x08R\
    \x10includeChildDocsB\0:\0\"B\n\x13BulkDetailsResponse\x12)\n\x05entry\
    \x18\x01\x20\x03(\x0b2\x11.BulkDetailsEntryR\x05entryB\0:\0\"\xaf\x03\n\
    \x0fDetailsResponse\x12\x1e\n\x05docV1\x18\x01\x20\x01(\x0b2\x06.DocV1R\
    \x05docV1B\0\x12*\n\x0fanalyticsCookie\x18\x02\x20\x01(\tR\x0fanalyticsC\
    ookieB\0\x12)\n\nuserReview\x18\x03\x20\x01(\x0b2\x07.ReviewR\nuserRevie\
    wB\0\x12\x1e\n\x05docV2\x18\x04\x20\x01(\x0b2\x06.DocV2R\x05docV2B\0\x12\
    \x20\n\nfooterHtml\x18\x05\x20\x01(\tR\nfooterHtmlB\0\x12\x1e\n\x05badge\
    \x18\x07\x20\x03(\x0b2\x06.BadgeR\x05badgeB\0\x12'\n\x08features\x18\x0c\
    \x20\x01(\x0b2\t.FeaturesR\x08featuresB\0\x12,\n\x10detailsStreamUrl\x18\
    \r\x20\x01(\tR\x10detailsStreamUrlB\0\x12&\n\ruserReviewUrl\x18\x0e\x20\
    \x01(\tR\ruserReviewUrlB\0\x12B\n\x1bpostAcquireDetailsStreamUrl\x18\x11\
    \x20\x01(\tR\x1bpostAcquireDetailsStreamUrlB\0:\0\"\x9b\x01\n\x05Badge\
    \x12\x16\n\x05label\x18\x01\x20\x01(\tR\x05labelB\0\x12\x1e\n\x05image\
    \x18\x02\x20\x01(\x0b2\x06.ImageR\x05imageB\0\x12<\n\x0fbadgeContainer1\
    \x18\x04\x20\x01(\x0b2\x10.BadgeContainer1R\x0fbadgeContainer1B\0\x12\
    \x1a\n\x07message\x18\x0b\x20\x01(\tR\x07messageB\0:\0\"Q\n\x0fBadgeCont\
    ainer1\x12<\n\x0fbadgeContainer2\x18\x01\x20\x01(\x0b2\x10.BadgeContaine\
    r2R\x0fbadgeContainer2B\0:\0\"Z\n\x0fBadgeContainer2\x12E\n\x12badgeLink\
    Container\x18\x02\x20\x01(\x0b2\x13.BadgeLinkContainerR\x12badgeLinkCont\
    ainerB\0:\0\",\n\x12BadgeLinkContainer\x12\x14\n\x04link\x18\x02\x20\x01\
    (\tR\x04linkB\0:\0\"t\n\x08Features\x124\n\x0ffeaturePresence\x18\x01\
    \x20\x03(\x0b2\x08.FeatureR\x0ffeaturePresenceB\0\x120\n\rfeatureRating\
    \x18\x02\x20\x03(\x0b2\x08.FeatureR\rfeatureRatingB\0:\0\";\n\x07Feature\
    \x12\x16\n\x05label\x18\x01\x20\x01(\tR\x05labelB\0\x12\x16\n\x05value\
    \x18\x03\x20\x01(\tR\x05valueB\0:\0\"\xec\x05\n\x18DeviceConfigurationPr\
    oto\x12\"\n\x0btouchScreen\x18\x01\x20\x01(\x05R\x0btouchScreenB\0\x12\
    \x1c\n\x08keyboard\x18\x02\x20\x01(\x05R\x08keyboardB\0\x12\x20\n\nnavig\
    ation\x18\x03\x20\x01(\x05R\nnavigationB\0\x12$\n\x0cscreenLayout\x18\
    \x04\x20\x01(\x05R\x0cscreenLayoutB\0\x12*\n\x0fhasHardKeyboard\x18\x05\
    \x20\x01(\x08R\x0fhasHardKeyboardB\0\x124\n\x14hasFiveWayNavigation\x18\
    \x06\x20\x01(\x08R\x14hasFiveWayNavigationB\0\x12&\n\rscreenDensity\x18\
    \x07\x20\x01(\x05R\rscreenDensityB\0\x12\"\n\x0bglEsVersion\x18\x08\x20\
    \x01(\x05R\x0bglEsVersionB\0\x122\n\x13systemSharedLibrary\x18\t\x20\x03\
    (\tR\x13systemSharedLibraryB\0\x128\n\x16systemAvailableFeature\x18\n\
    \x20\x03(\tR\x16systemAvailableFeatureB\0\x12(\n\x0enativePlatform\x18\
    \x0b\x20\x03(\tR\x0enativePlatformB\0\x12\"\n\x0bscreenWidth\x18\x0c\x20\
    \x01(\x05R\x0bscreenWidthB\0\x12$\n\x0cscreenHeight\x18\r\x20\x01(\x05R\
    \x0cscreenHeightB\0\x126\n\x15systemSupportedLocale\x18\x0e\x20\x03(\tR\
    \x15systemSupportedLocaleB\0\x12\"\n\x0bglExtension\x18\x0f\x20\x03(\tR\
    \x0bglExtensionB\0\x12\"\n\x0bdeviceClass\x18\x10\x20\x01(\x05R\x0bdevic\
    eClassB\0\x124\n\x14maxApkDownloadSizeMb\x18\x11\x20\x01(\x05R\x14maxApk\
    DownloadSizeMbB\0:\0\"\xf5\x05\n\x08Document\x12\x1e\n\x05docid\x18\x01\
    \x20\x01(\x0b2\x06.DocidR\x05docidB\0\x12(\n\nfetchDocid\x18\x02\x20\x01\
    (\x0b2\x06.DocidR\nfetchDocidB\0\x12*\n\x0bsampleDocid\x18\x03\x20\x01(\
    \x0b2\x06.DocidR\x0bsampleDocidB\0\x12\x16\n\x05title\x18\x04\x20\x01(\t\
    R\x05titleB\0\x12\x12\n\x03url\x18\x05\x20\x01(\tR\x03urlB\0\x12\x1a\n\
    \x07snippet\x18\x06\x20\x03(\tR\x07snippetB\0\x122\n\x0fpriceDeprecated\
    \x18\x07\x20\x01(\x0b2\x06.OfferR\x0fpriceDeprecatedB\0\x123\n\x0cavaila\
    bility\x18\t\x20\x01(\x0b2\r.AvailabilityR\x0cavailabilityB\0\x12\x1e\n\
    \x05image\x18\n\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12!\n\x05child\x18\
    \x0b\x20\x03(\x0b2\t.DocumentR\x05childB\0\x12<\n\x0faggregateRating\x18\
    \r\x20\x01(\x0b2\x10.AggregateRatingR\x0faggregateRatingB\0\x12\x1e\n\
    \x05offer\x18\x0e\x20\x03(\x0b2\x06.OfferR\x05offerB\0\x12?\n\x11transla\
    tedSnippet\x18\x0f\x20\x03(\x0b2\x0f.TranslatedTextR\x11translatedSnippe\
    tB\0\x12<\n\x0fdocumentVariant\x18\x10\x20\x03(\x0b2\x10.DocumentVariant\
    R\x0fdocumentVariantB\0\x12\x20\n\ncategoryId\x18\x11\x20\x03(\tR\ncateg\
    oryIdB\0\x12+\n\ndecoration\x18\x12\x20\x03(\x0b2\t.DocumentR\ndecoratio\
    nB\0\x12#\n\x06parent\x18\x13\x20\x03(\x0b2\t.DocumentR\x06parentB\0\x12\
    ,\n\x10privacyPolicyUrl\x18\x14\x20\x01(\tR\x10privacyPolicyUrlB\0:\0\"\
    \x81\x03\n\x0fDocumentVariant\x12&\n\rvariationType\x18\x01\x20\x01(\x05\
    R\rvariationTypeB\0\x12\x1b\n\x04rule\x18\x02\x20\x01(\x0b2\x05.RuleR\
    \x04ruleB\0\x12\x16\n\x05title\x18\x03\x20\x01(\tR\x05titleB\0\x12\x1a\n\
    \x07snippet\x18\x04\x20\x03(\tR\x07snippetB\0\x12&\n\rrecentChanges\x18\
    \x05\x20\x01(\tR\rrecentChangesB\0\x12;\n\x0fautoTranslation\x18\x06\x20\
    \x03(\x0b2\x0f.TranslatedTextR\x0fautoTranslationB\0\x12\x1e\n\x05offer\
    \x18\x07\x20\x03(\x0b2\x06.OfferR\x05offerB\0\x12\x1e\n\tchannelId\x18\t\
    \x20\x01(\x03R\tchannelIdB\0\x12!\n\x05child\x18\n\x20\x03(\x0b2\t.Docum\
    entR\x05childB\0\x12+\n\ndecoration\x18\x0b\x20\x03(\x0b2\t.DocumentR\nd\
    ecorationB\0:\0\"\xb7\x04\n\x05Image\x12\x1e\n\timageType\x18\x01\x20\
    \x01(\x05R\timageTypeB\0\x120\n\tdimension\x18\x02\x20\x01(\n2\x10.Image\
    .DimensionR\tdimensionB\0\x12\x1c\n\x08imageUrl\x18\x05\x20\x01(\tR\x08i\
    mageUrlB\0\x12,\n\x10altTextLocalized\x18\x06\x20\x01(\tR\x10altTextLoca\
    lizedB\0\x12\x1e\n\tsecureUrl\x18\x07\x20\x01(\tR\tsecureUrlB\0\x120\n\
    \x12positionInSequence\x18\x08\x20\x01(\x05R\x12positionInSequenceB\0\
    \x128\n\x16supportsFifeUrlOptions\x18\t\x20\x01(\x08R\x16supportsFifeUrl\
    OptionsB\0\x12-\n\x08citation\x18\n\x20\x01(\n2\x0f.Image.CitationR\x08c\
    itationB\0\x12\x16\n\x05color\x18\x0f\x20\x01(\tR\x05colorB\0\x122\n\x13\
    screenshotSetNumber\x18\x15\x20\x01(\x05R\x13screenshotSetNumberB\0\x1a=\
    \n\tDimension\x12\x16\n\x05width\x18\x03\x20\x01(\x05R\x05widthB\0\x12\
    \x18\n\x06height\x18\x04\x20\x01(\x05R\x06heightB\0\x1aH\n\x08Citation\
    \x12(\n\x0etitleLocalized\x18\x0b\x20\x01(\tR\x0etitleLocalizedB\0\x12\
    \x12\n\x03url\x18\x0c\x20\x01(\tR\x03urlB\0:\0\"t\n\x0eTranslatedText\
    \x12\x14\n\x04text\x18\x01\x20\x01(\tR\x04textB\0\x12$\n\x0csourceLocale\
    \x18\x02\x20\x01(\tR\x0csourceLocaleB\0\x12$\n\x0ctargetLocale\x18\x03\
    \x20\x01(\tR\x0ctargetLocaleB\0:\0\"\xa2\x01\n\x0bPlusOneData\x12\x1e\n\
    \tsetByUser\x18\x01\x20\x01(\x08R\tsetByUserB\0\x12\x16\n\x05total\x18\
    \x02\x20\x01(\x03R\x05totalB\0\x12$\n\x0ccirclesTotal\x18\x03\x20\x01(\
    \x03R\x0ccirclesTotalB\0\x123\n\rcirclesPeople\x18\x04\x20\x03(\x0b2\x0b\
    .PlusPersonR\rcirclesPeopleB\0:\0\"^\n\nPlusPerson\x12\"\n\x0bdisplayNam\
    e\x18\x02\x20\x01(\tR\x0bdisplayNameB\0\x12*\n\x0fprofileImageUrl\x18\
    \x04\x20\x01(\tR\x0fprofileImageUrlB\0:\0\"\x89\x01\n\x0cAlbumDetails\
    \x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12)\n\x07details\x18\
    \x02\x20\x01(\x0b2\r.MusicDetailsR\x07detailsB\0\x126\n\rdisplayArtist\
    \x18\x03\x20\x01(\x0b2\x0e.ArtistDetailsR\rdisplayArtistB\0:\0\"\x95\x08\
    \n\nAppDetails\x12&\n\rdeveloperName\x18\x01\x20\x01(\tR\rdeveloperNameB\
    \0\x120\n\x12majorVersionNumber\x18\x02\x20\x01(\x05R\x12majorVersionNum\
    berB\0\x12\"\n\x0bversionCode\x18\x03\x20\x01(\x05R\x0bversionCodeB\0\
    \x12&\n\rversionString\x18\x04\x20\x01(\tR\rversionStringB\0\x12\x16\n\
    \x05title\x18\x05\x20\x01(\tR\x05titleB\0\x12\"\n\x0bappCategory\x18\x07\
    \x20\x03(\tR\x0bappCategoryB\0\x12&\n\rcontentRating\x18\x08\x20\x01(\
    \x05R\rcontentRatingB\0\x12,\n\x10installationSize\x18\t\x20\x01(\x03R\
    \x10installationSizeB\0\x12\x20\n\npermission\x18\n\x20\x03(\tR\npermiss\
    ionB\0\x12(\n\x0edeveloperEmail\x18\x0b\x20\x01(\tR\x0edeveloperEmailB\0\
    \x12,\n\x10developerWebsite\x18\x0c\x20\x01(\tR\x10developerWebsiteB\0\
    \x12$\n\x0cnumDownloads\x18\r\x20\x01(\tR\x0cnumDownloadsB\0\x12\"\n\x0b\
    packageName\x18\x0e\x20\x01(\tR\x0bpackageNameB\0\x12.\n\x11recentChange\
    sHtml\x18\x0f\x20\x01(\tR\x11recentChangesHtmlB\0\x12\x20\n\nuploadDate\
    \x18\x10\x20\x01(\tR\nuploadDateB\0\x12#\n\x04file\x18\x11\x20\x03(\x0b2\
    \r.FileMetadataR\x04fileB\0\x12\x1a\n\x07appType\x18\x12\x20\x01(\tR\x07\
    appTypeB\0\x12\x1c\n\x08unstable\x18\x15\x20\x01(\x08R\x08unstableB\0\
    \x12(\n\x0ehasInstantLink\x18\x18\x20\x01(\x08R\x0ehasInstantLinkB\0\x12\
    \"\n\x0bcontainsAds\x18\x1e\x20\x01(\tR\x0bcontainsAdsB\0\x123\n\x0cdepe\
    ndencies\x18\"\x20\x01(\x0b2\r.DependenciesR\x0cdependenciesB\0\x12E\n\
    \x12testingProgramInfo\x18#\x20\x01(\x0b2\x13.TestingProgramInfoR\x12tes\
    tingProgramInfoB\0\x12<\n\x0fearlyAccessInfo\x18$\x20\x01(\x0b2\x10.Earl\
    yAccessInfoR\x0fearlyAccessInfoB\0\x12\"\n\x0binstantLink\x18+\x20\x01(\
    \tR\x0binstantLinkB\0\x12,\n\x10developerAddress\x18-\x20\x01(\tR\x10dev\
    eloperAddressB\0:\0\"\x99\x01\n\x0cDependencies\x12\x1c\n\x08unknown1\
    \x18\x01\x20\x01(\x05R\x08unknown1B\0\x12\x1c\n\x08unknown2\x18\x02\x20\
    \x01(\x03R\x08unknown2B\0\x12-\n\ndependency\x18\x03\x20\x03(\x0b2\x0b.D\
    ependencyR\ndependencyB\0\x12\x1c\n\x08unknown3\x18\x04\x20\x01(\x05R\
    \x08unknown3B\0:\0\"l\n\nDependency\x12\"\n\x0bpackageName\x18\x01\x20\
    \x01(\tR\x0bpackageNameB\0\x12\x1a\n\x07version\x18\x02\x20\x01(\x05R\
    \x07versionB\0\x12\x1c\n\x08unknown4\x18\x04\x20\x01(\x05R\x08unknown4B\
    \0:\0\"\x90\x01\n\x12TestingProgramInfo\x12\x20\n\nsubscribed\x18\x02\
    \x20\x01(\x08R\nsubscribedB\0\x12\"\n\x0bsubscribed1\x18\x03\x20\x01(\
    \x08R\x0bsubscribed1B\0\x122\n\x13testingProgramEmail\x18\x05\x20\x01(\t\
    R\x13testingProgramEmailB\0:\0\"+\n\x0fEarlyAccessInfo\x12\x16\n\x05emai\
    l\x18\x03\x20\x01(\tR\x05emailB\0:\0\"\x87\x01\n\rArtistDetails\x12\x20\
    \n\ndetailsUrl\x18\x01\x20\x01(\tR\ndetailsUrlB\0\x12\x14\n\x04name\x18\
    \x02\x20\x01(\tR\x04nameB\0\x12<\n\rexternalLinks\x18\x03\x20\x01(\x0b2\
    \x14.ArtistExternalLinksR\rexternalLinksB\0:\0\"\x9f\x01\n\x13ArtistExte\
    rnalLinks\x12\x20\n\nwebsiteUrl\x18\x01\x20\x03(\tR\nwebsiteUrlB\0\x124\
    \n\x14googlePlusProfileUrl\x18\x02\x20\x01(\tR\x14googlePlusProfileUrlB\
    \0\x12.\n\x11youtubeChannelUrl\x18\x03\x20\x01(\tR\x11youtubeChannelUrlB\
    \0:\0\"\x87\x05\n\x0fDocumentDetails\x12-\n\nappDetails\x18\x01\x20\x01(\
    \x0b2\x0b.AppDetailsR\nappDetailsB\0\x123\n\x0calbumDetails\x18\x02\x20\
    \x01(\x0b2\r.AlbumDetailsR\x0calbumDetailsB\0\x126\n\rartistDetails\x18\
    \x03\x20\x01(\x0b2\x0e.ArtistDetailsR\rartistDetailsB\0\x120\n\x0bsongDe\
    tails\x18\x04\x20\x01(\x0b2\x0c.SongDetailsR\x0bsongDetailsB\0\x120\n\
    \x0bbookDetails\x18\x05\x20\x01(\x0b2\x0c.BookDetailsR\x0bbookDetailsB\0\
    \x123\n\x0cvideoDetails\x18\x06\x20\x01(\x0b2\r.VideoDetailsR\x0cvideoDe\
    tailsB\0\x12H\n\x13subscriptionDetails\x18\x07\x20\x01(\x0b2\x14.Subscri\
    ptionDetailsR\x13subscriptionDetailsB\0\x12<\n\x0fmagazineDetails\x18\
    \x08\x20\x01(\x0b2\x10.MagazineDetailsR\x0fmagazineDetailsB\0\x126\n\rtv\
    ShowDetails\x18\t\x20\x01(\x0b2\x0e.TvShowDetailsR\rtvShowDetailsB\0\x12\
    <\n\x0ftvSeasonDetails\x18\n\x20\x01(\x0b2\x10.TvSeasonDetailsR\x0ftvSea\
    sonDetailsB\0\x12?\n\x10tvEpisodeDetails\x18\x0b\x20\x01(\x0b2\x11.TvEpi\
    sodeDetailsR\x10tvEpisodeDetailsB\0:\0\"h\n\x0cFileMetadata\x12\x1c\n\
    \x08fileType\x18\x01\x20\x01(\x05R\x08fileTypeB\0\x12\"\n\x0bversionCode\
    \x18\x02\x20\x01(\x05R\x0bversionCodeB\0\x12\x14\n\x04size\x18\x03\x20\
    \x01(\x03R\x04sizeB\0:\0\"\x81\x02\n\x0fMagazineDetails\x12,\n\x10parent\
    DetailsUrl\x18\x01\x20\x01(\tR\x10parentDetailsUrlB\0\x12N\n!deviceAvail\
    abilityDescriptionHtml\x18\x02\x20\x01(\tR!deviceAvailabilityDescription\
    HtmlB\0\x12(\n\x0epsvDescription\x18\x03\x20\x01(\tR\x0epsvDescriptionB\
    \0\x12D\n\x1cdeliveryFrequencyDescription\x18\x04\x20\x01(\tR\x1cdeliver\
    yFrequencyDescriptionB\0:\0\"\xaa\x02\n\x0cMusicDetails\x12\x1e\n\tcenso\
    ring\x18\x01\x20\x01(\x05R\tcensoringB\0\x12\"\n\x0bdurationSec\x18\x02\
    \x20\x01(\x05R\x0bdurationSecB\0\x122\n\x13originalReleaseDate\x18\x03\
    \x20\x01(\tR\x13originalReleaseDateB\0\x12\x16\n\x05label\x18\x04\x20\
    \x01(\tR\x05labelB\0\x12(\n\x06artist\x18\x05\x20\x03(\x0b2\x0e.ArtistDe\
    tailsR\x06artistB\0\x12\x16\n\x05genre\x18\x06\x20\x03(\tR\x05genreB\0\
    \x12\"\n\x0breleaseDate\x18\x07\x20\x01(\tR\x0breleaseDateB\0\x12\"\n\
    \x0breleaseType\x18\x08\x20\x03(\x05R\x0breleaseTypeB\0:\0\"\xee\x01\n\
    \x0bSongDetails\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12)\n\
    \x07details\x18\x02\x20\x01(\x0b2\r.MusicDetailsR\x07detailsB\0\x12\x1e\
    \n\talbumName\x18\x03\x20\x01(\tR\talbumNameB\0\x12\"\n\x0btrackNumber\
    \x18\x04\x20\x01(\x05R\x0btrackNumberB\0\x12\x20\n\npreviewUrl\x18\x05\
    \x20\x01(\tR\npreviewUrlB\0\x126\n\rdisplayArtist\x18\x06\x20\x01(\x0b2\
    \x0e.ArtistDetailsR\rdisplayArtistB\0:\0\"I\n\x13SubscriptionDetails\x12\
    0\n\x12subscriptionPeriod\x18\x01\x20\x01(\x05R\x12subscriptionPeriodB\0\
    :\0\"\xa5\x01\n\x07Trailer\x12\x1e\n\ttrailerId\x18\x01\x20\x01(\tR\ttra\
    ilerIdB\0\x12\x16\n\x05title\x18\x02\x20\x01(\tR\x05titleB\0\x12$\n\x0ct\
    humbnailUrl\x18\x03\x20\x01(\tR\x0cthumbnailUrlB\0\x12\x1c\n\x08watchUrl\
    \x18\x04\x20\x01(\tR\x08watchUrlB\0\x12\x1c\n\x08duration\x18\x05\x20\
    \x01(\tR\x08durationB\0:\0\"\x8c\x01\n\x10TvEpisodeDetails\x12,\n\x10par\
    entDetailsUrl\x18\x01\x20\x01(\tR\x10parentDetailsUrlB\0\x12$\n\x0cepiso\
    deIndex\x18\x02\x20\x01(\x05R\x0cepisodeIndexB\0\x12\"\n\x0breleaseDate\
    \x18\x03\x20\x01(\tR\x0breleaseDateB\0:\0\"\xad\x01\n\x0fTvSeasonDetails\
    \x12,\n\x10parentDetailsUrl\x18\x01\x20\x01(\tR\x10parentDetailsUrlB\0\
    \x12\"\n\x0bseasonIndex\x18\x02\x20\x01(\x05R\x0bseasonIndexB\0\x12\"\n\
    \x0breleaseDate\x18\x03\x20\x01(\tR\x0breleaseDateB\0\x12\"\n\x0bbroadca\
    ster\x18\x04\x20\x01(\tR\x0bbroadcasterB\0:\0\"\x95\x01\n\rTvShowDetails\
    \x12\"\n\x0bseasonCount\x18\x01\x20\x01(\x05R\x0bseasonCountB\0\x12\x1e\
    \n\tstartYear\x18\x02\x20\x01(\x05R\tstartYearB\0\x12\x1a\n\x07endYear\
    \x18\x03\x20\x01(\x05R\x07endYearB\0\x12\"\n\x0bbroadcaster\x18\x04\x20\
    \x01(\tR\x0bbroadcasterB\0:\0\"a\n\x0bVideoCredit\x12\x20\n\ncreditType\
    \x18\x01\x20\x01(\x05R\ncreditTypeB\0\x12\x18\n\x06credit\x18\x02\x20\
    \x01(\tR\x06creditB\0\x12\x14\n\x04name\x18\x03\x20\x03(\tR\x04nameB\0:\
    \0\"\xca\x02\n\x0cVideoDetails\x12&\n\x06credit\x18\x01\x20\x03(\x0b2\
    \x0c.VideoCreditR\x06creditB\0\x12\x1c\n\x08duration\x18\x02\x20\x01(\tR\
    \x08durationB\0\x12\"\n\x0breleaseDate\x18\x03\x20\x01(\tR\x0breleaseDat\
    eB\0\x12&\n\rcontentRating\x18\x04\x20\x01(\tR\rcontentRatingB\0\x12\x16\
    \n\x05likes\x18\x05\x20\x01(\x03R\x05likesB\0\x12\x1c\n\x08dislikes\x18\
    \x06\x20\x01(\x03R\x08dislikesB\0\x12\x16\n\x05genre\x18\x07\x20\x03(\tR\
    \x05genreB\0\x12$\n\x07trailer\x18\x08\x20\x03(\x0b2\x08.TrailerR\x07tra\
    ilerB\0\x122\n\nrentalTerm\x18\t\x20\x03(\x0b2\x10.VideoRentalTermR\nren\
    talTermB\0:\0\"\xee\x01\n\x0fVideoRentalTerm\x12\x1e\n\tofferType\x18\
    \x01\x20\x01(\x05R\tofferTypeB\0\x12.\n\x11offerAbbreviation\x18\x02\x20\
    \x01(\tR\x11offerAbbreviationB\0\x12$\n\x0crentalHeader\x18\x03\x20\x01(\
    \tR\x0crentalHeaderB\0\x12+\n\x04term\x18\x04\x20\x03(\n2\x15.VideoRenta\
    lTerm.TermR\x04termB\0\x1a6\n\x04Term\x12\x18\n\x06header\x18\x05\x20\
    \x01(\tR\x06headerB\0\x12\x14\n\x04body\x18\x06\x20\x01(\tR\x04bodyB\0:\
    \0\"\xa2\x03\n\x06Bucket\x12$\n\x08document\x18\x01\x20\x03(\x0b2\x06.Do\
    cV1R\x08documentB\0\x12\"\n\x0bmultiCorpus\x18\x02\x20\x01(\x08R\x0bmult\
    iCorpusB\0\x12\x16\n\x05title\x18\x03\x20\x01(\tR\x05titleB\0\x12\x1a\n\
    \x07iconUrl\x18\x04\x20\x01(\tR\x07iconUrlB\0\x12*\n\x0ffullContentsUrl\
    \x18\x05\x20\x01(\tR\x0ffullContentsUrlB\0\x12\x1e\n\trelevance\x18\x06\
    \x20\x01(\x01R\trelevanceB\0\x12,\n\x10estimatedResults\x18\x07\x20\x01(\
    \x03R\x10estimatedResultsB\0\x12*\n\x0fanalyticsCookie\x18\x08\x20\x01(\
    \tR\x0fanalyticsCookieB\0\x122\n\x13fullContentsListUrl\x18\t\x20\x01(\t\
    R\x13fullContentsListUrlB\0\x12\"\n\x0bnextPageUrl\x18\n\x20\x01(\tR\x0b\
    nextPageUrlB\0\x12\x1a\n\x07ordered\x18\x0b\x20\x01(\x08R\x07orderedB\0:\
    \0\"O\n\x0cListResponse\x12!\n\x06bucket\x18\x01\x20\x03(\x0b2\x07.Bucke\
    tR\x06bucketB\0\x12\x1a\n\x03doc\x18\x02\x20\x03(\x0b2\x06.DocV2R\x03doc\
    B\0:\0\"\x92\x05\n\x05DocV1\x12)\n\tfinskyDoc\x18\x01\x20\x01(\x0b2\t.Do\
    cumentR\tfinskyDocB\0\x12\x16\n\x05docid\x18\x02\x20\x01(\tR\x05docidB\0\
    \x12\x20\n\ndetailsUrl\x18\x03\x20\x01(\tR\ndetailsUrlB\0\x12\x20\n\nrev\
    iewsUrl\x18\x04\x20\x01(\tR\nreviewsUrlB\0\x12(\n\x0erelatedListUrl\x18\
    \x05\x20\x01(\tR\x0erelatedListUrlB\0\x12&\n\rmoreByListUrl\x18\x06\x20\
    \x01(\tR\rmoreByListUrlB\0\x12\x1c\n\x08shareUrl\x18\x07\x20\x01(\tR\x08\
    shareUrlB\0\x12\x1a\n\x07creator\x18\x08\x20\x01(\tR\x07creatorB\0\x12,\
    \n\x07details\x18\t\x20\x01(\x0b2\x10.DocumentDetailsR\x07detailsB\0\x12\
    *\n\x0fdescriptionHtml\x18\n\x20\x01(\tR\x0fdescriptionHtmlB\0\x12,\n\
    \x10relatedBrowseUrl\x18\x0b\x20\x01(\tR\x10relatedBrowseUrlB\0\x12*\n\
    \x0fmoreByBrowseUrl\x18\x0c\x20\x01(\tR\x0fmoreByBrowseUrlB\0\x12&\n\rre\
    latedHeader\x18\r\x20\x01(\tR\rrelatedHeaderB\0\x12$\n\x0cmoreByHeader\
    \x18\x0e\x20\x01(\tR\x0cmoreByHeaderB\0\x12\x16\n\x05title\x18\x0f\x20\
    \x01(\tR\x05titleB\0\x120\n\x0bplusOneData\x18\x10\x20\x01(\x0b2\x0c.Plu\
    sOneDataR\x0bplusOneDataB\0\x12(\n\x0ewarningMessage\x18\x11\x20\x01(\tR\
    \x0ewarningMessageB\0:\0\"\xf2\x08\n\x05DocV2\x12\x16\n\x05docid\x18\x01\
    \x20\x01(\tR\x05docidB\0\x12$\n\x0cbackendDocid\x18\x02\x20\x01(\tR\x0cb\
    ackendDocidB\0\x12\x1a\n\x07docType\x18\x03\x20\x01(\x05R\x07docTypeB\0\
    \x12\x1e\n\tbackendId\x18\x04\x20\x01(\x05R\tbackendIdB\0\x12\x16\n\x05t\
    itle\x18\x05\x20\x01(\tR\x05titleB\0\x12\x1a\n\x07creator\x18\x06\x20\
    \x01(\tR\x07creatorB\0\x12*\n\x0fdescriptionHtml\x18\x07\x20\x01(\tR\x0f\
    descriptionHtmlB\0\x12\x1e\n\x05offer\x18\x08\x20\x03(\x0b2\x06.OfferR\
    \x05offerB\0\x123\n\x0cavailability\x18\t\x20\x01(\x0b2\r.AvailabilityR\
    \x0cavailabilityB\0\x12\x1e\n\x05image\x18\n\x20\x03(\x0b2\x06.ImageR\
    \x05imageB\0\x12\x1e\n\x05child\x18\x0b\x20\x03(\x0b2\x06.DocV2R\x05chil\
    dB\0\x12B\n\x11containerMetadata\x18\x0c\x20\x01(\x0b2\x12.ContainerMeta\
    dataR\x11containerMetadataB\0\x12,\n\x07details\x18\r\x20\x01(\x0b2\x10.\
    DocumentDetailsR\x07detailsB\0\x12<\n\x0faggregateRating\x18\x0e\x20\x01\
    (\x0b2\x10.AggregateRatingR\x0faggregateRatingB\0\x123\n\x0crelatedLinks\
    \x18\x0f\x20\x01(\x0b2\r.RelatedLinksR\x0crelatedLinksB\0\x12\x20\n\ndet\
    ailsUrl\x18\x10\x20\x01(\tR\ndetailsUrlB\0\x12\x1c\n\x08shareUrl\x18\x11\
    \x20\x01(\tR\x08shareUrlB\0\x12\x20\n\nreviewsUrl\x18\x12\x20\x01(\tR\nr\
    eviewsUrlB\0\x12\x20\n\nbackendUrl\x18\x13\x20\x01(\tR\nbackendUrlB\0\
    \x120\n\x12purchaseDetailsUrl\x18\x14\x20\x01(\tR\x12purchaseDetailsUrlB\
    \0\x12*\n\x0fdetailsReusable\x18\x15\x20\x01(\x08R\x0fdetailsReusableB\0\
    \x12\x1c\n\x08subtitle\x18\x16\x20\x01(\tR\x08subtitleB\0\x12W\n\x18unkn\
    ownCategoryContainer\x18\x18\x20\x01(\x0b2\x19.UnknownCategoryContainerR\
    \x18unknownCategoryContainerB\0\x12*\n\tunknown25\x18\x19\x20\x01(\x0b2\
    \n.Unknown25R\tunknown25B\0\x12,\n\x10descriptionShort\x18\x1b\x20\x01(\
    \tR\x10descriptionShortB\0\x12.\n\x11reviewSnippetsUrl\x18\x1f\x20\x01(\
    \tR\x11reviewSnippetsUrlB\0\x120\n\x12reviewQuestionsUrl\x18\"\x20\x01(\
    \tR\x12reviewQuestionsUrlB\0:\0\"3\n\tUnknown25\x12$\n\x04item\x18\x02\
    \x20\x03(\x0b2\x0e.Unknown25ItemR\x04itemB\0:\0\"^\n\rUnknown25Item\x12\
    \x16\n\x05label\x18\x01\x20\x01(\tR\x05labelB\0\x123\n\tcontainer\x18\
    \x03\x20\x01(\x0b2\x13.Unknown25ContainerR\tcontainerB\0:\0\".\n\x12Unkn\
    own25Container\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\0:\0\"\
    \xb8\x02\n\x0cRelatedLinks\x123\n\x08unknown1\x18\n\x20\x01(\x0b2\x15.Re\
    latedLinksUnknown1R\x08unknown1B\0\x12,\n\x10privacyPolicyUrl\x18\x12\
    \x20\x01(\tR\x10privacyPolicyUrlB\0\x12:\n\x10youMightAlsoLike\x18\x18\
    \x20\x01(\x0b2\x0c.RelatedLinkR\x10youMightAlsoLikeB\0\x12\x1e\n\x05rate\
    d\x18\x1d\x20\x01(\x0b2\x06.RatedR\x05ratedB\0\x122\n\x0crelatedLinks\
    \x18\"\x20\x03(\x0b2\x0c.RelatedLinkR\x0crelatedLinksB\0\x123\n\x0ccateg\
    oryInfo\x185\x20\x01(\x0b2\r.CategoryInfoR\x0ccategoryInfoB\0:\0\"M\n\
    \x14RelatedLinksUnknown1\x123\n\x08unknown2\x18\x02\x20\x01(\x0b2\x15.Re\
    latedLinksUnknown2R\x08unknown2B\0:\0\"X\n\x14RelatedLinksUnknown2\x12\
    \x1a\n\x07homeUrl\x18\x02\x20\x01(\tR\x07homeUrlB\0\x12\"\n\x0bnextPageU\
    rl\x18\x03\x20\x01(\tR\x0bnextPageUrlB\0:\0\"q\n\x05Rated\x12\x16\n\x05l\
    abel\x18\x01\x20\x01(\tR\x05labelB\0\x12\x1e\n\x05image\x18\x02\x20\x01(\
    \x0b2\x06.ImageR\x05imageB\0\x12.\n\x11learnMoreHtmlLink\x18\x04\x20\x01\
    (\tR\x11learnMoreHtmlLinkB\0:\0\"S\n\x0bRelatedLink\x12\x16\n\x05label\
    \x18\x01\x20\x01(\tR\x05labelB\0\x12\x14\n\x04url1\x18\x02\x20\x01(\tR\
    \x04url1B\0\x12\x14\n\x04url2\x18\x03\x20\x01(\tR\x04url2B\0:\0\"P\n\x0c\
    CategoryInfo\x12\x1a\n\x07appType\x18\x01\x20\x01(\tR\x07appTypeB\0\x12\
    \"\n\x0bappCategory\x18\x02\x20\x01(\tR\x0bappCategoryB\0:\0\"\xf7\x01\n\
    \x17EncryptedSubscriberInfo\x12\x14\n\x04data\x18\x01\x20\x01(\tR\x04dat\
    aB\0\x12$\n\x0cencryptedKey\x18\x02\x20\x01(\tR\x0cencryptedKeyB\0\x12\
    \x1e\n\tsignature\x18\x03\x20\x01(\tR\tsignatureB\0\x12\x20\n\ninitVecto\
    r\x18\x04\x20\x01(\tR\ninitVectorB\0\x12,\n\x10googleKeyVersion\x18\x05\
    \x20\x01(\x05R\x10googleKeyVersionB\0\x12.\n\x11carrierKeyVersion\x18\
    \x06\x20\x01(\x05R\x11carrierKeyVersionB\0:\0\"\x82\x05\n\x0cAvailabilit\
    y\x12\"\n\x0brestriction\x18\x05\x20\x01(\x05R\x0brestrictionB\0\x12\x1e\
    \n\tofferType\x18\x06\x20\x01(\x05R\tofferTypeB\0\x12\x1b\n\x04rule\x18\
    \x07\x20\x01(\x0b2\x05.RuleR\x04ruleB\0\x12|\n\x20perdeviceavailabilityr\
    estriction\x18\t\x20\x03(\n2..Availability.PerDeviceAvailabilityRestrict\
    ionR\x20perdeviceavailabilityrestrictionB\0\x12,\n\x10availableIfOwned\
    \x18\r\x20\x01(\x08R\x10availableIfOwnedB\0\x12$\n\x07install\x18\x0e\
    \x20\x03(\x0b2\x08.InstallR\x07installB\0\x127\n\nfilterInfo\x18\x10\x20\
    \x01(\x0b2\x15.FilterEvaluationInfoR\nfilterInfoB\0\x126\n\rownershipInf\
    o\x18\x11\x20\x01(\x0b2\x0e.OwnershipInfoR\rownershipInfoB\0\x1a\xcb\x01\
    \n\x20PerDeviceAvailabilityRestriction\x12\x1e\n\tandroidId\x18\n\x20\
    \x01(\x06R\tandroidIdB\0\x12.\n\x11deviceRestriction\x18\x0b\x20\x01(\
    \x05R\x11deviceRestrictionB\0\x12\x1e\n\tchannelId\x18\x0c\x20\x01(\x03R\
    \tchannelIdB\0\x127\n\nfilterInfo\x18\x0f\x20\x01(\x0b2\x15.FilterEvalua\
    tionInfoR\nfilterInfoB\0:\0\"S\n\x14FilterEvaluationInfo\x129\n\x0eruleE\
    valuation\x18\x01\x20\x03(\x0b2\x0f.RuleEvaluationR\x0eruleEvaluationB\0\
    :\0\"\xdb\x02\n\x04Rule\x12\x18\n\x06negate\x18\x01\x20\x01(\x08R\x06neg\
    ateB\0\x12\x1c\n\x08operator\x18\x02\x20\x01(\x05R\x08operatorB\0\x12\
    \x12\n\x03key\x18\x03\x20\x01(\x05R\x03keyB\0\x12\x1e\n\tstringArg\x18\
    \x04\x20\x03(\tR\tstringArgB\0\x12\x1a\n\x07longArg\x18\x05\x20\x03(\x03\
    R\x07longArgB\0\x12\x1e\n\tdoubleArg\x18\x06\x20\x03(\x01R\tdoubleArgB\0\
    \x12!\n\x07subrule\x18\x07\x20\x03(\x0b2\x05.RuleR\x07subruleB\0\x12$\n\
    \x0cresponseCode\x18\x08\x20\x01(\x05R\x0cresponseCodeB\0\x12\x1a\n\x07c\
    omment\x18\t\x20\x01(\tR\x07commentB\0\x12&\n\rstringArgHash\x18\n\x20\
    \x03(\x06R\rstringArgHashB\0\x12\x1c\n\x08constArg\x18\x0b\x20\x03(\x05R\
    \x08constArgB\0:\0\"\xe7\x01\n\x0eRuleEvaluation\x12\x1b\n\x04rule\x18\
    \x01\x20\x01(\x0b2\x05.RuleR\x04ruleB\0\x12.\n\x11actualStringValue\x18\
    \x02\x20\x03(\tR\x11actualStringValueB\0\x12*\n\x0factualLongValue\x18\
    \x03\x20\x03(\x03R\x0factualLongValueB\0\x12*\n\x0factualBoolValue\x18\
    \x04\x20\x03(\x08R\x0factualBoolValueB\0\x12.\n\x11actualDoubleValue\x18\
    \x05\x20\x03(\x01R\x11actualDoubleValueB\0:\0\"\xc9\x01\n\x11LibraryAppD\
    etails\x12*\n\x0fcertificateHash\x18\x02\x20\x01(\tR\x0fcertificateHashB\
    \0\x12@\n\x1arefundTimeoutTimestampMsec\x18\x03\x20\x01(\x03R\x1arefundT\
    imeoutTimestampMsecB\0\x12D\n\x1cpostDeliveryRefundWindowMsec\x18\x04\
    \x20\x01(\x03R\x1cpostDeliveryRefundWindowMsecB\0:\0\"i\n\x13LibraryInAp\
    pDetails\x120\n\x12signedPurchaseData\x18\x01\x20\x01(\tR\x12signedPurch\
    aseDataB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\tR\tsignatureB\0:\0\"\
    \xd8\x02\n\x0fLibraryMutation\x12\x1e\n\x05docid\x18\x01\x20\x01(\x0b2\
    \x06.DocidR\x05docidB\0\x12\x1e\n\tofferType\x18\x02\x20\x01(\x05R\toffe\
    rTypeB\0\x12$\n\x0cdocumentHash\x18\x03\x20\x01(\x03R\x0cdocumentHashB\0\
    \x12\x1a\n\x07deleted\x18\x04\x20\x01(\x08R\x07deletedB\0\x124\n\nappDet\
    ails\x18\x05\x20\x01(\x0b2\x12.LibraryAppDetailsR\nappDetailsB\0\x12O\n\
    \x13subscriptionDetails\x18\x06\x20\x01(\x0b2\x1b.LibrarySubscriptionDet\
    ailsR\x13subscriptionDetailsB\0\x12:\n\x0cinAppDetails\x18\x07\x20\x01(\
    \x0b2\x14.LibraryInAppDetailsR\x0cinAppDetailsB\0:\0\"\xf8\x01\n\x1aLibr\
    arySubscriptionDetails\x12:\n\x17initiationTimestampMsec\x18\x01\x20\x01\
    (\x03R\x17initiationTimestampMsecB\0\x12:\n\x17validUntilTimestampMsec\
    \x18\x02\x20\x01(\x03R\x17validUntilTimestampMsecB\0\x12$\n\x0cautoRenew\
    ing\x18\x03\x20\x01(\x08R\x0cautoRenewingB\0\x12:\n\x17trialUntilTimesta\
    mpMsec\x18\x04\x20\x01(\x03R\x17trialUntilTimestampMsecB\0:\0\"\xd5\x01\
    \n\rLibraryUpdate\x12\x18\n\x06status\x18\x01\x20\x01(\x05R\x06statusB\0\
    \x12\x18\n\x06corpus\x18\x02\x20\x01(\x05R\x06corpusB\0\x12\"\n\x0bserve\
    rToken\x18\x03\x20\x01(\x0cR\x0bserverTokenB\0\x12.\n\x08mutation\x18\
    \x04\x20\x03(\x0b2\x10.LibraryMutationR\x08mutationB\0\x12\x1a\n\x07hasM\
    ore\x18\x05\x20\x01(\x08R\x07hasMoreB\0\x12\x1e\n\tlibraryId\x18\x06\x20\
    \x01(\tR\tlibraryIdB\0:\0\"^\n\x1aAndroidAppNotificationData\x12\"\n\x0b\
    versionCode\x18\x01\x20\x01(\x05R\x0bversionCodeB\0\x12\x1a\n\x07assetId\
    \x18\x02\x20\x01(\tR\x07assetIdB\0:\0\"y\n\x15InAppNotificationData\x12*\
    \n\x0fcheckoutOrderId\x18\x01\x20\x01(\tR\x0fcheckoutOrderIdB\0\x122\n\
    \x13inAppNotificationId\x18\x02\x20\x01(\tR\x13inAppNotificationIdB\0:\0\
    \"0\n\x10LibraryDirtyData\x12\x1a\n\x07backend\x18\x01\x20\x01(\x05R\x07\
    backendB\0:\0\"\x91\x06\n\x0cNotification\x12,\n\x10notificationType\x18\
    \x01\x20\x01(\x05R\x10notificationTypeB\0\x12\x1e\n\ttimestamp\x18\x03\
    \x20\x01(\x03R\ttimestampB\0\x12\x1e\n\x05docid\x18\x04\x20\x01(\x0b2\
    \x06.DocidR\x05docidB\0\x12\x1c\n\x08docTitle\x18\x05\x20\x01(\tR\x08doc\
    TitleB\0\x12\x1e\n\tuserEmail\x18\x06\x20\x01(\tR\tuserEmailB\0\x127\n\
    \x07appData\x18\x07\x20\x01(\x0b2\x1b.AndroidAppNotificationDataR\x07app\
    DataB\0\x12C\n\x0fappDeliveryData\x18\x08\x20\x01(\x0b2\x17.AndroidAppDe\
    liveryDataR\x0fappDeliveryDataB\0\x12H\n\x13purchaseRemovalData\x18\t\
    \x20\x01(\x0b2\x14.PurchaseRemovalDataR\x13purchaseRemovalDataB\0\x12K\n\
    \x14userNotificationData\x18\n\x20\x01(\x0b2\x15.UserNotificationDataR\
    \x14userNotificationDataB\0\x12N\n\x15inAppNotificationData\x18\x0b\x20\
    \x01(\x0b2\x16.InAppNotificationDataR\x15inAppNotificationDataB\0\x12K\n\
    \x14purchaseDeclinedData\x18\x0c\x20\x01(\x0b2\x15.PurchaseDeclinedDataR\
    \x14purchaseDeclinedDataB\0\x12(\n\x0enotificationId\x18\r\x20\x01(\tR\
    \x0enotificationIdB\0\x126\n\rlibraryUpdate\x18\x0e\x20\x01(\x0b2\x0e.Li\
    braryUpdateR\rlibraryUpdateB\0\x12?\n\x10libraryDirtyData\x18\x0f\x20\
    \x01(\x0b2\x11.LibraryDirtyDataR\x10libraryDirtyDataB\0:\0\"`\n\x14Purch\
    aseDeclinedData\x12\x18\n\x06reason\x18\x01\x20\x01(\x05R\x06reasonB\0\
    \x12,\n\x10showNotification\x18\x02\x20\x01(\x08R\x10showNotificationB\0\
    :\0\"7\n\x13PurchaseRemovalData\x12\x1e\n\tmalicious\x18\x01\x20\x01(\
    \x08R\tmaliciousB\0:\0\"\xde\x01\n\x14UserNotificationData\x12.\n\x11not\
    ificationTitle\x18\x01\x20\x01(\tR\x11notificationTitleB\0\x12,\n\x10not\
    ificationText\x18\x02\x20\x01(\tR\x10notificationTextB\0\x12\x20\n\ntick\
    erText\x18\x03\x20\x01(\tR\ntickerTextB\0\x12\"\n\x0bdialogTitle\x18\x04\
    \x20\x01(\tR\x0bdialogTitleB\0\x12\x20\n\ndialogText\x18\x05\x20\x01(\tR\
    \ndialogTextB\0:\0\"\xf7\x03\n\x0fAggregateRating\x12\x14\n\x04type\x18\
    \x01\x20\x01(\x05R\x04typeB\0\x12\x20\n\nstarRating\x18\x02\x20\x01(\x02\
    R\nstarRatingB\0\x12$\n\x0cratingsCount\x18\x03\x20\x01(\x04R\x0cratings\
    CountB\0\x12(\n\x0eoneStarRatings\x18\x04\x20\x01(\x04R\x0eoneStarRating\
    sB\0\x12(\n\x0etwoStarRatings\x18\x05\x20\x01(\x04R\x0etwoStarRatingsB\0\
    \x12,\n\x10threeStarRatings\x18\x06\x20\x01(\x04R\x10threeStarRatingsB\0\
    \x12*\n\x0ffourStarRatings\x18\x07\x20\x01(\x04R\x0ffourStarRatingsB\0\
    \x12*\n\x0ffiveStarRatings\x18\x08\x20\x01(\x04R\x0ffiveStarRatingsB\0\
    \x12&\n\rthumbsUpCount\x18\t\x20\x01(\x04R\rthumbsUpCountB\0\x12*\n\x0ft\
    humbsDownCount\x18\n\x20\x01(\x04R\x0fthumbsDownCountB\0\x12$\n\x0ccomme\
    ntCount\x18\x0b\x20\x01(\x04R\x0ccommentCountB\0\x120\n\x12bayesianMeanR\
    ating\x18\x0c\x20\x01(\x01R\x12bayesianMeanRatingB\0:\0\"\x15\n\x11Accep\
    tTosResponse:\0\"\x8e\x03\n\x14CarrierBillingConfig\x12\x10\n\x02id\x18\
    \x01\x20\x01(\tR\x02idB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\
    \0\x12\x20\n\napiVersion\x18\x03\x20\x01(\x05R\napiVersionB\0\x12*\n\x0f\
    provisioningUrl\x18\x04\x20\x01(\tR\x0fprovisioningUrlB\0\x12(\n\x0ecred\
    entialsUrl\x18\x05\x20\x01(\tR\x0ecredentialsUrlB\0\x12\"\n\x0btosRequir\
    ed\x18\x06\x20\x01(\x08R\x0btosRequiredB\0\x12N\n!perTransactionCredenti\
    alsRequired\x18\x07\x20\x01(\x08R!perTransactionCredentialsRequiredB\0\
    \x12`\n*sendSubscriberIdWithCarrierBillingRequests\x18\x08\x20\x01(\x08R\
    *sendSubscriberIdWithCarrierBillingRequestsB\0:\0\"\x8c\x01\n\rBillingCo\
    nfig\x12K\n\x14carrierBillingConfig\x18\x01\x20\x01(\x0b2\x15.CarrierBil\
    lingConfigR\x14carrierBillingConfigB\0\x12,\n\x10maxIabApiVersion\x18\
    \x02\x20\x01(\x05R\x10maxIabApiVersionB\0:\0\"\xd0\x01\n\x0eCorpusMetada\
    ta\x12\x1a\n\x07backend\x18\x01\x20\x01(\x05R\x07backendB\0\x12\x14\n\
    \x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12\x20\n\nlandingUrl\x18\x03\
    \x20\x01(\tR\nlandingUrlB\0\x12\"\n\x0blibraryName\x18\x04\x20\x01(\tR\
    \x0blibraryNameB\0\x12&\n\rrecsWidgetUrl\x18\x06\x20\x01(\tR\rrecsWidget\
    UrlB\0\x12\x1c\n\x08shopName\x18\x07\x20\x01(\tR\x08shopNameB\0:\0\"5\n\
    \x0bExperiments\x12$\n\x0cexperimentId\x18\x01\x20\x03(\tR\x0cexperiment\
    IdB\0:\0\"P\n\x10SelfUpdateConfig\x12:\n\x17latestClientVersionCode\x18\
    \x01\x20\x01(\x05R\x17latestClientVersionCodeB\0:\0\"\x9d\x07\n\x0bTocRe\
    sponse\x12)\n\x06corpus\x18\x01\x20\x03(\x0b2\x0f.CorpusMetadataR\x06cor\
    pusB\0\x124\n\x14tosVersionDeprecated\x18\x02\x20\x01(\x05R\x14tosVersio\
    nDeprecatedB\0\x12\x20\n\ntosContent\x18\x03\x20\x01(\tR\ntosContentB\0\
    \x12\x1a\n\x07homeUrl\x18\x04\x20\x01(\tR\x07homeUrlB\0\x120\n\x0bexperi\
    ments\x18\x05\x20\x01(\x0b2\x0c.ExperimentsR\x0bexperimentsB\0\x12H\n\
    \x1etosCheckboxTextMarketingEmails\x18\x06\x20\x01(\tR\x1etosCheckboxTex\
    tMarketingEmailsB\0\x12\x1c\n\x08tosToken\x18\x07\x20\x01(\tR\x08tosToke\
    nB\0\x12*\n\x0ficonOverrideUrl\x18\t\x20\x01(\tR\x0ficonOverrideUrlB\0\
    \x12?\n\x10selfUpdateConfig\x18\n\x20\x01(\x0b2\x11.SelfUpdateConfigR\
    \x10selfUpdateConfigB\0\x12@\n\x1arequiresUploadDeviceConfig\x18\x0b\x20\
    \x01(\x08R\x1arequiresUploadDeviceConfigB\0\x126\n\rbillingConfig\x18\
    \x0c\x20\x01(\x0b2\x0e.BillingConfigR\rbillingConfigB\0\x12&\n\rrecsWidg\
    etUrl\x18\r\x20\x01(\tR\rrecsWidgetUrlB\0\x12&\n\rsocialHomeUrl\x18\x0f\
    \x20\x01(\tR\rsocialHomeUrlB\0\x12:\n\x17ageVerificationRequired\x18\x10\
    \x20\x01(\x08R\x17ageVerificationRequiredB\0\x120\n\x12gplusSignupEnable\
    d\x18\x11\x20\x01(\x08R\x12gplusSignupEnabledB\0\x12&\n\rredeemEnabled\
    \x18\x12\x20\x01(\x08R\rredeemEnabledB\0\x12\x1a\n\x07helpUrl\x18\x13\
    \x20\x01(\tR\x07helpUrlB\0\x12\x1a\n\x07themeId\x18\x14\x20\x01(\x05R\
    \x07themeIdB\0\x124\n\x14entertainmentHomeUrl\x18\x15\x20\x01(\tR\x14ent\
    ertainmentHomeUrlB\0\x12\x18\n\x06cookie\x18\x16\x20\x01(\tR\x06cookieB\
    \0:\0\"\xe2\x08\n\x07Payload\x123\n\x0clistResponse\x18\x01\x20\x01(\x0b\
    2\r.ListResponseR\x0clistResponseB\0\x12<\n\x0fdetailsResponse\x18\x02\
    \x20\x01(\x0b2\x10.DetailsResponseR\x0fdetailsResponseB\0\x129\n\x0erevi\
    ewResponse\x18\x03\x20\x01(\x0b2\x0f.ReviewResponseR\x0ereviewResponseB\
    \0\x120\n\x0bbuyResponse\x18\x04\x20\x01(\x0b2\x0c.BuyResponseR\x0bbuyRe\
    sponseB\0\x129\n\x0esearchResponse\x18\x05\x20\x01(\x0b2\x0f.SearchRespo\
    nseR\x0esearchResponseB\0\x120\n\x0btocResponse\x18\x06\x20\x01(\x0b2\
    \x0c.TocResponseR\x0btocResponseB\0\x129\n\x0ebrowseResponse\x18\x07\x20\
    \x01(\x0b2\x0f.BrowseResponseR\x0ebrowseResponseB\0\x12Q\n\x16purchaseSt\
    atusResponse\x18\x08\x20\x01(\x0b2\x17.PurchaseStatusResponseR\x16purcha\
    seStatusResponseB\0\x12\"\n\x0blogResponse\x18\n\x20\x01(\tR\x0blogRespo\
    nseB\0\x122\n\x13flagContentResponse\x18\r\x20\x01(\tR\x13flagContentRes\
    ponseB\0\x12H\n\x13bulkDetailsResponse\x18\x13\x20\x01(\x0b2\x14.BulkDet\
    ailsResponseR\x13bulkDetailsResponseB\0\x12?\n\x10deliveryResponse\x18\
    \x15\x20\x01(\x0b2\x11.DeliveryResponseR\x10deliveryResponseB\0\x12B\n\
    \x11acceptTosResponse\x18\x16\x20\x01(\x0b2\x12.AcceptTosResponseR\x11ac\
    ceptTosResponseB\0\x12Q\n\x16androidCheckinResponse\x18\x1a\x20\x01(\x0b\
    2\x17.AndroidCheckinResponseR\x16androidCheckinResponseB\0\x12]\n\x1aupl\
    oadDeviceConfigResponse\x18\x1c\x20\x01(\x0b2\x1b.UploadDeviceConfigResp\
    onseR\x1auploadDeviceConfigResponseB\0\x12N\n\x15searchSuggestResponse\
    \x18(\x20\x01(\x0b2\x16.SearchSuggestResponseR\x15searchSuggestResponseB\
    \0\x12Q\n\x16testingProgramResponse\x18P\x20\x01(\x0b2\x17.TestingProgra\
    mResponseR\x16testingProgramResponseB\0:\0\"\x96\x01\n\x08PreFetch\x12\
    \x12\n\x03url\x18\x01\x20\x01(\tR\x03urlB\0\x12.\n\x08response\x18\x02\
    \x20\x01(\x0b2\x10.ResponseWrapperR\x08responseB\0\x12\x14\n\x04etag\x18\
    \x03\x20\x01(\tR\x04etagB\0\x12\x12\n\x03ttl\x18\x04\x20\x01(\x03R\x03tt\
    lB\0\x12\x1a\n\x07softTtl\x18\x05\x20\x01(\x03R\x07softTtlB\0:\0\":\n\
    \x0eServerMetadata\x12&\n\rlatencyMillis\x18\x01\x20\x01(\x03R\rlatencyM\
    illisB\0:\0\"I\n\x07Targets\x12\x1c\n\x08targetId\x18\x01\x20\x03(\x03R\
    \x08targetIdB\0\x12\x1e\n\tsignature\x18\x02\x20\x01(\x0cR\tsignatureB\0\
    :\0\">\n\x0cServerCookie\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04type\
    B\0\x12\x16\n\x05token\x18\x02\x20\x01(\x0cR\x05tokenB\0:\0\"F\n\rServer\
    Cookies\x123\n\x0cserverCookie\x18\x01\x20\x03(\x0b2\r.ServerCookieR\x0c\
    serverCookieB\0:\0\"\x8d\x03\n\x0fResponseWrapper\x12$\n\x07payload\x18\
    \x01\x20\x01(\x0b2\x08.PayloadR\x07payloadB\0\x12-\n\x08commands\x18\x02\
    \x20\x01(\x0b2\x0f.ServerCommandsR\x08commandsB\0\x12'\n\x08preFetch\x18\
    \x03\x20\x03(\x0b2\t.PreFetchR\x08preFetchB\0\x123\n\x0cnotification\x18\
    \x04\x20\x03(\x0b2\r.NotificationR\x0cnotificationB\0\x129\n\x0eserverMe\
    tadata\x18\x05\x20\x01(\x0b2\x0f.ServerMetadataR\x0eserverMetadataB\0\
    \x12$\n\x07targets\x18\x06\x20\x01(\x0b2\x08.TargetsR\x07targetsB\0\x126\
    \n\rserverCookies\x18\x07\x20\x01(\x0b2\x0e.ServerCookiesR\rserverCookie\
    sB\0\x12,\n\x10serverLogsCookie\x18\t\x20\x01(\x0cR\x10serverLogsCookieB\
    \0:\0\"?\n\x12ResponseWrapperApi\x12'\n\x07payload\x18\x01\x20\x01(\x0b2\
    \x0b.PayloadApiR\x07payloadB\0:\0\"X\n\nPayloadApi\x12H\n\x13userProfile\
    Response\x18\x05\x20\x01(\x0b2\x14.UserProfileResponseR\x13userProfileRe\
    sponseB\0:\0\"I\n\x13UserProfileResponse\x120\n\x0buserProfile\x18\x01\
    \x20\x01(\x0b2\x0c.UserProfileR\x0buserProfileB\0:\0\"\x9a\x01\n\x0eServ\
    erCommands\x12\x20\n\nclearCache\x18\x01\x20\x01(\x08R\nclearCacheB\0\
    \x122\n\x13displayErrorMessage\x18\x02\x20\x01(\tR\x13displayErrorMessag\
    eB\0\x120\n\x12logErrorStacktrace\x18\x03\x20\x01(\tR\x12logErrorStacktr\
    aceB\0:\0\"a\n\x12GetReviewsResponse\x12!\n\x06review\x18\x01\x20\x03(\
    \x0b2\x07.ReviewR\x06reviewB\0\x12&\n\rmatchingCount\x18\x02\x20\x01(\
    \x03R\rmatchingCountB\0:\0\"\xf3\x03\n\x06Review\x12\x20\n\nauthorName\
    \x18\x01\x20\x01(\tR\nauthorNameB\0\x12\x12\n\x03url\x18\x02\x20\x01(\tR\
    \x03urlB\0\x12\x18\n\x06source\x18\x03\x20\x01(\tR\x06sourceB\0\x12*\n\
    \x0fdocumentVersion\x18\x04\x20\x01(\tR\x0fdocumentVersionB\0\x12&\n\rti\
    mestampMsec\x18\x05\x20\x01(\x03R\rtimestampMsecB\0\x12\x20\n\nstarRatin\
    g\x18\x06\x20\x01(\x05R\nstarRatingB\0\x12\x16\n\x05title\x18\x07\x20\
    \x01(\tR\x05titleB\0\x12\x1a\n\x07comment\x18\x08\x20\x01(\tR\x07comment\
    B\0\x12\x1e\n\tcommentId\x18\t\x20\x01(\tR\tcommentIdB\0\x12\x20\n\ndevi\
    ceName\x18\x13\x20\x01(\tR\ndeviceNameB\0\x12\x1e\n\treplyText\x18\x1d\
    \x20\x01(\tR\treplyTextB\0\x120\n\x12replyTimestampMsec\x18\x1e\x20\x01(\
    \x03R\x12replyTimestampMsecB\0\x12'\n\x06author\x18\x1f\x20\x01(\x0b2\r.\
    ReviewAuthorR\x06authorB\0\x120\n\x0buserProfile\x18!\x20\x01(\x0b2\x0c.\
    UserProfileR\x0buserProfileB\0:\0\"H\n\x0cReviewAuthor\x12\x14\n\x04name\
    \x18\x02\x20\x01(\tR\x04nameB\0\x12\x20\n\x06avatar\x18\x05\x20\x01(\x0b\
    2\x06.ImageR\x06avatarB\0:\0\"\xa1\x02\n\x0bUserProfile\x12(\n\x0eperson\
    IdString\x18\x01\x20\x01(\tR\x0epersonIdStringB\0\x12\x1c\n\x08personId\
    \x18\x02\x20\x01(\tR\x08personIdB\0\x12\x1c\n\x08unknown1\x18\x03\x20\
    \x01(\x05R\x08unknown1B\0\x12\x1c\n\x08unknown2\x18\x04\x20\x01(\x05R\
    \x08unknown2B\0\x12\x14\n\x04name\x18\x05\x20\x01(\tR\x04nameB\0\x12\x1e\
    \n\x05image\x18\n\x20\x03(\x0b2\x06.ImageR\x05imageB\0\x12&\n\rgooglePlu\
    sUrl\x18\x13\x20\x01(\tR\rgooglePlusUrlB\0\x12.\n\x11googlePlusTagline\
    \x18\x16\x20\x01(\tR\x11googlePlusTaglineB\0:\0\"\x9a\x01\n\x0eReviewRes\
    ponse\x127\n\x0bgetResponse\x18\x01\x20\x01(\x0b2\x13.GetReviewsResponse\
    R\x0bgetResponseB\0\x12\"\n\x0bnextPageUrl\x18\x02\x20\x01(\tR\x0bnextPa\
    geUrlB\0\x12)\n\nuserReview\x18\x03\x20\x01(\x0b2\x07.ReviewR\nuserRevie\
    wB\0:\0\"\xa3\x01\n\rRelatedSearch\x12\x1e\n\tsearchUrl\x18\x01\x20\x01(\
    \tR\tsearchUrlB\0\x12\x18\n\x06header\x18\x02\x20\x01(\tR\x06headerB\0\
    \x12\x1e\n\tbackendId\x18\x03\x20\x01(\x05R\tbackendIdB\0\x12\x1a\n\x07d\
    ocType\x18\x04\x20\x01(\x05R\x07docTypeB\0\x12\x1a\n\x07current\x18\x05\
    \x20\x01(\x08R\x07currentB\0:\0\"\xa9\x02\n\x0eSearchResponse\x12&\n\ror\
    iginalQuery\x18\x01\x20\x01(\tR\roriginalQueryB\0\x12(\n\x0esuggestedQue\
    ry\x18\x02\x20\x01(\tR\x0esuggestedQueryB\0\x12(\n\x0eaggregateQuery\x18\
    \x03\x20\x01(\x08R\x0eaggregateQueryB\0\x12!\n\x06bucket\x18\x04\x20\x03\
    (\x0b2\x07.BucketR\x06bucketB\0\x12\x1a\n\x03doc\x18\x05\x20\x03(\x0b2\
    \x06.DocV2R\x03docB\0\x126\n\rrelatedSearch\x18\x06\x20\x03(\x0b2\x0e.Re\
    latedSearchR\rrelatedSearchB\0\x12\"\n\x0bnextPageUrl\x18\n\x20\x01(\tR\
    \x0bnextPageUrlB\0:\0\"F\n\x15SearchSuggestResponse\x12+\n\x05entry\x18\
    \x01\x20\x03(\x0b2\x13.SearchSuggestEntryR\x05entryB\0:\0\"\x8c\x03\n\
    \x12SearchSuggestEntry\x12\x14\n\x04type\x18\x01\x20\x01(\x05R\x04typeB\
    \0\x12(\n\x0esuggestedQuery\x18\x02\x20\x01(\tR\x0esuggestedQueryB\0\x12\
    L\n\x0eimageContainer\x18\x05\x20\x01(\x0b2\".SearchSuggestEntry.ImageCo\
    ntainerR\x0eimageContainerB\0\x12\x16\n\x05title\x18\x06\x20\x01(\tR\x05\
    titleB\0\x12^\n\x14packageNameContainer\x18\x08\x20\x01(\x0b2(.SearchSug\
    gestEntry.PackageNameContainerR\x14packageNameContainerB\0\x1a0\n\x0eIma\
    geContainer\x12\x1c\n\x08imageUrl\x18\x05\x20\x01(\tR\x08imageUrlB\0:\0\
    \x1a<\n\x14PackageNameContainer\x12\"\n\x0bpackageName\x18\x01\x20\x01(\
    \tR\x0bpackageNameB\0:\0:\0\"K\n\x16TestingProgramResponse\x12/\n\x06res\
    ult\x18\x02\x20\x01(\x0b2\x15.TestingProgramResultR\x06resultB\0:\0\"L\n\
    \x14TestingProgramResult\x122\n\x07details\x18\x04\x20\x01(\x0b2\x16.Tes\
    tingProgramDetailsR\x07detailsB\0:\0\"i\n\x15TestingProgramDetails\x12\
    \x16\n\x05flag1\x18\x02\x20\x01(\x08R\x05flag1B\0\x12\x10\n\x02id\x18\
    \x03\x20\x01(\x03R\x02idB\0\x12$\n\x0cunsubscribed\x18\x04\x20\x01(\x08R\
    \x0cunsubscribedB\0:\0\"n\n\nLogRequest\x12\x1e\n\ttimestamp\x18\x01\x20\
    \x01(\x03R\ttimestampB\0\x12>\n\x19downloadConfirmationQuery\x18\x02\x20\
    \x01(\tR\x19downloadConfirmationQueryB\0:\0\"]\n\x15TestingProgramReques\
    t\x12\"\n\x0bpackageName\x18\x01\x20\x01(\tR\x0bpackageNameB\0\x12\x1e\n\
    \tsubscribe\x18\x02\x20\x01(\x08R\tsubscribeB\0:\0\"\xc2\x01\n\x19Upload\
    DeviceConfigRequest\x12M\n\x13deviceConfiguration\x18\x01\x20\x01(\x0b2\
    \x19.DeviceConfigurationProtoR\x13deviceConfigurationB\0\x12$\n\x0cmanuf\
    acturer\x18\x02\x20\x01(\tR\x0cmanufacturerB\0\x12.\n\x11gcmRegistration\
    Id\x18\x03\x20\x01(\tR\x11gcmRegistrationIdB\0:\0\"Z\n\x1aUploadDeviceCo\
    nfigResponse\x12:\n\x17uploadDeviceConfigToken\x18\x01\x20\x01(\tR\x17up\
    loadDeviceConfigTokenB\0:\0\"\x84\x06\n\x15AndroidCheckinRequest\x12\x14\
    \n\x04imei\x18\x01\x20\x01(\tR\x04imeiB\0\x12\x10\n\x02id\x18\x02\x20\
    \x01(\x03R\x02idB\0\x12\x18\n\x06digest\x18\x03\x20\x01(\tR\x06digestB\0\
    \x120\n\x07checkin\x18\x04\x20\x01(\x0b2\x14.AndroidCheckinProtoR\x07che\
    ckinB\0\x12$\n\x0cdesiredBuild\x18\x05\x20\x01(\tR\x0cdesiredBuildB\0\
    \x12\x18\n\x06locale\x18\x06\x20\x01(\tR\x06localeB\0\x12\x1e\n\tlogging\
    Id\x18\x07\x20\x01(\x03R\tloggingIdB\0\x12&\n\rmarketCheckin\x18\x08\x20\
    \x01(\tR\rmarketCheckinB\0\x12\x1a\n\x07macAddr\x18\t\x20\x03(\tR\x07mac\
    AddrB\0\x12\x14\n\x04meid\x18\n\x20\x01(\tR\x04meidB\0\x12&\n\raccountCo\
    okie\x18\x0b\x20\x03(\tR\raccountCookieB\0\x12\x1c\n\x08timeZone\x18\x0c\
    \x20\x01(\tR\x08timeZoneB\0\x12&\n\rsecurityToken\x18\r\x20\x01(\x06R\rs\
    ecurityTokenB\0\x12\x1a\n\x07version\x18\x0e\x20\x01(\x05R\x07versionB\0\
    \x12\x1a\n\x07otaCert\x18\x0f\x20\x03(\tR\x07otaCertB\0\x12$\n\x0cserial\
    Number\x18\x10\x20\x01(\tR\x0cserialNumberB\0\x12\x12\n\x03esn\x18\x11\
    \x20\x01(\tR\x03esnB\0\x12M\n\x13deviceConfiguration\x18\x12\x20\x01(\
    \x0b2\x19.DeviceConfigurationProtoR\x13deviceConfigurationB\0\x12\"\n\
    \x0bmacAddrType\x18\x13\x20\x03(\tR\x0bmacAddrTypeB\0\x12\x1c\n\x08fragm\
    ent\x18\x14\x20\x01(\x05R\x08fragmentB\0\x12\x1c\n\x08userName\x18\x15\
    \x20\x01(\tR\x08userNameB\0\x12,\n\x10userSerialNumber\x18\x16\x20\x01(\
    \x05R\x10userSerialNumberB\0:\0\"\xc8\x03\n\x16AndroidCheckinResponse\
    \x12\x1a\n\x07statsOk\x18\x01\x20\x01(\x08R\x07statsOkB\0\x12-\n\x06inte\
    nt\x18\x02\x20\x03(\x0b2\x13.AndroidIntentProtoR\x06intentB\0\x12\x1c\n\
    \x08timeMsec\x18\x03\x20\x01(\x03R\x08timeMsecB\0\x12\x18\n\x06digest\
    \x18\x04\x20\x01(\tR\x06digestB\0\x12-\n\x07setting\x18\x05\x20\x03(\x0b\
    2\x11.GservicesSettingR\x07settingB\0\x12\x1c\n\x08marketOk\x18\x06\x20\
    \x01(\x08R\x08marketOkB\0\x12\x1e\n\tandroidId\x18\x07\x20\x01(\x06R\tan\
    droidIdB\0\x12&\n\rsecurityToken\x18\x08\x20\x01(\x06R\rsecurityTokenB\0\
    \x12$\n\x0csettingsDiff\x18\t\x20\x01(\x08R\x0csettingsDiffB\0\x12&\n\rd\
    eleteSetting\x18\n\x20\x03(\tR\rdeleteSettingB\0\x12F\n\x1ddeviceCheckin\
    ConsistencyToken\x18\x0c\x20\x01(\tR\x1ddeviceCheckinConsistencyTokenB\0\
    :\0\"B\n\x10GservicesSetting\x12\x14\n\x04name\x18\x01\x20\x01(\x0cR\x04\
    nameB\0\x12\x16\n\x05value\x18\x02\x20\x01(\x0cR\x05valueB\0:\0\"\xc3\
    \x03\n\x11AndroidBuildProto\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\
    \x12\x1a\n\x07product\x18\x02\x20\x01(\tR\x07productB\0\x12\x1a\n\x07car\
    rier\x18\x03\x20\x01(\tR\x07carrierB\0\x12\x16\n\x05radio\x18\x04\x20\
    \x01(\tR\x05radioB\0\x12\x20\n\nbootloader\x18\x05\x20\x01(\tR\nbootload\
    erB\0\x12\x18\n\x06client\x18\x06\x20\x01(\tR\x06clientB\0\x12\x1e\n\tti\
    mestamp\x18\x07\x20\x01(\x03R\ttimestampB\0\x12(\n\x0egoogleServices\x18\
    \x08\x20\x01(\x05R\x0egoogleServicesB\0\x12\x18\n\x06device\x18\t\x20\
    \x01(\tR\x06deviceB\0\x12\x20\n\nsdkVersion\x18\n\x20\x01(\x05R\nsdkVers\
    ionB\0\x12\x16\n\x05model\x18\x0b\x20\x01(\tR\x05modelB\0\x12$\n\x0cmanu\
    facturer\x18\x0c\x20\x01(\tR\x0cmanufacturerB\0\x12$\n\x0cbuildProduct\
    \x18\r\x20\x01(\tR\x0cbuildProductB\0\x12$\n\x0cotaInstalled\x18\x0e\x20\
    \x01(\x08R\x0cotaInstalledB\0:\0\"\xfb\x02\n\x13AndroidCheckinProto\x12*\
    \n\x05build\x18\x01\x20\x01(\x0b2\x12.AndroidBuildProtoR\x05buildB\0\x12\
    *\n\x0flastCheckinMsec\x18\x02\x20\x01(\x03R\x0flastCheckinMsecB\0\x12*\
    \n\x05event\x18\x03\x20\x03(\x0b2\x12.AndroidEventProtoR\x05eventB\0\x12\
    ,\n\x04stat\x18\x04\x20\x03(\x0b2\x16.AndroidStatisticProtoR\x04statB\0\
    \x12(\n\x0erequestedGroup\x18\x05\x20\x03(\tR\x0erequestedGroupB\0\x12$\
    \n\x0ccellOperator\x18\x06\x20\x01(\tR\x0ccellOperatorB\0\x12\"\n\x0bsim\
    Operator\x18\x07\x20\x01(\tR\x0bsimOperatorB\0\x12\x1a\n\x07roaming\x18\
    \x08\x20\x01(\tR\x07roamingB\0\x12\x20\n\nuserNumber\x18\t\x20\x01(\x05R\
    \nuserNumberB\0:\0\"_\n\x11AndroidEventProto\x12\x12\n\x03tag\x18\x01\
    \x20\x01(\tR\x03tagB\0\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\
    \0\x12\x1c\n\x08timeMsec\x18\x03\x20\x01(\x03R\x08timeMsecB\0:\0\"\xf4\
    \x01\n\x12AndroidIntentProto\x12\x18\n\x06action\x18\x01\x20\x01(\tR\x06\
    actionB\0\x12\x1a\n\x07dataUri\x18\x02\x20\x01(\tR\x07dataUriB\0\x12\x1c\
    \n\x08mimeType\x18\x03\x20\x01(\tR\x08mimeTypeB\0\x12\x1e\n\tjavaClass\
    \x18\x04\x20\x01(\tR\tjavaClassB\0\x121\n\x05extra\x18\x05\x20\x03(\n2\
    \x19.AndroidIntentProto.ExtraR\x05extraB\0\x1a5\n\x05Extra\x12\x14\n\x04\
    name\x18\x06\x20\x01(\tR\x04nameB\0\x12\x16\n\x05value\x18\x07\x20\x01(\
    \tR\x05valueB\0:\0\"Y\n\x15AndroidStatisticProto\x12\x12\n\x03tag\x18\
    \x01\x20\x01(\tR\x03tagB\0\x12\x16\n\x05count\x18\x02\x20\x01(\x05R\x05c\
    ountB\0\x12\x12\n\x03sum\x18\x03\x20\x01(\x02R\x03sumB\0:\0\"\xbc\x01\n\
    \x12ClientLibraryState\x12\x18\n\x06corpus\x18\x01\x20\x01(\x05R\x06corp\
    usB\0\x12\"\n\x0bserverToken\x18\x02\x20\x01(\x0cR\x0bserverTokenB\0\x12\
    \"\n\x0bhashCodeSum\x18\x03\x20\x01(\x03R\x0bhashCodeSumB\0\x12\"\n\x0bl\
    ibrarySize\x18\x04\x20\x01(\x05R\x0blibrarySizeB\0\x12\x1e\n\tlibraryId\
    \x18\x05\x20\x01(\tR\tlibraryIdB\0:\0\"\xcc\x02\n\x15AndroidDataUsagePro\
    to\x12\x1a\n\x07version\x18\x01\x20\x01(\x05R\x07versionB\0\x12.\n\x11cu\
    rrentReportMsec\x18\x02\x20\x01(\x03R\x11currentReportMsecB\0\x12T\n\x17\
    keyToPackageNameMapping\x18\x03\x20\x03(\x0b2\x18.KeyToPackageNameMappin\
    gR\x17keyToPackageNameMappingB\0\x12H\n\x13payloadLevelAppStat\x18\x04\
    \x20\x03(\x0b2\x14.PayloadLevelAppStatR\x13payloadLevelAppStatB\0\x12E\n\
    \x12ipLayerNetworkStat\x18\x05\x20\x03(\x0b2\x13.IpLayerNetworkStatR\x12\
    ipLayerNetworkStatB\0:\0\"\x98\x01\n\x17AndroidUsageStatsReport\x12\x1e\
    \n\tandroidId\x18\x01\x20\x01(\x03R\tandroidIdB\0\x12\x1e\n\tloggingId\
    \x18\x02\x20\x01(\x03R\tloggingIdB\0\x12;\n\nusageStats\x18\x03\x20\x01(\
    \x0b2\x19.UsageStatsExtensionProtoR\nusageStatsB\0:\0\"\xca\x01\n\tAppBu\
    cket\x12*\n\x0fbucketStartMsec\x18\x01\x20\x01(\x03R\x0fbucketStartMsecB\
    \0\x120\n\x12bucketDurationMsec\x18\x02\x20\x01(\x03R\x12bucketDurationM\
    secB\0\x123\n\x0cstatCounters\x18\x03\x20\x03(\x0b2\r.StatCountersR\x0cs\
    tatCountersB\0\x12(\n\x0eoperationCount\x18\x04\x20\x01(\x03R\x0eoperati\
    onCountB\0:\0\"C\n\x0bCounterData\x12\x16\n\x05bytes\x18\x01\x20\x01(\
    \x03R\x05bytesB\0\x12\x1a\n\x07packets\x18\x02\x20\x01(\x03R\x07packetsB\
    \0:\0\"\x98\x01\n\x0eIpLayerAppStat\x12\x20\n\npackageKey\x18\x01\x20\
    \x01(\x05R\npackageKeyB\0\x12(\n\x0eapplicationTag\x18\x02\x20\x01(\x05R\
    \x0eapplicationTagB\0\x128\n\x10ipLayerAppBucket\x18\x03\x20\x03(\x0b2\n\
    .AppBucketR\x10ipLayerAppBucketB\0:\0\"\xe3\x01\n\x14IpLayerNetworkBucke\
    t\x12*\n\x0fbucketStartMsec\x18\x01\x20\x01(\x03R\x0fbucketStartMsecB\0\
    \x120\n\x12bucketDurationMsec\x18\x02\x20\x01(\x03R\x12bucketDurationMse\
    cB\0\x123\n\x0cstatCounters\x18\x03\x20\x03(\x0b2\r.StatCountersR\x0csta\
    tCountersB\0\x126\n\x15networkActiveDuration\x18\x04\x20\x01(\x03R\x15ne\
    tworkActiveDurationB\0:\0\"\xde\x01\n\x12IpLayerNetworkStat\x12(\n\x0ene\
    tworkDetails\x18\x01\x20\x01(\tR\x0enetworkDetailsB\0\x12\x14\n\x04type\
    \x18\x02\x20\x01(\x05R\x04typeB\0\x12K\n\x14ipLayerNetworkBucket\x18\x03\
    \x20\x03(\x0b2\x15.IpLayerNetworkBucketR\x14ipLayerNetworkBucketB\0\x129\
    \n\x0eipLayerAppStat\x18\x04\x20\x03(\x0b2\x0f.IpLayerAppStatR\x0eipLaye\
    rAppStatB\0:\0\"\x97\x01\n\x17KeyToPackageNameMapping\x12\x20\n\npackage\
    Key\x18\x01\x20\x01(\x05R\npackageKeyB\0\x12\x1a\n\x07uidName\x18\x02\
    \x20\x01(\tR\x07uidNameB\0\x12<\n\x11sharedPackageList\x18\x03\x20\x03(\
    \x0b2\x0c.PackageInfoR\x11sharedPackageListB\0:\0\"O\n\x0bPackageInfo\
    \x12\x1a\n\x07pkgName\x18\x01\x20\x01(\tR\x07pkgNameB\0\x12\"\n\x0bversi\
    onCode\x18\x02\x20\x01(\x05R\x0bversionCodeB\0:\0\"\xa7\x01\n\x13Payload\
    LevelAppStat\x12\x20\n\npackageKey\x18\x01\x20\x01(\x05R\npackageKeyB\0\
    \x12(\n\x0eapplicationTag\x18\x02\x20\x01(\x05R\x0eapplicationTagB\0\x12\
    B\n\x15payloadLevelAppBucket\x18\x03\x20\x03(\x0b2\n.AppBucketR\x15paylo\
    adLevelAppBucketB\0:\0\"\x9e\x01\n\x0cStatCounters\x12$\n\x0cnetworkProt\
    o\x18\x01\x20\x01(\x05R\x0cnetworkProtoB\0\x12\x1e\n\tdirection\x18\x02\
    \x20\x01(\x05R\tdirectionB\0\x120\n\x0bcounterData\x18\x03\x20\x01(\x0b2\
    \x0c.CounterDataR\x0bcounterDataB\0\x12\x14\n\x04fgBg\x18\x04\x20\x01(\
    \x05R\x04fgBgB\0:\0\"T\n\x18UsageStatsExtensionProto\x126\n\tdataUsage\
    \x18\x01\x20\x01(\x0b2\x16.AndroidDataUsageProtoR\tdataUsageB\0:\0\"\x92\
    \x01\n\x14ModifyLibraryRequest\x12\x1e\n\tlibraryId\x18\x01\x20\x01(\tR\
    \tlibraryIdB\0\x12(\n\x0eaddPackageName\x18\x02\x20\x03(\tR\x0eaddPackag\
    eNameB\0\x12.\n\x11removePackageName\x18\x03\x20\x03(\tR\x11removePackag\
    eNameB\0:\0\"b\n\x11UrlRequestWrapper\x12K\n\x14developerAppsRequest\x18\
    1\x20\x01(\x0b2\x15.DeveloperAppsRequestR\x14developerAppsRequestB\0:\0\
    \"\xda\x01\n\x14DeveloperAppsRequest\x12M\n\x15developerIdContainer1\x18\
    \x01\x20\x01(\x0b2\x15.DeveloperIdContainerR\x15developerIdContainer1B\0\
    \x12M\n\x15developerIdContainer2\x18\x02\x20\x01(\x0b2\x15.DeveloperIdCo\
    ntainerR\x15developerIdContainer2B\0\x12\"\n\x0bunknownInt3\x18\x03\x20\
    \x01(\x05R\x0bunknownInt3B\0:\0\"\x84\x01\n\x14DeveloperIdContainer\x12\
    \"\n\x0bdeveloperId\x18\x01\x20\x01(\tR\x0bdeveloperIdB\0\x12\"\n\x0bunk\
    nownInt2\x18\x02\x20\x01(\x05R\x0bunknownInt2B\0\x12\"\n\x0bunknownInt3\
    \x18\x03\x20\x01(\x05R\x0bunknownInt3B\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
